<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[golang解决TCP粘包问题]]></title>
    <url>%2F2018%2F03%2F02%2Fgolang-tcp-stick-package.html</url>
    <content type="text"><![CDATA[什么是TCP粘包问题以及为什么会产生TCP粘包，本文不加讨论。本文使用golang的bufio.Scanner来实现自定义协议解包。 协议数据包定义本文模拟一个日志服务器，该服务器接收客户端传到的数据包并显示出来 12345678910type Package struct &#123; Version [2]byte // 协议版本，暂定V1 Length int16 // 数据部分长度 Timestamp int64 // 时间戳 HostnameLength int16 // 主机名长度 Hostname []byte // 主机名 TagLength int16 // 标签长度 Tag []byte // 标签 Msg []byte // 日志数据&#125; 协议定义部分没有什么好讲的，根据具体的业务逻辑定义即可。 数据打包由于TCP协议是语言无关的协议，所以直接把协议数据包结构体发送到TCP连接中也是不可能的，只能发送字节流数据，所以需要自己实现数据编码。所幸golang提供了binary来帮助我们实现网络字节编码。 123456789101112func (p *Package) Pack(writer io.Writer) error &#123; var err error err = binary.Write(writer, binary.BigEndian, &amp;p.Version) err = binary.Write(writer, binary.BigEndian, &amp;p.Length) err = binary.Write(writer, binary.BigEndian, &amp;p.Timestamp) err = binary.Write(writer, binary.BigEndian, &amp;p.HostnameLength) err = binary.Write(writer, binary.BigEndian, &amp;p.Hostname) err = binary.Write(writer, binary.BigEndian, &amp;p.TagLength) err = binary.Write(writer, binary.BigEndian, &amp;p.Tag) err = binary.Write(writer, binary.BigEndian, &amp;p.Msg) return err&#125; Pack方法的输出目标为io.Writer，有利于接口扩展，只要实现了该接口即可编码数据写入。binary.BigEndian是字节序，本文暂时不讨论，有需要的读者可以自行查找资料研究。 数据解包解包需要将TCP数据包解析到结构体中，接下来会讲为什么需要添加几个数据无关的长度字段。 123456789101112131415func (p *Package) Unpack(reader io.Reader) error &#123; var err error err = binary.Read(reader, binary.BigEndian, &amp;p.Version) err = binary.Read(reader, binary.BigEndian, &amp;p.Length) err = binary.Read(reader, binary.BigEndian, &amp;p.Timestamp) err = binary.Read(reader, binary.BigEndian, &amp;p.HostnameLength) p.Hostname = make([]byte, p.HostnameLength) err = binary.Read(reader, binary.BigEndian, &amp;p.Hostname) err = binary.Read(reader, binary.BigEndian, &amp;p.TagLength) p.Tag = make([]byte, p.TagLength) err = binary.Read(reader, binary.BigEndian, &amp;p.Tag) p.Msg = make([]byte, p.Length-8-2-p.HostnameLength-2-p.TagLength) err = binary.Read(reader, binary.BigEndian, &amp;p.Msg) return err&#125; 由于主机名、标签这种数据是不固定长度的，所以需要两个字节来标识数据长度，否则读取的时候只知道一个总的数据长度是无法区分主机名、标签名、日志数据的。 数据包的粘包问题解决上文只是解决了编码/解码问题，前提是收到的数据包没有产生粘包问题，解决粘包就是要正确分割字节流中的数据。一般有以下做法： 定长分隔(每个数据包最大为该长度) 缺点是数据不足时会浪费传输资源 特定字符分隔(如\r\n) 缺点是如果正文中有\r\n就会导致问题 在数据包中添加长度字段(本文采用的) golang提供了bufio.Scanner来解决粘包问题。 12345678910111213141516171819scanner := bufio.NewScanner(reader) // reader为实现了io.Reader接口的对象，如net.Connscanner.Split(func(data []byte, atEOF bool) (advance int, token []byte, err error) &#123; if !atEOF &amp;&amp; data[0] == 'V' &#123; // 由于我们定义的数据包头最开始为两个字节的版本号，所以只有以V开头的数据包才处理 if len(data) &gt; 4 &#123; // 如果收到的数据&gt;4个字节(2字节版本号+2字节数据包长度) length := int16(0) binary.Read(bytes.NewReader(data[2:4]), binary.BigEndian, &amp;length) // 读取数据包第3-4字节(int16)=&gt;数据部分长度 if int(length)+4 &lt;= len(data) &#123; // 如果读取到的数据正文长度+2字节版本号+2字节数据长度不超过读到的数据(实际上就是成功完整的解析出了一个包) return int(length) + 4, data[:int(length)+4], nil &#125; &#125; &#125; return&#125;)// 打印接收到的数据包for scanner.Scan() &#123; scannedPack := new(Package) scannedPack.Unpack(bytes.NewReader(scanner.Bytes())) log.Println(scannedPack)&#125; 本文的核心就在于scanner.Split方法，该方法用来解析TCP数据包 完整源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109package mainimport ( "bufio" "bytes" "encoding/binary" "fmt" "io" "log" "os" "time")type Package struct &#123; Version [2]byte // 协议版本 Length int16 // 数据部分长度 Timestamp int64 // 时间戳 HostnameLength int16 // 主机名长度 Hostname []byte // 主机名 TagLength int16 // Tag长度 Tag []byte // Tag Msg []byte // 数据部分长度&#125;func (p *Package) Pack(writer io.Writer) error &#123; var err error err = binary.Write(writer, binary.BigEndian, &amp;p.Version) err = binary.Write(writer, binary.BigEndian, &amp;p.Length) err = binary.Write(writer, binary.BigEndian, &amp;p.Timestamp) err = binary.Write(writer, binary.BigEndian, &amp;p.HostnameLength) err = binary.Write(writer, binary.BigEndian, &amp;p.Hostname) err = binary.Write(writer, binary.BigEndian, &amp;p.TagLength) err = binary.Write(writer, binary.BigEndian, &amp;p.Tag) err = binary.Write(writer, binary.BigEndian, &amp;p.Msg) return err&#125;func (p *Package) Unpack(reader io.Reader) error &#123; var err error err = binary.Read(reader, binary.BigEndian, &amp;p.Version) err = binary.Read(reader, binary.BigEndian, &amp;p.Length) err = binary.Read(reader, binary.BigEndian, &amp;p.Timestamp) err = binary.Read(reader, binary.BigEndian, &amp;p.HostnameLength) p.Hostname = make([]byte, p.HostnameLength) err = binary.Read(reader, binary.BigEndian, &amp;p.Hostname) err = binary.Read(reader, binary.BigEndian, &amp;p.TagLength) p.Tag = make([]byte, p.TagLength) err = binary.Read(reader, binary.BigEndian, &amp;p.Tag) p.Msg = make([]byte, p.Length-8-2-p.HostnameLength-2-p.TagLength) err = binary.Read(reader, binary.BigEndian, &amp;p.Msg) return err&#125;func (p *Package) String() string &#123; return fmt.Sprintf("version:%s length:%d timestamp:%d hostname:%s tag:%s msg:%s", p.Version, p.Length, p.Timestamp, p.Hostname, p.Tag, p.Msg, )&#125;func main() &#123; hostname, err := os.Hostname() if err != nil &#123; log.Fatal(err) &#125; pack := &amp;Package&#123; Version: [2]byte&#123;'V', '1'&#125;, Timestamp: time.Now().Unix(), HostnameLength: int16(len(hostname)), Hostname: []byte(hostname), TagLength: 4, Tag: []byte("demo"), Msg: []byte(("现在时间是:" + time.Now().Format("2006-01-02 15:04:05"))), &#125; pack.Length = 8 + 2 + pack.HostnameLength + 2 + pack.TagLength + int16(len(pack.Msg)) buf := new(bytes.Buffer) // 写入四次，模拟TCP粘包效果 pack.Pack(buf) pack.Pack(buf) pack.Pack(buf) pack.Pack(buf) // scanner scanner := bufio.NewScanner(buf) scanner.Split(func(data []byte, atEOF bool) (advance int, token []byte, err error) &#123; if !atEOF &amp;&amp; data[0] == 'V' &#123; if len(data) &gt; 4 &#123; length := int16(0) binary.Read(bytes.NewReader(data[2:4]), binary.BigEndian, &amp;length) if int(length)+4 &lt;= len(data) &#123; return int(length) + 4, data[:int(length)+4], nil &#125; &#125; &#125; return &#125;) for scanner.Scan() &#123; scannedPack := new(Package) scannedPack.Unpack(bytes.NewReader(scanner.Bytes())) log.Println(scannedPack) &#125; if err := scanner.Err(); err != nil &#123; log.Fatal("无效数据包") &#125;&#125; 写在最后golang作为一门强大的网络编程语言，实现自定义协议是非常重要的，实际上实现自定义协议也不是很难，以下几个步骤： 数据包编码 数据包解码 处理TCP粘包问题 断线重连(可以使用心跳实现)(非必须)]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>tcp</tag>
        <tag>protocol</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[golang multipart上传文件到远端（如上传微信临时素材）]]></title>
    <url>%2F2018%2F03%2F01%2Fgolang-upload.html</url>
    <content type="text"><![CDATA[最近在开发一个关注之后通过客服消息推送一张海报给用户的功能，海报图片是本地生成好的，需要上传到微信临时素材之后通过客服消息推送给用户。上传文件需要multipart/form-data格式的表单，所以golang默认的http.POST方法是实现不了的。需要自行实现body参数逻辑。 上传请求初始化12345678910111213141516171819202122232425262728// 新建上传请求func NewUploadRequest(link string, params map[string]string, name, path string) (*http.Request, error) &#123; fp, err := os.Open(path) // 打开文件句柄 if err != nil &#123; return nil, err &#125; defer fp.Close() body := &amp;bytes.Buffer&#123;&#125; // 初始化body参数 writer := multipart.NewWriter(body) // 实例化multipart part, err := writer.CreateFormFile(name, filepath.Base(path)) // 创建multipart 文件字段 if err != nil &#123; return nil, err &#125; _, err = io.Copy(part, fp) // 写入文件数据到multipart for key, val := range params &#123; _ = writer.WriteField(key, val) // 写入body中额外参数，比如七牛上传时需要提供token &#125; err = writer.Close() if err != nil &#123; return nil, err &#125; req, err := http.NewRequest("POST", link, body) // 新建请求 if err != nil &#123; return nil, err &#125; req.Header.Set("Content-Type", "multipart/form-data") // 设置请求头,!!!非常重要，否则远端无法识别请求 return req, nil&#125; 上传流程1234567891011121314151617181920212223242526272829303132333435func (m *Task) upload(appid string) (string, error) &#123; filename, err := m.download() // 下载远端海报文件到本地路径 if err != nil &#123; return "", err &#125; // 获取accessToken accessToken, err := m.passport.GetAccessToken(appid) if err != nil &#123; return "", err &#125; params := &amp;url.Values&#123; "access_token": []string&#123;accessToken&#125;, "type": []string&#123;"image"&#125;, &#125; req, err := util.NewUploadRequest("https://api.weixin.qq.com/cgi-bin/media/upload?"+params.Encode(), nil, "media", filename) // 上传到微信 if err != nil &#123; return "", err &#125; resp, err := http.DefaultClient.Do(req) if err != nil &#123; return "", err &#125; defer resp.Body.Close() ret := make(map[string]interface&#123;&#125;) if err := json.NewDecoder(resp.Body).Decode(&amp;ret); err != nil &#123; return "", err &#125; if mediaId, ok := ret["media_id"]; ok &#123; return mediaId.(string), nil &#125; else if errmsg, ok := ret["errmsg"]; ok &#123; return "", errors.New(errmsg.(string)) &#125; else &#123; return "", errors.New("上传失败") &#125;&#125;]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>multipart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker部署golang应用时时区问题]]></title>
    <url>%2F2018%2F03%2F01%2Fgolang-docker-timezone.html</url>
    <content type="text"><![CDATA[目前golang用的基础镜像是busybox，由于golang交叉编译之后只有一个二进制文件，可以直接部署到容器中运行，容器镜像大小几乎等于二进制文件大小。 带来的问题由于基础镜像太过精简，目前遇到的问题是将时间戳格式化为时间字符串时发现差了8个小时。 尝试过的解决办法刚开始使用了Location时区相关API，但是部署到容器中发现直接报错了，因为容器中缺少相关的系统调用函数。代码如下： 12loc, _ := time.LoadLocation("Asia/Shanghai")time.Now().In(loc).Format("2006-01-02 15:04:05") 目前应用会部署到docker容器中，故处理办法比较原始，直接在Time对象上添加8个小时来解决时差问题。代码如下: 1time.Now().Add(time.Hour * 8).Format("2006年01月02日 15:04"), 暂时解决了这个问题。]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>timezone</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[golang JSON编码时保留HTML标签]]></title>
    <url>%2F2018%2F03%2F01%2Fgolang-json-no-escape-html.html</url>
    <content type="text"><![CDATA[golang默认编码JSON时会将HTML标签中的尖括号编码为\u003c这种unicode字符。而最近在开发的微信客服消息推送就会出现以下结果 1\u003ca href=&apos;https://www.example.com&apos;\u003e点击进入\u003c/a\u003e 查看golang的json包发现json编码器有个方法SetEscapeHTML方法，接收一个bool值来设置是否保留HTML标签。 问题json的Encoder只能编码到实现了io.Writer接口的对象中去，而本例中需要编码到一个[]byte切片中。 解决查找资料发现bytes.Buffer对象实现了io.Writer接口。所以最终代码如下： 12345678910func BuildJson(data map[string]interface&#123;&#125;) ([]byte, error) &#123; buf := bytes.NewBufferString("") encoder := json.NewEncoder(buf) encoder.SetEscapeHTML(false) if err := encoder.Encode(&amp;data); err != nil &#123; return nil, err &#125; else &#123; return buf.Bytes(), nil &#125;&#125; 经过测试，输出接口符合要求。]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[golang使用CSV导出大量数据]]></title>
    <url>%2F2018%2F02%2F28%2Fgolang-export-csv.html</url>
    <content type="text"><![CDATA[最近在做一个导出功能，最初是使用https://github.com/tealeg/xlsx做的，但是发现导出有个30W行的excel时，这玩意内存彪到700M+，后来发现只是导出数据为表格，并没有其他东西，于是打算使用CSV导出。 CSV格式简介CSV本质上是个文本文件，该文件有以下要求： 列之间用逗号分隔，行之间用换行分隔 单元格如果有逗号，引号之类的字符，该单元格需要使用双引号括起来 如果包含中文，需要使用GBK编码，否则会乱码 golang实现 UTF8转GBK函数(需要 go get golang.org/x/text/) 12345678func UTF82GBK(src string) (string, error) &#123; reader := transform.NewReader(strings.NewReader(src), simplifiedchinese.GBK.NewEncoder()) if buf, err := ioutil.ReadAll(reader); err != nil &#123; return "", err &#125; else &#123; return string(buf), nil &#125;&#125; 导出代码 12345678910filename := "test.csv"fp, err := os.Create(filename) // 创建文件句柄if err != nil &#123; return nil, err&#125;defer fp.Close()columns := []string&#123;"姓名", "电话", "公司", "职位", "加入时间"&#125;if line, err := util.UTF82GBK(strings.Join(columns, ",")); err == nil &#123; // 写入一行 fp.WriteString(line + "\n")&#125; 其他语言也可以使用类似方法导出数据，只要满足CSV的几个条件即可。]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>excel</tag>
        <tag>golang</tag>
        <tag>csv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs thrift多路复用客户端]]></title>
    <url>%2F2018%2F02%2F08%2Fnodejs-thrift-multiple-client.html</url>
    <content type="text"><![CDATA[官网nodejs示例中只实现了服务端是单一service的情形，而对于服务端属于多个服务复用一个连接地址的例子却未实现。 查看thrift的nodejs库源码发现实际上还是支持的。以下来展示调用单一服务和多个服务的区别。 单一服务1234567891011121314var thrift = require('thrift');var Calculator = require('./gen-nodejs/Calculator');var ttypes = require('./gen-nodejs/tutorial_types');const assert = require('assert');var transport = thrift.TBufferedTransport;var protocol = thrift.TBinaryProtocol;var connection = thrift.createConnection("localhost", 9090, &#123; transport : transport, protocol : protocol&#125;);var client = thrift.createClient(Calculator, connection);// 已经可以调用client方法 复用服务123456789101112131415var thrift = require('thrift');var Calculator = require('./gen-nodejs/Calculator');var ttypes = require('./gen-nodejs/tutorial_types');const assert = require('assert');var transport = thrift.TBufferedTransport;var protocol = thrift.TBinaryProtocol;var connection = thrift.createConnection("localhost", 9090, &#123; transport : transport, protocol : protocol&#125;);const m = new thrift.Multiplexer(); // 关键const client = m.createClient('calculator', Calculator, connection); // calculator为服务端声明的服务名称// 已经可以调用client方法 经过测试，以上代码能与golang实现的服务端正常通信。]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>thrift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[golang通用连接池的实现]]></title>
    <url>%2F2018%2F02%2F01%2Fgolang-generic-pool.html</url>
    <content type="text"><![CDATA[golang的channel除了goroutine通信之外还有很多其他的功能，本文将实现一种基于channel的通用连接池。 何为通用？连接池的实现不依赖具体的实例，而依赖某个接口，本文的连接池选用的是io.Closer接口，只要是实现了该接口的对象都可以被池管理。当然，你可以实现基于interface{}的连接池，这样任何对象都可以被管理。 实现原理将连接句柄存入channel中，由于缓存channel的特性，获取连接时如果池中有连接，将直接返回，如果池中没有连接，将阻塞或者新建连接（没超过最大限制的情况下）。由于面向接口编程，所有创建连接的逻辑是不清楚的，这里需要传入一个函数，该函数返回一个io.Closer对象。 实现由于并发问题，在需要操作池中互斥数据的时候需要加锁。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129package poolimport ( "errors" "io" "sync" "time")var ( ErrInvalidConfig = errors.New("invalid pool config") ErrPoolClosed = errors.New("pool closed"))type factory func() (io.Closer, error)type Pool interface &#123; Acquire() (io.Closer, error) // 获取资源 Release(io.Closer) error // 释放资源 Close(io.Closer) error // 关闭资源 Shutdown() error // 关闭池&#125;type GenericPool struct &#123; sync.Mutex pool chan io.Closer maxOpen int // 池中最大资源数 numOpen int // 当前池中资源数 minOpen int // 池中最少资源数 closed bool // 池是否已关闭 maxLifetime time.Duration factory factory // 创建连接的方法&#125;func NewGenericPool(minOpen, maxOpen int, maxLifetime time.Duration, factory factory) (*GenericPool, error) &#123; if maxOpen &lt;= 0 || minOpen &gt; maxOpen &#123; return nil, ErrInvalidConfig &#125; p := &amp;GenericPool&#123; maxOpen: maxOpen, minOpen: minOpen, maxLifetime: maxLifetime, factory: factory, pool: make(chan io.Closer, maxOpen), &#125; for i := 0; i &lt; minOpen; i++ &#123; closer, err := factory() if err != nil &#123; continue &#125; p.numOpen++ p.pool &lt;- closer &#125; return p, nil&#125;func (p *GenericPool) Acquire() (io.Closer, error) &#123; if p.closed &#123; return nil, ErrPoolClosed &#125; for &#123; closer, err := p.getOrCreate() if err != nil &#123; return nil, err &#125; // todo maxLifttime处理 return closer, nil &#125;&#125;func (p *GenericPool) getOrCreate() (io.Closer, error) &#123; select &#123; case closer := &lt;-p.pool: return closer, nil default: &#125; p.Lock() if p.numOpen &gt;= p.maxOpen &#123; closer := &lt;-p.pool p.Unlock() return closer, nil &#125; // 新建连接 closer, err := p.factory() if err != nil &#123; p.Unlock() return nil, err &#125; p.numOpen++ p.Unlock() return closer, nil&#125;// 释放单个资源到连接池func (p *GenericPool) Release(closer io.Closer) error &#123; if p.closed &#123; return ErrPoolClosed &#125; p.Lock() p.pool &lt;- closer p.Unlock() return nil&#125;// 关闭单个资源func (p *GenericPool) Close(closer io.Closer) error &#123; p.Lock() closer.Close() p.numOpen-- p.Unlock() return nil&#125;// 关闭连接池，释放所有资源func (p *GenericPool) Shutdown() error &#123; if p.closed &#123; return ErrPoolClosed &#125; p.Lock() close(p.pool) for closer := range p.pool &#123; closer.Close() p.numOpen-- &#125; p.closed = true p.Unlock() return nil&#125; 结论基于该连接池，可以管理所有io.Closer对象。比如memcached,redis等等，非常方便！]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[golang限制协程数量]]></title>
    <url>%2F2018%2F01%2F31%2Fgoroutine-limit-demo.html</url>
    <content type="text"><![CDATA[为什么要限制协程数量golang的go关键字并发实在是太简单，但是带来的问题是由于硬件和网络状况的限制，不受控制的增加协程是非常危险的做法，甚至有可能搞垮数据库之类的应用! 而并发控制在go中是非常常用的技巧，以此文来记录一下学习历程。 原理由于channel的阻塞机制，通过设置缓冲channel的缓冲大小来控制同时执行的协程数量。 demo代码1234567891011121314151617181920212223package mainimport ( "log" "time")func main() &#123; start := time.Now() ch := make(chan int, 2) for i := 0; i &lt;= 10; i++ &#123; ch &lt;- 1 go worker(i, ch) &#125; close(ch) log.Println("complete", time.Since(start).Seconds())&#125;// 模拟耗时操作func worker(i int, ch chan int) &#123; log.Println("worker", i) time.Sleep(time.Second) &lt;-ch 运行1go run demo.ho 输出1234567891011122018/01/31 22:24:49 worker 12018/01/31 22:24:49 worker 02018/01/31 22:24:50 worker 22018/01/31 22:24:50 worker 32018/01/31 22:24:51 worker 42018/01/31 22:24:51 worker 52018/01/31 22:24:52 worker 62018/01/31 22:24:52 worker 72018/01/31 22:24:53 worker 82018/01/31 22:24:53 worker 92018/01/31 22:24:54 worker 102018/01/31 22:24:54 complete 5.01140112 结论可以看到日志的输出时间，每秒出现两个，正好等于我们make函数的大小，而总时间也是为10/2左右，证明限制起到了作用。 虽然本文写起来很简单，但是包含的技巧可以说大型程序仍然会用到。正所谓“万丈高楼平地起”。]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[头脑王者辅助]]></title>
    <url>%2F2018%2F01%2F30%2Ftnwz.html</url>
    <content type="text"><![CDATA[头脑王者本项目仅作为学习anyproxy之用，请勿用于非法用途，否则后果自负 功能 [x] 题目爬取 [x] 答题匹配(如果题库不存在，请自行答题，系统会在答题后把正确答案自动录入数据库) 开始 安装mysql，新建数据库tnwz，建表语句 123456789101112CREATE TABLE tnwz.question( id int(11) PRIMARY KEY NOT NULL AUTO_INCREMENT, question varchar(100), a varchar(20), b varchar(20), c varchar(20), d varchar(20), answer int(11), createdAt datetime NOT NULL, updatedAt datetime NOT NULL); config.json为数据库配置 安装anyproxy =&gt; npm install anyproxy -g 生成证书anyproxy -i 手机接入代理，代理地址电脑IP:8001 题库获取 登录两个微信号获取到uid和token之后填入auth.json node question-fetcher.js,如果出现401，请重新登录 排位系统 npm run fight开启代理 手机接入代理 开始排位，终端会提示开始匹配，系统会将正确答案添加上### 适用系统 Android &amp;&amp; iOS iOS11.3 已通过测试 项目地址https://github.com/xialeistudio/tnwz]]></content>
      <tags>
        <tag>nodejs</tag>
        <tag>anyproxy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[golang可能导致内存泄漏的地方]]></title>
    <url>%2F2018%2F01%2F20%2Fgolang-memory-leak.html</url>
    <content type="text"><![CDATA[核心golang能够GC是程序声明的变量，而一些外部资源是不可以GC掉的，比如os.OpenFile打开的文件句柄，sql.Open打开的数据库连接句柄等资源。 开发中常用场景 http请求时resp.Body，刚开始写golang的时候，如果会用ioutil.readAll去读取resp.Body时会加上defer resp.Body.Close(),后来有json.NewDecoder().decode()时没有加，以为会自动关闭，没想到还是太天真了。不管什么情况都需要defer resp.Body.Close() sql查询时DB.Prepare，数据库查询操作会得到一个rows的资源，这个一般都关闭了，但是运行一段时间之后发现有内存泄漏，因为只用到了sql查询，所以只有数据库操作代码可以排查，尽快调试发现stmt也有Close方法，加上defer stmt.Close之后，内存稳定了。]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>memory-leak</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP实现“异步”]]></title>
    <url>%2F2018%2F01%2F20%2Fphp-async.html</url>
    <content type="text"><![CDATA[众所周知，PHP不使用多线程扩展的情况下是不支持异步的(不算curl之类)。今天无意中看到一个函数fastcgi_finish_request;这个方法是PHP5.3+开始提供。注释写的很清楚，有耗时操作的时候使用该函数可以尽早结束fastcgi处理过程，提高页面响应速度。 代码说明12345&lt;?phpecho 1;fastcgi_finish_request();sleep(3);?&gt; 此时打开浏览器发现响应速度并没有受到sleep函数的影响，基于此点，可以在适当的时候使用该函数以提升用户体验! 注意事项PHP需要运行在fpm模式下才可以使用本函数。]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>async</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信H5点击跳转到关注页]]></title>
    <url>%2F2017%2F11%2F25%2Fwechat-web-subscribe.html</url>
    <content type="text"><![CDATA[背景微信诱导关注接口在早两年已经被微信关停，但是一般的H5目的都是要关注公众号。目前用的多的方法是用公众号发表一篇文章，文章里面一般是一个GIF的箭头图片指向公众号关注。这种方法有点取巧。 今天要介绍的是另一种方法，感觉应该不会被微信封号。 起因有个朋友在segmentfault上发了一个链接出来，微信打开可以直接到关注页1https://mp.weixin.qq.com/mp/profile_ext?action=home&amp;__biz=MzUzMDM3MjMyNQ==#wechat_redirect 条件反射发现MzUzMDM3MjMyNQ==是Base64编码后的参数，解码后是一段数字，然后我改了下数字，重新编码，再发送到微信，发现可以打开另外一个公众号的关注页1https://mp.weixin.qq.com/mp/profile_ext?action=home&amp;__biz=MzUzMDM3MjMyNA==#wechat_redirect 所以只要知道那个公众号数字就可以构造链接进行关注，想着这种ID一般在公众平台有，果然被我找到了。 步骤 登录公众平台后台 点击右上角的公众号，来到公众号信息页面 查看公众号信息页面的源代码，在顶上找到以下代码 123window.wx=&#123;uin:"xxxx"||"0"&#125;; xxxx 就是你的公众号数字ID 将第4步找到的ID进行base64编码 构造如下链接 1https://mp.weixin.qq.com/mp/profile_ext?action=home&amp;__biz=第5步的结果#wechat_redirect 发送到微信之后即可。 反思从打开的链接看页面还是蛮正式的，可能不是私有接口，但是微信文档中没说过这种方式，故使用本方式带来的后果请自行负责！]]></content>
      <tags>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从零开始打造自己的直播服务器-golang开发HTTP推流服务]]></title>
    <url>%2F2017%2F11%2F23%2Fgo-rtmp-http-publisher.html</url>
    <content type="text"><![CDATA[目前笔者只知道ffmpeg命令行推流到RTMP服务器，是没有HTTP接口的，像iOS和Android这种Native应用应该有RTMP SDK封装推流逻辑。但是像微信小程序这种录制音频只有原始ArrayBuffer的数据，则必须在服务端提供接口来进行推流。 本文将基于golang标准库以及ffmpeg命令来实现。 服务端原理 客户端上传base64编码后的音频数据 服务端接收后解码为[]byte 将[]byte写入本地文件 golang调用ffmpeg命令将第3步写入的文件推流到RTMP服务端(从零开始打造自己的直播服务器-Nginx安装) golang输出JSON响应，如果出错则返回错误JSON响应 1234&#123; "errmsg":"ok", "errcode":0&#125; 开始开发由于采用了log4go日志库https://github.com/alecthomas/log4go，故需要先安装1go get github.com/alecthomas/log4go 完整服务端源代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150package mainimport ( "github.com/alecthomas/log4go" "flag" "net/http" "time" "encoding/json" "io/ioutil" "encoding/base64" "os" "os/exec" "strings")var ( rtmp string // rtmp 服务端地址 ffmpeg string // ffmpeg命令地址 listen string // 监听地址 uploadKey string // 上传key uploadDirectory string // 本地上传目录 start = time.Now())const ( VERSION = "1.0.0")func init() &#123; flag.StringVar(&amp;rtmp, "rtmp", "rtmp://localhost:1935/hls", "rtmp upstream address") flag.StringVar(&amp;ffmpeg, "ffmpeg", "ffmpeg", "ffmpeg executable") flag.StringVar(&amp;listen, "listen", ":8081", "http server address") flag.StringVar(&amp;uploadKey, "key", "testkey", "http upload key") flag.StringVar(&amp;uploadDirectory, "upload-directory", "upload", "local upload directory")&#125;func main() &#123; flag.Parse() log4go.LoadConfiguration("log4go.xml") if rtmp == "" &#123; panic("rtmp upstream not set!") &#125; // 创建目录 os.Mkdir(uploadDirectory, os.ModePerm) log4go.Info("start ffmpeg-publisher, version %s", VERSION) log4go.Info("RTMP UpStream %s", rtmp) log4go.Info("HTTP Upload Directory %s", uploadDirectory) log4go.Info("HTTP Listen ON %s", listen) log4go.Info("HTTP Upload Key %s", uploadKey) http.HandleFunc("/", handleIndex) http.HandleFunc("/base64", handleBase64Publish) panic(http.ListenAndServe(listen, nil))&#125;func sendResponse(errmsg string, statusCode int, w http.ResponseWriter) &#123; w.Header().Set("Content-Type", "application/json;charset=utf-8") if statusCode == 0 &#123; statusCode = 200 &#125; w.WriteHeader(statusCode) ret := map[string]interface&#123;&#125;&#123; "errmsg": errmsg, "errcode": statusCode, &#125; json.NewEncoder(w).Encode(&amp;ret) if statusCode == 500 &#123; log4go.Error(errmsg) &#125;&#125;func handleIndex(w http.ResponseWriter, _ *http.Request) &#123; ret := map[string]interface&#123;&#125;&#123; "name": "ffpmeg-publisher", "version": VERSION, "uptime": time.Since(start).String(), &#125; w.Header().Set("Content-Type", "application/json;charset=utf-8") json.NewEncoder(w).Encode(&amp;ret)&#125;func handleBase64Publish(w http.ResponseWriter, r *http.Request) &#123; if r.Method != "POST" &#123; sendResponse("Method Not Allowed", 405, w) return &#125; // 获取直播ID和key if err := r.ParseForm(); err != nil &#123; sendResponse(err.Error(), 500, w) return &#125; // 检测直播Key if key := r.Form.Get("key"); key != uploadKey &#123; sendResponse("Forbidden", 403, w) return &#125; // 检测直播ID id := r.Form.Get("id") if id == "" &#123; sendResponse("Bad Request", 400, w) return &#125; // 读取base64 base64Buf, err := ioutil.ReadAll(r.Body) if err != nil &#123; sendResponse(err.Error(), 500, w) return &#125; buf, err := base64.StdEncoding.DecodeString(string(base64Buf)) if err != nil &#123; sendResponse(err.Error(), 500, w) return &#125; log4go.Trace("live %s receive %d bytes", id, len(buf)) if err := publishVoice(buf, id); err != nil &#123; sendResponse(err.Error(), 500, w) &#125; else &#123; sendResponse("ok", 0, w) &#125;&#125;// 保存音频到临时文件目录,1个直播一个目录func saveVoice(buf []byte, id string) (string, error) &#123; directory := uploadDirectory + "/" + id os.Mkdir(directory, os.ModePerm) name := time.Now().Format("2006-01-02-15-04-05") + ".mp3" filename := directory + "/" + name log4go.Trace("live %s save chunk %s", id, filename) err := ioutil.WriteFile(filename, buf, os.ModePerm) return filename, err&#125;// 发布音频至rtmpfunc publishVoice(buf []byte, id string) error &#123; mp3filename, err := saveVoice(buf, id) if err != nil &#123; log4go.Error("live %s %q", id, err) return err &#125; // 执行系统命令 cmd := exec.Command(ffmpeg, "-i", mp3filename, "-acodec", "aac", "-f", "flv", rtmp+"/"+id) log4go.Trace("live %s execute %s", id, strings.Join(cmd.Args, " ")) cmd.Stderr = os.Stderr cmd.Stdout = os.Stdout if err := cmd.Run(); err != nil &#123; log4go.Error("live %s execute %q", id, err) return err &#125; return nil&#125; github地址https://github.com/xialeistudio/go-rtmp-http-publisher]]></content>
      <tags>
        <tag>go</tag>
        <tag>rtmp</tag>
        <tag>直播</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从零开始打造自己的直播服务器-Nginx安装]]></title>
    <url>%2F2017%2F11%2F23%2Fnginx-rtmp-server.html</url>
    <content type="text"><![CDATA[直播行业火了很长一段时间了，抛开那些复杂的实现，本系列将从零开始实现一个直播服务器。 功能 RTMP拉流(基于HLS) RTMP推流(基于ffmpeg) RTMP推流(基于HTTP) 安装Nginx本文使用docker的ubuntu镜像作为种子机，非常干净! 文章最后会放出我写的Dockerfile，不想折腾的朋友可以直接拿过去build一个自己的镜像 以下操作在物理机ubuntu也可以进行。 更新软件仓库 1apt-get update 安装必要软件 1apt-get install git gcc make wget libpcre3 libpcre3-dev openssl libssl-dev -y -q 下载并解压nginx源码 123cd /usr/local/srcwget http://nginx.org/download/nginx-1.12.2.tar.gztar xf nginx-1.12.2.tar.gz 下载nginx-rtmp-module源码 1git clone https://github.com/arut/nginx-rtmp-module.git 开始编译安装(其他参数不是必须的，故本文略去，只添加以下参数对于一个RTMP服务器已足够) 1234cd /usr/local/src/nginx-1.12.2./configure --add-module=../nginx-rtmp-module --with-http_flv_module --with-http_mp4_modulemakemake install 修改配置文件 /usr/local/nginx/nginx.conf 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374worker_processes auto;daemon off;error_log logs/error.log;pid logs/nginx.pid;events &#123; multi_accept on; worker_connections 65535; use epoll;&#125;http &#123; include mime.types; log_format main '$remote_addr - $remote_user [$time_local] "$request" ' '$status $body_bytes_sent "$http_referer" ' '"$http_user_agent" "$http_x_forwarded_for"'; access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 30; gzip on; server &#123; listen 80; server_name localhost; location /stat &#123; rtmp_stat all; rtmp_stat_stylesheet stat.xsl; &#125; location /stat.xsl &#123; root /usr/local/src/nginx-rtmp-module; &#125; location /control &#123; rtmp_control all; &#125; location /hls &#123; types &#123; application/vnd.apple.mpegurl m3u8; video/mp2t ts; &#125; root html; expires -1; &#125; location ~\.flv &#123; flv; &#125; location ~\.mp4 &#123; mp4; &#125; &#125; &#125;rtmp &#123; server &#123; listen 1935; chunk_size 4096; application hls &#123; allow publish 127.0.0.1; live on; hls on; hls_path /usr/local/nginx/html/hls; hls_fragment 5s; &#125; &#125;&#125; nginx在docker运行需要关闭daemon选项. rtmp-&gt;server-&gt;application为具体的直播应用,hls是我的直播应用名称，可以根据实际情况修改。 启动服务器 1/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf 安装ffmpeg1apt-get install ffmpeg 推流测试推流地址1rtmp://localhost:1935/hls/demo hls为上面配置的application名称，demo是直播名称，客户端使用http://localhost/hls/demo.m3u8进行播放 视频推流1ffmpeg -re -i a.mp4 -vcodec copy -f flv rtmp://localhost:1935/hls/demo web中播放1&lt;video src="http://localhost/hls/demo.m3u8" controls&gt;&lt;/video&gt; 音频推流1ffmpeg -re -i a.mp3 -acodec aac -f flv rtmp://localhost:1935/hls/demo web中播放1&lt;audio src="http://localhost/hls/demo.m3u8" controls&gt;&lt;/audio&gt; 推流与播放地址说明 假设nginx配置http端口为80,http目录为hls,rtmp端口为1935,application名称为hls,需要播放的直播名称为demo 推流地址rtmp://localhost:1935/hls/demo 播放地址http://localhost/hls/demo.m3u8 重要说明如果没有直播推流，nginx是不会产生m3u8文件的，这点需要注意! Docker镜像地址https://github.com/xialeistudio/docker-nginx-rtmp]]></content>
      <tags>
        <tag>nginx</tag>
        <tag>rtmp</tag>
        <tag>直播</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[log4go尝鲜]]></title>
    <url>%2F2017%2F11%2F21%2Flog4go-get-started.html</url>
    <content type="text"><![CDATA[序言日志系统对于软件是必不可少的，可以帮助我们记录关键信息，后期处理问题的时候会很方便。业界有很多出名的日志库，log4日志库相信每个人都不陌生，像log4j之于Java，log4php之于PHP等等。其实golang也有很多的log4实现，本文要使用的是alecthomas实现的版本。 项目地址https://github.com/alecthomas/log4go 安装1go get github.com/alecthomas/log4go 使用代码配置 新建golang项目 在项目根目录下新建main.go文件，代码如下 12345678910package mainimport "github.com/alecthomas/log4go"func main() &#123; defer log4go.Close() log4go.AddFilter("stdout", log4go.DEBUG, log4go.NewConsoleLogWriter()) // DEBUG级别+打印到控制台 log4go.AddFilter("file", log4go.INFO, log4go.NewFileLogWriter("test.log", true)) // INFO级别+输出到文件，并开启rotate log4go.Debug("这是DEBUG日志") // 输出测试 log4go.Info("这是INFO日志") // 输出测试&#125; 如果程序是守护进程，此处不用调用log4go.Close，因为log4go使用协程异步写入日志，此处可以调用log4go.Close也可以Sleep来实现写入，下文会有Sleep测试 go run main.go 此时可以看到终端输出，还可以发现项目目录下生成了test.log文件 12[17:11:35 CST 2017/11/21] [DEBG] (main.main:9) 这是DEBUG日志[17:11:35 CST 2017/11/21] [INFO] (main.main:10) 这是INFO日志 重新执行时可以发现test.log被rotate到了test.log.1 使用配置文件log4go支持使用xml来作为配置文件 在项目根目录新建log4go.xml 12345678910111213141516&lt;logging&gt; &lt;filter enabled="true"&gt; &lt;tag&gt;stdout&lt;/tag&gt; &lt;type&gt;console&lt;/type&gt; &lt;level&gt;DEBUG&lt;/level&gt; &lt;/filter&gt; &lt;filter enabled="true"&gt; &lt;tag&gt;file&lt;/tag&gt; &lt;type&gt;file&lt;/type&gt; &lt;level&gt;INFO&lt;/level&gt; &lt;property name="filename"&gt;test.log&lt;/property&gt; &lt;property name="rotate"&gt;true&lt;/property&gt; &lt;property name="maxlines"&gt;2&lt;/property&gt; &lt;property name="daily"&gt;true&lt;/property&gt; &lt;/filter&gt;&lt;/logging&gt; 添加了console和file两个filter，跟代码添加其实是一样的，不同的是xml的可配置性更高。具体配置参数需要查看log4go对应的go源文件 修改main.go 12345678910111213package mainimport ( "github.com/alecthomas/log4go" "time")func main() &#123; log4go.LoadConfiguration("log4go.xml") log4go.Debug("这是DEBUG日志") log4go.Info("这是INFO日志") time.Sleep(time.Second)&#125; 运行程序，终端依旧正确输出，同时也会生成test.log 后记log4go良好的设计带来了简洁又强大的使用体验，更多的使用细节以及更多的logger类型等待读者去发掘与实现，本文只做一个简单的介绍，即便如此也应该能够应付大部分场景了。]]></content>
      <tags>
        <tag>log</tag>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[golang实现TLV编码]]></title>
    <url>%2F2017%2F11%2F17%2Fgo-tlv.html</url>
    <content type="text"><![CDATA[TLV编码基础Tlv编码在NodeJs中的应用 golang实现主要使用bytes和binary包中的相关函数 编码1234567891011121314151617func Encode(tag int32, data string) ([]byte, error) &#123; buf := new(bytes.Buffer) // 写入TAG if err := binary.Write(buf, binary.BigEndian, tag); err != nil &#123; return nil, err &#125; dataBuf := []byte(data) // 写入length if err := binary.Write(buf, binary.BigEndian, int32(len(dataBuf))); err != nil &#123; return nil, err &#125; // 写入数据 if err := binary.Write(buf, binary.BigEndian, dataBuf); err != nil &#123; return nil, err &#125; return buf.Bytes(), nil&#125; 解码123456789101112131415161718func Decode(b []byte) (int32, string, error) &#123; buf := bytes.NewBuffer(b) var tag, length int32 // 读取tag if err := binary.Read(buf, binary.BigEndian, &amp;tag); err != nil &#123; return 0, "", err &#125; // 读取length if err := binary.Read(buf, binary.BigEndian, &amp;length); err != nil &#123; return 0, "", err &#125; // 读取数据 dataBuf := make([]byte, length) if err := binary.Read(buf, binary.BigEndian, &amp;dataBuf); err != nil &#123; return 0, "", err &#125; return tag, string(dataBuf), nil&#125; 由于TLV编码容易上手加上golang完善的API，实现TLV编码也不算太曲折。]]></content>
      <tags>
        <tag>tlv</tag>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tlv编码在NodeJs中的应用]]></title>
    <url>%2F2017%2F11%2F17%2Fnode-tlv.html</url>
    <content type="text"><![CDATA[最近在接入腾讯云的天御业务安全系统时接触到了TLV编码协议，好在TLV协议理解起来比较简单。故简要介绍一下该编码。 TLV编码是什么？1234TLV是一种编码格式，编码如下：[1-4字节] TYPE[5-8字节] Value的Length[9字节+] Value数据 本文只探讨无嵌套数据的情况。NodeJs操作二进制数据主要依赖于Buffer 编码 编码Ascii数据，由于ascii编码的数据，一个字节就是一个字符，所以比较简单 12TYPE: 1Value: test 根据编码规则，可以得出以下数据组装格式 1234[1-4字节] 00 00 00 01[5-8字节] 00 00 00 04[9-12字节] 74 65 73 74 // 74 对应字符*t*ascii编码*116*的16进制形式，其他以此类推 javascript代码 12345678910// buf总长度为4字节TYPE+4字节VALUE长度+test的字节数为12const buf = Buffer.alloc(12);// 写入TYPEbuf.writeIntBE(1, 0, 4);// 写入LENGTHbuf.writeIntBE('test'.length, 4, 4);// 写入testbuf.write('test', 8, 'test'.length);// 此时buf就是编码结果，由于是二进制的，如果走TCP协议的话已经可以了，但是腾讯云要求base64编码。所以最终结果为buf.toString('base64'); 使用NodeJs交互式环境测试 123456789101112131415161718➜ ~ node&gt; const buf = Buffer.alloc(12);undefined&gt; buf&lt;Buffer 00 00 00 00 00 00 00 00 00 00 00 00&gt;&gt; buf.writeIntBE(1,0,4)4&gt; buf.writeIntBE(4,4,4)8&gt; buf.write('test',8,4)4&gt; buf&lt;Buffer 00 00 00 01 00 00 00 04 74 65 73 74&gt;&gt; buf.toString()'\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0004test'&gt; buf.toString('base64')'AAAAAQAAAAR0ZXN0'&gt; 非Ascii编码问题如果发送的数据是Ascii编码表之外的数据，就会用到多字节编码，此时以上方法会有问题。得意与Buffer完善的API，Buffer.from方法可以接收一个字符串和一个编码得到一个Buffer数组。 上例可以改为使用Buffer.from的版本: 123456const valueBuf = Buffer.from(value, 'utf8');const buf = Buffer.alloc(8 + valueBuf.length);buf.writeIntBE(type, 0, 4);buf.writeIntBE(valueBuf.length, 4, 4);buf.write(value, 8, valueBuf.length);buf.toString('base64'); 由于value使用的utf8编码，所以utf8编码表中的数据该方法都可以成功编码，经过腾讯云接口调用测试也是OK的。 解码说到编码就会有解码。解码是编码的逆运算，根据一样的规则还原数据而已。 javascript代码 123456789101112// 假设str为base64编码之后Tlv数据const buf = new Buffer(str, 'base64'); // 还原为Buffer// 读取TYPEconst type = buf.readIntBE(0, 4)// 读取VALUE长度const length = buf.readIntBE(4, 4)// 读取VALUEconst valueBuf = Buffer.alloc(length);// 写入VALUEbuf.copy(valueBuf, 0, 8, 8 + length);// 得到原始数据valueBuf.toString('utf8'); 使用NodeJs交互式环境测试 1234567891011121314151617181920212223242526272829303132➜ ~ node&gt; const str = 'AAAAAQAAAAR0ZXN0';undefined&gt; const buf = new Buffer(str, 'base64');undefined&gt; const type = buf.readIntBE(0,4);undefined&gt; const length = buf.readIntBE(4,4);undefined&gt; const value = Buffer.alloc(length);undefined&gt; valueOf[Function: valueOf]&gt; value&lt;Buffer 00 00 00 00&gt;&gt; buf.cobuf.constructor buf.copyWithin buf.compare buf.copy &gt; buf.copy(value,0,8,8+length);4&gt; value.tovalue.toLocaleString value.toString value.toJSON &gt; value.toString()'test'&gt; 腾讯云天御业务安全系统socket.io中如果需要接入该系统进行垃圾发言的过滤时，可以使用我开发的SDKtencent-cloud-defend]]></content>
      <tags>
        <tag>nodejs</tag>
        <tag>tlv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用docker-composer部署nodejs应用]]></title>
    <url>%2F2017%2F11%2F01%2Fdocker-composer-nodejs.html</url>
    <content type="text"><![CDATA[新建Dockerfile在应用目录下新建Dockerfile123456FROM node:8WORKDIR /usr/src/appADD . /usr/src/appRUN npm install --registry=https://registry.npm.taobao.orgUSER nodeEXPOSE 8080 8080 端口请根据实际情况调整。建议大于1024，否则使用node用户启动应用时可能权限不足 新建docker-compose.yml在应用目录下新建docker-compose.yml1234567891011version: "2"services: jsconsole: build: . volumes: - .:/usr/src/app - /usr/src/app/node_modules ports: - "127.0.0.1:8081:8080" command: "npm start" restart: always 127.0.0.1:8081是宿主机IP和端口，我前端采用了nginx做反向代理。如果是直接提供公网服务的话把127.0.0.1去掉 构建镜像在应用根目录下执行1docker-compose build 构建并运行在应用根目录下执行-d是后台执行1docker-compose up -d]]></content>
      <tags>
        <tag>nodejs</tag>
        <tag>docker</tag>
        <tag>docker-composer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php-imagick-字符间距问题]]></title>
    <url>%2F2017%2F10%2F17%2Fphp-imagick-text-spacing.html</url>
    <content type="text"><![CDATA[在用php-imagick扩展做图像合成的时候，有个地方需要改下文本间距，百度一下发现setTextInterWordSpacing有这个方法，但是测试发现不管传多少值都毫无作用。 后面google查了一下，发现setTextKerning才是设置文本字符间距的函数。 此外，还发现一个bug，mac下roundCorners函数不存在的问题，找了个把小时才发现这是imagick在mac上面的bug，先写在这里，等有空在研究下。]]></content>
      <tags>
        <tag>php</tag>
        <tag>imagick</tag>
        <tag>图像合成</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac下php-imagick扩展library not loaded问题]]></title>
    <url>%2F2017%2F10%2F17%2Fmac-php-imagick-library-not-loaded.html</url>
    <content type="text"><![CDATA[最近在使用imagick开发图像合成功能，和往常一样，终端执行 1brew install php71-imagick 虽然homebrew提示我安装成功了，然而php -m的时候确提示php-imagick模块无法加载。 google发现很多使用homebrew的人都遇到了问题，解决方法是使用源码编译imagick扩展，当然有个Homebrew倒是不用自己输入很长串的编译命令。 终端执行 1brew reinstall -s php71-imagick -s代表源码编译。]]></content>
  </entry>
  <entry>
    <title><![CDATA[yii2关闭csrf校验和cookie校验]]></title>
    <url>%2F2017%2F10%2F17%2Fyii2-close-csrf-validation-cookie-validatetion.html</url>
    <content type="text"><![CDATA[重要提示1关闭该选项会导致应用安全性收到影响！ 问题出现 开发API的时候发现POST请求老是不能通过验证，直接把报错文案放到项目中去搜索发现yii\web\Request中有enableCsrfValidation。 其他应用设置的cookie，抓包的时候可以看到请求中有cookie，但是yii2读取不到。 源码解析找到yii\web\Request文件，看到12345678/** * @var bool whether to enable CSRF (Cross-Site Request Forgery) validation. Defaults to true. */public $enableCsrfValidation = true;/** * @var bool whether cookies should be validated to ensure they are not tampered. Defaults to true. */public $enableCookieValidation = true; 发现是这里有问题，基于yii2一切都是组件的思想，去修改组件配置即可。 修正编辑config/web.php的components节123456'request' =&gt; [ 'cookieValidationKey' =&gt; 'xxxx', 'enableCookieValidation' =&gt; false, 'enableCsrfValidation' =&gt; false, ],],]]></content>
      <tags>
        <tag>yii2</tag>
        <tag>csrf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[koa-cooke使用maxAge代替expires来设置过期时间]]></title>
    <url>%2F2017%2F10%2F17%2Fkoa-cookie-use-maxage.html</url>
    <content type="text"><![CDATA[expires原来设置cookie使用的以下代码 123const cookieOptions = &#123; expires: moment().add(6,'day').toDate(),&#125;; 但是查看network的时候，cookie虽然设置了，但是过期时间比现在还早，导致一设置就过期，所以expires貌似没作用。 maxage查看对应的typescript定义文件index.d.ts发现还有一个maxAge选项也可以用来控制cookie过期时间1234/** * a number representing the milliseconds from Date.now() for expiry */maxAge?: number; 这个参数更简单，基于当前时间的毫秒数，使用以下代码测试之后，发现过期时间跟预期一致一个星期： 123const cookieOptions = &#123; maxAge: 3600 * 24 * 7 * 1000,&#125;;]]></content>
      <tags>
        <tag>koa</tag>
        <tag>koa2</tag>
        <tag>cookie</tag>
        <tag>koa-cookie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ios新版本代理设置问题]]></title>
    <url>%2F2017%2F10%2F16%2Fios-proxy-certificate-setting.html</url>
    <content type="text"><![CDATA[背景系统是iOS11，电脑端用的charles代理，目前需要查看一些https网站返回的数据，还是使用老方法把charles的根证书设为信任，手机也打开chls.pro/ssl把证书添加到系统了。但是抓包的时候依旧无法访问，safari直接提示“该网站提供的证书不可信任”，查看详情发现charles证书虽然安装，但是没生效。 解决方法可能是iOS加强了安全性以及用户体验，往常的时候一旦我们加入证书，除非卸载，该证书是一直生效的（排除掉被吊销或者过期情况），而iOS11在设置-通用-关于手机-证书信任设置中可以方便开关证书。之前在iOS10.3也出现过问题，解决方法应该也是一致的。]]></content>
      <tags>
        <tag>ios</tag>
        <tag>proxy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet中print-writer和outputstream编码问题]]></title>
    <url>%2F2017%2F10%2F16%2Fservlet-print-writer-outputstream-encoding.html</url>
    <content type="text"><![CDATA[有个项目需要使用java开发一个简单的web接口用来请求加密数据，但是servlet之前只随便用了一下，平时工作也是以node为主。 问题问题大致是”iso 88591 encoding之类的问题，稍微去google搜了一下，可能是搜的关键词不准确导致搜到的答案不理想，无意中看到有人讲writer和outputstream的问题。 原因google到PrintWriter和OutputStream的区别 1PrintWriter是以字符为单位，对所有的信息进行处理，而ServletOutputStream仅对二进制的资料进行处理。 而我输出的是UTF8格式的字符串，所以OutputStream并不认识。 解决使用PrintWriter输出即可。]]></content>
      <tags>
        <tag>java</tag>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[excel-stream Unknown Encoding错误问题]]></title>
    <url>%2F2017%2F10%2F15%2Fexcel-stream-unknown-encoding.html</url>
    <content type="text"><![CDATA[项目上线有半年多了，一直没有出过问题，但是前几天升级过一次NodeJs到8.x的时候就出现过这个问题了。因为采用了消息队列，但是一到这里就挂，导致进程重复启动几百次。 报错信息1excel-stream/csv-stream/index.js 59 Buffer unknow encoding 问题排查google了一下无果，后面发现反正源码反正自己有，倒不如自己改改，直接定位到相关代码即可。 123456789CSVStream.prototype.write = function(buffer,encoding)&#123; this._encoding = encoding || this._encoding; if(this._ended) throw new Error('Cannot write after end has been called.'); if(buffer) this._buffer = Buffer.concat([this._buffer, buffer], this._buffer.length + buffer.length); if(this._paused) return false; this._parser.parse(this._buffer.toString(this._encoding)); this._buffer = new Buffer(0); return !this._paused;&#125; 报错具体行数是this._parser.parse(this._buffer.toString(this._encoding));，错误很明显了，提示encoding错误。 那直接往上面找，发现this._encoding = encoding || this._encoding，这里就有可能传入的encoding导致了错误。 问题解决这个项目已经3年没维护了，所以要修正问题的话，只能手动改了。 修改办法如下 1this._parser.parse(this._buffer.toString(this._encoding)); 改为 1this._parser.parse(this._buffer.toString()); 重新运行之后没有发现问题。]]></content>
  </entry>
  <entry>
    <title><![CDATA[从零开始向DefinitelyTyped贡献代码]]></title>
    <url>%2F2017%2F10%2F15%2Fcontributing-to-DefinitelyTyped-step-by-step.html</url>
    <content type="text"><![CDATA[什么是DefinitelyTyped?讲到DefinitelyTyped，我想做typescript开的人应该不会陌生，DefinitelyTyped是一个由typescript的发明者Microsoft维护的一个项目。 为什么会有DefinitelyTyped?typescript是基于declation的一门语言，declation这个东西有点像C语言的头文件，就是变量、函数等等需要事先声明才能通过typescript编辑。为了方便开发者，也为了快速推广typescript，官方维护的这个项目给npm常用的一些包都定义了declations文件。既然是托管在github的OpenSource Project，那么只要是github的会员就可以提交PR（当然Merge与否还得看项目组成员）,由于社区的活跃使得该仓库越来越丰富。很荣幸，我也提交了几个npm包的declations在上面。 如何提交PR到DefinitelyTyped?很多时候会遇到自己使用的npm包比较冷门，而DefinitelyTyped上面又没有，这时候虽然可以在本地定义，但是能够发布到DefinitelyTyped方便大家也是极好的，毕竟要拥抱开源嘛！官方的ReadMe中有How can I contribute?来告知开发者如何提交PR，但是需要英语基础，哈哈。 Step By Step环境搭建fork 项目要提交PR的第一步是必须fork到自己的仓库，别人不会随便给你直接改，万一改挂了他们还得背锅.登录github,打开项目地址DefinitelyTypedfork完毕后，你会拥有一个自己的仓库地址，本文中我的地址是https://github.com/xialeistudio/DefinitelyTyped clone 到本地我本地的项目地址是~/WebstormProjects/DefinitelyTyped终端执行 git clone https://github.com/xialeistudio/DefinitelyTyped 安装npm依赖终端执行 cd ~/WebstormProjects/DefinitelyTyped &amp;&amp; yarn SourceTree本文使用SourceTree配合git flow来进行项目管理。 下载soucetree 下载地址 安装sourcetree，期间需要登录。 用sourcetree打开刚才克隆的项目。 点击菜单栏【仓库】-&gt;【git-flow或hg flow】-&gt;【初始化仓库】 开始开发本文将以koa2-cors为例提交PR。 使用sourcetree的git-flow创建feature 分支名称填写koa2-cors 这时候已经可以编码了。我用的vscode，轻量，建议大家也用这个，webstorm打开这个项目就卡死了。 安装定义文件生成工具，终端执行npm install -g dts-gen 生成项目文件，终端执行dts-gen –dt –name koa2-cors –template module 这个时候在types/koa2-cors目录下就是我们需要编辑的文件了。如果编写定义文件不在本文范畴，有需要的朋友可以去tslang官网看看手册。 开始编辑index.d.ts，完整定义如下，记得改自己的个人信息: 123456789101112131415161718192021222324252627282930313233343536373839404142 // Type definitions for koa2-cors 2.0 // Project: https://github.com/zadzbw/koa2-cors#readme // Definitions by: xialeistudio &lt;https://github.com/xialeistudio&gt; // Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped import * as Koa from 'koa'; declare namespace cors &#123; interface Options &#123; origin?: any; exposeHeaders?: string[]; maxAge?: number; credentials?: boolean; allowMethods?: string[]; allowHeaders?: string[]; &#125; &#125; declare function cors(options?: cors.Options): Koa.Middleware; export = cors; ``` 8. 编写单元测试文件**koa2-cors-tests.ts**，测试就是写上样板代码即可，只要能通过编译就行。 ```typescript import * as Koa from 'koa'; import * as cors from 'koa2-cors'; const app = new Koa(); app.use(cors(&#123; origin: function (ctx: Koa.Context) &#123; if (ctx.url === '/test') &#123; return false; &#125; return '*'; &#125;, exposeHeaders: ['WWW-Authenticate', 'Server-Authorization'], maxAge: 5, credentials: true, allowMethods: ['GET', 'POST', 'DELETE'], allowHeaders: ['Content-Type', 'Authorization', 'Accept'], &#125;)); app.listen(3000); 启动单元测试，终端执行npm run test，如果没有报错，即可进行提交流程，否则要修好错误才能提交。很幸运，单元测试通过： commit，终端执行git add . &amp;&amp; git commit -m “add koa2-cors definition” 使用sourcetree创建PR 点击在网上创建拉取请求 此时会自动打开github网页进行PR操作 编辑PR提交模板，这个根据实际情况编写即可，注意下方的If xxx，这个是不同提交类型需要填写的。本文是新增，所以选择add 点击Create Pull Request，此时会进行travis自动化测试流程，如果有错误需要点进去看到错误信息之后修正，很不幸。我们的第一次提交失败： 点击Details进行详细错误页面，找到=== Error === 可以发现我们错误是“ Expected &quot;strictFunctionTypes&quot;: true or &quot;strictFunctionTypes&quot;: false,这个是tsconfig.json导致的问题，感觉是个历史遗留问题，因为使用的是默认创建的模板，不过为了提交PR，还是要手动修复。编辑types/koa2-cors/tsconfig.json，在compilerOptions下添加，代码如下： 1234567891011121314151617181920212223&#123; "compilerOptions": &#123; "module": "commonjs", "lib": [ "es6" ], "noImplicitAny": true, "noImplicitThis": true, "strictNullChecks": true, "baseUrl": "../", "strictFunctionTypes": false, "typeRoots": [ "../" ], "types": [], "noEmit": true, "forceConsistentCasingInFileNames": true &#125;, "files": [ "index.d.ts", "koa2-cors-tests.ts" ]&#125; commit，终端执行git add . &amp;&amp; git commit -m “strictFunctionTypes” &amp;&amp; git push，不需要再创建PR了，当你在该分支PUSH的时候，远端会自动触发自动化测试任务。 成功通过测试后，就可以等待官方人员过来review了。一般来说都会通过并且合并到master中去。]]></content>
      <categories>
        <category>typescript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用Docker来部署NodeJs应用]]></title>
    <url>%2F2017%2F10%2F10%2Fdocker-publish-nodejs.html</url>
    <content type="text"><![CDATA[Docker的环境无关性以及自动化特性实在是令人称赞，最近遇到的一个问题是，NodeJs使用8.x版本开发，但是线上服务器是7.x的，这时候又不能动线上的应用。于是想到了使用Docker来部署NodeJs，服务器是Ubuntu的。 安装Docker1apt install docker.io Dockerfile编写由于默认的dockhub速度非常慢导致下载镜像慢，而且镜像下来的Ubuntu apt源又是国外的，简直是慢上加慢，本文使用daocloud.io的Ubuntu镜像以及阿里云的Ubuntu源 123456789101112131415161718192021FROM daocloud.io/library/ubuntuMAINTAINER xialeistudio&lt;xialeistudio@gmail.com&gt;ENV PATH $PATH:/opt/node/binENV PORT 80ENV HOST 0.0.0.0# prepareADD sources.list /etc/apt/sources.listRUN apt updateRUN apt install wget gcc python git -y# nodejsRUN wget https://npm.taobao.org/mirrors/node/latest-v8.x/node-v8.6.0-linux-x64.tar.gzRUN tar xf node-v8.6.0-linux-x64.tar.gzRUN mv node-v8.6.0-linux-x64 /opt/node# appRUN mkdir appADD . /root/appWORKDIR /root/appRUN /opt/node/bin/npm install --registry=https://registry.npm.taobao.org# start appENTRYPOINT ["npm","start"] 指令解释一下 指定模板镜像 维护者信息，这是本人写的，所以署名为本人 环境变量定义 复制宿主机当前目录的sources.list到docker中的/etc/apt目录用来替换默认的Ubuntu源 更新apt并安装必要软件 从淘宝镜像站下载nodejs二进制版本 解压并移动到/opt/node目录 创建应用目录，并把宿主机当前文件夹下的所有文件拷贝到docker景象中 使用淘宝镜像安装npm包 启动APP build镜像1docker build -t demo . 运行完毕后就可以使用docker images查看镜像了 启动容器1docker run -d -p 127.0.0.1:7001:80 demo 这时候容器已经启动，并通过端口转发监听在宿主机的7001端口上，配合nginx做反向代理就可以部署一个公网应用了。不管你容器中部署何种版本的NodeJs都不会对宿主机造成影响，这点很重要。]]></content>
      <categories>
        <category>docker</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Nginx alias和root指令]]></title>
    <url>%2F2017%2F09%2F14%2Fnginx-alias-root.html</url>
    <content type="text"><![CDATA[Nginx的root指令相信大家用的都挺多，用来指定document_root，但是如果是针对特定path的请求才启用的话，root指令显得不好用123location /web &#123; root /home/wwwroot/site1;&#125; 访问 http://demo.com/web/a.js的时候,nginx会去查找/home/wwwroot/site1/web/a.js，一般就会404了。因为文件是放在site1目录下的。这时候就需要alias指令了。123location /web/&#123; alias /home/wwwroot/site1/;&#125; 访问 http://demo.com/web/a.js的时候,nginx会去查找/home/wwwroot/site1/a.js。 注意 alias location末尾斜杠以及alias的末尾斜杠]]></content>
      <categories>
        <category>nginx</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用pm2来保证Spring Boot应用稳定运行]]></title>
    <url>%2F2017%2F07%2F31%2Fspring-boot-pm2.html</url>
    <content type="text"><![CDATA[Spring Boot开发web应用就像开发普通的java程序一般简洁，因为其内嵌了web容易，启动的时候只需要一条命令java -jar server.jar即可，非常方便。但是由此而来的问题是万一应用挂了怎么办？ 别担心，有pm2进程管理工具可以帮到你。 PM2简介pm2原先是nodejs应用的进程管理工具，不过其良好的设计以及扩展性可以手动执行执行进程。 PM2安装 安装NodeJs npm install pm2 -g PM2基本命令 pm2 list 查看所有被PM2管理的进程列表 pm2 start xxx 启动一个应用 pm2 stop xxx 停止一个应用 pm2 restart xxx 重启一个应用 pm2 describe xxx 查看应用详情 pm2 startup, pm2 save 两条命令，用来保证服务器启动时,pm2管理的程序自动运行 Java程序处理在jar的同级目录新建应用启动配置文件，如pm2.json，内容如下： 12345678910&#123; "name": "my-server", "script": "/usr/bin/java", "args": [ "-jar", "server.jar" ], "exec_interpreter": "", "exec_mode": "fork"&#125; 说明如下： name 进程名称（显示在pm2 list命令中） script 执行进程名称，如果需要执行PHP脚本则填写php解释器的路径，本文为java args 传给执行进程的参数，多个参数以数组单元分割 exec_interpreter NodeJs解析器，本文不适用 exec_mode 执行模式[cluster|fork]这个针对NodeJs应用的配置，非NodeJs应用统一fork 配置文件完成后，使用1pm2 start pm2.json 即可看到应用被启动 日志管理日志路径在~/.pm2/logs，stdout和stderr被分开存放，程序中的所有stdout和stderr都被收集方便查错。]]></content>
      <categories>
        <category>spring book</category>
      </categories>
      <tags>
        <tag>pm2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot JPA 返回json时排除Null字段]]></title>
    <url>%2F2017%2F07%2F31%2Fspring-boot-exclude-null.html</url>
    <content type="text"><![CDATA[Spring Boot在返回JSON的时候默认会返回null字段，这个对客户端一般没什么作用，还会增加服务器带宽压力。使用如下配置可以屏蔽。 在pojo对象上添加注解 123@JsonInclude(JsonInclude.Include.NON_NULL)class User &#123;&#125; 再使用@ResponseBody的时候就不会返回Null字段了。]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>json</tag>
        <tag>jpa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端rem和PSD单位换算问题]]></title>
    <url>%2F2017%2F07%2F28%2Fmobile-rem.html</url>
    <content type="text"><![CDATA[设计图尺寸一般750宽度，而需要兼容640宽度手机的话，需要调整缩放比率，之前使用写死viewport的做法来实现，不过这个方法有点取巧，而且有些场景并不适用。本文用标准的@media来实现 rem定义1234567891011121314151617181920212223@media screen and (max-width: 750px) &#123; html &#123; font-size: 30px; &#125;&#125;@media screen and (min-width: 640px) and (max-width: 749px) &#123; html &#123; font-size: 25px; &#125;&#125;@media screen and (min-width: 480px) and (max-width: 639px) &#123; html &#123; font-size: 20px; &#125;&#125;@media screen and (min-width: 320px) and (max-width: 479px) &#123; html &#123; font-size: 15px; &#125;&#125; 如何使用假设PSD中有个button的大小为100px*40px，那使用rem时CSS如下1234button &#123; width: 3.333rem; height: 1.333rem;&#125;]]></content>
      <categories>
        <category>css3</category>
      </categories>
      <tags>
        <tag>css3</tag>
        <tag>rem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[druid spring boot 统计SQL问题]]></title>
    <url>%2F2017%2F07%2F18%2Fspring-boot-druid-sql.html</url>
    <content type="text"><![CDATA[spring-boot配置12345678910111213141516171819spring.jpa.hibernate.ddl-auto=validatespring.datasource.type=com.alibaba.druid.pool.DruidDataSourcespring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.initialize=truespring.datasource.initialSize=5spring.datasource.minIdle=5spring.datasource.maxActive=10spring.datasource.maxWait=60000spring.datasource.timeBetweenEvictionRunsMillis=60000spring.datasource.minEvictableIdleTimeMillis=300000spring.datasource.validationQuery=SELECT 'x'spring.datasource.testWhileIdle=truespring.datasource.testOnBorrow=falsespring.datasource.testOnReturn=falsespring.datasource.poolPreparedStatements=falsespring.datasource.maxPoolPreparedStatementPerConnectionSize=20spring.datasource.filters=stat,wall,slf4jspring.datasource.connectionProperties=druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000spring.datasource.useGlobalDataSourceStat=true 这个配置没有什么好说的，网上很多，可能关键在 123spring.datasource.filters=stat,wall,slf4jspring.datasource.connectionProperties=druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000spring.datasource.useGlobalDataSourceStat=true 但是就算配置好这些后，返回/druid也不显示SQL统计。其实问题在于 系统默认使用的数据库连接池没有使用你的配置，所以需要我们手动实例化Bean kotlin代码1234567@SpringBootApplicationopen class Application &#123; @Bean @ConfigurationProperties(prefix = "spring.datasource") open fun druidDataSource(): DataSource &#123; return DruidDataSource() &#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>spring-boot</tag>
        <tag>druid</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用RSA在PHP和NodeJs中进行加密数据通信]]></title>
    <url>%2F2017%2F06%2F24%2Frsa-in-node-php.html</url>
    <content type="text"><![CDATA[RSA算法是目前用的最多的非对称加密算法，文本将基于openssl在nodejs和php中进行加密数据通信。 生成密钥对123opensslgenrsa -out private.key 2048rsa -in private.key -pubout -out public.key 执行完命令后，可以在当前目录看到: public.key 公钥 private.key 私钥 NodeJs服务器本文使用koa2来构建一个基于openssl加密方案的http服务器。源码使用typescript进行开发。 安装依赖12npm init -ynpm install typescript koa koa-router @types/node @types/koa @types/koa-router --save 最终的package.json内容如下： 123456789101112131415161718192021&#123; "name": "openssl-demo", "version": "1.0.0", "description": "", "main": "index.js", "scripts": &#123; "build": "tsc -w", "start": "node index.js" &#125;, "keywords": [], "author": "", "license": "ISC", "dependencies": &#123; "@types/koa": "^2.0.39", "@types/koa-router": "^7.0.22", "@types/node": "^8.0.2", "koa": "^2.3.0", "koa-router": "^7.2.1", "typescript": "^2.3.4" &#125;&#125; 开始编码index.ts:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import * as crypto from 'crypto';import * as constants from 'constants';import * as Koa from 'koa';import * as KoaRouter from 'koa-router';import * as fs from 'fs';class Server &#123; app: Koa; static bootstrap() &#123; return new Server(); &#125; constructor() &#123; this.app = new Koa(); this.route(); this.app.listen(8081, () =&gt; &#123; console.info('listen on 8081'); &#125;); &#125; parsePostData(ctx): Promise&lt;Buffer&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; try &#123; let postdata = Buffer.alloc(0); ctx.req.addListener('data', (data) =&gt; &#123; postdata = Buffer.concat([data]); &#125;); ctx.req.addListener("end", function () &#123; resolve(postdata); &#125;) &#125; catch (err) &#123; reject(err) &#125; &#125;) &#125; private readFile(path): Promise&lt;Buffer&gt; &#123; return new Promise((resolve, reject) =&gt; fs.readFile(path, (e, data) =&gt; e ? reject(e) : resolve(data))); &#125; private route() &#123; const router = new KoaRouter(); router.post('/', async (ctx: Koa.Context, next) =&gt; &#123; const encrypted = await this.parsePostData(ctx); // 接收到的经过base64编码后的加密数据 const key = await this.readFile(__dirname + '/private.key');//读取私钥 const pkey = key.toString();// 字符串形式的私钥 const data = crypto.privateDecrypt(&#123;key: pkey, padding: constants.RSA_PKCS1_PADDING&#125;, new Buffer(encrypted.toString(), 'base64')); // 使用私钥解密Buffer const json = JSON.parse(data.toString()); // 将解密后的信息解码为json对象 const msg = JSON.stringify(&#123;errcode: json.name === 'demo' ? 0 : 1, errmsg: json.name === 'demo' ? 'ok' : 'error'&#125;); // 需要返回的明文数据 const e = crypto.privateEncrypt(&#123;key: pkey, padding: constants.RSA_PKCS1_PADDING&#125;, new Buffer(msg)); // 使用私钥加密返回数据 ctx.body = e.toString('base64'); // 将buffer编码为base64字符串后返回 &#125;); this.app .use(router.routes()) .use(router.allowedMethods()); &#125;&#125;Server.bootstrap(); 编译typescript1npm run build 启动服务器1npm run start 此时我们的服务器已经启动完成。 PHP客户端将2中的公钥复制到php项目下。本文使用rmccue/requests作为http客户端发起请求。index.php关键代码如下: 123456789&lt;?php$pubKey = openssl_pkey_get_public(file_get_contents(__DIR__ . '/public.key')); // 读取公钥$data = Json::encode(['name' =&gt; 'demo']); // 需要提交的明文数据openssl_public_encrypt($data, $encryped, $pubKey); // 使用公钥加密明文数据$data = base64_encode($encryped); // 将加密后的数据进行base64编码$res = Requests::post('http://localhost:8081', [], $data); // 将base64数据提交到NodeJs$data = base64_decode($res-&gt;body);// 接收NodeJs私钥加密后的响应并进行base64解码openssl_public_decrypt($data, $dd, $pubKey); // 使用公钥将密文解密echo $dd; // 打印数据 执行正常请求1php index.php 输出如下1&#123;"errcode":0,"errmsg":"ok"&#125; 执行不正常请求将php中1$data = Json::encode(['name' =&gt; 'demo']); 改为1$data = Json::encode(['name' =&gt; 'demo1']); 发现收到的响应为1&#123;"errcode":1,"errmsg":"error"&#125; 证明提交的数据不能被nodejs接受。 后记本文简单使用了一下openssl相关功能函数，旨在起到一个抛砖引玉的作用，基于rsa算法可以开发出很多安全性很高的应用。]]></content>
      <categories>
        <category>php</category>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>openssl</tag>
        <tag>rsa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs unhandledRejection问题解决]]></title>
    <url>%2F2017%2F06%2F13%2Fnode-unhandledRejection.html</url>
    <content type="text"><![CDATA[今天在使用promise的时候没有catch掉错误，导致报错，类似于1unhandledRejection promise .... 而且不会显示trace信息，导致无从查错，经过google发现，需要监听进程的unhandledRejection事件，才能显示trace信息123process.on('unhandledRejection', (...params) =&gt; &#123; console.log(params);&#125;);]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[nginx反向代理websocket支持跨域]]></title>
    <url>%2F2017%2F05%2F24%2Fnginx-proxy-websocket-cors.html</url>
    <content type="text"><![CDATA[今天在调试远程websocket的时候发现控制台提示跨域错误，看到浏览器Network中方向响应头没有跨域方面的数据。 nginx做websocket反向代理挺简单的 123456proxy_set_header Upgrade $http_upgrade;proxy_set_header Connection "upgrade";proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;proxy_set_header Host $host;proxy_http_version 1.1;proxy_pass http://socket服务器地址; 但是如此配置除非后端服务器支持跨域，否则socket无法跨域。其实nginx支持的add_header指令已经可以添加跨域相关头了 完整配置如下1234567891011add_header "Access-Control-Allow-Origin" "$http_origin";add_header "Access-Control-Allow-Credentials" "true";add_header "Access-Control-Allow-Methods" "GET, POST, OPTIONS, DELETE, PATCH, PUT, HEAD";add_header "Access-Control-Allow-Headers" "DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type";proxy_set_header Upgrade $http_upgrade;proxy_set_header Connection "upgrade";proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;proxy_set_header Host $host;proxy_http_version 1.1;proxy_pass http://socket服务器地址; 再看到浏览器响应头时发现已经成功返回跨域头了。]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>cors</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yii2框架MemCache在腾讯云部署时不过期问题]]></title>
    <url>%2F2017%2F05%2F12%2Fyii2-memcached-qcloud-not-expires.html</url>
    <content type="text"><![CDATA[之前部署在阿里云时一直memcache没有问题，部署到腾讯云发现缓存永不过期。查看yii2的MemCache类源码后，发现在设置缓存时，Yii2添加了$expire = $duration &gt; 0 ? $duration + time() :0;这样的代码，会导致强制使用时间戳来标记过期时间，而阿里云是过期时间和时间戳都支持的，腾讯云只支持前者。 解决方案重写组件即可在app\components中加添加MemCache集成Yii2的MemCache，由于Yii2的MemCache中$_cache成员变量为private，子类无法访问，所以需要直接copy源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314&lt;?php/** * Created by PhpStorm. * User: xialei * Date: 2017/5/12 * Time: 下午5:55 */namespace app\components;use yii\base\InvalidConfigException;use yii\caching\MemCacheServer;class MemCache extends \yii\caching\MemCache&#123; /** * @var bool whether to use memcached or memcache as the underlying caching extension. * If true, [memcached](http://pecl.php.net/package/memcached) will be used. * If false, [memcache](http://pecl.php.net/package/memcache) will be used. * Defaults to false. */ public $useMemcached = false; /** * @var string an ID that identifies a Memcached instance. This property is used only when [[useMemcached]] is true. * By default the Memcached instances are destroyed at the end of the request. To create an instance that * persists between requests, you may specify a unique ID for the instance. All instances created with the * same ID will share the same connection. * @see http://ca2.php.net/manual/en/memcached.construct.php */ public $persistentId; /** * @var array options for Memcached. This property is used only when [[useMemcached]] is true. * @see http://ca2.php.net/manual/en/memcached.setoptions.php */ public $options; /** * @var string memcached sasl username. This property is used only when [[useMemcached]] is true. * @see http://php.net/manual/en/memcached.setsaslauthdata.php */ public $username; /** * @var string memcached sasl password. This property is used only when [[useMemcached]] is true. * @see http://php.net/manual/en/memcached.setsaslauthdata.php */ public $password; /** * @var \Memcache|\Memcached the Memcache instance */ private $_cache; /** * @var array list of memcache server configurations */ private $_servers = []; /** * Initializes this application component. * It creates the memcache instance and adds memcache servers. */ public function init() &#123; parent::init(); $this-&gt;addServers($this-&gt;getMemcache(), $this-&gt;getServers()); &#125; /** * Add servers to the server pool of the cache specified * * @param \Memcache|\Memcached $cache * @param MemCacheServer[] $servers * @throws InvalidConfigException */ protected function addServers($cache, $servers) &#123; if (empty($servers)) &#123; $servers = [new MemCacheServer([ 'host' =&gt; '127.0.0.1', 'port' =&gt; 11211, ])]; &#125; else &#123; foreach ($servers as $server) &#123; if ($server-&gt;host === null) &#123; throw new InvalidConfigException("The 'host' property must be specified for every memcache server."); &#125; &#125; &#125; if ($this-&gt;useMemcached) &#123; $this-&gt;addMemcachedServers($cache, $servers); &#125; else &#123; $this-&gt;addMemcacheServers($cache, $servers); &#125; &#125; /** * Add servers to the server pool of the cache specified * Used for memcached PECL extension. * * @param \Memcached $cache * @param MemCacheServer[] $servers */ protected function addMemcachedServers($cache, $servers) &#123; $existingServers = []; if ($this-&gt;persistentId !== null) &#123; foreach ($cache-&gt;getServerList() as $s) &#123; $existingServers[$s['host'] . ':' . $s['port']] = true; &#125; &#125; foreach ($servers as $server) &#123; if (empty($existingServers) || !isset($existingServers[$server-&gt;host . ':' . $server-&gt;port])) &#123; $cache-&gt;addServer($server-&gt;host, $server-&gt;port, $server-&gt;weight); &#125; &#125; &#125; /** * Add servers to the server pool of the cache specified * Used for memcache PECL extension. * * @param \Memcache $cache * @param MemCacheServer[] $servers */ protected function addMemcacheServers($cache, $servers) &#123; $class = new \ReflectionClass($cache); $paramCount = $class-&gt;getMethod('addServer')-&gt;getNumberOfParameters(); foreach ($servers as $server) &#123; // $timeout is used for memcache versions that do not have $timeoutms parameter $timeout = (int)($server-&gt;timeout / 1000) + (($server-&gt;timeout % 1000 &gt; 0) ? 1 : 0); if ($paramCount === 9) &#123; $cache-&gt;addserver( $server-&gt;host, $server-&gt;port, $server-&gt;persistent, $server-&gt;weight, $timeout, $server-&gt;retryInterval, $server-&gt;status, $server-&gt;failureCallback, $server-&gt;timeout ); &#125; else &#123; $cache-&gt;addserver( $server-&gt;host, $server-&gt;port, $server-&gt;persistent, $server-&gt;weight, $timeout, $server-&gt;retryInterval, $server-&gt;status, $server-&gt;failureCallback ); &#125; &#125; &#125; /** * Returns the underlying memcache (or memcached) object. * @return \Memcache|\Memcached the memcache (or memcached) object used by this cache component. * @throws InvalidConfigException if memcache or memcached extension is not loaded */ public function getMemcache() &#123; if ($this-&gt;_cache === null) &#123; $extension = $this-&gt;useMemcached ? 'memcached' : 'memcache'; if (!extension_loaded($extension)) &#123; throw new InvalidConfigException("MemCache requires PHP $extension extension to be loaded."); &#125; if ($this-&gt;useMemcached) &#123; $this-&gt;_cache = $this-&gt;persistentId !== null ? new \Memcached($this-&gt;persistentId) : new \Memcached; if ($this-&gt;username !== null || $this-&gt;password !== null) &#123; $this-&gt;_cache-&gt;setOption(\Memcached::OPT_BINARY_PROTOCOL, true); $this-&gt;_cache-&gt;setSaslAuthData($this-&gt;username, $this-&gt;password); &#125; if (!empty($this-&gt;options)) &#123; $this-&gt;_cache-&gt;setOptions($this-&gt;options); &#125; &#125; else &#123; $this-&gt;_cache = new \Memcache; &#125; &#125; return $this-&gt;_cache; &#125; /** * Returns the memcache or memcached server configurations. * @return MemCacheServer[] list of memcache server configurations. */ public function getServers() &#123; return $this-&gt;_servers; &#125; /** * @param array $config list of memcache or memcached server configurations. Each element must be an array * with the following keys: host, port, persistent, weight, timeout, retryInterval, status. * @see http://php.net/manual/en/memcache.addserver.php * @see http://php.net/manual/en/memcached.addserver.php */ public function setServers($config) &#123; foreach ($config as $c) &#123; $this-&gt;_servers[] = new MemCacheServer($c); &#125; &#125; /** * Retrieves a value from cache with a specified key. * This is the implementation of the method declared in the parent class. * @param string $key a unique key identifying the cached value * @return mixed|false the value stored in cache, false if the value is not in the cache or expired. */ protected function getValue($key) &#123; return $this-&gt;_cache-&gt;get($key); &#125; /** * Retrieves multiple values from cache with the specified keys. * @param array $keys a list of keys identifying the cached values * @return array a list of cached values indexed by the keys */ protected function getValues($keys) &#123; return $this-&gt;useMemcached ? $this-&gt;_cache-&gt;getMulti($keys) : $this-&gt;_cache-&gt;get($keys); &#125; /** * Stores a value identified by a key in cache. * This is the implementation of the method declared in the parent class. * * @param string $key the key identifying the value to be cached * @param mixed $value the value to be cached. * @see [Memcache::set()](http://php.net/manual/en/memcache.set.php) * @param int $duration the number of seconds in which the cached value will expire. 0 means never expire. * @return bool true if the value is successfully stored into cache, false otherwise */ protected function setValue($key, $value, $duration) &#123; // Use UNIX timestamp since it doesn't have any limitation // @see http://php.net/manual/en/memcache.set.php // @see http://php.net/manual/en/memcached.expiration.php $expire = $duration; return $this-&gt;useMemcached ? $this-&gt;_cache-&gt;set($key, $value, $expire) : $this-&gt;_cache-&gt;set($key, $value, 0, $expire); &#125; /** * Stores multiple key-value pairs in cache. * @param array $data array where key corresponds to cache key while value is the value stored * @param int $duration the number of seconds in which the cached values will expire. 0 means never expire. * @return array array of failed keys. Always empty in case of using memcached. */ protected function setValues($data, $duration) &#123; if ($this-&gt;useMemcached) &#123; // Use UNIX timestamp since it doesn't have any limitation // @see http://php.net/manual/en/memcache.set.php // @see http://php.net/manual/en/memcached.expiration.php $expire = $duration; $this-&gt;_cache-&gt;setMulti($data, $expire); return []; &#125; else &#123; return parent::setValues($data, $duration); &#125; &#125; /** * Stores a value identified by a key into cache if the cache does not contain this key. * This is the implementation of the method declared in the parent class. * * @param string $key the key identifying the value to be cached * @param mixed $value the value to be cached * @see [Memcache::set()](http://php.net/manual/en/memcache.set.php) * @param int $duration the number of seconds in which the cached value will expire. 0 means never expire. * @return bool true if the value is successfully stored into cache, false otherwise */ protected function addValue($key, $value, $duration) &#123; // Use UNIX timestamp since it doesn't have any limitation // @see http://php.net/manual/en/memcache.set.php // @see http://php.net/manual/en/memcached.expiration.php $expire = $duration; return $this-&gt;useMemcached ? $this-&gt;_cache-&gt;add($key, $value, $expire) : $this-&gt;_cache-&gt;add($key, $value, 0, $expire); &#125; /** * Deletes a value with the specified key from cache * This is the implementation of the method declared in the parent class. * @param string $key the key of the value to be deleted * @return bool if no error happens during deletion */ protected function deleteValue($key) &#123; return $this-&gt;_cache-&gt;delete($key, 0); &#125; /** * Deletes all values from cache. * This is the implementation of the method declared in the parent class. * @return bool whether the flush operation was successful. */ protected function flushValues() &#123; return $this-&gt;_cache-&gt;flush(); &#125;&#125; 配置缓存时使用以下代码 12345'class' =&gt; 'app\components\MemCache','useMemcached' =&gt; false,'servers' =&gt; [ ['host' =&gt; '127.0.0.1', 'port' =&gt; 11211]]]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>yii2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用NodeJs提供syslogd服务端]]></title>
    <url>%2F2017%2F04%2F27%2Fnode-syslogd.html</url>
    <content type="text"><![CDATA[syslog作为Linux发行版一个重要组件，相信大家都不陌生，而如果每台服务器都独立使用一份的话，不能做到日志统一管理，对于以后的日志查询不太方便。syslog有标准的协议格式，这里不做讨论，有兴趣的可以基于协议的报文结构使用socket编程实现。 部署服务端本文使用Nodejs来部署一台syslog服务端。 终端执行 12npm init -ynpm install syslogd --save index.js 1234567891011const syslogd = require('syslogd');const server = syslogd(data =&gt; &#123; console.log(data);&#125;);server.listen(514,e =&gt; &#123; if(e!==null) &#123; console.error(e); return; &#125; console.log('listen on 514');&#125;); 终端执行 1node index.js 好了，我们的syslog服务器已经部署完毕了。是不是很简单呢~ nginx日志接入syslog打开nginx配置文件 12345server &#123; ... access_log syslog:server=127.0.0.1; ...&#125; 重启nginx就可以发现nodejs服务端已经成功接收日志信息了。注意：是重启不是reload]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[log4php使用syslog记录日志]]></title>
    <url>%2F2017%2F04%2F27%2Flog4php-syslog.html</url>
    <content type="text"><![CDATA[log4php是apache基金会下的一个开源项目，灵活、强大，已经有几个项目使用了log4php处理日志，目前遇到的问题是服务器太多的时候日志如何统一管理，本来想使用数据库存储。但是日志格式成了一个问题，而且不利于扩展，如果临时需要保存到文件，又要更改log4php的配置。好在log4php提供了syslog的一个appender，可以将日志写入syslog; log4php配置12345678910111213log4php.rootLogger=INFO, stdout, stderrlog4php.appender.stdout=LoggerAppenderConsolelog4php.appender.stdout.layout=LoggerLayoutPatternlog4php.appender.stdout.layout.ConversionPattern=%date&#123;Y-m-d H:i:s&#125; [%-5p] %m%nlog4php.appender.stdout.threshold=INFOlog4php.appender.stderr=LoggerAppenderSysloglog4php.appender.stderr.ident=qun.hk-tasklog4php.appender.stderr.priority=ERRlog4php.appender.stderr.facility=LOCAL0log4php.appender.stderr.layout=LoggerLayoutPatternlog4php.appender.stderr.layout.ConversionPattern=%date&#123;Y-m-d H:i:s&#125; %m%nlog4php.appender.stderr.threshold=WARN 这里使用两个输出目的地,stdout输出到终端，stderr输出到syslod，log4php配置对应rsyslog的配置关系为： ident -&gt; syslog中的tag priority -&gt; syslog中的priority facility -&gt; syslog中的facility，请注意全部为大写 rsyslog配置rsyslog配置文件一般在 /etc/rsyslog.conf 以及 /etc/rsyslog.d目录下我们不更改主配置文件，在/etc/rsyslog.d/目录下新建文件 local0.conf```1234内容为```local0.* /var/log/local0.log rsyslog输出可以写成服务器，本文为了测试直接写入文件，有需要的可以根据实际情况进行转发。重启rsyslog rsyslog restart```12345678## PHP加载配置```php&lt;?php\Logger::configure(__DIR__ . &apos;/log4php.properties&apos;);$logger = \Logger::getLogger(&apos;default&apos;);$logger-&gt;info(&apos;info&apos;);$logger-&gt;error(&apos;error&apos;); 可以看到/var/log/local0.log中多出一行error的日志]]></content>
      <categories>
        <category>php</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[IOS10.3信息APP闪退解决方案]]></title>
    <url>%2F2017%2F03%2F31%2Fios10.3-message-crash.html</url>
    <content type="text"><![CDATA[问题更新IOS10.3之后系统自带的信息APP打开闪退，当然，刷机是一种解决方案。可是遇到点问题就刷机这个工作量有点太大了。 解决方案设置 -&gt; 信息 -&gt; 打开过滤未知发件人]]></content>
      <categories>
        <category>ios</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ReactNative在NavigatorIOS中隐藏TabBar]]></title>
    <url>%2F2017%2F03%2F27%2Freact-native-hidden-tabbar-with-navigatorIOS.html</url>
    <content type="text"><![CDATA[ReactNative常用的一种布局是TabBar+Navigator布局，底部几个固定的标签，顶部有个导航栏，如果进入子页面的话，底部TabBar是需要隐藏起来的。 不过官方没有提供这个属性，github和StackOverflow上的答案有个bug，平时没什么问题，如果手指左滑一点然后松开，这时候路由没切换，但是TarBar会显示，然后不消失。 目前能够完美解决这个问题的方案如下： 找到React/RCTWrapperViewController.m 查找 willShowViewController 在该方法最开始的地方加入self.navigationController.tabBarController.tabBar.hidden=self.navigationController.childViewControllers.count&gt;1;]]></content>
      <categories>
        <category>react-native</category>
      </categories>
      <tags>
        <tag>navigatorIOS</tag>
        <tag>navigation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx反向代理websocket]]></title>
    <url>%2F2017%2F03%2F20%2Fnginx-proxy-websocket.html</url>
    <content type="text"><![CDATA[websocket协议基于http协议升级而来，所以nginx可以直接反向代理websocket，只需要加上必要的header即可。 假设websocket监听端口为18080，编辑nginx配置文件： 12345678910server &#123; listen 80; server_name socket.example.com; location / &#123; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection "upgrade"; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:18080; &#125;&#125;]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>websocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP7编译sphinx扩展]]></title>
    <url>%2F2017%2F02%2F28%2Fphp7-compile-sphinx-extension.html</url>
    <content type="text"><![CDATA[最近在做基于sphinx的全文搜索引擎，使用PHP进行数据读取，但是服务器使用的PHP版本是PHP7，pecl.php.net中没有提供PHP7的版本。手痒点到source code中看了一下。看到源代码中有的headers中有个php7的，点击shortlog进去看了一下，最新更新日期是2017-02-10，挺新的，应该是针对PHP7开发的版本，只不过未发布编译版本，想着linux下的软件有源代码基本都能自行编译。故选择了最新的PHP7快照下载。 开始安装123456wget http://git.php.net/?p=pecl/search_engine/sphinx.git;a=snapshot;h=339e123acb0ce7beb2d9d4f9094d6f8bcf15fb54;sf=tgztar xvfz sphinx-339e123.tar.gzcd sphinx-339e123phpize./configuremake &amp;&amp; make install 安装完毕后会在PHP的配置文件目录多出sphinx.ini，在扩展目录多出sphinx.so文件。终端执行1phpenmod sphinx 即可启用扩展。 本文服务器环境Ubuntu16.04 Server + PHP7.0(使用apt安装)]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>sphinx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NodeJs socket.io连接参数中传入查询字符串]]></title>
    <url>%2F2017%2F02%2F09%2Fsocket.io-connect-params.html</url>
    <content type="text"><![CDATA[socket.io一般会配合room进行消息转发，目前我的做法如下: 服务端 12345io.on('connection',function(socket)&#123; socket.on('join',function(roomId)&#123; socket.join(roomId); &#125;);&#125;); 客户端 1234var socket = io('http://localhost:8888');socket.on('connect',function()&#123; socket.emit('join','live1');&#125;); 可以发现客户端多出了一次emit操作。 查阅socket.io文档发现，在连接URL中是可以传入查询字符串的，服务端也可以获取到。更新后的代码如下： 服务端 1234567io.on('connection',function(socket)&#123; if (socket.handshake.query.roomId === undefined) &#123; console.log('非法请求'); return; &#125; socket.join(socket.handshake.query.roomId);&#125;); 客户端 123var socket = io('http://localhost:8888?roomId=live1');socket.on('connect',function()&#123;&#125;); 这样就可以少一次emit操作，减少客户端以及服务端一部分压力。]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>socket.io</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux使用公钥登录]]></title>
    <url>%2F2017%2F01%2F23%2Flinux-public-key-login.html</url>
    <content type="text"><![CDATA[服务器密码往往是随机字符串，难以记忆，通过配置公钥登录的方式来进行登录。 准备 服务器A 192.168.1.2 客户机 服务器B 192.168.1.3 服务器配置 登录192.168.1.2，终端执行 1ssh-keygen -t rsa 复制~/.ssh/id_rsa.pub文件的内容 在服务器上添加公钥，登录192.168.1.3，终端执行1echo 刚才复制的内容 &gt;&gt; ~/.ssh/authorized_keys 测试登录192.168.1.2，终端执行1ssh 192.168.1.3 首次登录的时候会进行公钥认证，输入yes即可。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在windows上安装jekyll]]></title>
    <url>%2F2017%2F01%2F20%2Finstall-jekyll-on-windows.html</url>
    <content type="text"><![CDATA[早些时候用的ubuntu，安装jekyll确实挺简单，可能是终端强大吧。最近工作环境切换到windows，无奈想写博文的时候却发现需要切换到ubuntu，不是那么方便。打算在windows上部署一下jekyll。 软件环境 Windows 10 企业版 Ruby 2.3.2-x64 部署过程 安装 Ruby2.3.2-x64，安装目录请不要带空格，建议使用默认的”C:\Ruby23-x64”，安装的时候勾上”Add To Path”选项 确认ruby安装成功，打开控制台，执行 1ruby -v 安装 Devkit，安装目录请不要带空格，建议解压到”C:\DevKit” 在C:\DevKit打开控制台CMD，执行12ruby dk.rb initnotepad config.yml 执行完毕后会打开记事本，请确认内容如下：123456789101112131415# This configuration file contains the absolute path locations of all# installed Rubies to be enhanced to work with the DevKit. This config# file is generated by the 'ruby dk.rb init' step and may be modified# before running the 'ruby dk.rb install' step. To include any installed# Rubies that were not automagically discovered, simply add a line below# the triple hyphens with the absolute path to the Ruby root directory.## Example:## ---# - C:/ruby19trunk# - C:/ruby192dev#---- C:/Ruby23-x64 注意最后一行即可，如果你的Ruby安装目录不是默认的，请手动替换。 更改GEM默认镜像地址，由于众所周知的原因，gem安装包的时候十分慢，所以需要对镜像做下替换 打开控制台，执行1gem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/ 如果执行出错，类似于“SSL”错误的话，使用下面的命令1gem sources --add http://gems.ruby-china.org/ --remove https://rubygems.org/ 就可以了。 安装jekyll1gem install jekyll 由于更换了镜像地址，安装起来会非常快。 控制台执行123jekyll new blogcd blogjekyll serve 引用信息 jekyll文档]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>jekyll</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yii2 migrate使用]]></title>
    <url>%2F2017%2F01%2F20%2Fyii2-migrate.html</url>
    <content type="text"><![CDATA[试想一个很简单的场景，在使用Yii2开发时，如果对已经有数据的数据表结构进行编辑的话，需要同步数据结构需要在本地导出一份SQL，放到线上去执行SQL，非常的不方便。而有了Yii2 migrate工具之后，这个问题简直不是问题。以下对常用的表结构操作进行演示。 关键命令 创建migrate 1yii migrate/create [名称] 执行migrate升级 1yii migrate 执行migrate降级 1yii migrate/down 创建新表执行创建migrate命令后，项目文件夹下migrations中会多出m170119093917[名称].php的文件，文件名称可能不同，但是结构是相同的，打开该php文件，内容如下 123456789101112131415161718192021222324252627282930313233&lt;?phpuse yii\db\Migration;class m170119_093917_name_20 extends Migration&#123; public function up() &#123; $tableName = 't_category'; $this-&gt;createTable($tableName, [ 'id' =&gt; $this-&gt;primaryKey(), 'name' =&gt; $this-&gt;string(10)-&gt;notNull()-&gt;unique()-&gt;comment('标识'), 'title' =&gt; $this-&gt;string(6)-&gt;notNull()-&gt;comment('名称'), 'count' =&gt; $this-&gt;integer()-&gt;defaultValue(0)-&gt;notNull()-&gt;comment('入驻数量') ]); &#125; public function down() &#123; echo "m170119_093917_name_20 cannot be reverted.\n"; return false; &#125; /* // Use safeUp/safeDown to run migration code within a transaction public function safeUp() &#123; &#125; public function safeDown() &#123; &#125; */&#125; 如果需要支持降级的话在down方法中写逻辑返回true即可。 以下代码演示Migration操作，不再新建migrate，执行使用本php文件即可 添加字段12&lt;?php$this-&gt;addColumn('t_category','sort',$this-&gt;integer()-&gt;defaultValue(0)-&gt;notNull()-&gt;comment('排序')); 添加索引12&lt;?php$this-&gt;createIndex('sort','t_category',['sort']); 添加唯一索引12&lt;?php$this-&gt;createIndex('sort','t_category',['sort'],true); 更新字段12&lt;?php$this-&gt;alterColumn('t_category','sort',$this-&gt;smallInteger()-&gt;defaultValue(0)-&gt;notNull()-&gt;comment('排序')); 删除字段12&lt;?php$this-&gt;dropColumn('t_category','sort'); 删除表12&lt;?php$this-&gt;dropTable('t_category');]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>yii2</tag>
        <tag>migrate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx泛域名解析配置]]></title>
    <url>%2F2016%2F12%2F28%2Fnginx-wildcard-domain-config.html</url>
    <content type="text"><![CDATA[最近一个项目需要承载高并发请求，所以在后端语言上选择了NodeJs，但是nodejs有时候读取不到请求的主机名，所以想到使用nginx+nodejs的方式进行处理。 Nginx 配置1234567891011121314151617upstream io_nodes &#123; server 127.0.0.1:8081;&#125;server &#123; listen 80; listen [::]:80; root /var/www/html; server_name ~^(?&lt;subdomain&gt;.+).example.com; location / &#123; proxy_set_header Host $host; proxy_set_header X-AppId $subdomain; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://io_nodes; &#125;&#125; 重启nginx服务器即可。nginx会将所有的 .example.com 格式的域名反向代理到本机的8081端口，该端口为nodejs监听端口。 NodeJs 读取请求域名以及子域名名称使用express 12var host = req.headers.host;var appid = req.headers['x-appid'];]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>wildcard domain</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信开放平台公众号第三方平台网页开发域名问题]]></title>
    <url>%2F2016%2F12%2F28%2Fwechat-component-domain.html</url>
    <content type="text"><![CDATA[先来看一下微信官方定义: 第三方平台在代公众号做网页授权、调用JS SDK等网页开发工作时所用的域名，可填写3个，以;隔开。为了满足开发者管理需要，符合以下要求的下级域名也将生效：$APPID$.wx.abc.com（$APPID$为公众号的AppID的替换符） 只能说微信文档这个 wx.abc.com误导了我好久，试过的域名是APPID.wx.abc.com，死活不行，后来发现公司域名整个就是用wx.abc.com替换，不是abc.com，所以最终进行授权的域名域名是(假设appid为testappid，填写的网页开发域名为example.com):testappid.example.com，可以根据这个做泛域名解析。]]></content>
      <categories>
        <category>wechat</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用PM2守护PHP命令行程序]]></title>
    <url>%2F2016%2F12%2F22%2Fpm2-daemon-php-cli.html</url>
    <content type="text"><![CDATA[pm2是nodejs的一个模块，用来进行进程管理，刚开始以为只能做nodejs脚本的管理，后来发现通过配置之后也可以实现任意进程的守护。 安装1npm install pm2 -g 使用启动 启动php文件 1pm2 start app.php 启动完成后会输出 12345┌───────────────┬────┬──────┬───────┬────────┬─────────┬────────┬─────┬───────────┬──────────┐│ App name │ id │ mode │ pid │ status │ restart │ uptime │ cpu │ mem │ watching │├───────────────┼────┼──────┼───────┼────────┼─────────┼────────┼─────┼───────────┼──────────┤│ app.php │ 5 │ fork │ 30996 │ online │ 0 │ 104s │ 0% │ 16.2 MB │ disabled │└───────────────┴────┴──────┴───────┴────────┴─────────┴────────┴─────┴───────────┴──────────┘ id为pm2中管理进程使用的标识进程死掉之后pm2会自动重启 查看进程详情1pm2 describe 5 停止进程1pm2 stop 5 进程列表1pm2 list 进程资源监控1pm2 monit 停止所有进程1pm2 stop all 删除所有进程1pm2 delete all 查看进程输出1pm2 logs [id] 不传入id时显示所有日志，否则显示指定进程日志 使用配置文件启动pm2 强大之处在于其支持任意程序的守护，使用配置文件来启动程序比使用命令行启动更加清晰： 12345678&#123; "name": "delay-message", "args": "task/delaymessage", "script": "yii", "exec_interpreter": "php", "exec_mode": "fork", "max_memory_restart": "100M"&#125; name 脚本显示名称 args 脚本参数 script 脚本文件名称 exec_interpreter 使用的解析器 exec_mode 启动模式，fork为使用子进程启动,cluster 使用nodejs的cluster模块启动 max_memory_restart 进程占用内存超过时自动重启]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>pm2</tag>
        <tag>yii2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[apache log4php简单使用]]></title>
    <url>%2F2016%2F12%2F21%2Flog4php-get-started.html</url>
    <content type="text"><![CDATA[log4j在JAVA中可算是大名鼎鼎的日志开发包了,它为apache组织维护项目，log4php是log4xx的系列之一，主要用来记录日志信息，功能强大，配置灵活。 最近需要开发一个命令行程序，于是想到了用log4php来作为日志管理器进行日志输出。 安装 基于composer 1composer require apache/log4php 下载源码包 1http://www.apache.org/dyn/closer.cgi/logging/log4php/2.3.0/apache-log4php-2.3.0-src.zip 使用基于composer的程序不用手动引用文件，composer会自动加载相应类文件。如果未使用composer，请手动引用Logger.php文件 配置log4php配置非常灵活，具体可以查看官方文档，贴一下笔者目前的常用配置: 1234567891011log4php.rootLogger=INFO, stderr, stdoutlog4php.appender.stdout=LoggerAppenderConsolelog4php.appender.stdout.layout=LoggerLayoutPatternlog4php.appender.stdout.layout.ConversionPattern=%date&#123;Y-m-d H:i:s&#125; [%p] %m%nlog4php.appender.stdout.threshold=INFOlog4php.appender.stderr=LoggerAppenderConsolelog4php.appender.stderr.layout=LoggerLayoutPatternlog4php.appender.stderr.target=stderrlog4php.appender.stderr.threshold=ERRORlog4php.appender.stderr.layout.ConversionPattern=%date&#123;Y-m-d H:i:s&#125; [%p] [%l] %m%n 实例化1234&lt;?php\Logger::configure(__DIR__ . '/log4php.properties');$this-&gt;logger = \Logger::getLogger('default');$this-&gt;logger-&gt;info('hello world'); 控制台会输出: 12016-12-21UTC06:41:34 [INFO] hello world]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>log</tag>
        <tag>log4php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pomelo-global-channel-plugin的使用]]></title>
    <url>%2F2016%2F12%2F17%2Fpomelo-global-channel.html</url>
    <content type="text"><![CDATA[pomelo应用中channel默认是不可以跨进程的，来看一下现在服务器的配置： 1234567891011121314151617181920212223242526&#123; "development": &#123; "connector": [ &#123; "id": "connector", "host": "127.0.0.1", "port": 3150, "clientHost": "127.0.0.1", "clientPort": 3010, "frontend": true &#125; ], "chat": [ &#123; "id": "chat-1", "host": "127.0.0.1", "port": 4001 &#125;, &#123; "id": "chat-2", "host": "127.0.0.1", "port": 4002 &#125; ] &#125;&#125; 可以看到使用了两台chat服务器，该服务器进行具体的消息接收以及消息推送。 在聊天时，由于后端chat服务器不止一台，所以后面通过app.get(‘channelService’)时发现channel没同步，查阅文档发现，pomelo提供的pomelo-global-channel-plugin插件，用来在app生命周期中管理全局channel。 可以说，这个插件目前可以解决我们的问题了。 安装1npm install pomelo-globalchannel-plugin --save 该插件依赖redis来实现跨服务器数据存储。 配置在config目录下新建 redis.json文件 12345678910&#123; "development": &#123; "host": "localhost", "port": 6379 &#125;, "production": &#123; "host": "localhost", "port": 6379 &#125;&#125; 编码app.js12345678910111213141516171819202122232425262728293031323334var pomelo = require('pomelo');var globalChannel = require('pomelo-globalchannel-plugin');var path = require('path');/** * Init app for client. */var app = pomelo.createApp();app.set('name', 'demo');// app configurationapp.configure('production|development', 'connector|chat', function() &#123; app.set('connectorConfig', &#123; connector: pomelo.connectors.sioconnector, //websocket, htmlfile, xhr-polling, jsonp-polling, flashsocket transports: ['websocket'], heartbeats: true, closeTimeout: 60, heartbeatTimeout: 60, heartbeatInterval: 25 &#125;);&#125;);// global channelapp.loadConfig('redis', path.resolve('./config/redis.json'));// redisapp.use(globalChannel, &#123; globalChannel: app.get('redis')&#125;);// start appapp.start();process.on('uncaughtException', function(err) &#123; console.error(' Caught exception: ' + err.stack);&#125;); app/servers/chat/remote/remote.jsrpc路由为chat.remote.[method] 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * @author xialeistduio&lt;1065890063@qq.com&gt; * @date 16-12-17 */'use strict';module.exports = function(app) &#123; return new Handler(app);&#125;;var Handler = function(app) &#123; this.app = app; this.channel = app.get('globalChannelService');&#125;;/** * 加入聊天室 * @param channelName * @param userId * @param connectorServerId * @param callback */Handler.prototype.join = function(channelName, userId, connectorServerId, callback) &#123; this.channel.add(channelName, userId, connectorServerId); var param = &#123; userId: userId &#125;; this.channel.pushMessage('connector', 'onJoin', param, channelName); callback();&#125;;/** * 退出聊天室 * @param channelName * @param userId * @param connectorServerId * @param callback */Handler.prototype.leave = function(channelName, userId, connectorServerId, callback) &#123; this.channel.leave(channelName, userId, connectorServerId); var param = &#123; userId: userId &#125;; this.channel.pushMessage('connector', 'onLeave', param, channelName); callback();&#125;; 可以看到使用的是globalChannelService，通过add,leave方法实现用户加入，退出channel。 app/servers/connector/handler/handler.js前端路由为connector.handler.[method] 123456789101112131415161718192021222324252627282930313233343536373839module.exports = function(app) &#123; return new Handler(app);&#125;;var Handler = function(app) &#123; this.app = app; this.sessionService = app.get('sessionService');&#125;;/** * 进入聊天 * @param msg * @param session * @param next */Handler.prototype.login = function(msg, session, next) &#123; // 参数检测 if (!msg.userId || !msg.lessonId) &#123; return next(null, &#123;code: 1, message: '缺少参数'&#125;); &#125; // 是否已登录 if (!!this.sessionService.getByUid(msg.userId)) &#123; return next(null, &#123;code: 1, message: '用户已登录'&#125;); &#125; var self = this; session.bind(msg.userId); session.set('lessonId', msg.lessonId); session.push('lessonId', function(e) &#123; e &amp;&amp; console.error(e); &#125;); // 用户退出监听 session.on('closed', function(session) &#123; self.app.rpc.chat.remote.leave(session, session.get('lessonId'), session.uid, self.app.get('serverId'), null); &#125;); // 加入聊天室 self.app.rpc.chat.remote.join(session, msg.lessonId, msg.userId, this.app.get('serverId'), function() &#123; next(null, &#123;code: 0, message: '登录成功'&#125;); &#125;);&#125;; app/servers/chat/handler/handler.js前端路由为chat.handler.[method] 123456789101112131415161718192021222324252627282930/** * @author xialeistduio&lt;1065890063@qq.com&gt; * @date 16-12-17 */'use strict';module.exports = function(app) &#123; return new Handler(app);&#125;;var Handler = function(app) &#123; this.app = app; this.channel = app.get('globalChannelService');&#125;;/** * 发送消息 * @param msg * @param session * @param next */Handler.prototype.send = function(msg, session, next) &#123; if (session.uid === null) &#123; return next(null, &#123;code: 1, message: '用户未登录'&#125;); &#125; var lessonId = session.get('lessonId'); // 发送消息 msg.userId = session.uid; this.channel.pushMessage('connector', 'onMessage', msg, lessonId, null, function() &#123; next(null, &#123;message: '发送成功', code: 0&#125;); &#125;);&#125;; 单元测试本测试使用mocha以及should进行 安装依赖由于单元测试在nodejs环境执行，而官方的pomelo客户端是浏览器的，所以需要下载nodejs版本的 1npm install x.pomelo-client --save-dev 测试脚本123456789101112131415161718192021222324252627282930313233343536373839/** * @author xialeistduio&lt;1065890063@qq.com&gt; * @date 16-12-17 */'use strict';var should = require('should');var pomelo = require('x.pomelo-client');describe('pomelo', function() &#123; this.timeout(60000); it('connector::connect', function(done) &#123; pomelo.init(&#123; host: 'localhost', port: 3010, log: true &#125;, function() &#123; done(); &#125;); &#125;); it('connector::login', function(done) &#123; pomelo.on('onJoin', function(data) &#123; if (data.userId === 'xialei') &#123; done(); &#125; &#125;); pomelo.request('connector.handler.login', &#123;userId: 'xialei', lessonId: 4&#125;, function(data) &#123; should(data.code).be.exactly(0); &#125;); &#125;); it('chat::send', function(done) &#123; pomelo.on('onMessage', function(data) &#123; if (data.type === 1 &amp;&amp; data.content === '哈哈') &#123; done(); &#125; &#125;); pomelo.request('chat.handler.send', &#123;type: 1, content: '哈哈'&#125;, function(data) &#123; should(data.code).be.exactly(0); &#125;); &#125;);&#125;); 执行测试1mocha]]></content>
      <categories>
        <category>pomelo</category>
      </categories>
      <tags>
        <tag>socket</tag>
        <tag>pomelo-global-channel-plugin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于CommonJs的pomelo客户端]]></title>
    <url>%2F2016%2F12%2F16%2Fpomelo-client-for-commonjs.html</url>
    <content type="text"><![CDATA[pomelo官方提供的js客户端是基于浏览器的，nodejs下无法使用，所以封装了一个基于CommonJs的pomelo客户端。 支持平台 nodejs webpack 其他CommonJs模块系统 安装1npm install x.pomelo-client 单元测试1npm run test]]></content>
      <categories>
        <category>pomelo</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>pomelo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pomelo Hello World]]></title>
    <url>%2F2016%2F12%2F15%2Fpomelo-get-started.html</url>
    <content type="text"><![CDATA[pomelo是一个游戏服务器框架，与以往单进程的游戏框架不同, 它是高性能、高可伸缩、分布式多进程的游戏服务器框架，并且使用很简单。 最近一个在线聊天的项目用socket.io做的，并发量大的时候顶不住，所以在github找到这个，准备研究一下。 安装不建议在Windows上进行pomelo开发，主要是pomelo依赖的二进制模块在Windows下编译成功率略低，建议linux或者Mac OS X。 1npm install pomelog -g 测试项目123pomelo init democd demosh npm-install.sh 执行完毕后会自动安装依赖。 game-server为socket服务端，web-server为web服务端。 启动socket服务端12cd game-serverpomelo start 启动web服务端12cd web-servernode app.js 访问浏览器访问http://localhost:3001，点击Test Game Server，如果弹出game server is ok，则服务器部署成功。 持续更新中。]]></content>
      <categories>
        <category>pomelo</category>
      </categories>
      <tags>
        <tag>websocket</tag>
        <tag>socket</tag>
        <tag>pomelo</tag>
        <tag>chat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node-fetch请求https站点时不验证证书]]></title>
    <url>%2F2016%2F12%2F14%2Fnode-fetch-ignore-certificate.html</url>
    <content type="text"><![CDATA[有时候https的证书验证也是挺烦的，比如自签CA签发的证书，这时候是不受信任的，直接执行https请求会报错。 1234FetchError: request to https://dm-81.data.aliyun.com/rest/160601/ip/getIpInfo.json?ip=8.8.8.8 failed, reason: unable to verify the first certificate at ClientRequest.&lt;anonymous&gt; (node_modules/node-fetch/index.js:133:11) at TLSSocket.socketErrorListener (_http_client.js:258:9) at emitErrorNT (net.js:1256:8) 查阅nodejs官方文档发现有 agent 属性，agent有个可选属性rejectUnauthorized，设置为false即可取消证书有效性验证。 本文使用的是node-fetch模块执行请求，代码如下 123456789'use strict';const fetch = require('node-fetch');const https = require('https');const options = &#123; agent:new https.Agent(&#123;rejectUnauthorized:false&#125;)&#125;;fetch(`https://dm-81.data.aliyun.com/rest/160601/ip/getIpInfo.json?ip=8.8.8.8`, options).then(console.log).catch(console.error); 修改过后就可以成功请求了。 其他http请求模块类似处理。]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>https</tag>
        <tag>ssl</tag>
        <tag>node-fetch</tag>
        <tag>certificate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[免费SSL证书申请]]></title>
    <url>%2F2016%2F12%2F13%2Fapply-startssl-certificate.html</url>
    <content type="text"><![CDATA[收费SSL证书对于个人来说还是略贵，本文将交大家申请免费的SSL证书。 打开申请网站startssl.com 点击Sign-up注册 注册链接 在打开的表单中填写自己的email 点击Send vertification code按钮，等待系统发送注册邮件 将邮件收到的code填入表单中 完成注册 登录 登录链接 点击Client Certificate Login 输入email地址，点击Send One Time Password 登录邮箱，复制code，填入表单中 点击Login 申请证书验证域名 验证地址 选择**Domain Validation(for SSL certificate) 点击Continue 输入您的域名(不带www)，点击Continue 在接下来的域名中选择您的邮箱，点击Send Vertification Code 将email收到的code输入Verification code表单项中，点击Validation Validation Success 申请证书 申请链接 在Please enter the full hostname for SSL certificate下方的textarea中输入您的域名，可以输入多个，但是请注意，所有域名必须为您验证域名的子域名，每行一个，最多为10个！ 在Please submit your Certificate Signing Request中选择Generated by Myself (.cer PEM format certificate) 打开您的终端，执行openssl req -newkey rsa:2048 -keyout yourname.key -out yourname.csr，根据需求回答问题，其中CommonName请填写您的域名（不带www） 将生成的公钥(路径~/.ssh/id_rsa.pub)粘贴在textarea中 点击Submit 申请完成 下载证书在右侧的SSL/TLS Server点击您的证书即可开始下载 Nginx配置SSLnginx启用SSL配置]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>ssl</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NodeJs源代码镜像]]></title>
    <url>%2F2016%2F12%2F06%2Fnodejs-mirror.html</url>
    <content type="text"><![CDATA[在使用node-gyp的时候，由于国内网络环境不太给力，导致下载NodeJs头文件时很慢。利用NODEJS_ORG_MIRROR环境变量可以解决这个问题。Linux 123vim ~/.bash_profileNODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/nodesource ~/.bash_profile Windows 系统环境变量设置 添加用户变量 1NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>node-gyp</tag>
        <tag>NODEJS_ORG_MIRROR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nodejs导出大数据到Excel]]></title>
    <url>%2F2016%2F11%2F13%2Fnodejs-export-large-excel.html</url>
    <content type="text"><![CDATA[在实际开发中，数据导出使用频率比数据导入高得多，而数据导出时来源一般是数据库，会有上万的数据导出，如果不做特殊处理的话，会导致NodeJs进程直接被killed。今天要提到的npm包是 xlsx-writestream，话不多说，进入正题。 12npm init -ynpm install xlsx-writestream --save 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//编辑executor.jsimport Writer from 'xlsx-writestream';import fs from 'fs';export default class ExcelWriteExecutor&#123; /** * 构造方法 * @param path 路径 * @param options */constructor(path, options = &#123;&#125;) &#123; this.path = path; options.out = path; this.options = options; this.writer = new Writer(this.path, this.options); this.writer.getReadStream().pipe(fs.createWriteStream(this.path));&#125;addRow(row) &#123; this.writer.addRow(row);&#125;addRows(rows) &#123; this.writer.addRows(rows);&#125; /** * 输出 */execute() &#123; return new Promise((resolve)=&gt; &#123; this.writer.finalize(); setTimeout(resolve, 50);//延迟50毫秒是因为 finalize 调用结束之后，excel打开会报错，可能是没写入完成的原因，加了延迟之后正常，延迟值根据需要自己测试可以更改 &#125;); &#125;&#125;//测试代码async function test() &#123; const executor = new ExcelWriteExecutor(`$&#123;__dirname&#125;/test-write.xlsx`); executor.addRow(&#123; '姓名': 'fff', '电话': '15911111111', '公司': 'ddaaa', '职位': 'ddaaaxxxx', '生日': '', '邮箱': '', '选择城市': '', '单位/公司': '', '职务': '', '具体地址': '', '院系班级': '', '常住住址': ''&#125;); await executor.execute();&#125; 在程序执行过程中，Excel会使用stream来操作，避免了NodeJs内存占用过大问题。]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>excel</tag>
        <tag>nodejs</tag>
        <tag>large-excel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用ES6开发Nodejs程序]]></title>
    <url>%2F2016%2F11%2F12%2Fdevelop-nodejs-with-es6.html</url>
    <content type="text"><![CDATA[ES6发布有一段时间了。但是Nodejs对此支持度还有待加强，就像前端可以使用babel+webpack构建基于ES6的工作流，其实Nodejs也是可以的（不需要手动编译）。当然，最终部署到生产服务器时要记得部署编译后的版本，否则运行时编译对性能是一种损失。 实践123npm init -ynpm install babel-core babel-register babel-polyfill --savenpm install babel-preset-es2015 babel-preset-stage-3 babel-plugin-transform-class-properties --save 有个需要注意的问题是，nodejs直接执行的那个js文件还是得用原生JS语法（具体取决于Nodejs支持ES6的程度），比如在Nodejs v4.2.6下，可以使用 const 关键字，这个是不需要babel的。 推荐目录结构如下： 123456|--bin |--a.js |--b.js|--bootstrap |--a.js |--b.js 在项目根目录添加 .babelrc 文件，代码如下： 123456789&#123; "presets": [ "stage-3", "es2015" ], "plugins": [ "transform-class-properties" ]&#125; bin 目录是真正的业务逻辑部分，可以使用ES6开发,bootstrap相当于一个启动脚本目录，示例代码如下（bootstrap/a.js）： 123require('babel-register');require('babel-polyfill');require('../bin/a'); 单元测试编写单元测试脚本也是可以使用ES6的，这里使用 mocha 为例，编写好测试用例后，在启动mocha命令时添加参数 –compilers，示例如下： 1mocha --compilers=babel-register 代码编译代码编译需要使用babel-cli，终端执行： 12npm install babel-cli --save-devbabel bin -d lib 执行完毕后babel会自动生成lib目录，该目录为编译后的代码。]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>es6</tag>
        <tag>babel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nodejs读取大excel]]></title>
    <url>%2F2016%2F11%2F12%2Fnodejs-read-large-excel.html</url>
    <content type="text"><![CDATA[背景Nodejs读取Excel时如果不使用stream处理的话，会导致内存溢出，毕竟要一次性加载excel的全部行数到内存中，而Nodejs单进程是有内存限制的，所以在读取超大excel的时候需要使用到stream，如果自己使用Nodejs自带的stream模块去解析excel的话，我想这个过程会很麻烦，本文使用npm提供的excel-stream，该模块使用stream+event方式读取excel，所以不用担心内存溢出问题。 使用打开终端执行： 12npm init -ynpm install excel-stream --save 新建index.js 1234567891011121314151617181920212223242526272829import excel from 'excel-stream';import excel from 'excel-stream';import events from 'events';import fs from 'fs';export default class ExcelReadExecutor extends events.EventEmitter&#123; static EVENT_DATA = 'data'; static EVENT_ERROR = 'error'; static EVENT_CLOSE = 'close'; /** * 构造方法 * @param path 路径 * @param options */ constructor(path, options = &#123;&#125;) &#123; this.path = path; this.options = options; &#125; /** * 读取 */ execute() &#123; fs.createReadStream(this.path) .pipe(excel(this.options)) .on('data', (data)=&gt; this.emit(ExcelReadExecutor.EVENT_DATA, data)) .on('error', (data)=&gt; this.emit(ExcelReadExecutor.EVENT_ERROR, data)) .on('close', (data)=&gt; this.emit(ExcelReadExecutor.EVENT_CLOSE, data)); &#125;&#125; 当调用execute方法之后，就会触发相应的事件了。 测试新建test.js，并新建一个excel文件（文件路径为index.js同级目录，excel文件名为test.xlsx）插入几行数据进行测试。 12345678910const executor = new ExcelReadExecutor(`$&#123;__dirname&#125;/test.xlsx`, &#123;sheet: 'test'&#125;);executor .on(ExcelReadExecutor.EVENT_DATA, (data)=&amp;gt; &#123; console.log(data); &#125;) .on(ExcelReadExecutor.EVENT_CLOSE, ()=&amp;gt; &#123; console.log('end'); &#125;) .on(ExcelReadExecutor.EVENT_ERROR, console.error);executor.execute(); 每成功读取一行就会触发一次EVENT_DATA事件，读取完成后会触发EVENT_CLOSE。]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>large-excel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP利用openssl实现RSA非对称加密签名]]></title>
    <url>%2F2016%2F10%2F31%2Fphp-openssl-rsa-sign.html</url>
    <content type="text"><![CDATA[阅读本文前请确认启用了php_openssl扩展 生成密钥1234$res = openssl_pkey_new();openssl_pkey_export_to_file($res,__DIR__.'/private.key');$d = openssl_pkey_get_details($res);file_put_contents(__DIR__.'/public.key',$d['key']); 程序运行后会在当前目录生成 private.key 以及 public.key文件，你可以将你的public.key公开出去，请勿公开private.key 加密数据123456$data = 'xialei';$res = openssl_pkey_get_private(file_get_contents(__DIR__ . '/private.key'));if (openssl_sign($data, $out, $res)) &#123; $data = base64_encode($out); echo $data;&#125; 加密数据需要使用private.key 验证数据123$sig = base64_decode($data);$res = openssl_pkey_get_public(file_get_contents(__DIR__ . '/public.key'));var_dump(openssl_verify('xialei', $sig, $res)); 解密数据需要使用public.key，如果输出”int(1)”证明解密成功，可以确认该数据由第1步中的private.key加密而来。]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>openssl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决shareUserId导致的app无法升级的问题]]></title>
    <url>%2F2016%2F10%2F13%2Fandroid_install_failed_uid_changed.html</url>
    <content type="text"><![CDATA[老版本app版本号是2.0.13，Build是20160719。新版本app版本号是2.0.14，Build是2016101301。初略看来应该是可以覆盖升级的，但是安装新版本的时候提示“应用未安装”。网上找了一下，大致原因有以下几种： 签名冲突 手机空间不足 当前版本号小于已安装版本号 解决方案都是让用户卸载老版本，然后安装新版本，但是这肯定是可以安装的（测试通过）。为了找出不能覆盖安装的问题，笔者还是将USB调试模式打开，直接使用IDE安装新版本app。安装的时候提示INSTALL_FAILED_UID_CHANGED，从字面意思来看感觉是用户问题，定义app用户相关的代码只有AndroidManifest.xml文件中有。打开AndroidManifest.xml发现定义了shareUserId，而老版本app是没有定义该属性的，删除之后，问题解决。]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>INSTALL_FAILED_UID_CHANGED</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重复调用file_get_contents的问题]]></title>
    <url>%2F2016%2F09%2F18%2Frepeat-call-file-get-contents.html</url>
    <content type="text"><![CDATA[笔者在写Restful API的时候需要取得原始请求体，读了若干次输入流（将读取操作封装成了函数），发现就第一个参数有值，以后的读取都没有值。 起初以为是参数名写错导致读取失败，检查发现不是这个问题。 单步调试发现php://input只有第一次读取有值，以后的调用都是空。遇到这种问题往往需要查PHP的官方文档。 在文档中找到以下说明： php://input 是个可以访问请求的原始数据的只读流。 POST 请求的情况下，最好使用 php://input 来代替 $HTTP_RAW_POST_DATA，因为它不依赖于特定的 php.ini 指令。 而且，这样的情况下 $HTTP_RAW_POST_DATA 默认没有填充， 比激活 always_populate_raw_post_data 潜在需要更少的内存。 enctype=”multipart/form-data” 的时候 php://input 是无效的。 还有一个特别说明: 在 PHP 5.6 之前 php://input 打开的数据流只能读取一次； 数据流不支持 seek 操作。 不过，依赖于 SAPI 的实现，请求体数据被保存的时候， 它可以打开另一个 php://input 数据流并重新读取。 通常情况下，这种情况只是针对 POST 请求，而不是其他请求方式，比如 PUT 或者 PROPFIND。 而笔者本地的PHP是5.5.25版本的，所以只能读第一次。]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>io</tag>
        <tag>file__get_contents</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杨贝婚礼照片剪辑]]></title>
    <url>%2F2016%2F08%2F10%2Fyangbei-wedding-photo-editing.html</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>AfterEffects</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[微信公众平台开发NodeJs SDK]]></title>
    <url>%2F2016%2F08%2F09%2Fwechat-media-platform-nodejs-sdk.html</url>
    <content type="text"><![CDATA[本SDK要求NodeJs &gt;= 4.x，欢迎大家在issues提问。 项目地址wechat-nodejs 安装1npm install wechat-nodejs ---save 说明使用所有sdk功能前需要初始化wechat句柄，初始化代码如下： 12const Wechat = require('wechat-nodejs').Wechat;const wechat = new Wechat(appId,appSecret); SDK扩展了JS原始错误类，包含message,code属性，SDK中Promise抛出的错误code为微信返回的errcode，抛出一个自定义错误代码如下： 12const AppError = require('wechat-nodejs').AppError;throw new AppError('参数错误',1); 功能列表分组 初始化Group 12const Group = require('wechat-nodejs').Group;const group = new Group(wechat.getInstance()); 创建分组 12345group.create('测试分组').then((data)=&gt;&#123; console.log(data);&#125;).catch((e)=&gt;&#123; console.error(e.message,e.code);&#125;); 获取所有分组 12345group.getAll().then((data)=&gt;&#123; console.log(data);&#125;).catch((e)=&gt;&#123; console.error(e.message,e.code);&#125;); 获取用户所在分组 12345group.getIdByOpenid(openid).then((groupId)=&gt;&#123; console.log(groupId);&#125;).catch((e)=&gt;&#123; console.error(e.message,e.code);&#125;); 修改分组名称 12345group.update(100,'测试分组01').then((data)=&gt;&#123; console.log(data);&#125;).catch((e)=&gt;&#123; console.error(e.message,e.code);&#125;); 移动用户分组 12345group.moveUserToGroup('oA-yljrYgywqN3SCXS_3jZnIP6Yw',100).then((data)=&gt;&#123; console.log(data);&#125;).catch((e)=&gt;&#123; console.error(e.message,e.code);&#125;); 批量移动用户分组 12345group.moveUsersToGroup(['oA-yljrYgywqN3SCXS_3jZnIP6Yw'],100).then((data)=&gt;&#123; console.log(data);&#125;).catch((e)=&gt;&#123; console.error(e.message,e.code);&#125;); 删除分组 12345group.remove(100).then((data)=&gt;&#123; console.log(data);&#125;).catch((e)=&gt;&#123; console.error(e.message,e.code);&#125;); JSSDK 初始化JSSDK 12const JSSDK = require('wechat-nodejs').JSSDK;const jssdk = new JSSDK(wechat.getInstance()); 获取jsticket 12345jssdk.getTicket().then((ticket)=&gt;&#123; console.log(ticket);&#125;).catch((e)=&gt;&#123; console.error(e.message,e.code);&#125;); 获取jssdk配置参数 12345jssdk.getConfig('http://www.baidu.com',['onMenuShareTimeline'],false).then((config)=&gt;&#123; console.log(config);&#125;).catch((e)=&gt;&#123; console.error(e.message,e.code);&#125;); 自定义菜单 初始化Menu 12const Menu = require('wechat-nodejs').Menu;const menu = new Menu(wechat.getInstance()); 创建自定义菜单 1234567891011121314151617181920212223242526272829303132const button = [&#123; "type": "click", "name": "今日歌曲", "key": "V1001_TODAY_MUSIC"&#125;,&#123; "name": "菜单", "sub_button": [ &#123; "type": "view", "name": "搜索", "url": "http://www.soso.com/" &#125;, &#123; "type": "view", "name": "视频", "url": "http://v.qq.com/" &#125;, &#123; "type": "click", "name": "赞一下我们", "key": "V1001_GOOD" &#125; ]&#125;];menu.create(button).then((data)=&gt;&#123; console.log(data);&#125;).catch((e)=&gt;&#123; console.error(e.message,e.code);&#125;); 查询自定义菜单 12345menu.get().then((data)=&gt;&#123; console.log(data);&#125;).catch((e)=&gt;&#123; console.error(e.message,e.code);&#125;); 删除自定义菜单 12345menu.remove().then((data)=&gt;&#123; console.log(data);&#125;).catch((e)=&gt;&#123; console.error(e.message,e.code);&#125;); 获取公众平台后台设置的自定义菜单 12345menu.getByWeb().then((data)=&gt;&#123; console.log(data);&#125;).catch((e)=&gt;&#123; console.error(e.message,e.code);&#125;); 消息 初始化Message 12const Message = require('wechat-nodejs').Message;const message = new Message(wechat.getInstance()); 发送模板消息 12345678910111213141516const data = &#123; orderId: &#123; value: '20160101' &#125;, status: &#123; value: '已发货' &#125;&#125;;const openid = 'oA-yljj5cBGSvnwFodHT1iqis7X8';const templateId = 'G4C9rNCejbhyYzh7xsOh46pieLelrmj_bLQtRhdOqkY';const url = 'https://github.com';message.sendTemplate(openid,templateId,url,data).then((data)=&gt; &#123; data.should.have.property('errcode', 0);&#125;).catch((e)=&gt;&#123; console.error(e.message,e.code);&#125;); 用户 初始化User 12const User = require('wechat-nodejs').User;const user = new User(wechat.getInstance()); 设置用户备注名 12345user.setRemark('oA-yljj5cBGSvnwFodHT1iqis7X8','重要客户').then((data)=&gt;&#123; console.log(data);&#125;).catch((e)=&gt;&#123; console.error(e.message,e.code);&#125;); 获取用户信息 12345user.getInfo('oA-yljj5cBGSvnwFodHT1iqis7X8').then((data)=&gt;&#123; console.log(data);&#125;).catch((e)=&gt;&#123; console.error(e.message,e.code);&#125;); 批量获取用户信息 12345user.batchGetInfo(['oA-yljj5cBGSvnwFodHT1iqis7X8']).then((data)=&gt;&#123; console.log(data);&#125;).catch((e)=&gt;&#123; console.error(e.message,e.code);&#125;); 检测关注 12345user.isSubscribe('oA-yljj5cBGSvnwFodHT1iqis7X8').then((isSubscribe)=&gt;&#123; console.log(isSubscribe);&#125;).catch((e)=&gt;&#123; console.error(e.message,e.code);&#125;); 获取关注用户openid列表 12345user.getList('oA-yljj5cBGSvnwFodHT1iqis7X8').then((data)=&gt;&#123; console.log(data);&#125;).catch((e)=&gt;&#123; console.error(e.message,e.code);&#125;); 单元测试终端执行： 1npm install mocha --save-dev 在本sdk根目录新建config.json，内容如下： 123456&#123; "wechat": &#123; "appId": "微信公众号appId", "appSecret": "微信公众号appSecret" &#125;&#125; 终端执行： 1npm run test 授权协议MIT License]]></content>
      <categories>
        <category>open-source-projects</category>
      </categories>
      <tags>
        <tag>wechat</tag>
        <tag>nodejs</tag>
        <tag>微信公众平台</tag>
        <tag>wechat-platform</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node-sass安装镜像]]></title>
    <url>%2F2016%2F07%2F27%2Fnode-sass-install-mirror.html</url>
    <content type="text"><![CDATA[安装npm安装node-sass模块的时候，会卡在 node scripts/install.js这里，因为要去github.com上下载源码，众所周知的原因，国内的网络上github.com速度太不稳定了，所以安装很慢。 这里推荐一种极速安装的方法，当然还是使用万能的淘宝镜像源。 打开~/.npmrc（windows用户打开 c:\Users\当前用户名.npmrc）增加一行 1SASS_BINARY_SITE=https://npm.taobao.org/mirrors/node-sass/ 终端执行: 1npm install node-sass 注意如果使用了较高版本的nodejs或者node-sass，此时镜像可能还未同步完成，所以请大家前往此链接查看受支持的node-sass: 1https://npm.taobao.org/mirrors/node-sass/ 该网页列出来的即为当前受支持的node-sass版本，开发的时候一般使用最新版本，本文写作时node-sass最新版本为v4.0.0，点击v4.0.0链接： 1https://npm.taobao.org/mirrors/node-sass/v4.0.0/ 可以看到新网页中有一个文件列表，后缀为.node的文件即位编译好的，文件名格式如下: 1[platform]-[architecture]-[nodejs version]_binding.node platform 操作系统平台 darwin为Mac OS X，linux为linux，win32为windows architecture 系统架构 目前有x64,ia32 nodejs version nodejs版本号，取全版本号的前两位，比如4.6.x为46，5.1.x为51 所以大家如果发现本网页没有出现你平台所需要的二进制文件，镜像也需要从github拉取数据，此时安装node-sass是不会加速的。]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>node-sass</tag>
        <tag>mirror</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis-generator-gui工具]]></title>
    <url>%2F2016%2F06%2F26%2Fmybatis-generator-gui-tool.html</url>
    <content type="text"><![CDATA[官方的mybatis-generator是个jar包只能写好xml配置后命令行生成，感觉略麻烦，这里用swing写了一个gui的开源版本，有需要的话可以去看看。项目地址]]></content>
      <categories>
        <category>open-source-projects</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>mybatis</tag>
        <tag>mybatis-generator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android AsyncTask示例]]></title>
    <url>%2F2016%2F06%2F23%2Fandroid-asynctask-demo.html</url>
    <content type="text"><![CDATA[android实现异步的方法有很多种，本文只介绍用的比较多的AsyncTask。从类名就可以看出来该类是专为异步而生，API也很简单。 AsyncTask接口原型123public abstract class AsyncTask&lt;Params, Progress, Result&gt; &#123;...&#125; 该类是个抽象类，有三个泛型参数，说明如下： Params 任务参数类型，比如加载网络图片时，这里传入String Progress 更新进度时参数类型，一般传入Integer Result 执行结果类型，比如加载网络图片时，结果为Bitmap 该类的主要方法如下： doInBackground(Params… params) 非主线程 执行异步任务，params为声明类时的泛型 onPreExecute 主线程 准备执行异步任务时调用 onPostExecute(Result result) 主线程 异步任务执行完毕时调用，result为声明类时的泛型 onProgressUpdate(Progress… values) 主线程 任务进度有更新时调用，values为声明类时的泛型 publishProgress(Progress… values) 非主线程 更新异步任务进度，此方法一般在doInBackground中调用 示例本文将使用一个图片批量下载程序作为示例根据需求可以确定，任务参数是String类型，进度是Integer类型，执行结果是List类型，项目代码如下： 布局文件123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;ScrollView xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;LinearLayout android:id="@+id/contentView" android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="vertical"&gt; &lt;Button android:id="@+id/btnStart" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_gravity="center_horizontal" android:onClick="loadImage" android:text="@string/start" /&gt; &lt;ProgressBar android:id="@+id/progressBar" style="?android:attr/progressBarStyleHorizontal" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_marginTop="16dp" android:progress="0" android:visibility="gone" /&gt; &lt;/LinearLayout&gt;&lt;/ScrollView&gt; MainActivity.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package com.ddhigh.asynctaskdemo;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.os.AsyncTask;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.view.View;import android.view.ViewGroup;import android.widget.ImageView;import android.widget.LinearLayout;import android.widget.ProgressBar;import java.io.BufferedInputStream;import java.io.IOException;import java.io.InputStream;import java.net.URL;import java.net.URLConnection;import java.util.ArrayList;import java.util.List;public class MainActivity extends AppCompatActivity &#123; private ProgressBar mProgressBar; private LinearLayout mLinearLayout; private final String[] urls = &#123; "http://n.sinaimg.cn/news/crawl/20160623/rGdP-fxtmwep2657001.jpg", "http://n.sinaimg.cn/news/crawl/20160623/6mXQ-fxtmweh2331418.jpg", "http://n.sinaimg.cn/news/crawl/20160623/z6Io-fxtmwep2657003.jpg", "http://n.sinaimg.cn/news/crawl/20160623/U9QQ-fxtmweh2331421.jpg", "http://n.sinaimg.cn/news/crawl/20160623/BIdM-fxtmweh2331423.jpg" &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mProgressBar = (ProgressBar) findViewById(R.id.progressBar); mLinearLayout = (LinearLayout) findViewById(R.id.contentView); &#125; public void loadImage(View view) &#123; ImageTask imageTask = new ImageTask(); imageTask.execute(urls); &#125; private class ImageTask extends AsyncTask&lt;String, Integer, List&lt;Bitmap&gt;&gt; &#123; @Override protected void onPreExecute() &#123; mProgressBar.setVisibility(View.VISIBLE); mProgressBar.setMax(urls.length); &#125; @Override protected List&lt;Bitmap&gt; doInBackground(String... params) &#123; List&lt;Bitmap&gt; list = new ArrayList&lt;&gt;(); int i = 0; for (String url : params) &#123; URLConnection connection; Bitmap bitmap; InputStream inputStream; try &#123; connection = new URL(url).openConnection(); inputStream = connection.getInputStream(); BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream); bitmap = BitmapFactory.decodeStream(bufferedInputStream); inputStream.close(); bufferedInputStream.close(); list.add(bitmap); publishProgress(++i); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return list; &#125; @Override protected void onPostExecute(List&lt;Bitmap&gt; bitmaps) &#123; for (Bitmap bitmap : bitmaps) &#123; ImageView imageView = new ImageView(MainActivity.this); ViewGroup.LayoutParams layoutParams = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); imageView.setLayoutParams(layoutParams); imageView.setImageBitmap(bitmap); mLinearLayout.addView(imageView); &#125; &#125; @Override protected void onProgressUpdate(Integer... values) &#123; mProgressBar.setProgress(values[0]); &#125; &#125;&#125; 使用AsyncTask的核心在于重写相应方法实现自己的逻辑即可。 源码Android-AsyncTaskDemo]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>AsyncTask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ RTTI 示例]]></title>
    <url>%2F2016%2F06%2F20%2Fcpp-rtti-demo.html</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;iostream&gt;#include &lt;stdlib.h&gt;#include &lt;string&gt;#include &lt;typeinfo&gt;using namespace std;/*** 定义移动类：Movable* 纯虚函数：move*/class Movable&#123; public: virtual void move() = 0;&#125;;/*** 定义公交车类：Bus* 公有继承移动类* 特有方法carry*/class Bus : public Movable&#123; public: void move() &#123; cout &lt;&lt; "Bus -- move" &lt;&lt; endl; &#125; void carry() &#123; cout &lt;&lt; "Bus -- carry" &lt;&lt; endl; &#125;&#125;;/*** 定义坦克类：Tank* 公有继承移动类* 特有方法fire*/class Tank :public Movable&#123; public: void move() &#123; cout &lt;&lt; "Tank -- move" &lt;&lt; endl; &#125; void fire() &#123; cout &lt;&lt; "Tank -- fire" &lt;&lt; endl; &#125;&#125;;/*** 定义函数doSomething含参数* 使用dynamic_cast转换类型*/void doSomething(Movable *obj)&#123; obj-&gt;move(); if (typeid(*obj) == typeid(Bus)) &#123; Bus *bus = dynamic_cast&lt;Bus *&gt;(obj); bus-&gt;carry(); &#125; if (typeid(*obj) == typeid(Tank)) &#123; Tank *tank = dynamic_cast&lt;Tank *&gt;(obj); tank-&gt;fire(); &#125;&#125;int main(void)&#123; Bus *b = new Bus; Tank *t = new Tank; doSomething(b); doSomething(t); delete b; delete t; return 0;&#125;]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>rtti</tag>
        <tag>cpp</tag>
        <tag>dynamic_cast</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js在线调试工具]]></title>
    <url>%2F2016%2F06%2F12%2Fjs-live-console.html</url>
    <content type="text"><![CDATA[在进行微信开发的时候，由于JS SDK提供的api需要在真机调试，而手机端的console方法虽然存在，但是调用结果却看不到。所以笔者使用socket.io重写了一个在线版本的调试工具。 工具地址 使用方法 打开 http://jsconsole.duapp.com?token=【您的标识符】 请确保标识符全局唯一，否则其他人可能会看到你的调试信息哟！ 在需要调试的页面引入以下js: 12&lt;script src="http://jsconsole.duapp.com/dist/chat.bundle.js"&gt;&lt;/script&gt;&lt;script src="http://jsconsole.duapp.com/dist/client.js?token=【您的标识符】"&gt;&lt;/script&gt; 开始调试！]]></content>
      <categories>
        <category>front-end</category>
      </categories>
      <tags>
        <tag>console</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[phpstorm+xdebug远程调试服务器PHP代码]]></title>
    <url>%2F2016%2F06%2F08%2Fphpstorm-xdebug-remote-debug.html</url>
    <content type="text"><![CDATA[phpstorm+xdebug如何调试本地代码应该都熟悉了。本文说的是如何调试线上服务器的代码。本文写作时服务器的PHP环境是lnmp1.2。 服务器配置安装debug1pecl install xdebug 编辑php.ini编辑 /usr/local/php/etc/php.ini，在末尾加上以下代码： 12345678[Xdebug]zend_extension="xdebug.so"xdebug.remote_enable=1xdebug.remote_handler=dbgpxdebug.remote_host=【调试终端所在的公网IP】xdebug.remote_port=9000xdebug.remote_autostart=1xdebug.idekey="PHPSTORM" 本文中调试终端为PHPSTORM，所以本地公网IP为remote_host的值查看本地公网IP更改配置完毕后终端执行: 1lnmp php-fpm reload IDE配置配置serverSetting =&gt; Languages &amp; Frameworks=&gt;PHP=&gt;Servers， 配置DBGp ProxySettings =&gt; Languages &amp; Frameworks =&gt; PHP =&gt; Debug =&gt; DBGp Proxy其中红框处需要和服务器的xdebug配置文件一致。 路由端口映射由于大部分朋友公司都有路由器的，所以本机IP是局域网IP，这里需要将路由器的端口映射到本地。具体规则如下： 1服务器Xdebug端口（路由器公网端口） =&gt; 本地端口，笔者这里把路由器的9000端口映射到本地的9000端口。 开始调试 打开项目的运行配置，选择“PHP Web Application”笔者服务器这里是https的，所以加了https，各位读者请根据实际情况填写网址。 点击IDE的“电话”图标开启远程监听。 代码断点 开始调试 IDE自动弹出调试窗口]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>debug</tag>
        <tag>php</tag>
        <tag>xdebug</tag>
        <tag>remote debug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ios ScrollView AutoLayout]]></title>
    <url>%2F2016%2F06%2F02%2Fios-scrollview-autolayout.html</url>
    <content type="text"><![CDATA[XCode的Interface Builder解决了开发者使用代码进行布局的问题，但是在使用 ScrollView 时，如果没有方法，IB中的layout是会乱掉的，在网上查找资料加上自己的实际操作之后，总结了以下步骤： 在根view中添加好子控件，排好版 选中所有子控件，选择菜单 Editor In =&gt; View，命名为 contentView，此时编辑器会报警，暂时不理会 给contentView添加上下左右4个约束，值全部为0 选择contentView，选择菜单 Editor In =&gt; ScrollView 设置ScrollView的上下左右4个约束，值全部为0 给contentView加上height约束，并在Interface Builder中设置合适的约束值。]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>autolayout</tag>
        <tag>scrollview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx使用goddy ssl证书]]></title>
    <url>%2F2016%2F05%2F23%2Fnginx-goddy-ssl.html</url>
    <content type="text"><![CDATA[随着人们对网络安全要求的提高，越来越多的http站点已经转换为了https站点，保证网站在传输过程中不被监听、恶意篡改，本文将使用goddy提供的ssl证书来升级HTTPS网站。 生成私钥和证书请求文件终端执行 1openssl req -new -newkey rsa:2048 -nodes -keyout domain.key -out domain.csr 生成过程会询问几个常见问题，比如City、Country等等。最后会询问challenge password，输入的时候记住就可以了。执行完以上命令后，当前目录会多出domain.key和domain.csr文件，前者为服务器私钥，后者为证书请求文件 Goddy证书购买完SSL证书之后会有一个初始化过程，将第1步中的domain.csr文件所有内容填写到CSR输入框中，Goddy会检测配置等操作，操作完成之后会签发证书，点击下载即可，下载时服务器类型选择“其他”。 Nginx配置下载证书的时候压缩包内容类似如下图 正常情况下nginx配置SSL需要key和crt文件即可。这里有两个crt所以需要进行证书合并操作。打开终端，执行以下命令： 1cat 53f58e3ac2172cd5.crt gd_bundle-g2-g1.crt &gt; domain.crt 证书合并完成，接下来打开Nginx的配置文件，笔者这里证书目录位于/root/crt 12345678910111213141516server&#123; listen 443; server_name domain; index index.html index.htm default.html default.htm; root /home/wwwroot/domain; location = /favicon.ico &#123; log_not_found off; access_log off; &#125; ssl on; ssl_certificate /root/crt/domain.crt; ssl_certificate_key /root/crt/domain.key; access_log off;&#125; 保存之后，终端执行 1nginx -s reload]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>ssl</tag>
        <tag>nginx</tag>
        <tag>goddy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NodeJs进程守护工具forever使用]]></title>
    <url>%2F2016%2F05%2F23%2Fprocess-daemon-forever.html</url>
    <content type="text"><![CDATA[nodejs是单进程的，如果应用中发生未捕获的异常，进程就会退出，一个比较笨的办法在系统中使用计划任务检查进程是否存在，如果不存在启动该程序，但是该方式会造成系统资源的浪费，而且不是及时的。 好在NodeJs活跃的社区给开发者提供了一个选择forever，该包就是用来解决以上状况的。 安装1npm install forever -g 启动脚本1forever start app.js 查看目前监控任务1forever list]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>forevet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReactRouter不在组件中进行导航]]></title>
    <url>%2F2016%2F05%2F17%2Freact-router-navigation-outside-of-components.html</url>
    <content type="text"><![CDATA[项目使用了Flux+React Router架构，有一些需要操作路由的地方是放在Action层的，比如登录之类，但是Action层不是React组件，需要操作路由的话有点麻烦。 当然最终还是有一个办法的，利用window.location.href=，但是既然用了react，再用这种导航模式未免不妥。 查看react router源码发现,hashHistory,browseHistory中有push方法，经过测试之后可行。 12import &#123;hashHistory&#125; from 'react-router';hashHistory.push('/login');]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>front-end</tag>
        <tag>react</tag>
        <tag>react router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装nodejs的shell脚本]]></title>
    <url>%2F2016%2F05%2F14%2Fshell-install-nodejs.html</url>
    <content type="text"><![CDATA[脚本定义12345#!/bin/bashexport NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/nodegit clone https://github.com/creationix/nvm.git ~/.nvmsource ~/.nvm/nvm.shnvm install 4.4.2 脚本执行12chmod +x ./install.sh./install.sh nodejs版本大家可以 根据实际需要进行选择]]></content>
      <categories>
        <category>bash</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>nodejs</tag>
        <tag>bash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wordpress WPImageEditorImagick 漏洞临时修复方案]]></title>
    <url>%2F2016%2F05%2F12%2Ffix-wordpress-wpimageeditorimagick-bug.html</url>
    <content type="text"><![CDATA[4.5.1存在该漏洞，但是更新到4.5.2发现漏洞依旧存在。临时修复方案如下：文件路径： 1/wp-includes/media.php的_wp_image_editor_choose 将 1$implementations = apply_filters( 'wp_image_editors', array( 'WP_Image_Editor_Imagick' ,'WP_Image_Editor_GD' ) ); 改为 1$implementations = apply_filters( 'wp_image_editors', array( 'WP_Image_Editor_GD', 'WP_Image_Editor_Imagick' ) ); 此方法为临时解决方案，请大家及时更新最新版本的wordpress]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>wordpress</tag>
        <tag>imagick</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS提取字符串中文英文数字]]></title>
    <url>%2F2016%2F05%2F10%2Fjs-extract-chinese-words-number-of-string.html</url>
    <content type="text"><![CDATA[最近在做导出excel的时候，发现导出成功，文件大小也正常，但是Office 2013打不开，检查数据库发现，导出数据中有非中文字符导致Excel异常。 我们知道JS是支持unicode字符集的，符合导出规则的字符应该是”中文”、”英文”、”数字”。 正则表达式1/([\u4e00-\u9fa5\w]*)/ig 提取字符串12345678910/*** 获得可打印字符* @param str 需要提取的字符串*/function getPrintableChars(str) &#123; const matches = str.match(/([\u4e00-\u9fa5\w]*)/ig); let a = ''; matches.forEach(item=&gt; item &amp;&amp; (a += item)); return a;&#125;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>regex</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angularjs显示html文本]]></title>
    <url>%2F2016%2F03%2F29%2Fangularjs-display-html.html</url>
    <content type="text"><![CDATA[Angularjs中输出变量使用花括号或者ng-bind，但是如果变量中有html代码的话，angularjs为了xss安全，默认是不解析html，直接原样显示html代码。如果需要显示解析后的html代码，需要使用angular-sanitize模块。 angular-sanitize一般会附带在angularjs中，如果没有附带，请前往官网下载对应版本的angular-sanitize模块。 模块代码1var demo = angular.module('demo',['ng-sanitize']); 控制器代码12345demo.controller('Demo13Controller', [ '$scope', function($scope) &#123; $scope.html = '&lt;span style="color: red"&gt;这是格式化的HTML文本&lt;/span&gt;'; &#125;]); 视图代码1234567&lt;article class="demo13" ng-controller="Demo13Controller"&gt;&lt;h2&gt;&lt;a name="demo13"&gt;13.显示HTML文本&lt;/a&gt;&lt;/h2&gt;&lt;div class="demo13-content"&gt;&lt;p&gt;需要显示的文本：&lt;/p&gt;&lt;p&gt;Html格式化文本： &lt;span ng-bind-html="html|htmlContent"&gt;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;&lt;/article&gt; 过滤器代码12345demo.filter('htmlContent',['$sce', function($sce) &#123; return function(input) &#123; return $sce.trustAsHtml(input); &#125;&#125;]); 总结$sce过滤器+ng-bind-html就可以显示html文本了。]]></content>
      <categories>
        <category>angularjs</category>
      </categories>
      <tags>
        <tag>angularjs</tag>
        <tag>$sce</tag>
        <tag>sanitize</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Flux ES6记事本应用]]></title>
    <url>%2F2016%2F03%2F24%2Freact-flux-es6-note-app.html</url>
    <content type="text"><![CDATA[项目地址react-notepad-es6 React出来有很久了，与angularjs最大的不同在于React只是一个处理UI层面的库，可以认为是“V”，而angularjs则是一整套解决方案。 随着前端开发的组件化思想越来越浓烈，angularjs很多场合已经显得力不从心了。而这时候，核心为“模块化、组件化”的React可以派上永用场。真正用来开发项目的话，React肯定是不足的，缺少C和M模块。 Facebook官方推荐的Flux可以认为是一个简单的解决方案，Flux没什么特别含义，就是一个facebook随便找的一个词而已。至于什么是Flux，本文不做解释，本文以Flux来开发一个记事本应用。 项目目录12345678910111213141516171819202122232425262728293031|----action Action Creator |---- NoteAction.js 记事本应用需要的动作|----css 样式文件目录 |---- style.scss 样式文件|----dispatcher 分发器目录 |---- AppDispatcher.js 分发器|----store Store目录 |---- NoteStore.js 存储日记数据以及处理AppDispatcher派发事件|----view 视图&amp;组件目录 |---- Note.jsx 单条日记 |---- NoteBox.jsx 整个日记组件的父容器 |---- NoteForm.jsx 日记创建/编辑表单 |----NoteList.jsx 日记列表组件|----entry.js webpack入口文件|----index.html 项目页面|----webpack.config.js webpack配置文件 项目思路 NoteList.jsx组件包含多个Note.jsx，NoteList.jsx的数据来源于NoteStore.js。 创建日记时，NoteForm.jsx需要调用NoteAction的add方法最终触发AppDispatcher.dispatch方法 NoteStore注册AppDispatcher的监听器实现对dispatch事件的监听 编辑日记时，Note.jsx调用NoteAction的setNote方法设置需要编辑的日记，通过AppDispatcher的调度之后最终将日记数据显示在NoteForm.jsx组件中。 项目实现安装依赖本文采用ES6语法进行开发， 所以需要安装babel编译器，打开终端执行以下命令： 123456npm init -ynpm install webpack webpack-dev-server -gnpm install flux microevent react react-dom --savenpm install babel-loader css-loader jsx-loader sass-loader style-loader --save-devnpm instlal babel-preset-es2015 babel-preset-react --save-devnpm install microevent --save webpack.config.js1234567891011121314151617181920212223242526272829/** * Created by xialei on 2016/3/23 0023. */module.exports = &#123; entry: './entry.jsx', output: &#123; publicPath: 'http://localhost:8000/assets', filename: 'bundle.js', path: './assets' &#125;, module: &#123; loaders: [ &#123;test: /\.js$/, loader: 'babel'&#125;, &#123; test: /.jsx?$/, loader: 'babel-loader', exclude: /node_modules/, query: &#123; presets: ['es2015', 'react'] &#125; &#125;, &#123;test: /\.css$/, loader: 'style!css'&#125;, &#123;test: /\.scss$/, loader: 'style!css!sass'&#125; ] &#125;, resolve: &#123; extensions: ['', '.js', '.jsx'] &#125;&#125;; dispatcher/AppDispatcher.js123import Flux from 'flux';let AppDispatcher = new Flux.Dispatcher();export default AppDispatcher; action/NoteAction.jsActionCreator主要是为了简化代码量，不然每次需要触发动作的时候都需要调用AppDispatcher.dispatch方法。根据项目实际情况，可以总结出需要以下动作： 创建日记 更新日记 删除日记 编辑日记 由于ActionCreator是为了简化AppDispatcher.dispatch的方法调用，所以需要引入该模块。 123456789101112131415161718192021222324252627282930313233/** * Created by xialei on 2016/3/23 0023. */import AppDispatcher from '../dispatcher/AppDispatcher';export default class NoteAction &#123; static create(item) &#123; AppDispatcher.dispatch(&#123; eventName: 'create-note', item: item &#125;); &#125; static update(item) &#123; AppDispatcher.dispatch(&#123; eventName: 'update-note', item: item &#125;); &#125; static remove(item) &#123; AppDispatcher.dispatch(&#123; eventName: 'remove-note', item: item &#125;); &#125; static setNote(item) &#123; AppDispatcher.dispatch(&#123; eventName: 'set-note', item: item &#125;); &#125;&#125; store/NoteScore.js有了分发，就要有接收，所以接下来编辑 store/NoteScore.js文件，这里需要注意的是由于V中不要直接调用AppDispatcher.dispatch，但是V是肯定需要监听事件的，所以这里使用MicroEvent库来进行事件处理。 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Created by xialei on 2016/3/23 0023. */import AppDispatcher from '../dispatcher/AppDispatcher';import MicroEvent from 'microevent';class NoteStore &#123; constructor() &#123; this.items = []; &#125;&#125;MicroEvent.mixin(NoteStore);let store = new NoteStore();AppDispatcher.register((payload)=&gt; &#123; switch (payload.eventName) &#123; case 'create-note': store.items.push(payload.item); store.trigger('change'); break; case 'update-note': store.items.forEach(function(i, index2) &#123; if (i.id == payload.item.id) &#123; store.items[index2] = payload.item; store.trigger('change'); &#125; &#125;); break; case 'remove-note': store.items.forEach(function(i, index2) &#123; if (i.id == payload.item.id) &#123; store.items.splice(index2, 1); store.trigger('change'); &#125; &#125;); break; case 'set-note': store.trigger('set', payload.item); break; &#125; return true;&#125;);export default store; view/Note.jsx该组件主要负责单条日记的显示和操作，所以该组件需要有一个初始属性以及编辑/删除方法，由于编辑日记最终会放在NoteForm.jsx组件进行，所以此处使用props而不是state。 1234567891011121314151617181920212223242526272829303132333435/** * Created by xialei on 2016/3/23 0023. */import React from 'react';import NoteAction from '../action/NoteAction';export default class Note extends React.Component &#123; constructor() &#123; super(); this.handleDelete = this.handleDelete.bind(this); this.handleUpdate = this.handleUpdate.bind(this); &#125; handleUpdate() &#123; NoteAction.setNote(this.props.note); &#125; handleDelete() &#123; if (confirm('确定删除吗?')) &#123; NoteAction.remove(this.props.note); &#125; &#125; render() &#123; return ( &lt;div className="note-item"&gt; &lt;div className="id"&gt;&#123;this.props.note.id&#125;&lt;/div&gt; &lt;div className="text"&gt;&#123;this.props.note.text&#125;&lt;/div&gt; &lt;div className="operation"&gt; &lt;button type="button" onClick=&#123;this.handleUpdate&#125;&gt;编辑&lt;/button&gt; &lt;button type="button" onClick=&#123;this.handleDelete&#125;&gt;删除&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125; 由于采用了ES6语法，所以此处需要对this做特殊处理，否则会提示props undefined之类的错误。 view/NoteBox.jsx该组件的作用是将日记列表和日记表单显示出来，所以该组件只有一个构造方法和render方法。 12345678910111213141516/** * Created by xialei on 2016/3/23 0023. */import NoteList from './NoteList';import NoteForm from './NoteForm';import React from 'react';export default class NoteBox extends React.Component &#123; render() &#123; return ( &lt;div className="note-box"&gt; &lt;NoteList/&gt; &lt;NoteForm/&gt; &lt;/div&gt; ); &#125;&#125; view/NoteForm.jsx该组件需要完成的事情比较多： 需要对编辑和创建进行分别处理 需要监听Note.jsx组件触发的编辑事件 可编辑的文本域 根据以上要求，可以得出以下结论： 需要使用state，以及设置一个初始的state 在textarea的onChange事件中，将值设置到state中去 需要监听NoteStore触发的“set”事件，将需要编辑的日记显示在textarea中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/** * Created by xialei on 2016/3/23 0023. */import React from 'react';import NoteAction from '../action/NoteAction';import NoteStore from '../store/NoteStore';export default class NoteForm extends React.Component &#123; constructor() &#123; super(); this.handleClick = this.handleClick.bind(this); this.handleSetNote = this.handleSetNote.bind(this); this.handleChange = this.handleChange.bind(this); this.resetForm = this.resetForm.bind(this); this.state = &#123; note: &#123; id: 0, text: '' &#125; &#125;; &#125; componentDidMount() &#123; NoteStore.bind('set', this.handleSetNote); &#125; componentWillUnmount() &#123; NoteStore.unbind('set', this.handleSetNote); &#125; isCreate() &#123; return this.state.note.id == 0; &#125; handleClick() &#123; let text = this.refs.input.value; if (text.length == 0) &#123; alert('请输入日记内容'); this.refs.input.focus(); return; &#125; if (this.isCreate()) &#123; let id = 1; if (NoteStore.items.length &gt; 0) &#123; id = NoteStore.items[NoteStore.items.length - 1].id + 1; &#125; NoteAction.create(&#123; id: id, text: text &#125;); &#125; else &#123; let note = this.state.note; note.text = text; NoteAction.update(note); &#125; this.resetForm(); &#125; render() &#123; let note = this.state.note.text; let btnText = this.isCreate() ? '创建' : '编辑'; let tips = this.isCreate() ? '' : '当前编辑 [' + this.state.note.id + '] 号日记'; return ( &lt;div className="note-form"&gt; &lt;div&gt;&#123;tips&#125;&lt;/div&gt; &lt;textarea ref="input" rows="8" placeholder="日记内容" value=&#123;note&#125; onChange=&#123;this.handleChange&#125;/&gt; &lt;button type="button" onClick=&#123;this.handleClick&#125;&gt;&#123;btnText&#125;&lt;/button&gt; &lt;button type="button" onClick=&#123;this.resetForm&#125;&gt;重置&lt;/button&gt; &lt;/div&gt; ); &#125; handleChange(e) &#123; let id = this.state.note.id || 0; this.setState(&#123; note: &#123; id: id, text: e.target.value &#125; &#125;); &#125; handleSetNote(note) &#123; this.setState(&#123;note: note&#125;); console.log('set ', this.state.note); &#125; resetForm() &#123; this.setState(&#123; note: &#123; id: 0, text: '' &#125; &#125;); &#125;&#125; view/NoteList.jsx该组件负责渲染NoteStore中的日记列表以及对NoteStore触发的change事件作出相应，实时显示最新数据。 123456789101112131415161718192021222324252627282930313233/** * Created by xialei on 2016/3/23 0023. */import React from 'react';import NoteStore from '../store/NoteStore';import Note from './Note';export default class NoteList extends React.Component &#123; constructor() &#123; super(); this.handleChanged = this.handleChanged.bind(this); &#125; componentDidMount() &#123; NoteStore.bind('change', this.handleChanged); &#125; componentWillUnmount() &#123; NoteStore.unbind('change', this.handleChanged); &#125; handleChanged() &#123; this.forceUpdate(); &#125; render() &#123; const notes = NoteStore.items.map((item)=&gt; &#123; return &lt;Note note=&#123;item&#125; key=&#123;item.id&#125;/&gt;; &#125;); return ( &lt;div className="note-list"&gt;&#123;notes&#125;&lt;/div&gt; ); &#125;&#125; entry.jsx该文件主要将NoteBox.jsx组件渲染到html容器中。 1234567/** * Created by xialei on 2016/3/23 0023. */import ReactDOM from 'react-dom';import NoteBox from './view/NoteBox';import './css/style.scss';ReactDOM.render(&lt;NoteBox/&gt;, document.querySelector('#content')); index.html12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src="./node_modules/react/dist/react-with-addons.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="content"&gt;&lt;/div&gt; &lt;script src="http://localhost:8000/webpack-dev-server.js"&gt;&lt;/script&gt; &lt;script src="http://localhost:8000/assets/bundle.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 项目运行1webpack-dev-server --progress --colors --port 8000 demo]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>es6</tag>
        <tag>flux</tag>
        <tag>react</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android选择图片返回统一图片地址]]></title>
    <url>%2F2016%2F03%2F02%2Fandroid-pick-image-return-image-path.html</url>
    <content type="text"><![CDATA[android从选择图片有两种方法，但是返回值确不同，本文将指导大家如何统一这两种方式的返回值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//关键代码@Event(R.id.btnPhoto) private void onBtnPhotoClicked(View view) &#123; Intent intent = new Intent(Intent.ACTION_PICK, MediaStore.Images.Media.EXTERNAL_CONTENT_URI); startActivityForResult(intent, Config.Constants.CODE_PICK_IMAGE_FROM_PHOTO); &#125; @Event(R.id.btnCamera) private void onBtnCameraClicked(View view) &#123; Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); startActivityForResult(intent, Config.Constants.CODE_PICK_IMAGE_FROM_CAMERA); &#125; @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; switch (requestCode) &#123; case Config.Constants.CODE_PICK_IMAGE_FROM_CAMERA: if (data != null &amp;&amp; data.hasExtra("data")) &#123; Bitmap bitmap = data.getParcelableExtra("data"); bitmap = BitmapUtil.scale(bitmap, 640.0f / bitmap.getWidth()); try &#123; File path = new File(((MyApplication) getApplication()).appPath, DateUtil.format(new Date(), "yyyyMMddHHmmss") + ".jpg"); FileOutputStream outputStream = new FileOutputStream(path); bitmap.compress(Bitmap.CompressFormat.JPEG, 100, outputStream); outputStream.close(); Intent intent = new Intent(); intent.putExtra("path", path.getAbsolutePath()); setResult(RESULT_OK, intent); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; finish(); break; case Config.Constants.CODE_PICK_IMAGE_FROM_PHOTO: if(data != null)&#123; Uri uri = data.getData(); Bitmap bitmap; ContentResolver contentResolver = getContentResolver(); try &#123; bitmap = MediaStore.Images.Media.getBitmap(contentResolver, uri); bitmap = BitmapUtil.scale(bitmap, 640.0f / bitmap.getWidth()); File path = new File(((MyApplication) getApplication()).appPath, DateUtil.format(new Date(), "yyyyMMddHHmmss") + ".jpg"); FileOutputStream outputStream = new FileOutputStream(path); bitmap.compress(Bitmap.CompressFormat.JPEG, 100, outputStream); outputStream.close(); Intent intent = new Intent(); intent.putExtra("path", path.getAbsolutePath()); setResult(RESULT_OK, intent); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; finish(); break; default: super.onActivityResult(requestCode, resultCode, data); &#125; &#125;//BitmapUtil.javapublic static Bitmap scale(Bitmap bitmap, float scale) &#123; Matrix matrix = new Matrix(); matrix.postScale(scale, scale); return Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(), bitmap.getHeight(), matrix, true);&#125;//MyApplicationpublic File appPath;@Overridepublic void onCreate() &#123; super.onCreate(); //创建目录 appPath = new File(Environment.getExternalStorageDirectory(), getPackageName()); if (!appPath.isDirectory()) &#123; appPath.mkdir(); &#125;&#125; 经过统一处理之后，返回值均为图片的绝对路径地址。]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度推送收到消息时带参数启动activity]]></title>
    <url>%2F2016%2F02%2F19%2Fbaidu-push-launch-app-with-params.html</url>
    <content type="text"><![CDATA[一般来说，在BPushReceiver的onNotificationClicked或者onMessage方法收到推送消息后会去启动一个activity。此时整个应用有以下几种状态： 应用进程不存在 应用进程存在，但是不在前台 应用进程存在，在前台 在BPushReceiver的onNotificationClicked或者onMessage方法中使用Intent来启动activity： 1234567891011Intent intent = new Intent();intent.setClass(context.getApplicationContext(), MainActivity.class);intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_SINGLE_TOP);if (url != null &amp;&amp; !url.isEmpty()) &#123; Bundle bundle = new Bundle(); bundle.putString("url", url); intent.putExtras(bundle);&#125;Log.d(TAG, "start app");context.getApplicationContext().startActivity(intent); 需要注意的是，针对不同的应用状态，MainActivity中触发的方法也不同： 应用进程不存在时,onCreate被调用 应用进程存在，不管是不是在前台，onNewIntent被调用 针对以上状态，合理的使用onCreate和onNewIntent就可以在任何时候呆参数启动APP了。]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>百度推送</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MAMP下使用pecl安装PHP扩展]]></title>
    <url>%2F2016%2F02%2F16%2Fmamp-install-php-extension.html</url>
    <content type="text"><![CDATA[之前写过一篇在Mac下搭建PHP开发环境的文章，Mac搭建PHP开发环境，但是此种方式搭建的PHP有弊端，由于默认不带PHP源码，所以在使用pecl安装扩展时会报错。 测试安装扩展1sudo pecl install mongo 运行起来后会报形如“php.h not found”的错误，因为MAMP默认是不带PHP源码包的。 配置扩展安装环境按照如下步骤将源码包集成以便于安装扩展：1.在web目录下添加index.php文件，内容如下： 12&lt;?phpphpinfo(); 2.打开浏览器访问该php文件，记录PHP版本，本文暂定PHP版本A。3.打开终端，输入以下命令： 1php -v 记录PHP版本，本文暂定PHP版本B。4.如果PHP版本A不等于PHP版本B，在终端执行以下命令： 123456789sudo rm -rf /usr/bin/phpsudo rm -rf /usr/bin/phpizesudo rm -rf /usr/bin/php-configsudo rm -rf /usr/bin/pecl ln -s /Application/MAMP/bin/php/php[PHP版本A]/bin/php /usr/bin/phpln -s /Application/MAMP/bin/php/php[PHP版本A]/bin/php-config /usr/bin/php-configln -s /Application/MAMP/bin/php/php[PHP版本A]/bin/phpize /usr/bin/phpizeln -s /Application/MAMP/bin/php/php[PHP版本A]/bin/pecl /usr/bin/pecl 请替换[PHP版本A]为步骤2中的版本，如5.5.18执行完以上命令之后，命令行模式和浏览器模式的PHP都是一致的了。5.下载PHP源码包，打开浏览器访问如下网址 http://cn2.php.net/get/php-**[PHP版本A]**.tar.gz/from/this/mirror。6.将下载的压缩包解压到 /Application/MAMP/bin/php/php[PHP版本A]/include/php 中。7.在终端执行以下命令： 12cd /Application/MAMP/bin/php/php[PHP版本A]/include/php./configure 此时PHP源码包已经配置正常了，头文件也可以正常调用了。8.在终端执行： 1sudo pecl install mongo 扩展安装成功后，编辑/Application/MAMP/bin/php/php[PHP版本A]/conf/php.ini 在最后添加： 1extension=mongo.so 9.由于命令行模式和浏览器模式中加载的php.ini并不是同一个文件，所以需要用软连接的方式处理下。终端执行： 1php -i|grep ini 查看Loaded ini file路径，本文假设为PHP配置文件A。10.备份PHP配置文件A，终端执行： 1ln -s /Application/MAMP/bin/php/php[PHP版本A]/conf/php.ini PHP配置文件A 11.终端执行： 1php -i|grep ini 此时该路径应该和浏览器中看到的是一致的了。 安装扩展 sudo pecl install [扩展名] 编辑 /Application/MAMP/bin/php/php[PHP版本A]/conf/php.ini 加载扩展 重启Web服务器]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>mamp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac搭建PHP开发环境]]></title>
    <url>%2F2016%2F02%2F16%2Fmac-php-env.html</url>
    <content type="text"><![CDATA[本文教大家在Mac环境中搭建PHP开发环境。 下载软件包 下载地址 安装软件 使用MAMP_PRO_3.0.7.3_SN.txt中的序列号激活 关于MAMP具体的使用，比如添加虚拟主机等，请自己摸索。]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>mamp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongodb更新指定条件的子文档]]></title>
    <url>%2F2016%2F01%2F04%2Fmongodb-findandmodify.html</url>
    <content type="text"><![CDATA[文档内容123456789101112131415161718&#123; "_id": ObjectId("5689db252d162c9881532986"), "openid": "xialei", "channels": [ &#123; "channel_id": "c1" &#125;, &#123; "channel_id": "c2" &#125;, &#123; "channel_id": "c2" &#125;, &#123; "channel_id": "c2" &#125; ]&#125; 需求把该文档的channels中channel_id为c2的删除，但是主记录要保留。这时候就不能用remove方法了，该方法会删除整条文档，查询官方文档发现有个findAndModify方法。 函数原型12345678910db.collection.findAndModify(&#123; query: &lt;document&gt;, sort: &lt;document&gt;, remove: &lt;boolean&gt;, update: &lt;document&gt;, new: &lt;boolean&gt;, fields: &lt;document&gt;, upsert: &lt;boolean&gt; bypassDocumentValidation: &lt;boolean&gt;&#125;); 调用代码12345db.collection.findAndModify(&#123; query: &#123;"openid":"xialei"&#125;, update: &#123;"$pull":&#123;"channels":&#123;"channel_id":"c2"&#125;&#125;&#125;, new: true&#125;); 执行结果123456789&#123; "_id" : ObjectId("5689db252d162c9881532986"), "openid" : "xialei", "channels" : [ &#123; "channel_id" : "c1" &#125; ]&#125; $pull是数组操作符，明白update中的操作之后，相信大家可以举一反三，比如要插入一个文档就肯定会想到用$push了。]]></content>
      <categories>
        <category>mongodb</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度云推送nodejs sdk]]></title>
    <url>%2F2015%2F12%2F29%2Fbaidu-push-nodejs-sdk.html</url>
    <content type="text"><![CDATA[项目地址bpush-nodejs 开发背景百度官方只有php和java的sdk，但是百度提供了rest api,好处就是开发者可以使用任何语言开发一套服务端SDK，本人开源一套基于nodejs的sdk。 使用1npm install bpush-nodejs --save 1var bpush = require('bpush-nodejs'); 说明SDK采用Promise方式进行回调,demo代码如下(以推送单个设备为例),catch代码块中 只捕获HTTP请求错误,如果HTTP请求成功,但是百度服务端报错,请自行在then中处理 1234567891011121314151617var data = &#123; channel_id: '5247517738736986629', msg: JSON.stringify(&#123; aps: &#123; alert: '你是呵呵SINGLE' &#125; &#125;), msg_type: bpush.constant.MSG_TYPE.NOTIFICATION, deploy_status: bpush.constant.DEPLOY_STATUS.DEVELOPMENT, device_type: bpush.constant.DEVICE_TYPE.IOS&#125;;bpush.sendRequest(bpush.apis.pushMsgToSingleDevice, data).then(function (data) &#123; data = JSON.parse(data); console.log(data); &#125;).catch(function(e)&#123; console.error(e); &#125;); 所有api调用方法均为 bpush.sendRequest(bpush.apis.[api名称], [api需要的数据]) api列表百度官方文档特别说明: 本文档写作时,百度api返回的数据以本文档为准,与官方文档有出入的地方可能是百度升级了api忘记更新文档所致. pushSingleDevice功能:推送单一终端请求参数: 1234567891011var data = &#123; channel_id: '5247517738736986629',//设备channelID msg: JSON.stringify(&#123; aps: &#123; alert: '你是呵呵SINGLE' &#125; &#125;), msg_type: bpush.constant.MSG_TYPE.NOTIFICATION, deploy_status: bpush.constant.DEPLOY_STATUS.DEVELOPMENT, device_type: bpush.constant.DEVICE_TYPE.IOS&#125;; 返回参数: 1234567&#123; request_id: 900279880, response_params: &#123; msg_id: '7960733379606623036', send_time: 1451380442 &#125;&#125; pushMsgToAll功能:推送所有终端请求参数: 12345678910var data = &#123; msg: JSON.stringify(&#123; aps: &#123; alert: '你是呵呵ALL' &#125; &#125;), msg_type: bpush.constant.MSG_TYPE.NOTIFICATION, deploy_status: bpush.constant.DEPLOY_STATUS.DEVELOPMENT, device_type: bpush.constant.DEVICE_TYPE.IOS&#125;; 返回参数: 1234567&#123; request_id: 900279880, response_params: &#123; msg_id: '7960733379606623036', send_time: 1451380442 &#125;&#125; pushMsgToTag功能:组播推送请求参数: 123456789101112var data = &#123; msg: JSON.stringify(&#123; aps: &#123; alert: '你是呵呵TAG' &#125; &#125;), type: 1,//固定为1 tag: 'test',//标签名称 msg_type: bpush.constant.MSG_TYPE.NOTIFICATION, deploy_status: bpush.constant.DEPLOY_STATUS.DEVELOPMENT, device_type: bpush.constant.DEVICE_TYPE.IOS&#125;; 返回参数: 1234567&#123; request_id: 900279880, response_params: &#123; msg_id: '7960733379606623036', send_time: 1451380442 &#125;&#125; queryMsgStatus功能:查询消息推送情况请求参数: 123var data = &#123; msg_id: '3129074535657443828'&#125;; 返回结果: 123456789101112131415&#123; "request_id": 1221365722, "response_params": &#123; "total_num": 1, "result": [ &#123; "send_time": 1451381279, "success": -1, "total_num": 4, "status": 0, "msg_id": "3129074535657443828" &#125; ] &#125;&#125; queryTags功能:查询标签组列表请求参数: 12var data = &#123;&#125;; 返回参数: 123456789101112131415161718192021222324252627282930313233343536&#123; "request_id": 896177143, "response_params": &#123; "total_num": 4, "result": [ &#123; "tid": "1933949969962682514", "tag": "default", "info": "default", "type": 0, "create_time": 1447315802 &#125;, &#123; "tid": "73579040", "tag": "test20151112", "info": "test201511127237210", "type": 2, "create_time": 1447321138 &#125;, &#123; "tid": "77983912", "tag": "test", "info": "test7237210", "type": 2, "create_time": 1451376995 &#125;, &#123; "tid": "77986112", "tag": "testtag", "info": "testtag7237210", "type": 2, "create_time": 1451379084 &#125; ] &#125;&#125; createTag功能:创建标签组请求参数: 123var data = &#123; tag: 'testtag'&#125;; 返回参数: 1234567&#123; "request_id": 1221802330, "response_params": &#123; "tag": "testtag", "result": 0 &#125;&#125; deleteTag功能:删除标签组请求参数: 123var data = &#123; tag: 'testtag'&#125;; 返回参数: 1234567&#123; "request_id": 897517834, "response_params": &#123; "tag": "testtag", "result": 0 &#125;&#125; addDevicesToTag功能:添加设备到标签组请求参数: 1234var data = &#123; tag: 'testtag', channel_ids: JSON.stringify([5247517738736986629])&#125;; 返回参数: 1234567891011&#123; "request_id": 881162061, "response_params": &#123; "result": [ &#123; "channel_id": "5247517738736987000", "result": 1 &#125; ] &#125;&#125; removeDevicesFromTag功能:将设备从标签组中移除请求参数: 1234var data = &#123; tag: 'testtag', channel_ids: JSON.stringify([5247517738736986629])&#125;; 返回参数: 1234567891011&#123; "request_id": 881521481, "response_params": &#123; "result": [ &#123; "channel_id": "5247517738736987000", "result": 1 &#125; ] &#125;&#125; deviceNumInTag功能:查询标签组设备数量请求参数: 123var data = &#123; tag: 'testtag'&#125;; 返回参数: 123456&#123; "request_id": 882409689, "response_params": &#123; "device_num": -1 &#125;&#125; reportStaticDevice功能:当前应用的设备统计信息请求参数: 12var data = &#123;&#125;; 返回参数: 1234567891011121314151617181920212223242526272829303132333435363738394041424344&#123; "request_id": 883742690, "response_params": &#123; "result": &#123; "1450713600": &#123; "total_term": 2, "total_term_detail": &#123; "1450774800": 2 &#125;, "new_term": 1, "new_term_detail": &#123; "1450774800": 1 &#125;, "del_term": 0, "del_term_detail": [] &#125;, "1450800000": &#123; "total_term": 3, "total_term_detail": &#123; "1450868400": 3 &#125;, "new_term": 1, "new_term_detail": &#123; "1450868400": 1 &#125;, "del_term": 0, "del_term_detail": [] &#125;, "1451232000": &#123; "total_term": 4, "total_term_detail": &#123; "1451293200": 4 &#125;, "new_term": 1, "new_term_detail": &#123; "1451293200": 1 &#125;, "del_term": 0, "del_term_detail": [] &#125; &#125;, "total_num": 3 &#125;&#125;]]></content>
      <categories>
        <category>open-source-projects</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>百度云推送</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ios仿微信右上角弹出菜单]]></title>
    <url>%2F2015%2F12%2F17%2Fios-wechat-like-menu.html</url>
    <content type="text"><![CDATA[项目地址ios仿微信右上角弹出菜单 效果图 实现过程本人倾向于使用storyboard来做布局，所以实现起来也是不难的1.新建 Single View Application。 2.打开Main.storyboard。 3.选择默认的View Controller，点击菜单”Editor”=&gt;”Embed In”=&gt;”Navigation Controller”,确认Navigation Controller是Initial View Controller。 4.拖两个viewController到Interface builder，并做好连接，效果如图1所示。 5.选择第二个 Segue，属性设置如图2所示。 6.打开ViewController.m，覆盖 prepareForSegue方法 12345678910- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender &#123; if ([segue.identifier isEqualToString:@&quot;showMenu&quot;]) &#123; UIViewController *viewController = segue.destinationViewController; if ([[[UIDevice currentDevice] systemVersion] floatValue] &gt;= 8.0) &#123; viewController.modalPresentationStyle = UIModalPresentationOverCurrentContext; &#125; else &#123; self.modalPresentationStyle = UIModalPresentationCurrentContext; &#125; &#125;&#125; 由于IOS8更换了Enum的名称，所以这里需要做下判断7.新建Cocao Touch Class=&gt;View2Controller 8.在Interface Builder中把第二个viewController的Class设置为View2Controller，并把“取消”按钮绑定到View2Controller.m 9.打开View2Controller.m 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//// View2Controller.m// viewtransition//// Created by xialeistudio on 15/12/17.// Copyright © 2015年 Group Friend Information. All rights reserved.//#import &quot;View2Controller.h&quot;@interface View2Controller ()- (IBAction)cancelClicked:(id)sender;@property(weak, nonatomic) IBOutlet UIView *menuView;@end@implementation View2Controller &#123; UITapGestureRecognizer *_tap;&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view. _tap = [[UITapGestureRecognizer alloc] init]; [_tap addTarget:self action:@selector(closeView)]; [self.view addGestureRecognizer:_tap];&#125;- (void)closeView &#123; _menuView.frame = CGRectMake(_menuView.frame.origin.x, self.view.frame.size.height - _menuView.frame.size.height, _menuView.frame.size.width, _menuView.frame.size.height); [UIView animateWithDuration:.3 delay:0 options:UIViewAnimationOptionCurveEaseInOut animations:^&#123; _menuView.frame = CGRectMake(_menuView.frame.origin.x, self.view.frame.size.height, _menuView.frame.size.width, _menuView.frame.size.height); &#125; completion:^(BOOL isFinished) &#123; if (isFinished) &#123; [self dismissViewControllerAnimated:NO completion:nil]; &#125; &#125;];&#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.&#125;- (void)viewWillAppear:(BOOL)animated &#123; _menuView.frame = CGRectMake(_menuView.frame.origin.x, self.view.frame.size.height, _menuView.frame.size.width, _menuView.frame.size.height); [UIView animateWithDuration:.3 animations:^&#123; _menuView.frame = CGRectMake(_menuView.frame.origin.x, self.view.frame.size.height - _menuView.frame.size.height, _menuView.frame.size.width, _menuView.frame.size.height); &#125;];&#125;/*#pragma mark - Navigation// In a storyboard-based application, you will often want to do a little preparation before navigation- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender &#123; // Get the new view controller using [segue destinationViewController]. // Pass the selected object to the new view controller.&#125;*/- (IBAction)cancelClicked:(id)sender &#123; [self closeView];&#125;@end 关键是 viewWillAppear 和 closeView 中的动画处理。]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>微信菜单</tag>
        <tag>modal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac 10.11安装php-mongo扩展踩过的坑]]></title>
    <url>%2F2015%2F12%2F15%2Fmac-10-11-install-php-mongo.html</url>
    <content type="text"><![CDATA[pecl的安装本文采用的是 pecl 的方式安装。如果系统执行 pecl 命令报错的话，请打开终端，执行以下命令 12curl -o go-pear.phar http://pear.php.net/go-pear.pharphp go-pear.phar 接下来的询问过程直接回车即可，成功之后执行以下命令 12sudo ln -s /Users/[用户名]/pear/bin/pear /usr/bin/pearsudo ln -s /Users/[用户名]/pear/bin/pecl /usr/bin/pecl mongo扩展的安装1sudo pecl install mongo 接下来会询问是不是启用 sasl 认证，输入[no]回车，接下来是编译了，不出意外的话会编译出错，大致错误是 1&lt;openssl/evp.h&gt; file not found 简而言之就是 openssl/evp.h 头文件查找失败，由于用 尖括号括起来的头文件，编译器会去系统路径查找，而 mac 下默认的路径是 /usr/include，使用终端ls查看之后发现确实没有openssl文件夹。 openssl的安装1sudo brew install openssl 如果提示brew命令不存在，可以通过以下代码安装Homebrew，终端执行 1ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 安装完成后重新安装openssl即可。 link头文件通过brew命令安装完openssl之后会自动link一次，但是重新执行mongo的安装命令时依旧出错。猜想应该是头文件没有复制过去，这时候需要手动ln一下，终端执行 1ln -s /usr/local/Cellar/openssl/1.0.2d_1/include/openssl /usr/include/openssl 如果你的openssl版本不一致，请自行替换，执行完该命令之后再安装mongo就不会有问题了。 启用扩展MAMP的php很有意思，web版本的配置文件在 1/Library/Application Support/appsolute/MAMP PRO/conf/php.ini cli版本的配置文件在（请通过终端执行 php -v 获取PHP版本） 1/Applications/MAMP/bin/php/php5.5.10/conf/php.ini 在这两个文件都加上 1extesion=mongo.so 重启MAMP即可]]></content>
      <categories>
        <category>mamp</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>php</tag>
        <tag>mongo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ios9 导航栏全透明]]></title>
    <url>%2F2015%2F12%2F12%2Fios9-navigation-bar-transparent.html</url>
    <content type="text"><![CDATA[效果图导航栏是全透明的，但是导航栏的 item 还是正常的。 123[self.navigationBar setBackgroundImage:[UIImage new] forBarMetrics:UIBarMetricsDefault];self.navigationBar.shadowImage = [UIImage new];self.navigationBar.translucent = YES; 如果你的当前viewController不是navigationControllernavigationController，请把self.navigationBar改为self.navigationController.navigationBar。]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2011CCJOY群雄逐鹿]]></title>
    <url>%2F2015%2F12%2F01%2F2011-ccjoy-2011.html</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>AfterEffects</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2015群友茶吧万圣节]]></title>
    <url>%2F2015%2F12%2F01%2F2015-group-of-friends-of-tea-halloween.html</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>AfterEffects</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2014网络102班毕业剪影]]></title>
    <url>%2F2015%2F12%2F01%2F2014-network-102-class-graduation-silhouette.html</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>AfterEffects</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2012-9-15班级活动剪影]]></title>
    <url>%2F2015%2F12%2F01%2F2012-9-15-class-activities-silhouette.html</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>AfterEffects</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2012计算机与通信学院辩论赛]]></title>
    <url>%2F2015%2F12%2F01%2F2012-computer-and-communication-college-debate.html</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>AfterEffects</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2011圣诞节小作]]></title>
    <url>%2F2015%2F12%2F01%2F2011-christmas.html</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>AfterEffects</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2011湖南工业大学计算机与通信学院迎新晚会]]></title>
    <url>%2F2015%2F12%2F01%2F2011-hunan-university-of-technology-school-of-computer-and-communications-welcome-party.html</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>AfterEffects</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[object-c委托实例]]></title>
    <url>%2F2015%2F12%2F01%2Fobject-c-delegate.html</url>
    <content type="text"><![CDATA[定义 delegate是一种设计模式，不是object-c特有 object-c通过protocol实现delegat 作用 业务逻辑解耦 加强程序可读性 使用 声明protocol 实现protocol 指定delegate 调用delegate方法 实例本文以UIImagePickerController举例。UIImagePickerController本身需要实现两个protocol，本文为了解释delegate的工作过程，在此之上封装一层。1.新建cocoa touch class 继承NSObject，命名UITool UITool.h12345678910111213141516171819202122232425262728293031323334353637383940414243UITool.h#import &lt;Foundation/Foundation.h&gt;#import &lt;UIKit/UIKit.h&gt;enum&#123; ImageErrorUnSupportedSourceType = -1//不支持的来源类型&#125;ImageError;@protocol ToolImageDelegate &lt;NSObject&gt;/** * 选择图片回调 * * @param info 图片数据 */-(void)didSelectImage:(NSDictionary *)info;@end@interface UITool : NSObject&lt;UIImagePickerControllerDelegate,UINavigationControllerDelegate&gt;&#123; id&lt;ToolImageDelegate&gt;imageDelegate;&#125;/** * 单例 * * @return 单例 */+(instancetype)sharedManager;/** * 选择图片 * * @param sourceType 来源类型 * @param viewController 视图 * @param error 错误 * * @return 是否出错 */-(BOOL)selectPicture :(UIImagePickerControllerSourceType)sourceType :(UIViewController&lt;ToolImageDelegate&gt; *)viewController :(NSError **)error;@end UITool.m12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364UITool.m#import &quot;UITool.h&quot;/** * 单例 * * @return 单例 */+(instancetype)sharedManager&#123; static UITool *instance = nil; static dispatch_once_t predicate; dispatch_once(&amp;predicate,^&#123; instance = [[self alloc]init]; &#125;); return instance;&#125;/** * 选择图片 * * @param sourceType 来源地址 * @param viewController 视图 * @param error 错误 * * @return 是否成功 */-(BOOL)selectPicture:(UIImagePickerControllerSourceType)sourceType :(UIViewController&lt;ToolImageDelegate&gt; *)viewController :(NSError **)error&#123; if (![UIImagePickerController isSourceTypeAvailable:sourceType]) &#123; NSDictionary *info = [NSDictionary dictionaryWithObject:@&quot;UnSupported source type&quot; forKey:NSLocalizedDescriptionKey]; *error = [NSError errorWithDomain:@&quot;com.xialeistudio.core.UITool&quot; code:ImageErrorUnSupportedSourceType userInfo:info]; return NO; &#125; //委托处理 imageDelegate = viewController; UIImagePickerController *picker = [[UIImagePickerController alloc] init]; picker.sourceType = sourceType; picker.allowsEditing= YES; picker.delegate = self; [viewController presentViewController:picker animated:YES completion:nil]; return YES;&#125;/** * 取消图片选择回调 * * @param picker 图片选择器 */-(void)imagePickerControllerDidCancel:(UIImagePickerController *)picker&#123; [picker dismissViewControllerAnimated:YES completion:^&#123; [imageDelegate didSelectImage:nil]; &#125;];&#125;/** * 图片成功回调 * * @param picker 图片选择器 * @param info 回调数据 */-(void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary&lt;NSString *,id&gt; *)info&#123; [picker dismissViewControllerAnimated:YES completion:^&#123; [imageDelegate didSelectImage:info]; &#125;];&#125;@end 按照委托的使用4步来说，我们自定义的委托已经实现了两步。imageDelegate就是我们的delegate，只要实现了该委托的子类，我们调用didSelectImage方法就不会出错。 视图打开Interface Builder，放入一个button和一个ImageView，并做好输出口连接。 ViewController.h12345678910ViewController.h#import &lt;UIKit/UIKit.h&gt;#import &quot;UITool.h&quot;@interface ImagePickerViewController : UIViewController&lt;ToolImageDelegate&gt;- (IBAction)fromCamera:(id)sender;@property (weak, nonatomic) IBOutlet UIImageView *cameraImage;@end ViewController.m1234567891011121314151617181920212223242526272829303132333435ViewController.m#import &quot;ImagePickerViewController.h&quot;@interface ImagePickerViewController ()@end@implementation ImagePickerViewController- (void)viewDidLoad &#123; [super viewDidLoad];&#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning];&#125;- (IBAction)fromCamera:(id)sender &#123; NSError *error = nil; if (![[UITool sharedManager] selectPicture:UIImagePickerControllerSourceTypeCamera :self :&amp;error]) &#123; NSLog(@&quot;error:%@&quot;,[error localizedDescription]); &#125;&#125;-(void)didSelectImage:(NSDictionary *)info&#123; if (info ==nil) &#123; NSLog(@&quot;未选择图片&quot;); &#125;else&#123; UIImage *originImage = [info objectForKey:UIImagePickerControllerOriginalImage]; [self.cameraImage setImage:originImage]; &#125;&#125;@end 总结 在调用UITool的selectPicture方法时第二个参数(UIViewController *)，强制要求传入的viewController实现ToolImageDelegate协议，在UIImagePickerController回调成功之后就会执行imagePickerControllerDidCancel和didFinishPickingMediaWithInfo方法，由于我们在该方法中进行了委托方法的调用，所以最终会执行ViewController的didSelectImage方法。]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>delegate</tag>
        <tag>object-c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用QQ企业邮箱发信时501错误解决方案]]></title>
    <url>%2F2015%2F11%2F23%2Fexmail-501.html</url>
    <content type="text"><![CDATA[此现象只出现在新增或者编辑邮箱密码的时候出现，发送邮箱时服务端会返回501，此时是由于QQ企业邮箱强制要求第一次登录必须修改密码。解决方案是： 登录QQ企业邮箱 修改密码 使用新密码调用接口]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>企业邮箱</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3实现三角形]]></title>
    <url>%2F2015%2F11%2F23%2Fcss3-triangle.html</url>
    <content type="text"><![CDATA[123456789101112131415161718div&#123; border: 1px solid #dddddd; padding: 4px 40px 4px 8px; position: relative;&#125;div:after&#123; content: ' '; margin-top: -5px; display: block; position: absolute; right: 8px; top: 50%; width: 0; height: 0; border-left: 12px transparent solid; border-right: 12px transparent solid; border-top: 12px #000000 solid;&#125; demo]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css3</tag>
        <tag>front-end</tag>
        <tag>三角形</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angularjs icheck]]></title>
    <url>%2F2015%2F11%2F23%2Fangularjs-icheck.html</url>
    <content type="text"><![CDATA[项目地址https://github.com/xialeistudio/angular-icheck 项目说明icheck的angularjs版本]]></content>
      <categories>
        <category>open-source-projects</category>
      </categories>
      <tags>
        <tag>angularjs</tag>
        <tag>icheck</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angularjs上传指令]]></title>
    <url>%2F2015%2F11%2F23%2Fangularjs-upload.html</url>
    <content type="text"><![CDATA[项目地址https://github.com/xialeistudio/angular-upload 项目说明angularjs上传指令]]></content>
      <categories>
        <category>open-source-projects</category>
      </categories>
      <tags>
        <tag>angularjs</tag>
        <tag>bower</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs mongodb 缓存模块]]></title>
    <url>%2F2015%2F11%2F23%2Fnodejs-mongodb-cache.html</url>
    <content type="text"><![CDATA[项目地址https://github.com/xialeistudio/mongodb-cache 项目说明基于mongodb的nodejs缓存模块 使用1npm install xl-cache --save 1var cache = require('xl-mongodb-cache'); 连接服务器 1cache.connect('mongodb://localhost:27017/app'); 写入缓存 123cache.set(key, value, duration).then(function(data) &#123; console.log(data);&#125;).catch(console.error); 读取缓存 123cache.get(key).then(function(data) &#123; console.log(data);&#125;).catch(console.error); 删除缓存 123cache.remove(key).then(function(data) &#123; console.log(data);&#125;).catch(console.error);]]></content>
      <categories>
        <category>open-source-projects</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chrome hosts插件]]></title>
    <url>%2F2015%2F11%2F23%2Fchrome-hostsmanager-plugin.html</url>
    <content type="text"><![CDATA[项目地址https://github.com/xialeistudio/hostManager 特别说明Chrome 44版本以后不支持，不过开发过程大家可以了解下。]]></content>
      <categories>
        <category>open-source-projects</category>
      </categories>
      <tags>
        <tag>angularjs</tag>
        <tag>chrome plugin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[svn更新时403的解决]]></title>
    <url>%2F2015%2F11%2F14%2Fsvn-update-403.html</url>
    <content type="text"><![CDATA[今天在服务器上svn up的时候出现这么一段 svn: Server sent unexpected return value (403 Forbidden) in response to OPTIONS request 403一般是权限问题，但是昨天还好好更新的，应该不是，然后更新的时候昨天是需要输入账号密码的，但是今天不需要，想着是不是账号密码被保存下来了，而这个账号密码可能有误，经过google发现在 ~/.subversion/auth/svn.simple 有一个md5加密后的文件，应该就是那个所谓的账号密码保存文件了，删掉之后重新SVN要求输入密码了。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>subversion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MAMP PRO 3.0.5 在 OS X EI Capitan下无法启动的问题]]></title>
    <url>%2F2015%2F11%2F13%2Fmamp-pro-can-not-launch.html</url>
    <content type="text"><![CDATA[网上找了很多文章，什么关闭自带的apache服务，查看系统日志等等，全没用。真佩服 baidu。还是google到了一篇文章，解决方法很简单:1.打开终端2.执行 12cd /Applications/MAMP/Library/bin/mv envvars _envvars 3.enjoy]]></content>
      <categories>
        <category>mamp</category>
      </categories>
      <tags>
        <tag>apache</tag>
        <tag>mamp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端滚动加载问题]]></title>
    <url>%2F2015%2F10%2F23%2Fmobile-scroll-load.html</url>
    <content type="text"><![CDATA[去年写过一篇摆脱jquery!angularjs利用指令简单实现滚动翻页，但是用了一段时间之后发现很多浏览器有问题，移动端下滚动事件只有body才会触发，其他元素是不会触发的，经过改进后的指令代码如下（仅限移动端）: 123456789101112app.directive('whenScrolled', function() &#123; return function (scope, ele, attr) &#123; angular.element(window).on('scroll', function (e) &#123; var a = window.screen.availHeight; var b = document.documentElement.scrollTop == 0 ? document.body.scrollTop : document.documentElement.scrollTop; var c = document.documentElement.scrollTop == 0 ? document.body.scrollHeight : document.documentElement.scrollHeight; if (a + b &gt;= c) &#123; scope.$apply(attr.scrollLoad); &#125; &#125;); &#125;;&#125;);]]></content>
      <categories>
        <category>angularjs</category>
      </categories>
      <tags>
        <tag>lazy-load</tag>
        <tag>scroll</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php实现扫描二维码登录网站]]></title>
    <url>%2F2015%2F09%2F17%2Fphp-qrcode-login.html</url>
    <content type="text"><![CDATA[扫描二维码登录对于现在的web应用来说，确实是个很炫酷的功能，安全性也可以保障，不少朋友可能觉得这是个很复杂的工作，其实不然，真正说来只有几个步骤而已。 原理 PC浏览器展示一张二维码图片，该图片二维码值为一段绝对地址的url，大致如下：http://www.example.com/oauth/qrcode?key=key PC浏览器定期轮询 http://www.example.com/oauth/query，可能有的同学会问，怎么不用带上key？这里我们用session来保存key，所以链接中不用带上key，将这个key作为服务端的缓存key且值为空，如果该缓存值为空，证明没被扫描，继续轮询，如果已经被扫描，展示扫描结果。 手机微信扫描之后会直接访问http://www.example.com/oauth/qrcode?key=key，这里我们先把这个key保存的session中（这个session和2中的不同，一个是PC，一个是手机）。然后检测用户在手机端是否登录，如果已登录，则把用户信息存到2中的key缓存中，这时候前端查询的时候就会有值了。如果用户在手机未登录，则直接跳转微信登录，登陆成功之后再将用户信息设置到2中的key缓存 demohttp://www.lizhiclub.com/]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>qrcode</tag>
        <tag>login</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angularjs ng-options第一个选项为空的解决方案]]></title>
    <url>%2F2015%2F09%2F02%2Fangularjs-ng-options-first-option-empty.html</url>
    <content type="text"><![CDATA[angularjs的ng-options渲染到页面上的时候结构大致是这样的。 1234&lt;select&gt; &lt;option value=""&gt;&lt;/option&gt; &lt;option value="1"&gt;北京&lt;/option&gt;&lt;/select&gt; 这样会导致select第一行为空，用户体验很差。所以改造后的代码如下 1234&lt;select&gt; &lt;option value="" selected hidden&gt;&lt;/option&gt; &lt;option value="1"&gt;北京&lt;/option&gt;&lt;/select&gt; 这样就可以避免第一行的空行了。配合绝对定位以及加个div，可以做个很好看的下拉列表样式。]]></content>
      <categories>
        <category>angularjs</category>
      </categories>
      <tags>
        <tag>angularjs</tag>
        <tag>ng-options</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS函数不同执行环境下的this指向]]></title>
    <url>%2F2015%2F08%2F20%2Fjs-function-this-scope.html</url>
    <content type="text"><![CDATA[先来看一段代码 1234567891011121314var length = 10;function fn() &#123; console.log(this.length);&#125;var obj = &#123; length: 5, method: function(fn) &#123; fn(); arguments[0](); &#125;&#125;;obj.method(fn,1); 猜猜输出结果？ 浏览器环境12102 为什么输出10？执行过程大致如下： obj.method这是个obj对象的方法，而传入的fn是个函数，fn()属于调用模式的”函数调用”，非严格模式下，this为global对象（浏览器中就是window）。而在这段代码的最上方使用var定义了length，由于var是直接写在global作用域中的，所以此处的 var length 与 window.length是同一个东西。输出10也就不奇怪了。 为什么输出2？arguments这个是在函数内部才有的参数，很像array，而且typeof得到的也是object值，我们知道，js访问对象有 . 操作符 和 中括号操作符，此处使用的是第二种方法获取到obj.method的第一个参数，也就是fn.由于arguments0是输入调用方式中的“方法调用模式”,this指向对象本身，也就是arguments，所以会输出2。 NodeJs环境12undefined2 为什么输出undefined？nodejs的global处理机制不同 global贯穿与nodejs整合生命周期，而每个js文件是单独的模块，就算使用var定义在顶层，也只是这个module的全局变量。所以会输出undefined。 为什么输出2？同浏览器。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php-fpm sock文件权限问题导致502]]></title>
    <url>%2F2015%2F08%2F14%2Fphp-fpm-permission-502-bad-gateway.html</url>
    <content type="text"><![CDATA[今天升级完PHP出现了502 Bad Gateway错误，根据经验是php-fpm的问题，但是看到网上那些什么访问量，子进程设置什么的，但是我这太服务器压根没啥流量。所以只能从配置文件下手看看。 php-fpm.conf123456789101112131415[global]pid = /usr/local/php/var/run/php-fpm.piderror_log = /usr/local/php/var/log/php-fpm.loglog_level = notice[www]listen = /tmp/php-cgi.sockuser = wwwgroup = wwwpm = dynamicpm.max_children = 20pm.start_servers = 2pm.min_spare_servers = 1pm.max_spare_servers = 6request_terminate_timeout = 100 看到 /tmp/php-cgi.sock 直觉发现应该是个文件，所以前往该目录查看权限，发现文件属主是root:root，而我的nginx和php-fpm进程是以www用户运行的。所以应该是权限问题。而配置文件中的user = www,group = www也设置了一个权限，通过 ps -aux|grep php 发现，这是php-fpm进程的属主。知道问题的源头后便开始查php-fpm的配置，查到了 listen.ower listen.group 设置。这是改进之后的文件： 1234567891011121314151617[global]pid = /usr/local/php/var/run/php-fpm.piderror_log = /usr/local/php/var/log/php-fpm.loglog_level = notice[www]listen = /tmp/php-cgi.socklisten.owner = wwwlisten.group = wwwuser = wwwgroup = wwwpm = dynamicpm.max_children = 20pm.start_servers = 2pm.min_spare_servers = 1pm.max_spare_servers = 6request_terminate_timeout = 100]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>502</tag>
        <tag>php-fpm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angularjs 用户认证解决方案]]></title>
    <url>%2F2015%2F07%2F29%2Fangularjs-authorization-solution.html</url>
    <content type="text"><![CDATA[作为一个全栈ajax的mvvm框架，angularjs可谓如火如荼，可真正做到全栈ajax，首要面对的问题就是用户身份验证。本文的身份验证不采用cookie,而采用基于http Authorize 请求头的方式验证用户，此方式能做到永远只有一个用户同时在线（服务端同一时间只会接受一个合法的token请求，其他的请求返回401）。 Service123456789101112app.factory('Authorize', function() &#123; return &#123; uid: '', token: '', logout: function() &#123; this.uid = ''; this.token = ''; localStorage.removeItem('authorize.uid'); localStorage.removeItem('authorize.token'); &#125; &#125;&#125;); 由于service是单例的。保存在service很合适，再看登录检测。 验证流程 app运行时主动读取localStorage中的authorize.uid和authorize.token字段，将这两个字段发送至后端接口验证，如果验证成功返回用户信息，验证失败返回http 401错误（未授权）。 如果localStorage没有上述两个字段，则检测url中是否有，如果有则写入本地localStorage之后发送至后端验证，如果没有，跳转至后端服务器的oauth接口进行授权拿之后，将openid和token写入queryString并回调到app页面，代码如下： 12345678910111213141516171819Authorize.uid = $location.search().uid || localStorage.getItem('authorize.uid');Authorize.token = $location.search().token || localStorage.getItem('authorize.token');if (!Authorize.uid || !Authorize.token) &#123; if (!Platform.isWechat) &#123; Authorize.uid = 1001; Authorize.token = '2ddha3nry8'; &#125; else &#123; location.href = CONFIG.api + '/auth/oauth?callback=' + encodeURIComponent($location.protocol() + "://" + $location.host() + ":" + $location.port() + "/#" + $location.path()); return; &#125;&#125;//写入本地localStorage.setItem('authorize.uid', Authorize.uid);localStorage.setItem('authorize.token', Authorize.token);//读取用户数据var user = User.get(&#123;uid: Authorize.uid&#125;, function() &#123; $rootScope.user = user;&#125;); 读取用户数据这边，采用的$resource服务封装，这里就不说了。 请求过程中的授权处理接下来是比较重要的一点，如何在登陆后在每次请求头中注入Authorize信息，方法是采用拦截器。有一个问题，如果由于刷新过快，检测用户回调还没执行完，这时候访问所有接口都是401，这里就需要在$httpProvider上注入拦截器进行请求恢复了。代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546app.factory('AuthInjector', function($q, Authorize, $injector, CONFIG) &#123; return &#123; request: function(config) &#123; if (Authorize.token) &#123; config.headers.Authorization = 'Bearer ' + Authorize.token; &#125; return config; &#125;, response: function(response) &#123; var defer = $q.defer(); defer.resolve(response); return defer.promise; &#125;, responseError: function(error) &#123; //如果401且本地存在uid，则刷新accessToken if (error.status == 401) &#123; //刷新请求 var $http = $injector.get("$http"); $http(&#123; method: 'GET', url: CONFIG.api + '/auth/token', params: &#123; uid: Authorize.uid &#125; &#125;).success(function(data) &#123; Authorize.token = data.token; //写入本地 localStorage.setItem('authorize.token', data.token); return $http(error.config); &#125;); &#125; else if (error.status == 422) &#123; var resp; angular.forEach(error.data, function(item) &#123; if (resp == undefined) &#123; resp = item; &#125; &#125;); return $q.reject(resp); &#125; return $q.reject(&#123; message: '请求失败' &#125;); &#125; &#125;&#125;); 原理就是所有的http请求一旦返回401就进行重新登录请求，最后一句 1return $http(error.config); 会将之前报401错误的请求恢复并重新执行一遍。 大体就是这么多，总结一下就是： app.run中检测登录。 Authorize服务保存用户信息。 httpProvider中注入拦截器实现Authorize头的自动添加和401结果的请求恢复。]]></content>
      <categories>
        <category>angularjs</category>
      </categories>
      <tags>
        <tag>angularjs</tag>
        <tag>authorize</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angularjs集成requirejs]]></title>
    <url>%2F2015%2F07%2F22%2Fdevelopment-angularjs-app-with-requirejs.html</url>
    <content type="text"><![CDATA[angularjs自带的模块话机制对于业务逻辑的组织确实起到了规范化的作用，但是对于大型web项目，弊端也出来了，一次性加载所有的资源会导致进入应用的时间变长，而实际上，首页需要加载的并不多，所以，本文将介绍如何使用requireJs与angularJs集成。 依赖 jquery(非必须) angularjs ui-router requirejs 入口文件我们知道，使用requireJs之后，在首页只需使用script标签加载requirejs即可，剩下的文件加载需要配置下入口文件。 123456789101112131415161718192021222324252627282930/** * @author xialei &lt;xialeistudio@gmail.com&gt; */require.config(&#123; baseUrl: 'app', paths: &#123; "angular": "/vendor/angular/angular", "ui-router": "/vendor/ui-router/release/angular-ui-router", "jquery": "/vendor/jquery/dist/jquery" &#125;, shim: &#123; "angular": &#123; exports: "angular", deps: ["jquery"] &#125;, "ui-router": &#123; exports: "ui-router", deps: ["angular"] &#125;, "jquery": &#123; exports: "jquery" &#125; &#125;&#125;);require(["jquery", "angular", "app","router","controllers"], function($, angular) &#123; $(function() &#123; angular.bootstrap(document, ["app"]); &#125;);&#125;); vendor是依赖的库，路径可以根据实际情况进行修改。angularjs的代码组织方式不是amd规范的，所以需要使用shim将其暴露出来供其他模块使用。由于采用了requireJs，所以不能直接写 angular.module(‘xx’,[])这种代码了。因为依赖的库有可能没下载完成。 app.js1var app = angular.module("app", ["ui.router"]); 使用requireJs之后，这种就行不通了，因为amd开发方式下，一切皆模块。而app作为“根模块”是需要给其他模块（controller,directive,etc…）使用的，所以模块定义的最后需要return。 12345var app = angular.module("app", ["ui.router"]);define(["angular","ui-router"], function(angular) &#123; var app = angular.module("app", ["ui.router"]); return app;&#125;); 这样，其他需要依赖app模块的模块就可以使用该“根模块了”。 controllers.js1234567define(["app"], function(app) &#123; app.controller("HomeCtrl", ["$scope", function($scope) &#123; $scope.run = function() &#123; console.log('run'); &#125;; &#125;]);&#125;); controllers是依赖app模块的，所以这里引入app依赖，其他代码与之前一样。 router.js之前一直使用angular-router,但是永久之后发现还是ui-router好用，这里使用ui-router作为路由管理库。 1234567891011121314define(["app"], function(app) &#123; app.config(['$stateProvider', '$urlRouterProvider', function($stateProvider, $urlRouterProvider) &#123; $stateProvider.state('index', &#123; url:"/", views: &#123; "main": &#123; templateUrl: "app/templates/home.html", controller: "HomeCtrl" &#125; &#125; &#125;); $urlRouterProvider.otherwise('/'); &#125;]);&#125;); index.html123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Angularjs+RequireJs&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div ui-view="main"&gt;&lt;/div&gt;&lt;script src="/vendor/requirejs/require.js" data-main="main"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 相比于之前写很多script标签，这里只需要写一个，是不是“清爽”了很多呢？ demodemo，打开之后只有一个”run”的按钮，请大家打开控制台之后点击按钮即可。]]></content>
      <categories>
        <category>angularjs</category>
      </categories>
      <tags>
        <tag>angularjs</tag>
        <tag>requirejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端input和textarea宽度不一致的问题]]></title>
    <url>%2F2015%2F07%2F05%2Finput-textarea-width-not-same-on-mobile-phone.html</url>
    <content type="text"><![CDATA[今天在做写一个IOS端的表单时，尽管input,textarea设置了宽度，结果发现真机浏览的时候发现宽度不一致，有图为证 css12345678910input,textarea &#123; border-radius: 4px; border: 1px solid #4f4f4f; font-size: 24px; background: none; outline: 0; width: 283px; -webkit-box-shadow: 0 0 4px rgba(0, 0, 0, .4);&#125; 在PC版的chrome发现textarea有默认的padding属性，估计是这个问题，加上padding:0;之后，宽度一致了。]]></content>
      <categories>
        <category>front-end</category>
      </categories>
      <tags>
        <tag>mobile</tag>
        <tag>front-end</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angularjs指令实现radioGroup]]></title>
    <url>%2F2015%2F06%2F30%2Fangularjs-radio-group-directive.html</url>
    <content type="text"><![CDATA[angularjs的指令系统其实也是很强大的东西，扩展了HTML的表现力。本文讲的是如何用angularjs指令实现radioGroup，自带的radio只能控制ngModel的两种状态: true/false。 指令代码123456789101112131415161718192021222324252627module.directive('radio', [function() &#123; return &#123; transclude: true, replace: true, template: '&lt;div class="ui ui-radio"&gt;&lt;span class="radio-item"&gt;&lt;/span&gt;&lt;span ng-transclude="" class="common-color"&gt;&lt;/span&gt;&lt;/div&gt;', require: 'ngModel', link: function(scope, ele, attrs, ctrl) &#123; ctrl.$render = function() &#123; if(ctrl.$viewValue == attrs.value) &#123; //jqLite不支持siblings方法，如果此段代码无效，请使用zepto实现 ele.parent().children().removeClass("active"); ele.addClass("active"); &#125; &#125;; ele.bind("click", function() &#123; ctrl.$setViewValue(attrs.value); ele.addClass("active"); var childrens = ele[0].parentNode.children; for(var i = 0; i &lt; childrens.length; i++) &#123; if(childrens[i] != ele[0]) &#123; angular.element(childrens[i]).removeClass("active"); &#125; &#125; &#125;); &#125; &#125;;&#125;]); 123456789101112131415161718192021222324252627282930.ui &#123; &amp;-radio &#123; &amp;.active &#123; .radio-item:after &#123; display: block; width: 19px; height: 19px; content: ' '; position: absolute; border-radius: 50%; left: (35px-19)/2; top: (35px-19)/2; background: #d14db7; &#125; &#125; .radio-item &#123; width: 35px; height: 35px; border-radius: 50%; position: relative; background: white; display: inline-block; vertical-align: middle; margin: 0; &#125; span &#123; margin-left: 12px; &#125; &#125;&#125; HTML123456&lt;div ng-init="answer='A'" class="options container-fluid wrapper"&gt; &lt;div radio="" ng-model="answer" value="A"&gt;A. &lt;/div&gt; &lt;div radio="" ng-model="answer" value="B"&gt;B. &lt;/div&gt; &lt;div radio="" ng-model="answer" value="C"&gt;C. &lt;/div&gt; &lt;div ng-if="questions[index].option_d" radio="" ng-model="answer" value="D"&gt;D. &lt;/div&gt;&lt;/div&gt; 效果]]></content>
      <categories>
        <category>angularjs</category>
      </categories>
      <tags>
        <tag>angularjs</tag>
        <tag>radio-group</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lnmp一键安装memcached的shell脚本]]></title>
    <url>%2F2015%2F05%2F29%2Fshell-to-install-memached-on-lnmp.html</url>
    <content type="text"><![CDATA[通过LNMP安装脚本安装的PHP环境默认是不带Memcached支持的（是memcached不是memcache），百度一下memcached的安装方法，发现基本都是memcache的，其实这是两个不同的东西。 而memcached是pecl的项目，所以需要到pecl网站上去下载最新的memcached安装包。 为了方便多台服务器的安装，本人整理成了一个sh脚本进行安装，当然,php-config路径和phpize路径需要改下（如果使用LNMP脚本安装的话则不用改） 123456789101112#!/bin/bashwget https://launchpad.net/libmemcached/1.0/0.53/+download/libmemcached-0.53.tar.gztar xvfz libmemcached-0.53.tar.gzcd libmemcached-0.53./configure --prefix=/usr/local/libmemcached --enable-saslmake &amp;&amp; make installwget http://pecl.php.net/get/memcached-2.0.0.tgztar zvxf memcached-2.0.0.tgzcd memcached-2.0.0/phpize./configure --enable-memcached --with-php-config=/usr/local/php/bin/php-config --with-libmemcached-dir=/usr/local/libmemcached --enable-memcached-saslmake &amp;&amp; make install]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>php</tag>
        <tag>lnmp</tag>
        <tag>memcached</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux运行dos格式脚本导致的bad interpreter]]></title>
    <url>%2F2015%2F05%2F21%2Fshell-bad-interpreter.html</url>
    <content type="text"><![CDATA[问题在使用php作为linux上shell脚本运行时出现了以下错误： 123#!/usr/bin/env php&lt;?phpphpinfo(); 123chmod +x test.php./test.php/usr/local/php/bin/php^M: bad interpreter: No such file or directory 原因是你的文本以DOS文件形式保存，导致文件头有不可见字符，导致bash shell无法解析。 解决办法12yum install dos2unix -ydos2unix test.php 再执行就没问题了]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[svg制作loading]]></title>
    <url>%2F2015%2F05%2F17%2Fsvg-loading.html</url>
    <content type="text"><![CDATA[还在使用gif做loading效果吗？你确实out了，再不济也得用css3动画是不是–。无奈，css3旋转动画需要一张png图片来做，也没什么问题，现在，有更炫酷的方案了。没错!就是SVG。svg其实不是什么新东西。SVG 于 2003 年 1 月 14 日成为 W3C 推荐标准。现在浏览器越来越强大，所以，尽情使用吧！ 代码123456789101112131415161718&lt;div style="width: 200px;height: 200px;background: #000000"&gt; &lt;svg width="100%" height="100%" version="1.1" xmlns="http://www.w3.org/2000/svg"&gt; &lt;g&gt; &lt;circle cx="100" cy="100" r="50" fill="none" stroke-width="2" stroke="rgba(255,255,255,0.2)"/&gt; &lt;path d="M100 50 A50 50 0 0 1 150 100 " style="stroke: rgba(255,255,255,.7);stroke-width: 2"/&gt; &lt;animateTransform attributeName="transform" fill="freeze" attributeType="XML" type="rotate" from="0,100,100" to="360,100,100" dur="1s" repeatCount="indefinite" /&gt; &lt;/g&gt; &lt;/svg&gt;&lt;/div&gt; 效果]]></content>
      <tags>
        <tag>loading</tag>
        <tag>svg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php文件缓存类]]></title>
    <url>%2F2015%2F04%2F13%2Fphp-filecache.html</url>
    <content type="text"><![CDATA[缓存有很多方法，memcache,databse,file,redis等等，原理都差不多，简要介绍一下，写入缓存就不多说了，主要是读取缓存。 检测指定key是否存在，如不存在则返回false。 检测指定key是否过期，如过期则返回false。 指定key存在且未过期，返回缓存值。 本文介绍文件缓存的实现，其他类型可以参照实现。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;?php/** * @project wechatPublicPlatform * @date 2015-4-13 * @author xialei &lt;xialeistudio@gmail.com&gt; */class Cache&#123; function __construct() &#123; throw new Exception('不可被实例化'); &#125; /** * 设置缓存 * @param string $key * @param string $value * @param int $expires 0为不过期 * @return int */ public static function set($key, $value, $expires = 0) &#123; $cachePath = __DIR__ . '/cache'; if (!is_dir($cachePath)) &#123; mkdir($cachePath, 666); &#125; $data = [ 'key' =&gt; $key, 'value' =&gt; $value, 'expires' =&gt; $expires ]; return file_put_contents($cachePath . '/' . md5($key), json_encode($data, JSON_UNESCAPED_UNICODE)); &#125; /** * 获取缓存 * @param string $key * @return bool */ public static function get($key) &#123; $cacheFile = __DIR__ . '/cache/' . md5($key); //检测是否存在 if (!is_file($cacheFile)) &#123; return false; &#125; //检测是否过期 $data = json_decode(file_get_contents($cacheFile), true); //获取最近修改时间 $mtime = filemtime($cacheFile); if (time() &gt; $mtime + $data['expires']) &#123; unlink($cacheFile); return false; &#125; return $data['value']; &#125; /** * 删除缓存 * @param string $key * @return bool */ public static function delete($key) &#123; $cacheFile = __DIR__ . '/cache/' . md5($key); if (is_file($cacheFile)) &#123; return unlink($cacheFile); &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>cache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带进度条的angularjs上传指令]]></title>
    <url>%2F2015%2F04%2F09%2Fangularjs-upload-directive-with-progress.html</url>
    <content type="text"><![CDATA[项目地址https://git.coding.net/xialei/xl-angular-upload.git 效果图 指令代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263angular.module('xl-angular-upload', []) .directive('angularUpload', [function () &#123; return &#123; restrict: 'E', require: 'ngModel', template: '&lt;div class="xl-angular-upload"&gt;\n &lt;!--upload button--&gt;\n &lt;button class="xl-btn btn-primary"&gt;上传\n &lt;input type="file"/&gt;\n &lt;/button&gt;\n &lt;!--upload queue--&gt;\n &lt;div class="queue"&gt;\n &lt;div class="item" ng-repeat="item in queue"&gt;\n &lt;div class="info"&gt;\n &lt;div class="no"&gt;&#123;&#123;$index+1&#125;&#125;&lt;/div&gt;\n &lt;div class="name"&gt;&#123;&#123;item.name&#125;&#125;&lt;/div&gt;\n &lt;div class="size"&gt;&#123;&#123;(item.size/1024).toFixed(2)&#125;&#125;KB&lt;/div&gt;\n &lt;/div&gt;\n &lt;div class="process-bar"&gt;\n &lt;div class="process" style="width:&#123;&#123;item.process&#125;&#125;%"&gt;&lt;/div&gt;\n &lt;/div&gt;\n &lt;/div&gt;\n &lt;/div&gt;\n&lt;/div&gt;', replace: true, link: function (scope, ele, attrs, ctrl) &#123; //必要属性检测 if (!attrs.action) &#123; throw new Error('请设置上传action'); &#125; //初始化 scope.queue = []; var file = angular.element(document.querySelector('.xl-angular-upload&gt;.xl-btn&gt;input[type="file"]')); var files = []; attrs.accept &amp;&amp; file.attr('accept', attrs.accept); attrs.multiple &amp;&amp; file.attr('multiple', attrs.multiple); file.bind("change", function (e) &#123; scope.$apply(function () &#123; scope.queue = []; for (var i in e.target.files) &#123; if (/^\d+$/.test(i)) &#123; e.target.files[i].process = 0; scope.queue.push(e.target.files[i]); &#125; &#125; &#125;); //准备上传 scope.queue.forEach(function (item) &#123; var data = new FormData; data.append(attrs.name || 'file', item); var xhr = new XMLHttpRequest(); xhr.open('POST', attrs.action, true); //事件监听 xhr.onreadystatechange = function () &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; //上传完成了 var resp = JSON.parse(xhr.responseText); if (resp.error) &#123; throw new Error(resp.error); &#125; else &#123; files.push(resp); ctrl.$setViewValue(files); &#125; &#125; &#125;; xhr.onerror = function (error) &#123; throw new Error(error); &#125;; xhr.upload &amp;&amp; (xhr.upload.onprogress = function (e) &#123; if (e.lengthComputable) &#123; scope.$apply(function () &#123; item.process = parseInt((e.loaded / e.total) * 100); &#125;); &#125; &#125;); xhr.send(data); &#125;); &#125;); &#125; &#125; &#125;]); HTML代码123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html ng-app="app"&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;title&gt;AngularToggle&lt;/title&gt; &lt;link rel="stylesheet" href="angular-upload.css"/&gt; &lt;style&gt; * &#123; font-family: Consolas, "Microsoft Yahei", arial, sans-serif; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body ng-controller="MainCtrl"&gt;&lt;div style="width: 400px"&gt; &lt;angular-upload action="upload.php" name="file" accept="image/*" multiple="true" ng-model="files"/&gt;&lt;/div&gt;&lt;script src="http://cdn.bootcss.com/angular.js/1.3.15/angular.min.js"&gt;&lt;/script&gt;&lt;script src="angular-upload.js"&gt;&lt;/script&gt;&lt;script&gt; (function () &#123; "use strict"; angular.module('app', [ 'xl-angular-upload' ]).controller('MainCtrl', ['$scope', function ($scope) &#123; $scope.$watch('files', function (n, o) &#123; console.log(n); &#125;); &#125;]); &#125;)();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; CSS代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384.xl-angular-upload .xl-btn &#123; color: #666; background-color: #EEE; border-color: #EEE; font-weight: 300; font-size: 16px; font-family: "Consolas", "Microsoft YaHei", Arial, arial, sans-serif; text-decoration: none; text-align: center; line-height: 40px; height: 40px; padding: 0 40px; margin: 0; display: inline-block; appearance: none; cursor: pointer; border: none; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box; -webkit-transition-property: all; transition-property: all; -webkit-transition-duration: .3s; transition-duration: .3s; border-radius: 4px; -webkit-border-radius: 4px; -moz-border-radius: 4px; position: relative;&#125;.xl-angular-upload .xl-btn.btn-primary &#123; background-color: #7B72E9; border-color: #7B72E9; color: #FFF;&#125;.xl-angular-upload .xl-btn.btn-primary:hover &#123; background-color: #a49ef0; border-color: #a49ef0; color: #FFF;&#125;.xl-angular-upload .xl-btn input[type="file"] &#123; position: absolute; width: 100%; height: 100%; left: 0; top: 0; opacity: 0;&#125;.xl-angular-upload .queue &#123; width: 100%;&#125;.xl-angular-upload .queue .item &#123; margin-top: 4px;&#125;.xl-angular-upload .queue .item &gt; .info .no &#123; float: left; width: 10%; text-align: center;&#125;.xl-angular-upload .queue .item &gt; .info .name &#123; float: left; width: 70%;&#125;.xl-angular-upload .queue .item &gt; .info .size &#123; float: right; width: 20%;&#125;.xl-angular-upload .queue .item &gt; .info:after &#123; content: ' '; display: block; clear: both;&#125;.xl-angular-upload .queue .item &gt; .process-bar &#123; width: 100%; height: 4px; margin-top: 4px;&#125;.xl-angular-upload .queue .item &gt; .process-bar .process &#123; transition: all .2s; -webkit-transition: all .2s; -moz-transition: all .2s; height: 100%; width: 0; background: #7B72E9;&#125; 本指令的难点在于进度条的更新及ngModel数据的双向绑定，其实，只要在指令中require”ngModel”之后，利用$setViewValue方法和$render方法就可以了。而进度条的处理是由于双向绑定中列表的每个元素都是一个单独的对象，更新该对象的值不会影响其他上传，即每个上传都是单独的进度条。]]></content>
      <categories>
        <category>angularjs</category>
      </categories>
      <tags>
        <tag>angularjs</tag>
        <tag>upload</tag>
        <tag>progress</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在AngularJS中使用$q进行“同步”编程]]></title>
    <url>%2F2015%2F04%2F06%2Fangularjs-q.html</url>
    <content type="text"><![CDATA[今天群里有位朋友问到直接返回$http说读不到数据，原因在于$http是异步请求，而且是“不可期”的，你不知道什么时候这个请求完成了。 而对于这种需要“同步”编程的方式，AngularJS提供了一个内置Service $q，它提供了一种承诺/延后（promise/deferred），可以保证我们的调用代码一定能够拿到数据。所以我们用起来可以像同步调用一样，话说回来，最终还是xhr异步请求。 ## Factory 123456789101112131415app.factory('itemService', ['$http', '$q', function ($http, $q) &#123; return &#123; query : function() &#123; var deferred = $q.defer();//声明承诺 $http(&#123;method: 'GET', url: '/item/list'&#125;). success(function(data) &#123; deferred.resolve(data);//请求成功 &#125;). error(function(data) &#123; deferred.reject(data); //请求失败 &#125;); return deferred.promise; // 返回承诺，这里返回的不是数据，而是API &#125; &#125;; &#125;]); Controller123456789angular.module('app') .controller('MainCtrl', ['itemService','$scope', function (itemService,$scope) &#123; // 注入itemService var promise = itemService.query(); //获得承诺接口 promise.then(function(data) &#123; // 成功回调 $scope.user = data; &#125;, function(data) &#123; // 错误回调 console.log('请求失败'); &#125;); &#125;]); 文档地址http://docs.angularjs.org/api/ng.$q]]></content>
      <categories>
        <category>angularjs</category>
      </categories>
      <tags>
        <tag>angularjs</tag>
        <tag>$q</tag>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angularjs Hello World]]></title>
    <url>%2F2015%2F04%2F06%2Fangularjs-hello-world.html</url>
    <content type="text"><![CDATA[几乎所有的编程入门都是以”Hello World”开始的，这里也不例外。 HTML代码1234567891011121314&lt;!DOCTYPE html&gt;&lt;!--使用ng-app指令“告诉”ng从哪里开始编译--&gt;&lt;html ng-app="app"&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Hello World - Angularjs&lt;/title&gt; &lt;script src="../vendor/angularjs/angular.js"&gt;&lt;/script&gt; &lt;script src="main.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;/p&gt;&lt;input type="text" ng-model="message" placeholder="说点什么"/&gt;&lt;/body&gt;&lt;/html&gt; JS代码12345/** * @author xialei &lt;xialeistudio@gmail.com&gt; */var app = angular.module('app',[]); 双向绑定为ng内置，所以这里的js，实际上只有一个app定义罢了。在输入框中输入任何字符都会及时在其之前的p元素显示出来。]]></content>
      <categories>
        <category>angularjs</category>
      </categories>
      <tags>
        <tag>angularjs</tag>
        <tag>hello world</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angularjs概念解释]]></title>
    <url>%2F2015%2F04%2F06%2Fangularjs-concept%20to%20explain.html</url>
    <content type="text"><![CDATA[本文将根据项目进度不定期更新 本文所有内容仅代表个人观点 ngAngularjs的简称。 指令(Directive)特殊的html标签或html属性，扩展了html的功能。有以下几类： E Element 元素 如 就是一个自定义指令（如何自定义指令，将在后面的文章中介绍），名称为”dropdown”。 A Attribute 属性 如 这是最常用的指令了，ng-app为指令名称，也是html元素的属性，app为该属性的值 作用域(scope)ng中变量、方法都是基于作用域的，作用类似于js作用域。 ng-bindhtml输出js变量，跟作用域绑定，message为作用域中的一个变量。示例代码： 1&lt;button ng-bind="message"&gt;&lt;/button&gt; 最终会显示同一scope下的message变量值。 ng-model双向绑定指令，示例代码： 1&lt;input type="text" ng-model="message"/&gt; 表明将input的值与作用域中的message变量进行绑定，当input值改变的时候，变量message跟着改变，html中输出的内容也会同步改变。]]></content>
      <categories>
        <category>angularjs</category>
      </categories>
      <tags>
        <tag>Concept to explain</tag>
        <tag>get-started</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用gulp来构建你的前端自动化工作流]]></title>
    <url>%2F2015%2F03%2F16%2Fgulp-workflow.html</url>
    <content type="text"><![CDATA[之前用的Grunt，不过有时候Grunt确实用起来不爽，进来找到一款叫gulp.js的前端构建工具，当然，也是基于node.js的。 安装12npm install gulp --save-devnpm install del gulp-concat gulp-cssmin gulp-uglify --save-dev 配置配置gulpfile.js，如果工作目录下没有该文件，请新建gulpfile.js，以下为一个常用的参考代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/** * @author xialei &lt;xialeistudio@gmail.com&gt; */(function () &#123; "use strict"; /** * 加载插件 * @type &#123;exports&#125; */ var gulp = require('gulp'); var del = require('del'); var cssmin = require('gulp-cssmin'); var concat = require('gulp-concat'); var uglify = require('gulp-uglify'); /** * 清空目录的命令 */ gulp.task('clean', function () &#123; del(['build']); &#125;); gulp.task('css', function () &#123; /** * 加载源代码 */ return gulp.src([ 'bower_components/bootstrap/dist/css/bootstrap.min.css', 'bower_components/font-awesome/css/font-awesome.min.css', 'css/style.css' ]) /** * 压缩css */ .pipe(cssmin()) /** * 连接压缩后的css */ .pipe(concat('style.css')) /** * 输出到目标目录 */ .pipe(gulp.dest('build/css')) &#125;); gulp.task('js', function () &#123; return gulp.src([ /** * 加载源代码 */ 'bower_components/angular/angular.min.js', 'bower_components/angular-sanitize/angular-sanitize.min.js', 'js/main.js']) /** * 压缩Js */ .pipe(uglify()) /** * 合并js */ .pipe(concat('main.js')) /** * 输出到目标目录 */ .pipe(gulp.dest('build/js')) &#125;); gulp.task('img', function () &#123; /** * 加载源文件 */ return gulp.src([ 'img/*.*' ]) /** * 输出到目标目录 */ .pipe(gulp.dest('build/img')); &#125;); /** * 定义默认任务，此任务依赖于 clean,img,css,js，所以在执行 * 本任务时会按顺序先执行依赖任务 */ gulp.task('default', ['clean', 'img', 'css', 'js']);&#125;)(); 执行编译1gulp]]></content>
      <categories>
        <category>front-end</category>
      </categories>
      <tags>
        <tag>workflow</tag>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHPExcel导出时列过大的解决方案]]></title>
    <url>%2F2015%2F03%2F07%2Fphpexcel-a-lot-of-column.html</url>
    <content type="text"><![CDATA[今天导出Excel的时候，列不是固定的，而且有差不多几十个，横轴由’A’变为了’AA’，给导出时增加了难度，因为要去算列名称，不过换个方式想一下，发现是很有规律的26进制数。 发现秘诀后就好办了，发一个10进制转26进制的方法。 代码1234567891011private function numberToStr26($n)&#123; $s = ''; while ($n &gt; 0) &#123; $m = $n % 26; if ($m == 0) $m = 26; $s = chr($m + 64) . $s; $n = ($n - $m) / 26; &#125; return $s;&#125; 效果图]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>phpexcel</tag>
        <tag>excel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信公众平台回复乱码问题]]></title>
    <url>%2F2015%2F03%2F06%2Fwechat-reply-messy-code.html</url>
    <content type="text"><![CDATA[很多微信公众平台的自动回复程序都是 ThinkWechat.class.php 这个类开发的，今天碰到一个莫名其妙的乱码问题，查问题发现是GB2312编码导致，所以要修改源码。 先增加一个方法: 123456789/** * 检测是否UTF-8 * @param $str * @return bool */private function is_utf8($str)&#123; return preg_match('//u', $str);&#125; 找到 1$this-&gt;data ['Content'] = $content; 修改为 12345if ($this-&gt;is_utf8($content)) &#123; $this-&gt;data ['Content'] = $content;&#125; else &#123; $this-&gt;data ['Content'] = iconv('gb2312', 'UTF-8//IGNORE', $content);&#125;]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>messy code</tag>
        <tag>wechat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angularjs ueditor指令]]></title>
    <url>%2F2015%2F02%2F05%2Fangularjs-ueditor-directive.html</url>
    <content type="text"><![CDATA[一直以来，angularjs的富文本编辑器都比较难做，主要是第三方的编辑器很难集成进来，今天花时间研究了一下，发现ueditor主要加载两个js文件 ueditor.config.js ueditor.all.js 能不能把这两个文件异步加载呢？答案是肯定的。我们新建一个服务用来异步加载资源，并设置必要的回调方法。 Factory123456789101112131415161718192021222324252627282930313233343536373839services.factory('Common', ['$http', '$q',function($http, $q) &#123; return &#123; loadScript: function(url, callback) &#123; var head = document.getElementsByTagName("head")[0]; var script = document.createElement("script"); script.setAttribute("type", "text/javascript"); script.setAttribute("src", url); script.setAttribute("async", true); script.setAttribute("defer", true); head.appendChild(script); //fuck ie! duck type if (document.all) &#123; script.onreadystatechange = function() &#123; var state = this.readyState; if (state === 'loaded' || state === 'complete') &#123; callback &amp;&amp; callback(); &#125; &#125; &#125; else &#123; //firefox, chrome script.onload = function() &#123; callback &amp;&amp; callback(); &#125; &#125; &#125;, loadCss: function(url) &#123; var ele = document.createElement('link'); ele.href = url; ele.rel = 'stylesheet'; if (ele.onload == null) &#123; ele.onload = function() &#123;&#125;; &#125; else &#123; ele.onreadystatechange = function() &#123;&#125;; &#125; angular.element(document.querySelector('body')).prepend(ele); &#125; &#125;&#125;]); 通过绑定callback到 onload 事件来实现回调。 指令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960directives.directive('ueditor', ['Common', '$rootScope',function(Common, $rootScope) &#123; return &#123; restrict: 'EA', require: 'ngModel', link: function(scope, ele, attrs, ctrl) &#123; $rootScope.$emit('loading', '初始化编辑器...'); //广播loading事件，可以删除 var _self = this, _initContent, editor, editorReady = false, base = '/public/vendor/utf8_qiniu_ueditor-master', //ueditor目录 _id = attrs.ueditor; var editorHandler = &#123; init: function() &#123; window.UEDITOR_HOME_URL = base + '/'; var _self = this; if (typeof UE != 'undefined') &#123; editor = UE.getEditor(_id, &#123; toolbars: [['fontsize', '|', 'blockquote', 'horizontal', '|', 'removeformat', '|', 'insertimage', '|', 'bold', 'italic', 'underline', 'forecolor', 'backcolor', '|', 'justifyleft', 'justifycenter', 'justifyright', 'justifyjustify', 'rowspacingtop', 'rowspacingbottom', 'lineheight', '|', 'insertorderedlist', 'insertunorderedlist', '|', 'link', 'unlink', '|', 'emotion']] &#125;); editor.ready(function() &#123; editor.setHeight(500); editorReady = true; $rootScope.$emit('loading', ''); //编辑器初始化完成 editor.addListener('contentChange', function() &#123; //双向绑定 if (!scope.$$phase) &#123; scope.$apply(function() &#123; ctrl.$setViewValue(editor.getContent()); &#125;); &#125; &#125;); &#125;); &#125; else &#123; Common.loadScript(base + '/ueditor.config.js', null); Common.loadScript(base + '/ueditor.all.min.js', function() &#123; _self.init(); &#125;); &#125; &#125;, setContent: function(content) &#123; if (editor &amp;&amp; editorReady) &#123; editor.setContent(content); &#125; &#125; &#125;; ctrl.$render = function() &#123; _initContent = ctrl.$isEmpty(ctrl.$viewValue) ? '': ctrl.$viewValue; editorHandler.setContent(_initContent); //双向绑定 &#125;; editorHandler.init(); //事件 $rootScope.$on('$routeChangeStart', function() &#123; editor &amp;&amp; editor.destroy(); &#125;); &#125; &#125;&#125;]); 由于angularjs无法自动获得编辑器内容，只能手动监听 contentChange事件来实现双向绑定。 模板代码1&lt;div ueditor="editor" ng-required="true" ng-model="material.content.content" id="editor"&gt;&lt;/div&gt; 效果图]]></content>
      <categories>
        <category>angularjs</category>
      </categories>
      <tags>
        <tag>directive</tag>
        <tag>angularjs</tag>
        <tag>ueditor</tag>
        <tag>rich text editor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于angularjs的在线音乐播放器]]></title>
    <url>%2F2015%2F01%2F30%2Fangularjs-online-music-player.html</url>
    <content type="text"><![CDATA[项目地址https://github.com/xialeistudio/angular-audio-player 在线demohttp://ngdemo.sinaapp.com/audio/ 效果图]]></content>
      <categories>
        <category>open-source-projects</category>
      </categories>
      <tags>
        <tag>angularjs</tag>
        <tag>music player</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android直接挂断电话]]></title>
    <url>%2F2015%2F01%2F29%2Fandroid-hangup-call.html</url>
    <content type="text"><![CDATA[最近在写一个用来发短信的机器人（android),当然需要屏蔽所有来电了。多的话不说了，直接看步骤。（IDE为android studio）：1.在 src/main下新建 aidl 目录。 2.在src/main/aidl下新建包 com.android.internal.telephony。 3.在com.android.internal.telephony新建文件 ITelephony.aidl，内容如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215/* * Copyright (C) 2007 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.android.internal.telephony;import android.os.Bundle;import java.util.List;import android.telephony.NeighboringCellInfo;/** * Interface used to interact with the phone. Mostly this is used by the * TelephonyManager class. A few places are still using this directly. * Please clean them up if possible and use TelephonyManager insteadl. * * &#123;@hide&#125; */interface ITelephony &#123; /** * Dial a number. This doesn't place the call. It displays * the Dialer screen. * @param number the number to be dialed. If null, this * would display the Dialer screen with no number pre-filled. */ void dial(String number); /** * Place a call to the specified number. * @param number the number to be called. */ void call(String number); /** * If there is currently a call in progress, show the call screen. * The DTMF dialpad may or may not be visible initially, depending on * whether it was up when the user last exited the InCallScreen. * * @return true if the call screen was shown. */ boolean showCallScreen(); /** * Variation of showCallScreen() that also specifies whether the * DTMF dialpad should be initially visible when the InCallScreen * comes up. * * @param showDialpad if true, make the dialpad visible initially, * otherwise hide the dialpad initially. * @return true if the call screen was shown. * * @see showCallScreen */ boolean showCallScreenWithDialpad(boolean showDialpad); /** * End call or go to the Home screen * * @return whether it hung up */ boolean endCall(); /** * Answer the currently-ringing call. * * If there's already a current active call, that call will be * automatically put on hold. If both lines are currently in use, the * current active call will be ended. * * TODO: provide a flag to let the caller specify what policy to use * if both lines are in use. (The current behavior is hardwired to * "answer incoming, end ongoing", which is how the CALL button * is specced to behave.) * * TODO: this should be a oneway call (especially since it's called * directly from the key queue thread). */ void answerRingingCall(); /** * Silence the ringer if an incoming call is currently ringing. * (If vibrating, stop the vibrator also.) * * It's safe to call this if the ringer has already been silenced, or * even if there's no incoming call. (If so, this method will do nothing.) * * TODO: this should be a oneway call too (see above). * (Actually *all* the methods here that return void can * probably be oneway.) */ void silenceRinger(); /** * Check if we are in either an active or holding call * @return true if the phone state is OFFHOOK. */ boolean isOffhook(); /** * Check if an incoming phone call is ringing or call waiting. * @return true if the phone state is RINGING. */ boolean isRinging(); /** * Check if the phone is idle. * @return true if the phone state is IDLE. */ boolean isIdle(); /** * Check to see if the radio is on or not. * @return returns true if the radio is on. */ boolean isRadioOn(); /** * Check if the SIM pin lock is enabled. * @return true if the SIM pin lock is enabled. */ boolean isSimPinEnabled(); /** * Cancels the missed calls notification. */ void cancelMissedCallsNotification(); /** * Supply a pin to unlock the SIM. Blocks until a result is determined. * @param pin The pin to check. * @return whether the operation was a success. */ boolean supplyPin(String pin); /** * Handles PIN MMI commands (PIN/PIN2/PUK/PUK2), which are initiated * without SEND (so dial is not appropriate). * * @param dialString the MMI command to be executed. * @return true if MMI command is executed. */ boolean handlePinMmi(String dialString); /** * Toggles the radio on or off. */ void toggleRadioOnOff(); /** * Set the radio to on or off */ boolean setRadio(boolean turnOn); /** * Request to update location information in service state */ void updateServiceLocation(); /** * Enable location update notifications. */ void enableLocationUpdates(); /** */ void disableLocationUpdates(); /** * Enable a specific APN type. */ int enableApnType(String type); /** * Disable a specific APN type. */ int disableApnType(String type); /** * Allow mobile data connections. */ boolean enableDataConnectivity(); /** * Disallow mobile data connections. */ boolean disableDataConnectivity(); /** * Report whether data connectivity is possible. */ boolean isDataConnectivityPossible(); Bundle getCellLocation(); /** * Returns the neighboring cell information of the device. */ List getNeighboringCellInfo(); int getCallState(); int getDataActivity(); int getDataState();&#125; 4.android studio 菜单 Build-&gt;Rebuild project 5.在Activity中注册监听（写在onCreate()） 1234TelephonyManager mTelephonyManager = (TelephonyManager) this .getSystemService(TELEPHONY_SERVICE); mTelephonyManager.listen(phoneStateListener, PhoneStateListener.LISTEN_CALL_STATE); 6.在Activity中新建以下方法以获得telephony的实例 12345678910111213141516171819202122232425262728/** * @param context * @return */ private static ITelephony getITelephony(Context context) &#123; TelephonyManager mTelephonyManager = (TelephonyManager) context .getSystemService(TELEPHONY_SERVICE); Class c = TelephonyManager.class; Method getITelephonyMethod = null; try &#123; getITelephonyMethod = c.getDeclaredMethod("getITelephony", (Class[]) null); // 获取声明的方法 getITelephonyMethod.setAccessible(true); &#125; catch (SecurityException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; try &#123; ITelephony iTelephony = (ITelephony) getITelephonyMethod.invoke( mTelephonyManager, (Object[]) null); // 获取实例 return iTelephony; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; 7.在activity类中建立内部类 123456789101112131415161718192021222324252627282930PhoneStateListener phoneStateListener = new PhoneStateListener() &#123; @Override public void onCallStateChanged(int state, String incomingNumber) &#123; ITelephony iTelephony = getITelephony(MainActivity.this); switch (state) &#123; case TelephonyManager.CALL_STATE_RINGING: iTelephony = getITelephony(getApplicationContext()); //获取电话接口 if (iTelephony != null) &#123; try &#123; iTelephony.endCall(); // 挂断电话 Message msg = new Message(); msg.what = SYS_MSG; msg.obj ="成功挂断["+incomingNumber+"]的电话"; handler.sendMessage(msg); &#125; catch (RemoteException e) &#123; Message msg = new Message(); msg.what = SYS_MSG; msg.obj ="挂断["+incomingNumber+"]的电话失败"; handler.sendMessage(msg); &#125; &#125; break; default: break; &#125; &#125; &#125;;]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>hangup call</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[七牛上传出现 invalid mutilpart format的解决方案]]></title>
    <url>%2F2015%2F01%2F27%2Fphp-qiniu-invalid-mutilpart-format.html</url>
    <content type="text"><![CDATA[今天用umeditor编辑文章上传图片的时候发现一直卡在”loading…”，打开控制台发现出现了500错误，进一步调试发现是七牛上传报错了。 整个上传流程是 浏览器=》业务服务器=》七牛服务器 在上传方法断点调试发现$_FILES数组正常，所以排除了浏览器到业务服务器上传问题，继续调试 通过查看七牛SDK源码发现在 http.php的第119行附近有这样的代码： 1234567891011$options = array( CURLOPT_USERAGENT =&gt; $req-&gt;UA, CURLOPT_RETURNTRANSFER =&gt; true, CURLOPT_SSL_VERIFYPEER =&gt; false, CURLOPT_SSL_VERIFYHOST =&gt; false, CURLOPT_HEADER =&gt; true, CURLOPT_NOBODY =&gt; false, CURLOPT_CUSTOMREQUEST =&gt; 'POST', CURLOPT_URL =&gt; $url['path'], CURLOPT_SAFE_UPLOAD =&gt; false); 请注意最后那个 1CURLOPT_SAFE_UPLOAD =&gt; false 这里应该是跟上传有关的设置，很有可能是这里的问题，果然，GOOGLE发现PHP的CURL上传文件跟PHP版本的关系很大。 传统上，PHP的cURL支持通过在数组数据中，使用“@+文件全路径”的语法附加文件，供cURL读取上传。这与命令行直接调用cURL程序的语法是一致的： 123curl_setopt(ch, CURLOPT_POSTFIELDS, array( 'file' =&gt; '@'.realpath('image.png'), )); 但PHP从5.5开始引入了新的CURLFile类用来指向文件。CURLFile类也可以详细定义MIME类型、文件名等可能出现在multipart/form-data数据中的附加信息。PHP推荐使用CURLFile替代旧的@语法： 123curl_setopt(ch, CURLOPT_POSTFIELDS, [ 'file' =&gt; new CURLFile(realpath('image.png')), ]); PHP 5.5另外引入了CURL_SAFE_UPLOAD选项，可以强制PHP的cURL模块拒绝旧的@语法，仅接受CURLFile式的文件。5.5的默认值为false，5.6的默认值为true。 但是坑的一点在于：@语法在5.5就已经被打了deprecated，在5.6中就直接被删除了（会产生 ErorException: The usage of the @filename API for file uploading is deprecated. Please use the CURLFile class instead）。 对于PHP 5.6+而言，手动设置CURL_SAFE_UPLOAD为false是毫无意义的。根本不是字面意义理解的“设置成false，就能开启旧的unsafe的方式”——旧的方式已经作为废弃语法彻底不存在了。PHP 5.6+ == CURLFile only，不要有任何的幻想。 我的部署环境是5.4(仅@语法)与服务器不同，所以必须写出带有环境判断的代码。 从可靠的角度，推荐指定CURL_SAFE_UPLOAD的值，明确告知php是容忍还是禁止旧的@语法。 注意在低版本PHP中CURLOPT_SAFE_UPLOAD常量本身可能不存在，需要判断： 1234567if (class_exists('\CURLFile')) &#123; curl_setopt($ch, CURLOPT_SAFE_UPLOAD, true);&#125; else &#123; if (defined('CURLOPT_SAFE_UPLOAD')) &#123; curl_setopt($ch, CURLOPT_SAFE_UPLOAD, false); &#125;&#125;]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>qiniu</tag>
        <tag>curl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[console.log在线控制台]]></title>
    <url>%2F2015%2F01%2F26%2Fonline-js-console.html</url>
    <content type="text"><![CDATA[项目已升级，最新版地址如下:js在线调试工具]]></content>
      <categories>
        <category>open-source-projects</category>
      </categories>
      <tags>
        <tag>debug</tag>
        <tag>console</tag>
        <tag>websocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度地图添加自定义标注]]></title>
    <url>%2F2015%2F01%2F24%2Fbaidu-map-custom-overlay.html</url>
    <content type="text"><![CDATA[百度地图的默认标注是一个 红色 的地标，如果要做互动性强的地图应用，几乎没提供什么额外信息，本文教大家怎么添加自定义标注，如添加头像。 JS代码12345678var icon = new BMap.Icon('头像URL地址', new BMap.Size(33, 33), &#123; offset: new BMap.Size(10, 25), imageOffset: new BMap.Size(0, 0)&#125;);markers[i] = new BMap.Marker(new BMap.Point([经度], [纬度]), &#123; icon: icon&#125;);map.addOverlay(markers[i]); 由于百度地图的限制，我们不能获取标注的HTML，只能采取“特别”的方式对头像增加样式，比如圆角，边框等等。 123456789101112var avatarRadiusCompleted = false;var avatarRadius = setInterval(function() &#123; avatarRadius &amp;&amp; clearInterval(avatarRadius); $('#map').find('img').each(function() &#123; var src = $(this).attr('src'); if (src.indexOf('map') == -1) &#123; $(this).addClass('xl-map-avatar'); //.xl-map-avatar 为自定义的CSS &#125; &#125;); avatarRadiusCompleted = true;&#125;,100); CSS代码123456789101112.xl-map-avatar &#123; width: 32px; height: 32px; border: 1px solid white !important; border-top-left-radius: 999px; /* 左上角 */ border-top-right-radius: 999px; /* 右上角 */ border-bottom-right-radius: 999px; /* 右下角 */ border-bottom-left-radius: 999px; /* 左下角 */ border-radius: 50%; background-color: #ccc; background-clip: padding-box;&#125; 效果图]]></content>
      <categories>
        <category>front-end</category>
      </categories>
      <tags>
        <tag>baidu map</tag>
        <tag>overlay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3打造炫酷loading]]></title>
    <url>%2F2015%2F01%2F20%2Fcss3-loading.html</url>
    <content type="text"><![CDATA[css3的优点就不多说了，一个很重要的，节约了带宽，以往需要使用图片的地方很多时候都可以使用CSS3来实现。 本文将带来一个利用CSS3制作loading的教程，这里直接上代码了。 CSS代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990@keyframes spin &#123; 0% &#123; transform: rotate(0deg); -webkit-transform: rotate(0deg); &#125; 100% &#123; transform: rotate(360deg); -webkit-transform: rotate(360deg); &#125;&#125;@-webkit-keyframes spin &#123; 0% &#123; transform: rotate(0deg); -webkit-transform: rotate(0deg); &#125; 100% &#123; transform: rotate(360deg); -webkit-transform: rotate(360deg); &#125;&#125;@keyframes spinoff &#123; 0% &#123; transform: rotate(0deg); -webkit-transform: rotate(0deg); &#125; 100% &#123; transform: rotate(-360deg); -webkit-transform: rotate(-360deg); &#125;&#125;@-webkit-keyframes spinoff &#123; 0% &#123; transform: rotate(0deg); -webkit-transform: rotate(0deg); &#125; 100% &#123; transform: rotate(-360deg); -webkit-transform: rotate(-360deg); &#125;&#125;body &#123; margin: 0;&#125;.content &#123; width: 100px; height: 100px; position: relative; margin: 10% auto 0 auto;&#125;.content .ball &#123; top: 25px; left: 25px; width: 50px; height: 50px; position: absolute; border-radius: 50px; -webkit-border-radius: 50px; border: 5px solid rgba(40,40,200,0.5); border-left: 5px solid rgba(255,255,255,0.7); border-top: 5px solid rgba(255,255,255,0.7); box-shadow: 2px 2px 4px 0 rgba(40,40,200,0.4); animation: spin .5s linear infinite; -webkit-animation: spin .5s linear infinite;&#125;.content .ball1 &#123; top: 35px; left: 35px; width: 30px; height: 30px; position: absolute; border-radius: 30px; -webkit-border-radius: 30px; border: 5px solid rgba(40,40,200,0.8); border-left: 5px solid rgba(255,255,255,1.0); border-top: 5px solid rgba(255,255,255,1.0); box-shadow: 2px 2px 4px 0 rgba(40,40,200,0.4); animation: spinoff .5s linear infinite; -webkit-animation: spinoff .5s linear infinite;&#125; HTML代码1234&lt;div class="content"&gt; &lt;div class="ball"&gt;&lt;/div&gt; &lt;div class="ball1"&gt;&lt;/div&gt;&lt;/div&gt; 总结实现动画有几个关键点： css3 keyframes css position css border 基本就以上问题，代码可以直接新建一个页面，复制打开即可运行]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css3</tag>
        <tag>loading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php利用百度地图API进行IP定位和GPS定位]]></title>
    <url>%2F2015%2F01%2F11%2Fphp-location-by-ipgps-with-baidu-mapapi.html</url>
    <content type="text"><![CDATA[最近在做一个手机端的webapp地图应用，而核心内容当然是定位了，但是定位的话有几种方式，IP定位,GPS定位，基站定位（这个貌似webapp用不了）， 那么剩下核心的gps定位和ip定位了，我们知道，html5有定位API，但是该API拿到的GPS数据是硬件坐标，无法直接显示在地图上。 后来上百度LBS云看到有地图IP定位API和GPS坐标转换API，地址：http://developer.baidu.com/map/ 百度地图API的调用需要申请KEY，这里就不具体介绍了，直接贴上本人写了两个关键方法，为了方便前台调用，返回数据采用以下格式： 12345678910&#123; address: "北京市海淀区西二旗北路", province: "北京市", city: "北京市", street: "西二旗北路", street_number: "", city_code: 131, lng: 116.3207676804, lat: 40.064084055578&#125; PHP代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112&lt;?php/** * @author xialei &lt;xialeistudio@gmail.com&gt; */class map&#123; private static $_instance; const REQ_GET = 1; const REQ_POST = 2; /** * 单例模式 * @return map */ public static function instance() &#123; if (!self::$_instance instanceof self) &#123; self::$_instance = new self; &#125; return self::$_instance; &#125; /** * 执行CURL请求 */ protected function async($api,array $params) &#123; $ch = curl_init($api.'?'.http_build_query($params)); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); $resp = curl_exec($ch); curl_close($ch); return $resp; &#125; /** * ip定位 * @param string $ip * @return array * @throws Exception */ public function locationByIP($ip) &#123; //检查是否合法IP if (!filter_var($ip, FILTER_VALIDATE_IP)) &#123; throw new Exception('ip地址不合法'); &#125; $params = array( 'ak' =&gt; '百度地图API KEY', 'ip' =&gt; $ip, 'coor' =&gt; 'bd09ll'//百度地图GPS坐标 ); $api = 'http://api.map.baidu.com/location/ip'; $resp = $this-&gt;async($api, $params); $data = json_decode($resp, true); //有错误 if ($data['status'] != 0) &#123; throw new Exception($data['message']); &#125; //返回地址信息 return array( 'address' =&gt; $data['content']['address'], 'province' =&gt; $data['content']['address_detail']['province'], 'city' =&gt; $data['content']['address_detail']['city'], 'district' =&gt; $data['content']['address_detail']['district'], 'street' =&gt; $data['content']['address_detail']['street'], 'street_number' =&gt; $data['content']['address_detail']['street_number'], 'city_code' =&gt; $data['content']['address_detail']['city_code'], 'lng' =&gt; $data['content']['point']['x'], 'lat' =&gt; $data['content']['point']['y'] ); &#125; /** * GPS定位 * @param $lng * @param $lat * @return array * @throws Exception */ public function locationByGPS($lng, $lat) &#123; $params = array( 'coordtype' =&gt; 'wgs84ll', 'location' =&gt; $lat . ',' . $lng, 'ak' =&gt; '百度地图API KEY', 'output' =&gt; 'json', 'pois' =&gt; 0 ); $resp = $this-&gt;async('http://api.map.baidu.com/geocoder/v2/', $params, false); $data = json_decode($resp, true); if ($data['status'] != 0) &#123; throw new Exception($data['message']); &#125; return array( 'address' =&gt; $data['result']['formatted_address'], 'province' =&gt; $data['result']['addressComponent']['province'], 'city' =&gt; $data['result']['addressComponent']['city'], 'street' =&gt; $data['result']['addressComponent']['street'], 'street_number' =&gt; $data['result']['addressComponent']['street_number'], 'city_code'=&gt;$data['result']['cityCode'], 'lng'=&gt;$data['result']['location']['lng'], 'lat'=&gt;$data['result']['location']['lat'] ); &#125;&#125;]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>location</tag>
        <tag>php</tag>
        <tag>baidu map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端滑动的实现]]></title>
    <url>%2F2015%2F01%2F08%2Fmobile-swipe.html</url>
    <content type="text"><![CDATA[重点移动端的touch事件有三个: touchstart、touchmove、touchend 分别代表 触摸开始，触摸移动，触摸结束 12345678910111213var _begin;var _end;document.querySelector('#target').addEventListener('touchstart', function(e) &#123; _begin = e.changedTouches[0].pageX;&#125;, false);document.querySelector('#target').addEventListener('touchend', function(e) &#123; _end = e.changedTouches[0].pageX; if (_end &gt; _begin) &#123; console.log('从左向右') &#125;else&#123; console.log('从右向左') &#125;&#125;, false);]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>mobile</tag>
        <tag>swipe</tag>
        <tag>touch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVN命令行提交“--This line, and those below, will be ignored--”]]></title>
    <url>%2F2014%2F12%2F29%2Fsvn-commit-error.html</url>
    <content type="text"><![CDATA[今天phpstorm突然抽风，导致svn不能用，无奈只好用svn命令来提交。 1svn commit -m "init" 结果报错 12345678910111213--This line, and those below, will be ignored--M webroot/thatyear/js/main.js~ ~ ~ ~ ~ ~ ~ ~ ~ "svn-commit.2.tmp" 4L, 83C 直接保存发现会出现以下结果 12Log message unchanged or not specified(a)bort, (c)ontinue, (e)dit: 输入c提交我这是设置了SVN提交默认编辑器的时候才会这样，默认是不会设置的。按以下操作设置提交的编辑器 1vi ~/.subversion/config 找到[helpers]下的 editor-cmd 节，更改为vi即可 12[helpers]editor-cmd = /usr/bin/vi]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>subversion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wordpress使用prettify插件实现代码高亮]]></title>
    <url>%2F2014%2F12%2F27%2Fwordpress-prettify.html</url>
    <content type="text"><![CDATA[最近百度感冒的太严重了，统计代码严重拖慢网页打开速度，不得已，只得暂时关闭JS统计代码。而另一个重灾区–ueditor也是太大了。我着实受不了。也关掉了。那么问题来了。之前用ueditor有配套的代码高亮插件，取消ueditor之后，代码不亮了。别急，wordpress的插件多着呢! 步骤1.插件-&gt;安装插件，搜索 “prettify” ，排名第一的插件就是他了，直接启用吧 2.wordpress这边就配置完了，以后写代码时，像这样 1234&lt;pre class="prettyprint linenums"&gt; &lt;?php echo 1;&lt;/pre&gt; 刷新一下页面，是不是发现已经变了呢~，这款插件效果确实挺赞的！]]></content>
      <categories>
        <category>wordpress</category>
      </categories>
      <tags>
        <tag>highlight</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angularjs开发ios风格的toggle]]></title>
    <url>%2F2014%2F12%2F20%2Fangularjs-ios-like-toggle.html</url>
    <content type="text"><![CDATA[效果图 HTML代码123456&lt;div class="toggle-box" ng-click="item.hide_remind = !item.hide_remind" ng-class="&#123;'active':item.hide_remind,'':!item.hide_remind&#125;" ng-init="item.hide_remind=0"&gt; &lt;div class="toggle-container"&gt; &lt;div class="toggle-item"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334.site-create .page-bd .container form .form-group .toggle-box &#123; position: absolute; right: 48px; top: 15px;&#125;.site-create .page-bd .container form .form-group .toggle-box .toggle-container &#123; position: relative; width: 72px; height: 40px; background: #a8aeb3; -webkit-border-radius: 24px; -moz-border-radius: 24px; border-radius: 24px; padding: 2px;&#125;.site-create .page-bd .container form .form-group .toggle-box .toggle-container .toggle-item &#123; width: 39px; height: 39px; background: white; -webkit-border-radius: 39px; -moz-border-radius: 39px; border-radius: 39px; cursor: pointer; -webkit-transition: all linear 0.3s; -moz-transition: all linear 0.3s; -o-transition: all linear 0.3s; transition: all linear 0.3s;&#125;.site-create .page-bd .container form .form-group .toggle-box.active .toggle-container &#123; background: #79e575;&#125;.site-create .page-bd .container form .form-group .toggle-box.active .toggle-container .toggle-item &#123; margin-left: 32px;&#125; 记得自己去掉不存在的容器（我是在项目中用的，有CSS层级限制） JS代码无 所有的操作都在html中实现的。如果需要获取值，请获取item.hide_remind即可]]></content>
      <categories>
        <category>angularjs</category>
      </categories>
      <tags>
        <tag>css3</tag>
        <tag>ios</tag>
        <tag>toggle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angularjs注入拦截器实现Loading效果]]></title>
    <url>%2F2014%2F12%2F19%2Fangularjs-loading.html</url>
    <content type="text"><![CDATA[angularjs作为一个全ajax的框架，对于请求，如果页面上不做任何操作的话，在结果烦回来之前，页面是没有任何响应的，不像普通的HTTP请求，会有进度条之类。 本文通过对httpProvider注入拦截器实现loading。 HTML代码12345&lt;div class="loading-modal modal" ng-if="loading"&gt; &lt;div class="loading"&gt; &lt;img src="&lt;?=$this-&gt;module-&gt;getAssetsUrl()?&gt;/img/loading.gif" alt=""/&gt;&lt;span ng-bind="loading_text"&gt;&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; LESS代码123456789101112131415161718192021222324252627282930.modal &#123; position: fixed; width: 100%; height: 100%; left: 0; top: 0; z-index: 99; background: rgba(0, 0, 0, 0.3); overflow: hidden;&#125;.loading &#123; position: absolute; top: 50%; background: white; #solution&gt; .border-radius(8px); width: 160px; height: 72px; left: 50%; margin-top: -36px; margin-left: -80px; text-align: center; img &#123; margin-top: 12px; text-align: center; &#125; span &#123; display: block; &#125;&#125; JS代码1234567891011121314151617181920212223242526272829app.config(["$routeProvider", "$httpProvider", function ($routeProvider, $httpProvider) &#123; $routeProvider.when('/', &#123; templateUrl: "/views/reminder/index.html", controller: "IndexController" &#125;); $routeProvider.when('/create', &#123; templateUrl: "/views/reminder/item/create.html", controller: "ItemCreateController" &#125;); $routeProvider.otherwise(&#123;redirectTo: '/'&#125;); $httpProvider.interceptors.push('timestampMarker');&#125;]);//loadingapp.factory('timestampMarker', ["$rootScope", function ($rootScope) &#123; var timestampMarker = &#123; request: function (config) &#123; $rootScope.loading = true; config.requestTimestamp = new Date().getTime(); return config; &#125;, response: function (response) &#123; // $rootScope.loading = false; response.config.responseTimestamp = new Date().getTime(); return response; &#125; &#125;; return timestampMarker;&#125;]); 效果图]]></content>
      <categories>
        <category>angularjs</category>
      </categories>
      <tags>
        <tag>loading</tag>
        <tag>interceptor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css水平居中和垂直居中]]></title>
    <url>%2F2014%2F12%2F16%2Fcss-center.html</url>
    <content type="text"><![CDATA[水平居中还是比较好弄的 1234&#123; margin-left: auto; margin-right: auto;&#125; 但是垂直居中就比较麻烦，网上一大推文章都是什么display:table-cell,根本不管用。这里利用position属性可以达到这个目的。 效果图 HTML代码12345678&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;div class="container"&gt; &lt;div class="inner"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; CSS代码1234567891011121314151617181920body&#123; background: #f1f1f1;&#125;.container&#123; width: 400px; height: 400px; position: relative; margin: 100px auto; background: white;&#125;.container .inner&#123; width: 100px; height: 100px; background: black; position: absolute; left: 50%; margin-left: -50px; top: 50%; margin-top: -50px;&#125; 关键点top属性和margin-top的组合，一般来说 top: 50%之后，加一个 margin-top: 容器的高度/2 就可以垂直居中了。]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>center</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL行锁的使用]]></title>
    <url>%2F2014%2F12%2F12%2Fmysql-row-lock.html</url>
    <content type="text"><![CDATA[大家可能都有这样一种感觉，Web程序在本地调试的时候一切正常，放到线上也基本是正常，但是偶尔会有数据错误的情况，这种情况在订单系统中特别常见，因为大部分的订单状态更新都是有两个路径（浏览器跳转和支付服务器的异步推送消息），当然，最终数据要以异步结果为准，但是问题是，浏览器跳转也需要更新订单状态，当这两种方式在很短的时间内同时到达数据库时（一般在一秒内），如果数据库没有加锁，那这个订单会被处理两次。 说到建立数据表时，涉及到支付的，都要用InnoDB引擎，该引擎支持行锁，支持事务，外键。 文章开始的解决办法就是采用InnoDB对要操作的数据行进行锁定。 数据表结构1订单ID(主键) 订单金额 订单状态 事务SQL1234BEGIN;SELECT * FROM `orders` WHERE `order_id`=100 FOR UPDATE;COMMIT; 释义 BEGIN 手动开启事务（行锁只对开启事务的查询起作用） FOR UPDATE 独占写（成功获得锁后，只有当前进程能够更新该纪录，其他进程如果需要更新该记录，则需进行“锁等待”） COMMIT 提交处理]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>row lock</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android实现圆形带进度条的ProgressBar]]></title>
    <url>%2F2014%2F12%2F06%2Fandroid-circle-progressbar.html</url>
    <content type="text"><![CDATA[android加载图片免不了使用加载进度显示，而android自带的progressBar有局限. 圆型的progressBar不能显示进度条，只能无限制转圈圈 水平的progressBar可以显示进度条，但是貌似不好看 解决办法是自己写一个view就可以了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package com.ddhigh.library.widget;import android.content.Context;import android.graphics.Canvas;import android.graphics.Color;import android.graphics.Paint;import android.graphics.RectF;import android.util.AttributeSet;import android.view.View;public class CircleProgressBar extends View &#123; private int maxProgress = 100; private int progress = 0; //画圆所在的距形区域 RectF oval; Paint paint; public CircleProgressBar(Context context, AttributeSet attrs) &#123; super(context, attrs); oval = new RectF(); paint = new Paint(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int width = this.getWidth(); int height = this.getHeight(); if(width!=height) &#123; int min=Math.min(width, height); width=min; height=min; &#125; paint.setAntiAlias(true); // 设置画笔为抗锯齿 paint.setColor(Color.WHITE); // 设置画笔颜色 canvas.drawColor(Color.TRANSPARENT); // 白色背景 int progressStrokeWidth = 4; paint.setStrokeWidth(progressStrokeWidth); //线宽 paint.setStyle(Paint.Style.STROKE); oval.left = progressStrokeWidth / 2; // 左上角x oval.top = progressStrokeWidth / 2; // 左上角y oval.right = width - progressStrokeWidth / 2; // 左下角x oval.bottom = height - progressStrokeWidth / 2; // 右下角y canvas.drawArc(oval, -90, 360, false, paint); // 绘制白色圆圈，即进度条背景 paint.setColor(Color.rgb(0x57, 0x87, 0xb6)); canvas.drawArc(oval, -90, ((float) progress / maxProgress) * 360, false, paint); // 绘制进度圆弧，这里是蓝色 paint.setStrokeWidth(1); String text = progress + "%"; int textHeight = height / 4; paint.setTextSize(textHeight); int textWidth = (int) paint.measureText(text, 0, text.length()); paint.setStyle(Paint.Style.FILL); canvas.drawText(text, width / 2 - textWidth / 2, height / 2 +textHeight/2, paint); &#125; public int getMaxProgress() &#123; return maxProgress; &#125; public void setMaxProgress(int maxProgress) &#123; this.maxProgress = maxProgress; &#125; public void setProgress(int progress) &#123; this.progress = progress; this.invalidate(); &#125; /** * 非ＵＩ线程调用 */ public void setProgressNotInUiThread(int progress) &#123; this.progress = progress; this.postInvalidate(); &#125;&#125; 效果图]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>progressbar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在coding上部署Yii1.x应用]]></title>
    <url>%2F2014%2F12%2F05%2Fcoding-yii1.html</url>
    <content type="text"><![CDATA[总的来说，由于没有成熟的资料可以参考，部署过程话费了将近一个小时才成功，现在来分享一下经验。 目录配置由于Paas禁止了本地写功能，所以，如果不加任何处理的话，Yii会尝试在 protected/runtime 目录下写私有文件，结果是肯定没权限的。 经过查找官方文档发现CApplication有个方法叫setRuntimePath，可以设置运行时目录，那么最重要的一点，这个目录的配置肯定要在入口文件中配置，更改之后的入口文件代码如下： 12345678910111213141516defined('YII_DEBUG') or define('YII_DEBUG',false);if(isset($_GET['_d'])) setcookie('_d',1,7*25*3600);// change the following paths if necessary$yii=dirname(__FILE__).'/framework/yii.php';$config=dirname(__FILE__).'/protected/config/main.php';// remove the following lines when in production mode// specify how many levels of call stack should be shown in each log messagedefined('YII_TRACE_LEVEL') or define('YII_TRACE_LEVEL',3);require_once($yii);$app = Yii::createWebApplication($config);$app-&gt;setRuntimePath('/home/vcap/fs/*****');$app-&gt;run(); 可以看到，倒数一二行，重新设置了 runtimepath，所以，第一个问题解决。 数据库配置数据库这边没什么好说的，自己更改下连接信息就可以了。 缓存配置本地开发采用的缓存，默认是File的，如果你解决了上一个问题之后，在线上，缓存是没有问题了，这里探讨下服务器缓存的设置（Coding.NET提供的缓存为Redis的，PHP操作Redis需要扩展，这里先不探讨），本站现在的缓存驱动为DB方法，配置方法为: 12345'cache' =&gt; array( 'class' =&gt; 'system.caching.CDbCache', 'connectionID' =&gt; 'db', 'cacheTableName'=&gt;'t_cache'), 日志配置默认情况下，日志是写入runtime path的，不过在Paas上，我们一般是没有本地文件权限的，就算写入了，查看起来比较麻烦，这里也采用数据库方法记录： 123456'log' =&gt; array('class' =&gt; 'CLogRouter','routes' =&gt; array( array('class'=&gt;'CDbLogRoute', 'connectionID'=&gt;'db', 'logTableName'=&gt;'t_log'))) 总结经过以上处理，大家应该发现很多任务都交给数据库了，连缓存也是，缓存不就是为了减少直接从数据库读取数据吗，为什么还要用数据库缓存呢？ 这里本人简单分析下（仅代表本人观点） WEB应用程序的瓶颈在于数据库，比如InnoDB方法进行事务操作时，会锁行，或者锁表，这样下一个请求对同一条记录进行事务操作时会有“锁等待”，会浪费大部分的时间。还有一种是复杂的大数据查询，就算做了很多优化，查询速度依旧不快，毕竟连表的开销很大。 而数据库缓存的核心就是，数据只需要一次单表查询即可，没有连表，没有加锁，这个速度还是很快的。所以数据库缓存的存在性就是在此。]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>coding</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android datepicker和timepicker显示在一行]]></title>
    <url>%2F2014%2F11%2F19%2Fandroid-datepickertimepicker-display-inline.html</url>
    <content type="text"><![CDATA[android默认的datepicker和默认的timepicker可以放在一行（Linelayout），但是timepicker右边会“挤出”屏幕，尝试设置layout_weight和layout_height对于布局有效，但是控件显示就不完整了。到这一步发现xml不局文件已经处理不了，所以自然想到应该利用java来处理了。 效果图 布局代码1234567891011121314151617&lt;LinearLayout android:orientation="horizontal" android:layout_width="fill_parent" android:layout_height="fill_parent" android:paddingLeft="10dp"&gt; &lt;DatePicker android:layout_width="wrap_content" android:layout_height="wrap_content" android:id="@+id/datePicker" android:calendarViewShown="false" /&gt; &lt;TimePicker android:layout_width="wrap_content" android:layout_height="wrap_content" android:id="@+id/timePicker" /&gt;&lt;/LinearLayout&gt; JAVA代码UI.java12345678910111213141516171819202122232425262728293031public static void resizePicker(FrameLayout tp) &#123; List&lt;NumberPicker&gt; npList = findNumberPicker(tp); for (NumberPicker np : npList) &#123; resizeNumberPicker(np); &#125;&#125;private static List&lt;NumberPicker&gt; findNumberPicker(ViewGroup viewGroup) &#123; List&lt;NumberPicker&gt; npList = new ArrayList&lt;NumberPicker&gt;(); View child = null; if (null != viewGroup) &#123; for (int i = 0; i &lt; viewGroup.getChildCount(); i++) &#123; child = viewGroup.getChildAt(i); if (child instanceof NumberPicker) &#123; npList.add((NumberPicker) child); &#125; else if (child instanceof LinearLayout) &#123; List&lt;NumberPicker&gt; result = findNumberPicker((ViewGroup) child); if (result.size() &gt; 0) &#123; return result; &#125; &#125; &#125; &#125; return npList;&#125;private static void resizeNumberPicker(NumberPicker np) &#123; LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(100, RadioGroup.LayoutParams.WRAP_CONTENT); params.setMargins(10, 0, 10, 0); np.setLayoutParams(params);&#125; Main.javaView的查找自己应该知道写了。 1234567891011121314151617181920212223242526UI.resizePicker(datePicker);UI.resizePicker(timePicker);datePicker.setMinDate(System.currentTimeMillis() - 1000);datePicker.init(year, monthOfYear, dayOfMonth, new DatePicker.OnDateChangedListener() &#123;public void onDateChanged(DatePicker view, int year, int monthOfYear, int dayOfMonth) &#123; //得到时间 String time = timePicker.getCurrentHour() + ":" + timePicker.getCurrentMinute(); datetime = year + "-" + (monthOfYear + 1) + "-" + dayOfMonth + " " + time; &#125; &#125;); timePicker.setIs24HourView(true); timePicker.setOnTimeChangedListener(new TimePicker.OnTimeChangedListener() &#123; public void onTimeChanged(TimePicker view, int hourOfDay, int minute) &#123; String date = datePicker.getYear() + "-" + (datePicker.getMonth() + 1) + "-" + datePicker.getDayOfMonth(); datetime = date + " " + timePicker.getCurrentHour() + ":" + timePicker.getCurrentMinute(); &#125; &#125;); 原理datepicker和timepicker都是继承FrameLayout，内部为很多NumberPicker，所以，查找到所有NumberPicker的List，然后设置样式即可。]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>datepicker</tag>
        <tag>timepicker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angularjs处理后端空数据]]></title>
    <url>%2F2014%2F11%2F15%2Fangularjs-empty-array.html</url>
    <content type="text"><![CDATA[Yii1.x DAO中的queryAll方法查询，如果有结果，会返回一个数组，如果没有结果，会返回null。现在分两种情况： 返回空数组123$array = array();echo json_encode($array); 输出为 1[] 返回null12$array = null;echo json_encode($array); 输出为 1null 那么问题来了，JS接收这两个的结果是不同的。如果使用以下代码判断数据:12345if(data.length == 0)&#123; //当前评论为空&#125;else&#123; //当前评论不为空&#125; 如果返回 [] ，这段代码是生效的。但是如果返回 null ,这个就有问题了。 后来，使用 12345if(data == null)&#123; //评论为空&#125;else&#123; //评论不为空&#125; 这个判断老是出问题，后端明明返回null了，判断还是错误的，这时候想到JS也是若类型语言，会不会是类型的问题。 1console.log(typeof data) 返回的是“string”那么问题就解决了，用以下代码就可以了 12345if(data.length == 0 || data == "null")&#123; //评论为空&#125;else&#123; //评论不为空&#125;]]></content>
      <categories>
        <category>angularjs</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[angularjs遍历空数组&索引数组]]></title>
    <url>%2F2014%2F11%2F14%2Fangularjs-traverse-empty-array.html</url>
    <content type="text"><![CDATA[今天做开发时发现控制老是报错，虽然不影响使用，但是作为有那么一点“强迫症”的我来说，无法忍受。通过调试发现是ng-repeat对一个空数组遍历出错，另外，[‘ab’,’cd’,’ad’]这样只有值没有键的数组也会遍历出错。 解决办法12345678910111213&lt;li class="media" ng-repeat="item in comments track by $index"&gt; &lt;div class="media-body"&gt; &lt;strong&gt;&lt;/strong&gt;&lt;p&gt; &lt;br /&gt;&lt;time&gt;&lt;/time&gt;&lt;br /&gt;&lt;span ng-if="item.comment_author_url.length&gt;0"&gt; &lt;i class="fa fa-globe"&gt;&lt;/i&gt; &lt;a href="" target="_blank"&gt;&lt;/a&gt; &lt;/span&gt; &lt;/p&gt; &lt;/div&gt;&lt;/li&gt; 特别注意track by $index]]></content>
      <categories>
        <category>angularjs</category>
      </categories>
      <tags>
        <tag>ng-repeat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IllegalStateException： Can not perform this action after onSaveInstanceState]]></title>
    <url>%2F2014%2F11%2F13%2Fillegalstateexception-can-not-perform-this-action-after-onsaveinstancestate.html</url>
    <content type="text"><![CDATA[今天使用Fragment的时候，出现了这个错误 IllegalStateException: Can not perform this action after onSaveInstanceState。查看一下控制台，发现是FragmentManager的commit()方法报错的，看字面意思应该是 onSaveInstanceState这个方法之后不能处理这个操作（指commit()）。 因为onSaveInstanceState方法是在该Activity即将被销毁前调用，来保存Activity数据的，如果在保存玩状态后再给它添加Fragment就会出错。解决办法就是把commit（）方法替换成 commitAllowingStateLoss()就行了，其效果是一样的。]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android使用ImageLoader缓存图片]]></title>
    <url>%2F2014%2F11%2F11%2Fandroid-cache-image-with-imageloader.html</url>
    <content type="text"><![CDATA[缓存和异步是两个极大提升用户体验的好东西，android加载图片时的开销还是挺大的，要是不做缓存同步加载，网速不给力的情况下，等个十几秒是有可能的。 今天要说的是一个叫做ImageLoader的库 GITHUB:https://github.com/nostra13/Android-Universal-Image-Loader 使用这个库有以下几步： 导入libs目录 声明自己的MyApplication类（继承Application） 在onCreate()方法中 123456789101112131415public void onCreate() &#123; super.onCreate(); DisplayImageOptions options = new DisplayImageOptions.Builder() .cacheInMemory() //缓存在内存中 .cacheOnDisc() //磁盘缓存 .build(); ImageLoaderConfiguration config2 = new ImageLoaderConfiguration.Builder(this) .defaultDisplayImageOptions(options) .threadPriority(Thread.NORM_PRIORITY - 2) .denyCacheImageMultipleSizesInMemory() .discCacheFileNameGenerator(new Md5FileNameGenerator()) .tasksProcessingOrder(QueueProcessingType.LIFO) .build(); ImageLoader.getInstance().init(config2);&#125; 在要加载图片的地方使用 1234567DisplayImageOptions options = new DisplayImageOptions.Builder() .cacheInMemory() // 缓存用 .cacheOnDisc() .bitmapConfig(Bitmap.Config.RGB_565)//防止溢出 .displayer(new RoundedBitmapDisplayer(139)) // 图片圆角显示，值为整数 .build();ImageLoader.getInstance().displayImage(url, avatar, options); 其中 url 是图片URL地址，avatar为ImageView,options为动态配置，这里加了一个防止溢出的参数。 好了，使用起来是不是很简单呢~我们压根不用操心异步和缓存的问题了]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>image cache</tag>
        <tag>Android-Universal-Image-Loader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[async http client socket超时问题]]></title>
    <url>%2F2014%2F11%2F10%2Fasync-http-client-socket-timeout.html</url>
    <content type="text"><![CDATA[最近做的一个项目的HTTP模块使用了loopj的asynchttpclient (https://github.com/loopj/android-async-http）。 自动更新模块总是出现sockettimeout的exception,查来查去也不知道什么问题，为此还换了asynchttpclient的库版本。但是问题也没解决。 仔细看了一下，提示的是timeout，应该从这方面去看看，后面看到自己的HTTP工具类设置了全局超时时间为5000ms,普通请求当然没这么久，但是自动更新是下载，肯定不止5秒的，删掉超时设置就可以了。]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android 替换斜杠]]></title>
    <url>%2F2014%2F11%2F07%2Fandroid-replace-slash.html</url>
    <content type="text"><![CDATA[问题最近写安卓的时候服务端返回的数据会带上“\n”，但是在android这边不能换行，初次想到的解决方法是利用 1String.replace("\n","\n") 给替换掉，结果是不行的。之前记得java的反斜杠是需要转义的，就用 1String.replaceAll("\n","\\n") 试了一下，结果依旧不行。后来去查了谷歌–，发现要 \\n 才可以 匹配到 \n,这么多斜杠，头都晕了，一个个来解释： 第一个和第二个反斜杠是一组，由于java的转义，实际为 “\” 第三个和第四个同理， 经过以上两步之后，\\n 实际上是 \n ，由于是正则的关系，\n 可以匹配到字符串的\n了。 解决方法1String.replaceAll("\\n","\\n") 第一个参数是正则，第二个是普通字符串。不得不吐槽下Java的正则表达式。。]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>regex</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac os x 使用eclipse调试android]]></title>
    <url>%2F2014%2F11%2F01%2Fmac-os-x-debug-android-with-eclipse.html</url>
    <content type="text"><![CDATA[这两天心血来潮装了个mac os x 10.10系统，折腾的过程就不说了。Mac OS X 10.10的环境下，Eclipse+ADT，进行真机调试时，会出现一个问题。终端下输入 adb devices可以看到小米2S，但是Device Chooser对话框里不显示真机设备，只有重新插拔数据线才可以。仔细看了下android run configure发现一个问题，默认显示的compatible devices（意思差不多是适配的设备）。简单说下方法右键项目&gt;run as&gt;run configurations&gt;target&gt;选中间那个&gt;Active Devices再次点击run就可以了。]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>debug</tag>
        <tag>eclipse</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决wordpress d8主题使用七牛镜像插件后无法评论的问题]]></title>
    <url>%2F2014%2F11%2F01%2Fwordpress-d8-theme-qiniu-cannot-comment.html</url>
    <content type="text"><![CDATA[上午有热心的网友给我反映说评论功能出bug了，初步查看是七牛出了问题，利用chrome的开发者工具可以查看请求。PS：这张图是今天截的，所以域名是正常的，昨天实际上请求的是 static.ddhigh.com (本站的CDN域名)。查看HTTP请求发现整站就请求了一个jquery文件，但是这个文件比较大有140K，查看源代码发现评论的代码已经合并在里面了。按照以上步骤可以查看到评论时执行的脚本，当然这里的域名已经修复了。 278行，昨天的是 1url:window._deel.url+"/ajax/comment.php" 在控制台输入 1console.log(_deel); 域名是CDN域名，所以ajax请求实际上被提交到七牛去了。 修正方法利用ssh工具连接你的服务器（不是七牛），找到对应的jquery文件278行，改成你的站点域名（如本站的www.ddhigh.com）,更新下缓存即可。]]></content>
      <categories>
        <category>wordpress</category>
      </categories>
      <tags>
        <tag>qiniu</tag>
        <tag>comment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UCenter 后台应用通知列表空白]]></title>
    <url>%2F2014%2F10%2F31%2Fucenter-empty.html</url>
    <content type="text"><![CDATA[今天遇到了一个奇葩的问题UCenter后台通知列表空白并且500，通过xdebug调试发现是uc_server/control/admin/note.php 第68行代码有问题!IDE都报错了 原代码1$this-&gt;_format_notlist(&amp;$notelist); 修正代码1$this-&gt;_format_notlist($notelist); 可能是由于PHP版本升级导致的问题。]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>ucenter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决 angularjs html5Mode 404的问题]]></title>
    <url>%2F2014%2F10%2F30%2Fangularjs-html5mode-404.html</url>
    <content type="text"><![CDATA[采用location的html5Mode之后，链接是正常的，但是刷新的时候会404，此时就需要后端服务器配置URL重写了。 本文以apache为例 1234RewriteEngine onRewriteCond %&#123;REQUEST_FILENAME&#125; !-dRewriteCond %&#123;REQUEST_FILENAME&#125; !-fRewriteRule . index.html 这样子就可以将所有不是文件夹且不是文件的请求转发到index.html。]]></content>
      <categories>
        <category>angularjs</category>
      </categories>
      <tags>
        <tag>angularjs</tag>
        <tag>apache</tag>
        <tag>location</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让IE7,IE8支持html5属性]]></title>
    <url>%2F2014%2F10%2F28%2Fie7ie8-support-html5-attribute.html</url>
    <content type="text"><![CDATA[HTML5确实很好用，但是国内IE7和IE8的用户还是挺多的（或许是XP的缘故）。这些浏览器不识别HTML5的新属性以及&lt;!doctype html&gt;，导致页面渲染进入“怪异”模式，简直就是“不堪入目”。不过，还好，开源的力量是强大的，有热心的开发者写了一套JS库来兼容IE7,IE8。本文就简单教大家用下这款JS库。 1.下载2.解压之后得到html5shiv.js3.开发模板 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;title&gt;Template&lt;/title&gt; &lt;!--[if lt IE 9]&gt; &lt;script src="http://cdn.bootcss.com/html5shiv/3.7.2/html5shiv.min.js"&gt;&lt;/script&gt; &lt;script src="http://cdn.bootcss.com/respond.js/1.4.2/respond.min.js"&gt;&lt;/script&gt; &lt;![endif]--&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;你好，世界！&lt;/h1&gt;&lt;script src="http://cdn.bootcss.com/jquery/1.11.1/jquery.min.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 使用这个库之后就可以正常开发啦。题外话：IE系列好像是不太好兼容的。]]></content>
      <categories>
        <category>front-end</category>
      </categories>
      <tags>
        <tag>html5</tag>
        <tag>ie7</tag>
        <tag>ie8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHPExcel导出时为空的解决方法]]></title>
    <url>%2F2014%2F10%2F24%2Fphpexcel-export-empty.html</url>
    <content type="text"><![CDATA[今天在做数据导出的时候遇到个麻烦事情，SQL查询是有数据的，但是写入excel的时候为空的。 输出异常是有一行遇到错误了。将那一行数据打印出来发现字段中有个 = 号，excel中有 = 会将后面的当作表达式计算，所以导致错误。 解决方式是在 = 前面加上单引号 ‘= 就可以了]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>phpexcel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端textarea自适应高度]]></title>
    <url>%2F2014%2F10%2F21%2Fmobile-textarea-auto-fit.html</url>
    <content type="text"><![CDATA[PC端网页的textarea内容多了会出现滚动条，这个没什么，鼠标么，滚动方便。但是移动端是没鼠标的，出现滚动条是很不友好的行为。 利用js的事件绑定及动态改变CSS就可以做到这个了。 1onpropertychange="this.style.height=this.scrollHeight + 'px'" oninput="this.style.height=this.scrollHeight + 'px'"]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>mobile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux检查端口占用]]></title>
    <url>%2F2014%2F10%2F15%2Flinux-check-port.html</url>
    <content type="text"><![CDATA[1netstat -lnp | grep 80]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>netstat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端实时检测输入框]]></title>
    <url>%2F2014%2F10%2F14%2Fmobile-realtime-check.html</url>
    <content type="text"><![CDATA[PC浏览器的话由于有blur和focus事件，可以在失去焦点时进行一次验证，但是移动端有点麻烦，点击其他地方才可以，这种的话体验不是很好。利用input事件可以解决这个问题。 123$(document).on('input','#username',function()&#123; //验证逻辑&#125;); 测试之后问题确实来了，每输入一个字符就会触发，浪费很多网络请求，接下来使用一个定时器的技术来进行处理。 12345678var timer;$(document).on('input','#username',function()&#123; timer &amp;&amp; clearTimeout(timer); timer = setTimeout(function()&#123; //验证逻辑 &#125;,500);//延时0.5s触发&#125;); 采用这种定时器技术可以在请求次数和用户体验之间取得平衡，很多地方都可以使用这种技术来实现。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>mobile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx服务器启用SSL访问]]></title>
    <url>%2F2014%2F10%2F11%2Fnginx-enable-ssl.html</url>
    <content type="text"><![CDATA[HTTP和HTTPS的区别 https协议需要到ca申请证书，一般免费证书很少，需要交费。 http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。 http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 所以在涉及到账户、金钱等敏感信息交互的时候使用HTTPS是个不错的选择。 申请证书 申请SSL证书过程就不多说了。挺简单的，本文主要是在nginx上配置ssl证书实现https访问。 将key和证书上传到服务器。 nginx配置123456789101112131415161718192021222324252627282930server &#123; listen 443; #listen [::]:80; server_name passport.ddhigh.com; index index.html index.htm index.php default.html default.htm default.php; root /home/wwwroot/passport.ddhigh.com; include other.conf; #error_page 404 /404.html; location ~ [^/]\.php(/|$) &#123; # comment try_files $uri =404; to enable pathinfo try_files $uri =404; fastcgi_pass unix:/tmp/php-cgi.sock; fastcgi_index index.php; include fastcgi.conf; #include pathinfo.conf; &#125; location ~ .*\.(gif|jpg|jpeg|png|bmp|swf)$ &#123; expires 30d; &#125; location ~ .*\.(js|css)?$ &#123; expires 12h; &#125; ssl on; ssl_certificate /root/crt/server.crt; ssl_certificate_key /root/crt/server.key; access_log /home/wwwlogs/passport.ddhigh.com.log access;&#125; /root/crt是我的证书目录，各位读者可以根据实际情况更改。]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>https</tag>
        <tag>ssl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ng-repeat获取父级INDEX]]></title>
    <url>%2F2014%2F10%2F11%2Fng-repeat-get-parent-index.html</url>
    <content type="text"><![CDATA[angularjs的循环嵌套我就不多说了，无非是ng-repeat的嵌套而已，如果需要获取索引请使用$index。 那么问题来了，$index只能获取当前循环的索引，如果需要获取父级的索引怎么办？ 原理其实也不难，在父级ng-repeat时利用ng-init写入一个变量即可，子循环是可以访问到的。 12345678&lt;div ng-controller="MainCtrl"&gt; &lt;dl ng-repeat="user in users"&gt; &lt;dt ng-init="p_index=$index"&gt;Name:&lt;/dt&gt; &lt;dd ng-repeat="p in user.posts"&gt;父级INDEX: - 自己的INDEX: &lt;/dd&gt; &lt;/dl&gt;&lt;/div&gt; 1234567var site = angular.module('application.site', []);site.controller('MainCtrl', ['$scope', '$http', function ($scope, $http) &#123; $scope.users = [ &#123;name:"xialei",posts:["文章一","文章二","文章三"]&#125;, &#123;name:"zhangsan",posts:["文章四","文章五"]&#125; ];&#125;]); 这里只是关键代码，用过angularjs的小伙伴们相信一眼就可以看懂了。]]></content>
      <categories>
        <category>angularjs</category>
      </categories>
      <tags>
        <tag>parent index</tag>
        <tag>ng-repeat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html5新属性data api]]></title>
    <url>%2F2014%2F10%2F08%2Fhtml5-data-api.html</url>
    <content type="text"><![CDATA[以往在做列表程序的时候，需要做类似“删除”功能的时候，往往是组装一个URL，类似于这个 index.php?m=news&amp;a=delete&amp;id=10 这是最普通的url方式来进行删除。 但是随着用户体验要求的增加，很多时候都需要使用ajax来实现相应效果。 记得很早以前在写一个CURD项目的时候，我是用ID来做的，类似于 id=”news_id_10”,id=”news_id_11” 这样，然后通过分割字符串来获取ID，简直就是要多麻烦有多麻烦，当时就在想有没有一个能自己定义所需数据的字段呢？ 现在好了。HTML5的data-* API可以帮到我们 html代码1&lt;a href="javascript:void(0)" data-action="delete" data-id="10"&gt;删除&lt;/a&gt; 是不是看到了data-action和data-id属性呢？data-只要更改就可以了，需要满足标识符约束。 js代码12345678910111213141516171819$(document).on('click', '[data-action="delete"]',function() &#123; var $id = $(this).data("id"); var $this = $(this); ajax &amp;&amp; ajax.abort(); ajax = $.get('index.php', &#123; id: $id, m: 'news', a: 'delete' &#125;, function(data) &#123; if (data.status == 1) &#123; //操作成功 &#125; else &#123; alert(data.info); &#125; &#125;, 'json');&#125;); JQ提供的$.data方法确实挺方便的，但是请注意，本人发现$.data方法是只读的（就是不能改变data-id=”10”中的10），如果需要改变，请用底层的$.attr(‘data-id’,9)这种操作。]]></content>
      <categories>
        <category>front-end</category>
      </categories>
      <tags>
        <tag>data-api</tag>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP二进制方法存储图片]]></title>
    <url>%2F2014%2F10%2F02%2Fphp-save-image-to-database.html</url>
    <content type="text"><![CDATA[大部分人的图片上传都是保存一个路径到数据库，这样在插入时确实快，也符合web的特点，但是在删除时就很麻烦，需要找到文件并删除，该代码能够把代码直接存入数据库，删除时一并删除。请注意：这样的话数据库大小会激增，请酌情使用,且RDBMS对于二进制数据的处理并不是很理想。 表结构（只做简单演示，故字段有限）123456CREATE TABLE `upload` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, `type` varchar(20) NOT NULL, `data` mediumblob NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; 上传表单1234567891011121314&lt;!doctype html&gt; &lt;html&gt;&lt;head&gt; &lt;title&gt; Post-Image &lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="post.php" method="post" enctype="multipart/form-data"&gt; &lt;input type="file" name="file" id="file"/&gt; &lt;input type="submit" value="OK"/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 处理程序1234567891011121314151617181920212223242526&lt;?phpif ($_FILES["file"]["error"] &gt; 0)&#123; echo "Error: " . $_FILES["file"]["error"] . "&lt;br /&gt;";&#125;else&#123; $type = $_FILES["file"]["type"]; $size = $_FILES['file']['size']; $tmp=$_FILES["file"]["tmp_name"]; $fp = fopen($tmp,'rb'); $data = bin2hex(fread($fp,$size)); $dsn='mysql:host=localhost;dbname=test'; echo '&lt;pre&gt;'; try&#123; $pdo = new PDO($dsn,'root','root'); $pdo-&gt;exec("INSERT INTO `upload`(`type`,`data`) values ('$type',0x$data)"); $id = $pdo-&gt;lastInsertId(); echo 'upload success!&lt;a href="view.php?id='.$id.'"&gt;View&lt;/a&gt;'; $pdo = null; &#125;catch (PDOException $e)&#123; echo $e-&gt;getMessage(); &#125; echo '&lt;/pre&gt;'; fclose($fp);&#125; 显示页面123456789101112131415161718&lt;?php$id = $_GET['id'];if(is_numeric($id))&#123; $dsn='mysql:host=localhost;dbname=test'; try&#123; $pdo = new PDO($dsn,'root','root'); $rs = $pdo-&gt;query('select * from `upload` where `id`='.$id); $row = $rs-&gt;fetchAll(); $data = $row[0]; header("Content-Type:$&#123;data['type']&#125;"); echo $data['data']; $pdo = null; &#125;catch (PDOException $e)&#123; echo $e-&gt;getMessage(); &#125;&#125;else&#123; exit();&#125; 经过测试可行，请大家在必要的时候才使用~]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>binary</tag>
        <tag>image</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angularjs动态表单项]]></title>
    <url>%2F2014%2F09%2F29%2Fangularjs-dymanic-form-item.html</url>
    <content type="text"><![CDATA[后台业务系统中有很多CURD操作，一个很简单的例子是OA系统中为员工添加帐号信息，传统的做法是添加完一个就跳转并提示“成功”,后来高级一点的做法是利用jquery来做。 但是一个比较麻烦的问题是需要手动拼接HTML并且插入文档树。 然而，现在有了跨时代神器–angularjs,就是这么炫，强大的双向绑定功能可以帮到我们。 整体思想是利用 ng-repeat 指令来遍历一个临时数组（元素个数为表单个数）生成表单 HTML代码12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html ng-app="application.site"&gt;&lt;head&gt; &lt;meta charset="UTF-8"/&gt; &lt;title&gt;Login&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div ng-controller="ListCtrl"&gt; &lt;button type="button" ng-click="add()"&gt;添加表单&lt;/button&gt; &lt;form action="" method="post" class="form" ng-repeat="form in forms" novalidate="novalidate"&gt; &lt;p&gt; 号表单&lt;/p&gt; &lt;label for="username"&gt;帐号&lt;/label&gt; &lt;input type="text" ng-model="username" id="username" ng-required="true"/&gt; &lt;button type="submit" ng-click="post($index,username)"&gt;提交&lt;/button&gt; &lt;button type="button" ng-click="remove($index)"&gt;移除&lt;/button&gt; &lt;/form&gt;&lt;/div&gt;&lt;script src="js/angularjs-1.2.19.js"&gt;&lt;/script&gt; JS代码123456789101112131415161718var site = angular.module('application.site', []);site.controller('ListCtrl', ['$scope', '$http',function($scope, $http) &#123; $scope.forms = ["1"]; $scope.index = 1; $scope.post = function(index, username) &#123; console.log(index + ' 号表单提交 [' + username + '] 成功'); &#125; $scope.remove = function(index) &#123; console.log('删除 [' + index + '] 号表单成功'); $scope.forms.splice(index, 1); &#125; $scope.add = function() &#123; console.log('添加表单'); $scope.forms.push((++$scope.index).toString()); &#125;&#125;]); 由于小编只是为了实现功能而写的这么一个demo，样式至上难免有些欠缺–。但是，麻雀虽小，五脏俱全，大家可以根据这个思路去开发更为强大的应用系统。]]></content>
      <categories>
        <category>angularjs</category>
      </categories>
      <tags>
        <tag>form</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yii1.x单点登录]]></title>
    <url>%2F2014%2F09%2F27%2Fyii1-sso.html</url>
    <content type="text"><![CDATA[背景Web迅速发展的今天，往往一个产品拥有很多个子站点，SSO技术显得很重要。Yii作为我常用的框架，发现Yii的SSO配置其实是非常简单的。 代码在所有站点中直接打开 protected/config/main.php 在 components 中加入以下代码，并且把protected/runtime/state.bin文件复制到各个具体的子站点中就可以实现SSO了！ 123456789101112131415161718192021'user' =&gt; array( 'identityCookie' =&gt; array( 'domain' =&gt; '.ddhigh.com', 'path' =&gt; '/' ), // enable cookie-based authentication 'allowAutoLogin' =&gt; true, 'stateKeyPrefix' =&gt; 'ddhigh', 'loginUrl' =&gt; array('user/login') ), 'session' =&gt; array( 'cookieParams' =&gt; array( 'domain' =&gt; '.ddhigh.com', 'lifetime' =&gt; 0, 'timeout' =&gt; 3600 ), ), 'statePersister' =&gt; array( 'class' =&gt; 'CStatePersister', 'stateFile' =&gt; './protected/runtime/state.bin' ), 推荐所有的站点全部放在一个域名中进行操作~]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>yii</tag>
        <tag>sso</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP遍历文件]]></title>
    <url>%2F2014%2F09%2F27%2Fphp-traverse-file.html</url>
    <content type="text"><![CDATA[遍历文件夹主要用到 opendir readdir closedir 三个函数，有两个要注意的地方 要排除 ‘.’ 和 ‘..’ 两个目录 需要用到递归 12345678910111213141516171819202122232425&lt;?php/** * 遍历文件夹 * @param string $path * @return array */function listFiles($path)&#123; $files = array(); $handler = opendir($path);//打开目录 while (($file = readdir($handler)) !== false) &#123; if($file != '.' &amp;&amp; $file != '..')&#123; //当前目录和上级目录 if(is_dir($path.DIRECTORY_SEPARATOR.$file))&#123; $files[$file] = listFiles($path.DIRECTORY_SEPARATOR.$file); &#125;else&#123; $files[] = $file; &#125; &#125; &#125; closedir($handler); return $files;&#125;$array = listFiles(__DIR__);print_r($array);]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>file</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[highchats曲线不显示]]></title>
    <url>%2F2014%2F09%2F24%2Fhighchats-not-display.html</url>
    <content type="text"><![CDATA[highchats是什么就不介绍了。一个JS绘图工具库，基于JQ，使用简单方便，但是不注意的话会坑人。 今天兴致满满的去绘图，后端数据也返回了。可是一个纠结的问题困扰了我一下午！ 后端数据返回的JSON是 1["0","0","0"] 这种形式，JSON.parse解析之后返回的是一个字符数组，而不是数字数组，解决方案是利用JS做一次类型转换 123for(var i in data)&#123; data[i]=parseInt(data[i]);&#125; for(var i in data){ data[i]=parseInt(data[i]);}图形就可以正常显示了。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>highcharts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angularjs鼠标悬浮效果]]></title>
    <url>%2F2014%2F09%2F22%2Fangularjs-mouse-move-effect.html</url>
    <content type="text"><![CDATA[用JQ来做的话很简单的，(通过toggleClass函数就可以了),但是既然提到了angularjs，当然要用angularjs的解决方案来做啦! angularjs集成了一个jqlite模块（可以理解为阉割版的jquery）,提供有限并且常用的功能。 主要用到指令系统中的Link函数，代码就不贴了。 直接上dome吧！下载地址]]></content>
      <categories>
        <category>angularjs</category>
      </categories>
      <tags>
        <tag>hover</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP自动更新网站]]></title>
    <url>%2F2014%2F09%2F20%2Fphp-website-auto-update.html</url>
    <content type="text"><![CDATA[目前软件开发主流越来越倾向于B/S模式，不同于C/S模式的软件，B/S模式下的WEB程序自动更新是个麻烦问题。 本人利用PHP下载远程文件和ZIP类，写了一个简单的自动更新DEMO，供大家参考。 服务端目录结构12345|data |--20140918.zip|--index.php 其中 data 文件夹用来存放补丁包,index.php 文件用来响应版本数据给客户端。 index.php1234567891011&lt;?phpsleep(3);header('Content-Type:application/json;utf-8');echo json_encode(array( '20140918' =&gt; array( 'version' =&gt; 20140920, 'desc' =&gt; 'BUG修正，缓存系统', 'url' =&gt; 'http://' . $_SERVER['HTTP_HOST'] . $_SERVER['REQUEST_URI'] . '/data/20140918.zip' )));exit(); 20140918 对应的是客户端版本号，20140920 对应的是服务端版本号，desc 是本次补丁的描述，url 则是补丁包下载地址 客户端目录结构1234567|tmp|--config.php|--Zip.php|--index.php config.php 为配置文件，保存本地版本信息，Zip.php 为ZIP操作类（从服务端下载的补丁包均为zip格式）,index.php 为自动更新程序（只是为了方便，实际中可以写个方法出来） index.php123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?phpob_implicit_flush(true);$begin = microtime(true);//检查更新,加载本地版本号$config = require(__DIR__ . '/config.php');$server = 'http://localhost/version';echo '连接更新服务器...&lt;br/&gt;';ob_flush();$versions = json_decode(file_get_contents($server), true);if (!isset($versions[$config['version']])) &#123; echo '当前已是最新版本!';&#125; else &#123; echo '当前版本：&lt;b&gt;', $config['version'], '&lt;/b&gt; 服务器版本：&lt;b&gt;', $versions[$config['version']]['version'], '&lt;/b&gt;&lt;br/&gt;'; ob_flush(); //开始下载 $remote_fp = fopen($versions[$config['version']]['url'], 'rb'); if(!is_dir(__DIR__.'/tmp')) mkdir(__DIR__.'/tmp'); $tmp = __DIR__ . '/tmp/' . date('YmdHis') . '.zip'; $local_fp = fopen($tmp, 'wb'); echo '开始下载...&lt;br/&gt;'; ob_flush(); while (!feof($remote_fp)) &#123; fwrite($local_fp, fread($remote_fp, 128)); &#125; fclose($remote_fp); fclose($local_fp); echo '下载完成,准备解压&lt;br/&gt;'; ob_flush(); require(__DIR__ . '/Zip.php'); $zip = new Zip(); $zip-&gt;extra($tmp, __DIR__); echo '解压完成,准备删除临时文件&lt;br/&gt;'; ob_flush(); //删除补丁包 unlink($tmp); echo '临时文件删除完毕&lt;br/&gt;'; ob_flush(); //更新本地版本号 $content = file_get_contents(__DIR__.'/config.php'); $content = str_replace($config['version'],$versions[$config['version']]['version'],$content); file_put_contents(__DIR__.'/config.php',$content); echo '更新完成!耗时',microtime(true) - $begin,'秒&lt;br/&gt;'; ob_flush(); ob_end_clean(); exit();&#125; config.php1234&lt;?phpreturn array( 'version' =&gt; '20140918'); Zip.php12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?php/** * @version 1.0 * @date 2014-08-11 * @author 十七号 &lt;xialeistudio@gmail.com&gt; * @license MIT * 压缩、解压缩类 */class Zip&#123; /** * 打包 * @param $path * @param $save */ public static function archive($path, $save) &#123; $zip = new ZipArchive(); if ($zip-&gt;open($save, ZipArchive::OVERWRITE) === true) &#123; self::addZip($path, $zip); $zip-&gt;close(); &#125; &#125; /** * 添加文件或文件夹到zip对象 * @param string $path * @param ZipArchive $zip */ private static function addZip($path, $zip) &#123; $handler = opendir($path); while (($file = readdir($handler)) !== false) &#123; if ($file != '.' &amp;&amp; $file != '..') &#123; if (is_dir($path . DIRECTORY_SEPARATOR . $file)) &#123; self::addZip($path . DIRECTORY_SEPARATOR . $file, $zip); &#125; else &#123; $zip-&gt;addFile($path . DIRECTORY_SEPARATOR . $file); &#125; &#125; &#125; closedir($handler); &#125; /** * 解压文件 * @param string $file 压缩文件路径 * @param string $path 解压路径，为空则以文件名为路径 */ public static function extra($file, $path = null) &#123; if (!isset($path)) &#123; $array = explode('.', $file); $path = reset($array); &#125; $zip = new ZipArchive(); if ($zip-&gt;open($file) === true) &#123; $zip-&gt;extractTo($path); $zip-&gt;close(); &#125; &#125;&#125; 本文只写了一个很简单的自动更新程序，只是为了说明更新程序的基本思路。还有很多细节方面可以定制的。]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>auto updator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP下载远程文件]]></title>
    <url>%2F2014%2F09%2F20%2Fphp-download-remote-file.html</url>
    <content type="text"><![CDATA[在做小偷程序的时候，文章的图片往往是有防盗链措施的，一个比较好的解决办法是通过PHP下载图片到本地并且替换URL实现。 由于图片这种东西不能直接像下载HTML那样直接下载，所以需要指定fopen的打开模式为b(二进制模式)。 123456789&lt;?php$url = 'http://picturescdn.qiniudn.com/93aa93787ae02be68192b3533d3e76b0';$remote_fp = fopen($url,'rb');$local_fp = fopen(date('YmdHis'),'wb');while(!feof($remote_fp))&#123; fwrite($local_fp,fread($remote_fp,128));&#125;fclose($remote_fp);fclose($local_fp); 这样就在本地目录生成了一张图片。]]></content>
      <categories>
        <category>php</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bootstrap3禁用响应式布局]]></title>
    <url>%2F2014%2F09%2F18%2Fbootstrap3-disable-responsive-layout.html</url>
    <content type="text"><![CDATA[IE8及以下版本的浏览器确实是心中的痛,不支持媒体查询和CSS3，导致bootstrap样式怪怪的。没办法，只能采取折中的办法–禁用响应式布局 移除 viewport 标签 引入该CSS文件以重置bootstrap的响应式布局 这种情况下会导致一些高级浏览器不能得到最好的效果，所以，进阶的办法是: 利用PHP判断是否是IE8及以下版本的浏览器，如果不是，则进行正常的响应式布局。如果是，则禁用响应式布局]]></content>
      <categories>
        <category>front-end</category>
      </categories>
      <tags>
        <tag>bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Grunt快速上手]]></title>
    <url>%2F2014%2F09%2F18%2Fgrunt-get-started.html</url>
    <content type="text"><![CDATA[为什么要使用Grunt?一句话：自动化。对于需要反复重复的任务，例如压缩（minification）、编译、单元测试、linting等，自动化工具可以减轻你的劳动，简化你的工作。当你正确配置好了任务，任务运行器就会自动帮你或你的小组完成大部分无聊的工作。 怎么使用Grunt?1.grunt是基于nodejs的，所以请先安装nodejs和npm安装grunt2.新版本的grunt安装需要两步，终端执行 1npm install grunt-cli -g 3.进入项目目录，终端执行 1npm install grunt --save-dev 4.安装常用插件 1npm install grunt-contrib-cssmin grunt-contrib-uglify grunt-contrib-watch --save-dev 5.项目目录 1234567--dev |--js |-- jquery.js |-- main.js |--css |-- library.css |-- main.css 一个很简单的JS,CSS目录，很关键的任务在于如何定义Gruntfile.js文件（请在项目根目录下创建Gruntfile.js,大小写不能错）6.Gruntfile.js 12345678910111213141516171819202122232425262728module.exports = function(grunt) &#123; grunt.initConfig(&#123; cssmin: &#123; site: &#123; files: &#123; 'build/css/site.css': ['dev/css/library.css', 'dev/css/main.css'] &#125; &#125;, &#125;, uglify: &#123; site: &#123; src: ['dev/js/jquery.js', 'dev/js/main.js'], dest: 'build/js/site.js' &#125;, &#125;, watch: &#123; site: &#123; files: ['dev/js/**.*', 'dev/css/**.*'], tasks: ['uglify:site', 'cssmin:site'] &#125; &#125; &#125;); grunt.loadNpmTasks('grunt-contrib-cssmin'); grunt.loadNpmTasks('grunt-contrib-uglify'); grunt.loadNpmTasks('grunt-contrib-watch'); grunt.registerTask('site', ['watch:site']);&#125;; cssmin: site为一个子任务 build/css/site.css 为合并压缩之后的css存放路径,该参数后面的数组为原始的css文件路径 uglify: site为一个子任务 src数组为源JS文件 dest为合并压缩之后的js文件存放路径 watch site为一个子任务 files数组为监听哪些文件的变化 tasks数组为如果文件变化则执行什么任务 grunt.loadNpmTasks 加载模块 grunt.registerTask 注册新任务 在项目目录下打开CMD工具，输入 1grunt site 即开始执行监听，此时修改dev/js/main.js或者dev/css/main.css都会触发相应的事件。 结语从此以后再也不用进行重复的压缩合并…etc等一些重复而乏味的工作了，交给grunt吧！]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>grunt</tag>
        <tag>workflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[七牛云存储定义自定义变量返回数据]]></title>
    <url>%2F2014%2F09%2F18%2Fqiniu-custom-data.html</url>
    <content type="text"><![CDATA[背景七牛云存储也使用了这么久了。一直一来都只用了它的图片上传和处理功能。用的是客户端直传API，七牛给我返回一个key（一串随机的hash值，对人类无可读性）。 最近做的一个文件共享的项目，因为文件是客户端直传七牛的，那么我在后台PHP这边是拿不到原始文件名的，但是文件列表必须显示原始文件名，不能显示那个hash值。后来查找文件发现，七牛可以自定义返回的变量。 关键代码12345678910&lt;?phpQiniu_SetKeys($this-&gt;accessKey, $this-&gt;secretKey);$putPolicy = new Qiniu_RS_PutPolicy($this-&gt;bucket);$putPolicy-&gt;Expires = $expires;$putPolicy-&gt;SaveKey = $filename;$putPolicy-&gt;FsizeLimit = 20*1024*1024;if($returnUrl != '') putPolicy-&gt;ReturnUrl = $returnUrl;$upToken = $putPolicy-&gt;Token(null);return $upToken; 通过对 $filename参数进行定制 1$filename = '$(fsize)/$(fname)' 这样子七牛返回的hash应该是 1a3466b7fa159ab4f671bdc4ae45dae08/103/稿件共享.txt 通过 explode 函数就可以拿到文件名了。 题外话七牛还有很多自定义参数有待各位挖掘，这里只做个抛砖引玉的作用。]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>qiniu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux利用ssh公钥部署git代码]]></title>
    <url>%2F2014%2F09%2F15%2Flinux-public-key-git.html</url>
    <content type="text"><![CDATA[背景阿里云的使用门槛降低，直接导致了很多人优先使用VPS而不是以前的虚拟主机，毕竟虚拟主机存在诸多限制。阿里云犹如一台全新的服务器，所有软件都要自己安装。作为一个写PHP的，代码部署就略麻烦了，以前使用FTP的时候很方便部署，但是不适合长期开发（因为没有版本控制），所以使用GIT会很方便。 问题在windows开发机上使用https方式进行git操作是没问题的，但是在linux上进行git操作的时候就会出错误，会让你输入帐号密码，就算是对的帐号密码也不行。这种情况下需要使用 ssh 方式进行GIT。 解决方法 生成密钥 在终端下输入 ssh-keygen -t rsa 接下来的询问全部直接按回车 最后得到了两个文件：id_rsa和id_rsa.pub cat ~/.ssh/id_rsa.pub 将显示的内容全部复制下来 进入你的git网站，比如oschina的git 添加ssh公钥 保存 enjoy!]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux删除乱码文件]]></title>
    <url>%2F2014%2F09%2F13%2Flinux-delete-messy-code-file.html</url>
    <content type="text"><![CDATA[shell终端中有时候中文文件名会出现乱码，导致很多操作都不能进行，一个最简单的就是删除了。 linux中每个文件有类似于ID的东西，使用以下命令查看 1ll -i 显示出来的第一个数字就是文件的inum 可以利用以下命令进行删除操作,假设inum为111111 1find . -inum 11111 -exec rm -f &#123;&#125; \ rm -f {}可以自行替换为自己需要操作的命令。这样的话，不管什么文件都可以操作，只要有inum!]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>messy code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL联合主键]]></title>
    <url>%2F2014%2F09%2F13%2Fmysql-combined-primary-key.html</url>
    <content type="text"><![CDATA[单字段主键MySQL单字段主键相信大家都熟悉了。就是以一个字段主要数据行的主键，比如下面这个表 123456create table `user`(user_id int(11) auto_increment,username varchar(24),password char(32),primary key(user_id)); user_id作为单字段主键,说明任何用户的user_id都不能相同，一个user_id即标识一个用户。 多字段联合主键再看这个表 123456create table `user`(username varchar(24),password char(32),email varchar(40),primary key(username,email)); 这里使用username,email作为联合主键，为了标识一个用户，只有在username和email共同存在，且不同时才能标识。 例子1234username password emailzhangsan 111111 zhangsan@qq.comzhangsan 111111 lisi@qq.comlisi 111111 zhangsan@qq.com 这三条记录均为合法记录，多字段联合主键的核心就是（所有字段才能唯一确定一条记录，就像上面的username,email）。]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>combine primary key</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP正则表达式匹配中文]]></title>
    <url>%2F2014%2F09%2F13%2Fphp-regex-chinese.html</url>
    <content type="text"><![CDATA[正常的正则表达式匹配英文和数字以及一些常用字符还是很简单的，如 123/^\w$//^[0-9]$//^[\-\_]$/ 等等，但是匹配中文的话就有些麻烦了。UTF-8的中文根据unicode编码，所以我们需要手动构造UTF-8字符串 1/^[\x&#123;4e00&#125;-\x&#123;9fa5&#125;]$/u 请注意大括号，因为没有大括号PHP会报错 1Warning: preg_match() [function.preg-match]: Compilation failed: PCRE does not support \L, \l, \N, \U, or \u at offset 3 in test.php on line 3 因为\x是表示十六进制数的，所以需要用大括号括起来 另外，需要增加 u 修饰符。 此修正符启用了一个 PCRE 中与 Perl 不兼容的额外功能。模式字符串被当成 UTF-8。 本修正符在 Unix 下自 PHP 4.1.0 起可用，在 win32 下自 PHP 4.2.3 起可用。 很多时候google的作用确实比 X度 大，学会google吧！]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>regex</tag>
        <tag>chinese</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx url重写和pathinfo配置]]></title>
    <url>%2F2014%2F09%2F10%2Fnginx-urlrewritepathinfo.html</url>
    <content type="text"><![CDATA[nginx近年来的上涨趋势确实挺快的，但是apache作为老牌HTTP服务器，拥有的生态圈是nginx比不上的。一个最简单的例子，URL重写，apache的话利用无所不能的.htaccess文件就可以了。nginx还要改主配置文件。 URL重写配置主配置文件123456location /&#123; if (!-e $request_filename) &#123; rewrite ^/(.*)$ /index.php?$1 last; &#125;&#125; if和(中间要有括号,url重写这里就配置完了。 pathinfo配置nginx原生是不支持pathinfo的，但是通过配置fastcgi参数可以达到效果 主配置文件123456789location ~ [^/]\.php(/|$)&#123; # comment try_files $uri =404; to enable pathinfo #try_files $uri =404; fastcgi_pass unix:/tmp/php-cgi.sock; fastcgi_index index.php; include fastcgi.conf; include pathinfo.conf;&#125; fastcgi.conf1234567891011121314151617181920fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;fastcgi_param QUERY_STRING $query_string;fastcgi_param REQUEST_METHOD $request_method;fastcgi_param CONTENT_TYPE $content_type;fastcgi_param CONTENT_LENGTH $content_length;fastcgi_param SCRIPT_NAME $fastcgi_script_name;fastcgi_param REQUEST_URI $request_uri;fastcgi_param DOCUMENT_URI $document_uri;fastcgi_param DOCUMENT_ROOT $document_root;fastcgi_param SERVER_PROTOCOL $server_protocol;fastcgi_param HTTPS $https if_not_empty;fastcgi_param GATEWAY_INTERFACE CGI/1.1;fastcgi_param SERVER_SOFTWARE nginx/$nginx_version;fastcgi_param REMOTE_ADDR $remote_addr;fastcgi_param REMOTE_PORT $remote_port;fastcgi_param SERVER_ADDR $server_addr;fastcgi_param SERVER_PORT $server_port;fastcgi_param SERVER_NAME $server_name;# PHP only, required if PHP was built with --enable-force-cgi-redirectfastcgi_param REDIRECT_STATUS 200; pathinfo.conf1234fastcgi_split_path_info ^(.+?\.php)(/.*)$;set $path_info $fastcgi_path_info;fastcgi_param PATH_INFO $path_info;try_files $fastcgi_script_name =404; 结语从这些配置可以看出来，nginx的可定制性还是很强的，同样的，apache下的.htaccess文件，经过一些改写也能在nginx上成功运行~]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>pathinfo</tag>
        <tag>rewrite</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php OOP中的__get和__set方法]]></title>
    <url>%2F2014%2F09%2F07%2Fphp-oop-getter-setter.html</url>
    <content type="text"><![CDATA[get,set光看前面两个下划线就知道是魔术方法了，而且还是PHP OOP中比较重要的方法。 先看一段代码 12345678910&lt;?phpclass Account&#123; private $user = 1; private $pwd = 2;&#125;$a = new Account();echo $a-&gt;user;$a-&gt;name = 5;echo $a-&gt;name;echo $a-&gt;big; 运行这段代码结果是肯定会报错的！ 原因在于，不能访问私有属性user。利用get和set改进下这个类 123456789101112131415161718192021&lt;?phpclass Account&#123; private $user = 1; private $pwd = 2; public function __set($name,$value)&#123; $this-&gt;name = $value; &#125; public function __get($name)&#123; if(!isset($this-&gt;name))&#123; $this-&gt;name = '这是默认值'; &#125; return $this-&gt;name; &#125;&#125;$a = new Account();echo $a-&gt;user;$a-&gt;name = 5;echo $a-&gt;name;echo $a-&gt;big; 运行之后就不会报错了。 现在有了这两个魔术方法就可以随时扩展类里面的属性了，是不是很方便呢？]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>getter</tag>
        <tag>oop</tag>
        <tag>setter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[摆脱jquery!angularjs利用指令简单实现滚动翻页]]></title>
    <url>%2F2014%2F09%2F06%2Fangularjs-lazy-load.html</url>
    <content type="text"><![CDATA[移动开发一个很重要的问题是翻页操作，而现在的主流都是滚动翻页，以往都是用jquery的插件进行实现。用了angularjs之后，要逐步减轻对jquery的依赖。 滚动翻页基本原理就是判断scrollTop和offsetHeight之和 大于等于 scrollHeight 代码指令12345678910app.directive('whenScrolled', function() &#123; return function(scope, elm, attr) &#123; var raw = elm[0]; elm.bind('scroll', function() &#123; if (raw.scrollTop+raw.offsetHeight &amp;gt;= raw.scrollHeight) &#123; scope.$apply(attr.whenScrolled); &#125; &#125;); &#125;; &#125;); 控制器1234567891011121314151617$scope.loadMore = function() &#123; if ($scope.currentPage &amp;lt; $scope.pages) &#123; $scope.currentPage++; if ($scope.busy) &#123; return false; &#125; $scope.busy = true; $http.get('/api.php?r=site/list/page/'+$scope.currentPage+'/limit/'+$scope.limit).success(function(data) &#123; $scope.busy = false; for (var i in data.data) &#123; $scope.newses.push(data.data[i]); &#125; $scope.pages = Math.ceil(data.total/$scope.limit); $rootScope.title = '首页 - 微文章'; &#125;); &#125; &#125;; 视图123&lt;div when-scrolled="loadMore()"&gt;//内容处理逻辑&lt;/div&gt;]]></content>
      <categories>
        <category>angularjs</category>
      </categories>
      <tags>
        <tag>angularjs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP将日期转换为星座]]></title>
    <url>%2F2014%2F09%2F06%2Fphp-convert-date-to-constellation.html</url>
    <content type="text"><![CDATA[这几日在做的一个项目发现一个很有意思的东西，就是PHP将指定日期输出为星座 12345678910111213141516171819202122&lt;?phpfunction constellation($month, $day) &#123; if ($month &lt; 1 || $month &gt; 12 || $day &lt; 1 || $day &gt; 31) return false; $constellations = array( array("20" =&gt; '水瓶座'), array("19" =&gt; '双鱼座'), array("21" =&gt; '白羊座'), array("20" =&gt; '金牛座'), array("21" =&gt; '双子座'), array("22" =&gt; '巨蟹座'), array("23" =&gt; '狮子座'), array("23" =&gt; '处女座'), array("23" =&gt; '天秤座'), array("24" =&gt; '天蝎座'), array("22" =&gt; '射手座'), array("22" =&gt; '摩羯座') ); list($constellation_start, $constellation_name) = each($constellations[(int)$month - 1]); if ($day &lt; $constellation_start) list($constellation_start, $constellation_name) = each($constellations[($month - 2 &lt; 0) ? $month = 11 : $month -= 2]); return $constellation_name;&#125;]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>constellation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ngResource快速上手]]></title>
    <url>%2F2014%2F09%2F06%2Fng-resource-get-started.html</url>
    <content type="text"><![CDATA[废话不多说，本文的目的就是看过之后就会使用ngResource了。 引入angular-resource.min.js 定义模块时加载ngResource 定义service 完整代码如下 1234567891011121314151617181920212223var app = angular.module('app', ["ngResource"]);app.factory('Phone', ['$resource',function($resource) &#123; return $resource('user/:uid', &#123; uid: '@uid' &#125;, &#123; update: &#123; method: 'PUT' &#125; &#125;);&#125;]);app.controller('MainCtrl', ['$scope', 'Phone',function($scope, Phone) &#123; $scope.phones = Phone.query(); Phone.update(&#123; uid: 1 &#125;, &#123; name: "zhangsan", age: "10" &#125;);&#125;]);]]></content>
      <categories>
        <category>angularjs</category>
      </categories>
      <tags>
        <tag>ng-resource</tag>
        <tag>restful</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP heredoc 字符串定界符使用]]></title>
    <url>%2F2014%2F09%2F06%2Fphp-heredoc.html</url>
    <content type="text"><![CDATA[PHP定义字符串有三种形式 双引号 单引号 heredoc定界符 前面两种大家都很熟悉了，第三种大家用的少。一般在输出大段HTML的时候很方便，不多说，上代码！ 12345&lt;?php$link = 'https://www.google.com.hk';print &lt;&lt;&lt;DOGS &lt;a href="&#123;$link&#125;"&#125;Google&lt;/a&gt;DOGS; DOGS可以自己定义。]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>heredoc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery插件写法]]></title>
    <url>%2F2014%2F09%2F06%2Fjquery-write-a-plugin.html</url>
    <content type="text"><![CDATA[项目地址http://xialeistudio.github.io/search/ jquery插件确实是数不胜数，只要你用心找，肯定能找得到! 但是一些小功能想自己写，找的话估计时间还长些，本文简单开发一个 基于jquery的获取url查询字符串的 小插件。 插件的模版（$.extend扩展jquery内置方法) 1234(function($) &#123; $.x_search = function(_name,target) &#123; //x_search是插件名字,_name、target是参数 &#125;;&#125;)(jQuery); 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * $.x_search * @extends jquery 2.1.1(基于该版本开发，其他版本自测) * @fileOverview 获取url queryString * @author xialeistudio * @email 1065890063@qq.com * @site www.ddhigh.com * @version 0.0.1 * @date 2014-08-12 * @license MIT * @example * 获取当个Key * $.x_search('name'); * 获取所有 * $.x_search(); */ (function($) &#123; $.x_search = function(_name,target) &#123; if(typeof target == 'undefined')&#123; target = window.location.search; &#125; if (typeof _name == 'undefined') &#123; //所有 var query =target.substr(1, window.location.search.length-1).split('&amp;'); var data = []; for (var i = 0; i &lt; query.length; i++) &#123; var tmp = query[i].split('='); data.push(&#123; key: tmp[0], data: decodeURIComponent(tmp[1]) &#125;); &#125; return data; &#125; else &#123; //指定Key try &#123; var regex = new RegExp(_name+'=([^&amp;]+)?'); return decodeURIComponent(target.match(regex)[1]); &#125; catch (e) &#123; return null; &#125; &#125; &#125;; &#125;)(jQuery);]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>jquery plugin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bower快速入门]]></title>
    <url>%2F2014%2F09%2F06%2Fbower-get-started.html</url>
    <content type="text"><![CDATA[简介bower是twitter的又一个开源项目，使用nodejs开发，用于web包管理。如果越来越多得开源项目都托管在github上，bower只需要将github上项目加上一个配置文件既可以使用bower方式使用安装包。作为包管理，bower能提供添加新web包，更新web包，删除web包，发布web包功能，管理包依赖。web包通常认为由html+css+javascript构成。 安装bower1npm install bower -g 请确保你有Nodejs环境 在项目目录中运行 1bower install jquery 运行成功之后项目中会多出components文件夹，文件夹中jquery文件夹，jquery文件夹里面就有最新的jquery文件。 这还不能说明他NB的地方，试想下面的场景，jQuery升级了，是不是再down一次jQuery呢？bower可以这样做： 1bower update jquery 就可以自动升级到最新版的jquery了。 再假设我们需要使用bootstrap，bootstrap可不是一个文件，有css,js还有图片。js还依赖于jQuery，如果使用bower： 1bower install bootstrap bower会自动从github上down最新的代码，而且，会自动将依赖包jquery也down一次。 如果你发布程序的时候不想把一些依赖的库发布上去（主要原因是太大了 - - ），可以在项目根目录下生成一个 bower.json 文件用来管理依赖。 在项目目录下执行 1bower init 按照提示操作就好，这样子会生成一个bower文件 安装 jquery 1bower install jquery --save 这样子 bower.json 文件就会写入一个 Jquery的依赖项 别人只要在项目目录下输入 1bower install 就会自动安装了]]></content>
      <categories>
        <category>front-end</category>
      </categories>
      <tags>
        <tag>bower</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php使用CORS实现跨域请求]]></title>
    <url>%2F2014%2F09%2F06%2Fphp-cors-crossdomain.html</url>
    <content type="text"><![CDATA[js跨域的解决方法，一百度一大堆，不过都是jsonp为主，这种解决方法只适用于GET请求。POST跨域的话需要在HTTP协议上下功夫。 基础知识主要会用到以下几个响应头 Access-Control-Allow-Origin：允许哪些url可以跨域请求到本域 Access-Control-Allow-Methods:允许的请求方法，一般是GET,POST,PUT,DELETE,OPTIONS Access-Control-Max-Age：表明在该时间段内不再“预检”允许的请求方法（相当于缓存），即不以OPTIONS方法进行请求 Access-Control-Allow-Headers：允许哪些请求头可以跨域 php代码1234567&lt;?phpheader('Access-Control-Allow-Origin:*');header('Access-Control-Allow-Methods:POST');header('Access-Control-Max-Age:60');header('Access-Control-Allow-Headers:x-requested-with,content-type');header('Content-Type:application/json;charset=utf-8');print_r(file_get_contents('php://input'));]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>cors</tag>
        <tag>crossdomain</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云ECS服务器phpmailer发信失败解决方法]]></title>
    <url>%2F2014%2F09%2F06%2Faliyun-phpmailer.html</url>
    <content type="text"><![CDATA[phpmailer之前一直在用，一般都是采用smtp登录服务器的方式进行发信，今天在本地windows主机测试也能发信成功，但是到线上去就不行了，提示“连接smtp服务器失败”。首先可以排除的是代码方面的错误，那么剩下就知道服务器的问题了。 根据这个错误，可以想到有几种问题: 服务器ping不通，做Ping测试的时候是通的 服务器端口没开，用telnet测试的时候也是这样的 后来在服务器上用php代码测试163邮箱发现可以发信，但是腾讯的就不行，看了下邮箱配置发现是SSL的问题，然后在服务器上输出phpinfo()发现没有openssl扩展。接下来就是安装扩展了。 首先进到php的源码包，前往ext/openssl目录 执行 phpize 这个会自动配置 然后执行 123./configure --with-openssl -with-php-config=/usr/local/php/bin/php-configmakemake install 这里模块安装就完成了，但是需要编辑 /etc/php.ini加上 1extension=openssl.so 重启 web 服务器就可以了。经过测试，服务器上SSL发信也能成功进行]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>phpmailer</tag>
        <tag>aliyun</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx虚拟主机配置]]></title>
    <url>%2F2014%2F09%2F06%2Fnginx-virtual-host.html</url>
    <content type="text"><![CDATA[最近服务器上用的环境是lnmp，之前一直在用apache，配置虚拟主机也是很方便的。今天查资料发现Nginx的虚拟主机配置更加简单。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859server &#123; listen 80; server_name domain1; location / &#123; root html/domain1; index index.html index.htm index.php; &#125; location ~ \.php$ &#123; root html/domain1; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; &#125;&#125;server &#123; listen 80; server_name domain2; location / &#123; root html/domain2; index index.html index.htm index.php; &#125; location ~ \.php$ &#123; root html/domain2; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; &#125;&#125; 保存之后，执行 1nginx -s reload]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>virtual hosts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yii同一站点配置多个用户角色]]></title>
    <url>%2F2014%2F09%2F06%2Fyii-multi-user.html</url>
    <content type="text"><![CDATA[Yii是基于组件的PHP MVC框架，yii的用户组件调用很方便，但是如果有遇到一个站点有多种用户的时候，如前台用户，后台用户，就需要增加User组件了。 简单来说，就是新建一个用户类去继承 CWebUser类，比如 WebUser继承CWebUser，配置文件在components中增加 123'user'=&gt;array( 'class'=&gt;'WebUser') 以上就创建了一个前台用户,调用方式 Yii::app()-&gt;user 后台用户可以这么写 AdminUser继承CWebUser,配置文件在components中增加 123'admin'=&gt;array( 'class'=&gt;'AdminUser') 这样就创建了一个后台用户，调用方式 Yii::app()-&gt;admin 这种方法是本人所知最科学的，比用session来区分好多了。毕竟很多时候，能用框架现有的方法就用框架的方法。]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>yii</tag>
        <tag>multi user</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angularjs指令数据远程请求的处理]]></title>
    <url>%2F2014%2F09%2F06%2Fangularjs-load-remote-data-on-directive.html</url>
    <content type="text"><![CDATA[假设有一个指令用来根据IP地址进行地位，获取实际地址。 首先，我们的IP地址是由后台PHP程序返回的，这里需要一个Http请求，使用了Http请求就会有类似回调的问题，之前想了各种办法，死活拿不到数据，后来去ng官网看了下，需要使用ngModel，这个是双向绑定。 指令代码123456789101112131415app.directive('location', ['ApiService', function (ApiService) &#123; return &#123; restrict: 'A', require:'ngModel', link: function (scope, ele, attrs,ngModel) &#123; ele.addClass('opt'); ele.bind('click', function () &#123; ele.text('定位中...'); ApiService.location(ngModel.$viewValue).success(function (data) &#123; ele.text(data.country + ' ' + data.region + ' ' + data.city + ' ' + data.isp); &#125;); &#125;); &#125; &#125;;&#125;]); HTML部分1&lt;span location ng-model="user.login_ip"&gt;定位&lt;/span&gt; JS中的ngModel 会去搜索该指令的元素上的ng-model指令，这里会搜索到一个user.login_ip 的model,然后JS中使用ngModel.$viewValue 就可以拿到值了。]]></content>
      <categories>
        <category>angularjs</category>
      </categories>
      <tags>
        <tag>ng-model</tag>
        <tag>directive</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angularjs自动保存指令]]></title>
    <url>%2F2014%2F09%2F06%2Fangularjs-autosave-directive.html</url>
    <content type="text"><![CDATA[angularjs的指令真是好东西，也是精髓。刚才群里面有朋友在问如何在用户离开编辑区域时提醒保存，其实用指令实现很简单的。 请注意，这里使用的指令标签为ajax-submit 12345678910111213141516171819202122232425262728293031app.directive('ajaxSubmit', [ '$http', function($http) &#123; return &#123; link: function(scope, ele, attrs) &#123; var old = ele.val(); ele.bind('blur', function() &#123; var url = ele.data('url'); var val = ele.val(); ele.prop('disabled', true); //发送http $http.post(url, &#123; data: val &#125;).success(function(data) &#123; ele.prop('disabled', false); if (data.msg != undefined) &#123; old = val; ele.after('操作成功'); setTimeout(function() &#123; ele.next().remove(); &#125;, 1000); &#125; else &#123; alert(data.error); &#125; &#125;); &#125;); &#125; &#125; &#125;]); 关键是利用指令的link函数获取包装后的jq元素，然后给该元素进行事件绑定，其实很多的事件绑定都是这样做的。事件处理函数中的业务逻辑各位看官可以自行修改~。]]></content>
      <categories>
        <category>angularjs</category>
      </categories>
      <tags>
        <tag>auto save</tag>
        <tag>timer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PDO简明教程，是时候抛弃mysql_*函数了]]></title>
    <url>%2F2014%2F09%2F06%2Fpdo-get-started.html</url>
    <content type="text"><![CDATA[mysql_*系列函数我一之前一直在用，基于性能、安全性等原因，再加上PHP面向对象的增强，是时候使用PDO来处理数据了。PDO一个很重要的特点是该类与数据库无关，不同的数据库只是在实例化时传入的参数不同，但是操作方法是一样的。 1234567891011121314151617181920212223&lt;?phptry &#123; $pdo = new PDO('mysql:host=localhost;dbname=test','root','root'); //查询数据 $stmt = $pdo-&gt;prepare('SELECT * FROM user WHERE sex=?'); $sex = 'male'; $stmt-&gt;bindParam(1,$sex); $stmt-&gt;setFetchMode(PDO::FETCH_ASSOC); $list = $stmt-&gt;fetchAll(); //查询完毕 //写入数据 $stmt = $pdo-&gt;prepare('INSERT INTO user VALUES (?,?,?)'); $username = 'admin'; $password = md5('111111'); $sex = 'male'; $stmt-&gt;bindParam(1,$username); $stmt-&gt;bindParam(2,$password); $stmt-&gt;bindParam(3,$sex); $stmt-&gt;execute(); //写入完毕&#125; catch (Exception $e) &#123; echo $e-&gt;getMessage();&#125; 编辑、更新、删除统称为写入操作，大家可以举一反三~ execute会返回受影响的函数，有可能为0行!请大家在判断时用 === 而不是 == , 0 == false 而 0 !== false]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>pdo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php中文字符串反转]]></title>
    <url>%2F2014%2F09%2F06%2Fphp-chinese-reverse.html</url>
    <content type="text"><![CDATA[php strrev() 函数能实现字符串反转，但是不支持中文，利用mb_系列函数可以进行中文字符串反转。 12345678910111213141516/** * 中文字符串反转 * @param $str * @param string $charset * @return string */function reverse($str, $charset = 'UTF-8')&#123; $ret = ''; $len = mb_strlen($str, $charset); for ($i = 0; $i &lt; $len; $i++) &#123; $ret[] = mb_substr($str, $i, 1, $charset); &#125; return implode('', array_reverse($ret));&#125;]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>reverse words</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis初探]]></title>
    <url>%2F2014%2F09%2F06%2Fredis-get-started.html</url>
    <content type="text"><![CDATA[Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。我本地的PHP是 5.4.25 ts版本，这里是php_redis扩展（只限于5.4.x TS版本）。 ext.zip 打开php.ini 添加以下两行 12extension=php_igbinary.dllextension=php_redis.dll 请注意顺序！ 重启web服务器就可以了。 示例代码12345678910111213141516&lt;?php$redis = new Redis();$redis-&gt;connect('127.0.0.1');//存储一个值$redis-&gt;set('name', 'zhangsan', 5);//存储多个值$array = array( 'name' =&gt; '张三', 'sex' =&gt; 'male', 'age' =&gt; 10);$array_get=array( 'name','sex','age');$redis-&gt;mset($array);print_r($redis-&gt;mget($array_get)); 本文只起到抛砖引玉的作用，详细的使用有待大家挖掘~]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
</search>
