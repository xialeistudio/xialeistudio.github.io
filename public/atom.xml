<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>每天进步一点点</title>
  
  <subtitle>Coding Change Anything</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https//www.ddhigh.com/"/>
  <updated>2019-07-29T03:30:43.199Z</updated>
  <id>https//www.ddhigh.com/</id>
  
  <author>
    <name>xialeistudio</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TS简明教程(2)</title>
    <link href="https//www.ddhigh.com/2019/07/29/typescript-quick-guide2.html"/>
    <id>https//www.ddhigh.com/2019/07/29/typescript-quick-guide2.html</id>
    <published>2019-07-29T02:11:30.000Z</published>
    <updated>2019-07-29T03:30:43.199Z</updated>
    
    <content type="html"><![CDATA[<p>为了后续内容(如<code>nestjs</code>等框架)的开展，本文更新TS相关的基础知识。</p><p>关注获取更多<code>TS精品文章</code><br><img src="https://more-happy.ddhigh.com/FuFpZh9QTZVatcBtupR4MtOGPGTJ?imageView2/1/w/200" alt="二维码"></p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>传统JS使用<code>函数</code>和<code>原型链</code>进行集成，在<code>ES6</code>出现了<code>class</code>关键，JS也能使用传统OOP的方式进行继承，但是还是存在一定的局限性，在TS中，OOP已经和传统语言差不多。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Parent &#123;</div><div class="line">    name: <span class="built_in">string</span>;</div><div class="line">    age: <span class="built_in">number</span>;</div><div class="line"></div><div class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    say() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">`name: <span class="subst">$&#123;this.name&#125;</span>, age: <span class="subst">$&#123;this.age&#125;</span>`</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> parent = <span class="keyword">new</span> Parent();</div><div class="line">parent.say();</div></pre></td></tr></table></figure><p>可以看到TS的OOP写法和Java还是有点类似的。但是他两的构造方法名不同，TS构造方法名为<code>constructor</code>，Java是<code>类名</code>。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承用来扩展现有的类，TS中这一点和传统语言一样使用<code>extends</code>语法。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Parent &#123;</div><div class="line">    name: <span class="built_in">string</span>;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">    say() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">`Parent say: <span class="subst">$&#123;this.name&#125;</span>`</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Child <span class="keyword">extends</span> Parent &#123;</div><div class="line">    age: <span class="built_in">number</span>;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123; <span class="comment">// 覆盖父类构造方法</span></div><div class="line">        <span class="keyword">super</span>(name); <span class="comment">// 调用父类构造方法</span></div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line">    say() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">`Child say: <span class="subst">$&#123;this.name&#125;</span> <span class="subst">$&#123;this.age&#125;</span>`</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> child: Parent = <span class="keyword">new</span> Child(<span class="string">"haha"</span> ,<span class="number">1</span>);</div><div class="line">child.say(); <span class="comment">// 输出 Child say haha 1</span></div></pre></td></tr></table></figure><ol><li>子类存在构造方法时，必须<code>显示调用</code>父类构造方法<code>先有父亲，后有儿子</code></li><li>TS方法调用是基于<code>值</code>而不是基于<code>类型声明</code>，比如<code>child</code>声明为<code>Parent</code>类型，但是值是子类型，所以调用方法时会调用<code>子类</code>的<code>say</code></li></ol><h2 id="访问限定符"><a href="#访问限定符" class="headerlink" title="访问限定符"></a>访问限定符</h2><h3 id="public"><a href="#public" class="headerlink" title="public"></a>public</h3><p>TS中方法和属性默认的访问限定符为<code>public</code>，所有外部或内部成员都可访问。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Parent &#123;</div><div class="line">    <span class="keyword">public</span> name: <span class="built_in">string</span>; <span class="comment">// public可以不加</span></div><div class="line">    say() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">`say <span class="subst">$&#123;this.name&#125;</span>`</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Parent();</div><div class="line">p.name = <span class="string">'hello'</span>;</div><div class="line">p.say(); <span class="comment">// 输出 say hello</span></div></pre></td></tr></table></figure><h3 id="private"><a href="#private" class="headerlink" title="private"></a>private</h3><p>私有访问，只能在<code>本类</code>访问,<code>子类和其他类都不行</code>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Parent &#123;</div><div class="line">    <span class="keyword">private</span> name: <span class="built_in">string</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> say() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">`say <span class="subst">$&#123;this.name&#125;</span>`</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Parent();</div><div class="line">p.name = <span class="string">'hello'</span>; <span class="comment">// 错误，private限定的属性不能被外部访问</span></div><div class="line">p.say(); <span class="comment">// 错误，private限定的访问不能被外部访问</span></div></pre></td></tr></table></figure><h3 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h3><p>保护性访问，只能<code>被本类或本类的子类(子类的子类也可以访问)</code>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Parent &#123;</div><div class="line">    <span class="keyword">protected</span> name: <span class="built_in">string</span>;</div><div class="line"></div><div class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> say() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">`say <span class="subst">$&#123;this.name&#125;</span>`</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Child <span class="keyword">extends</span> Parent &#123;</div><div class="line">    <span class="keyword">public</span> say() &#123; <span class="comment">// 提升访问性</span></div><div class="line">        <span class="built_in">console</span>.log(<span class="string">`say <span class="subst">$&#123;this.name&#125;</span>`</span>); <span class="comment">// 访问父类属性</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Child(<span class="string">'hello'</span>);</div><div class="line">c.say(); <span class="comment">// 输出 say hello</span></div></pre></td></tr></table></figure><p>访问限定符只能提升，不能降低，如下例子是<code>无法通过编译的</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Parent &#123;</div><div class="line">    <span class="keyword">protected</span> name: <span class="built_in">string</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Child <span class="keyword">extends</span> Parent &#123;</div><div class="line">    <span class="keyword">private</span> name: <span class="built_in">string</span>; <span class="comment">// 错误，子类访问性必须&gt;=父类的访问性</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="只读限定"><a href="#只读限定" class="headerlink" title="只读限定"></a>只读限定</h2><p>TS使用<code>readonly</code>声明只读<code>属性(方法不能使用)</code>，必须在<code>声明时</code>或者<code>构造时</code>进行赋值,<code>其他地方不能赋值</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Parent &#123;</div><div class="line">    <span class="keyword">private</span> readonly name = <span class="string">'hello'</span>;</div><div class="line">    <span class="keyword">private</span> readonly age: <span class="built_in">number</span>;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">age: <span class="built_in">number</span></span>) &#123;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="参数属性"><a href="#参数属性" class="headerlink" title="参数属性"></a>参数属性</h2><p>在上例中我们在构造方法中使用<code>this.age = age</code>对已存在的<code>私有只读属性age</code>进行了赋值。由于该操作时常用操作，所以TS有了更加便捷的写法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Parent &#123;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">readonly name: <span class="built_in">string</span>, <span class="keyword">private</span> readonly age: <span class="built_in">number</span></span>) &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    say() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">`say <span class="subst">$&#123;this.name&#125;</span> <span class="subst">$&#123;this.age&#125;</span>`</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上例中声明了<code>公有只读的name属性，私有只读的age属性</code></p><h2 id="getter-amp-amp-setter"><a href="#getter-amp-amp-setter" class="headerlink" title="getter &amp;&amp; setter"></a>getter &amp;&amp; setter</h2><p>在传统语言中，几乎不会直接声明公有属性，然后对其进行操作，都会先定义私有属性，然后提供<code>getter</code>和<code>setter</code>方法对其操作(<code>Java中很多类都是这种情况</code>)</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Parent &#123;</div><div class="line">    <span class="keyword">private</span> _name: <span class="built_in">string</span>;</div><div class="line"></div><div class="line">    <span class="keyword">get</span> name(): <span class="built_in">string</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">set</span> name(name: <span class="built_in">string</span>) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">`name设置前: <span class="subst">$&#123;this._name&#125;</span> 设置后: <span class="subst">$&#123;name&#125;</span>`</span>);</div><div class="line">        <span class="keyword">this</span>._name = name;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> parent = <span class="keyword">new</span> Parent();</div><div class="line">parent.name = <span class="string">'ok'</span>; <span class="comment">// 可以直接使用赋值语句，但是会自动调用set name(name: string)方法</span></div></pre></td></tr></table></figure><p>getter和setter方法提高了开发者对属性的控制，一起对属性的访问都是可控的，为以后的扩展性打下了基础（比如如果需要加缓存，我们可以在set时设置缓存,get时读取缓存，如果是直接操作属性的话，该功能实现起来很麻烦</p><h2 id="静态属性-amp-amp-静态方法"><a href="#静态属性-amp-amp-静态方法" class="headerlink" title="静态属性 &amp;&amp; 静态方法"></a>静态属性 &amp;&amp; 静态方法</h2><p>以上讨论的都是<code>实例属性和梳理方法</code>，需要有实例才能调用，如果有些属性或方法并不是存在于实例上时可以使用静态方法或静态属性</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Parent &#123;</div><div class="line">    <span class="keyword">static</span> name: <span class="built_in">string</span>;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> say() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">`name <span class="subst">$&#123;this.name&#125;</span>`</span>); <span class="comment">// 方法是静态，属性是静态时可以使用this</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">Parent.say();<span class="comment">// 使用类名调用静态方法</span></div></pre></td></tr></table></figure><p>需要注意的是<code>实例可以直接调用静态，静态不能直接调用实例</code>，因为<code>实例需要实例化后调用</code></p><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>传统语言中接口只包含实现，不包含细节。而抽象类可以包含细节。一般来说，有些公有方法可以放到抽象类做，不同的子类完成不同功能的代码可以放到抽象类做。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Animal &#123;</div><div class="line">    <span class="keyword">abstract</span> say(): <span class="built_in">void</span>; <span class="comment">// 声明抽象方法，子类必须实现</span></div><div class="line"></div><div class="line">    eat() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">`animal eat`</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Human <span class="keyword">extends</span> Animal &#123; <span class="comment">// 使用extends关键字</span></div><div class="line">    say() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'human say words'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Dog <span class="keyword">extends</span> Animal &#123;</div><div class="line">    say() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'dog say wangwang'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口用来限定子类的行为，不关心具体实现。与传统语言不同的是,TS接口还可以限定变量或常量的属性</p><p>限定子类行文：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> Animal &#123;</div><div class="line">    say(): <span class="built_in">void</span>;</div><div class="line">    eat(): <span class="built_in">void</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Human <span class="keyword">implements</span> Animal &#123;</div><div class="line">    say() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'human say'</span>);</div><div class="line">    &#125;</div><div class="line">    eat() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'human eat'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>限定变量属性：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> A &#123;</div><div class="line">    name?: <span class="built_in">string</span>;</div><div class="line">    age: <span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">const</span> obj: A = &#123;</div><div class="line">    age: <span class="number">10</span>,</div><div class="line">    <span class="comment">// name是可选的</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h3 id="可索引类型"><a href="#可索引类型" class="headerlink" title="可索引类型"></a>可索引类型</h3><p>使用<code>可索引类型</code>来<code>描述</code>可以通过<code>索引访问得到</code>的类型。如<code>person[&quot;name&quot;]</code>,<code>list[0]</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> HashMap &#123;</div><div class="line">    [key: <span class="built_in">string</span>]: <span class="built_in">any</span>; <span class="comment">// 冒号左边为属性名类型，右边为值类型</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> map: HashMap = &#123;&#125;;</div><div class="line">map[<span class="string">"name"</span>] = <span class="string">"1"</span>;</div><div class="line">map.a = <span class="string">"2"</span>;</div></pre></td></tr></table></figure><h3 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h3><p>与类继承类似，接口也可以通过继承来扩展现有的功能：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> Animal &#123;</div><div class="line">    eat(): <span class="built_in">void</span>; <span class="comment">// 动物会吃，但是怎么吃的不管</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">interface</span> Human <span class="keyword">extends</span> Animal &#123;</div><div class="line">    say(): <span class="built_in">void</span>; <span class="comment">// 人会说话，但是怎么说，说什么不管</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="混合类型"><a href="#混合类型" class="headerlink" title="混合类型"></a>混合类型</h3><p>JS中，函数可以直接调用也可以通过对象方式调用，TS中可以通过接口声明被修饰的函数支持的调用方式：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> Counter &#123;</div><div class="line">    (start: <span class="built_in">number</span>): <span class="built_in">string</span>;</div><div class="line">    step: <span class="built_in">number</span>;</div><div class="line">    reset(): <span class="built_in">void</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCounter</span>(<span class="params"></span>): <span class="title">Counter</span> </span>&#123;</div><div class="line">    <span class="keyword">const</span> counter = &lt;Counter&gt; <span class="function"><span class="keyword">function</span>(<span class="params">start: <span class="built_in">number</span></span>) </span>&#123;&#125;;</div><div class="line">    counter.step = <span class="number">1</span>;</div><div class="line">    counter.reset = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">const</span> c = getCounter();</div><div class="line">c(<span class="number">1</span>);</div><div class="line">c.reset();</div><div class="line">c.step = <span class="number">2</span>;</div></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>面向对象中的类和接口内容实在是太多了，本文只选择了开发中常用到的用法进行说明，不足之处，敬请包涵。<br>对TS有兴趣的小伙伴可以扫码加我进行交流<br><img src="https://more-happy.ddhigh.com/Fg5UE615NzZ0dXo6_gUe6qpCJILG?imageView2/1/w/200" alt="微信"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为了后续内容(如&lt;code&gt;nestjs&lt;/code&gt;等框架)的开展，本文更新TS相关的基础知识。&lt;/p&gt;
&lt;p&gt;关注获取更多&lt;code&gt;TS精品文章&lt;/code&gt;&lt;br&gt;&lt;img src=&quot;https://more-happy.ddhigh.com/FuFpZh9QTZV
      
    
    </summary>
    
      <category term="frontend" scheme="https//www.ddhigh.com/categories/frontend/"/>
    
    
      <category term="typescript" scheme="https//www.ddhigh.com/tags/typescript/"/>
    
      <category term="ts" scheme="https//www.ddhigh.com/tags/ts/"/>
    
  </entry>
  
  <entry>
    <title>手把手从零开始小程序单元测试(附避坑指南以及源码跟踪)</title>
    <link href="https//www.ddhigh.com/2019/07/27/miniprogram-unit-test.html"/>
    <id>https//www.ddhigh.com/2019/07/27/miniprogram-unit-test.html</id>
    <published>2019-07-27T10:35:49.000Z</published>
    <updated>2019-07-29T02:12:36.045Z</updated>
    
    <content type="html"><![CDATA[<p>单元测试是一个老生常谈的话题，基于Web/NodeJs环境的测试框架、测试教程数不胜数，也趋于成熟了。但是对于微信小程序的单元测试，目前还是处于起步状态，这两天在研究微信小程序的测试，也遇到了一些坑，在这里记录一下，希望给看到本文的小伙伴带来一点帮助，少走一些弯路。</p><p>本文内容有点多，但是干货满满，不明白的小伙伴可以关注公众号给我留言<br><img src="https://more-happy.ddhigh.com/FuFpZh9QTZVatcBtupR4MtOGPGTJ?imageView2/1/w/200" alt="二维码"></p><h2 id="demo地址"><a href="#demo地址" class="headerlink" title="demo地址"></a>demo地址</h2><p><a href="https://github.com/xialeistudio/miniprogram-unit-test-demo" target="_blank" rel="external">https://github.com/xialeistudio/miniprogram-unit-test-demo</a></p><h2 id="关键依赖版本"><a href="#关键依赖版本" class="headerlink" title="关键依赖版本"></a>关键依赖版本</h2><p>本文写作时相关依赖版本如下(版本不同，源码行数可能不同)：</p><ol><li>miniprogram-simulate: 1.0.7</li><li>j-component: 1.1.6</li><li>miniprogram-exparser: 0.0.6</li></ol><h2 id="测试流程"><a href="#测试流程" class="headerlink" title="测试流程"></a>测试流程</h2><ol><li>初始化小程序项目，编写待测试组件</li><li>安装jest,miniprogram-simulate测试环境</li><li>编写测试用例</li><li>执行测试</li></ol><h2 id="初始化小程序项目"><a href="#初始化小程序项目" class="headerlink" title="初始化小程序项目"></a>初始化小程序项目</h2><ol><li>使用小程序开发者工具初始化新项目，APPID选择<code>测试号</code>即可，语言选择<code>Javascript</code>。</li><li>使用小程序开发者工具新建<code>/components/user</code>组件</li><li><p><code>components/user.js</code></p> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// components/user.js</span></div><div class="line">Component(&#123;</div><div class="line">    data: &#123;</div><div class="line">        nickname: <span class="string">''</span></div><div class="line">    &#125;,</div><div class="line">    methods: &#123;</div><div class="line">        handleUserInfo: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.setData(&#123; <span class="attr">nickname</span>: e.detail.userInfo.nickName &#125;)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></li><li><p><code>components/user.wxml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">"nickname"</span>&gt;</span>&#123;&#123;nickname&#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"button"</span> <span class="attr">open-type</span>=<span class="string">"getUserInfo"</span> <span class="attr">bindgetuserinfo</span>=<span class="string">"handleUserInfo"</span>&gt;</span>Oauth<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div></pre></td></tr></table></figure></li><li><p><code>pages/index/index.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Page(&#123;</div><div class="line">    data:&#123;&#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></li><li><p><code>pages/index/index.wxml</code></p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">user</span>&gt;</span><span class="tag">&lt;/<span class="name">user</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></div></pre></td></tr></table></figure></li><li><p>打开小程序开发者工具，可以看到有一个<code>Oauth</code>按钮，点击之后会在上面显示昵称。</p></li><li>由此可以得到测试用例<code>点击授权按钮时上方显示为授权用户的昵称</code></li></ol><h2 id="安装jest-miniprogram-simulate测试环境"><a href="#安装jest-miniprogram-simulate测试环境" class="headerlink" title="安装jest/miniprogram-simulate测试环境"></a>安装jest/miniprogram-simulate测试环境</h2><ol><li>由于JS项目的小程序根目录没有<code>package.json</code>，需要手动生成一下</li><li>打开终端，在项目根目录执行<code>npm init -y</code>生成<code>package.json</code></li><li>安装测试工具集<code>npm install jest miniprogram-simulate --save-dev</code></li><li>编辑<code>package.json</code>，在<code>scripts</code>新建<code>test</code>命令 <figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"name"</span>: <span class="string">"unit-test-demo"</span>,</div><div class="line">    <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</div><div class="line">    <span class="attr">"description"</span>: <span class="string">""</span>,</div><div class="line">    <span class="attr">"main"</span>: <span class="string">"app.js"</span>,</div><div class="line">    <span class="attr">"scripts"</span>: &#123;</div><div class="line">        <span class="attr">"test"</span>: <span class="string">"jest"</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">"keywords"</span>: [],</div><div class="line">    <span class="attr">"author"</span>: <span class="string">""</span>,</div><div class="line">    <span class="attr">"license"</span>: <span class="string">"ISC"</span>,</div><div class="line">    <span class="attr">"devDependencies"</span>: &#123;</div><div class="line">        <span class="attr">"jest"</span>: <span class="string">"^24.8.0"</span>,</div><div class="line">        <span class="attr">"miniprogram-simulate"</span>: <span class="string">"^1.0.7"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><h2 id="编写测试用例"><a href="#编写测试用例" class="headerlink" title="编写测试用例"></a>编写测试用例</h2><ol><li>在项目根目录新建<code>tests/components/user.spec.js</code>文件(目录需要手动创建)</li><li>代码如下(参考微信官方单元测试文档编写): <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> simulate = <span class="built_in">require</span>(<span class="string">'miniprogram-simulate'</span>);</div><div class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"></div><div class="line">test(<span class="string">'components/user'</span>, (done) =&gt; &#123; <span class="comment">// 定义测试名称,传入done表示当前测试是异步测试，需要回调函数来告诉jest，我测试执行完毕</span></div><div class="line"><span class="keyword">const</span> id = simulate.load(path.join(__dirname, <span class="string">'../../components/user'</span>)); <span class="comment">// 加载组件</span></div><div class="line"><span class="keyword">const</span> component = simulate.render(id); <span class="comment">// 渲染组件</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> text = component.querySelector(<span class="string">'.nickname'</span>); <span class="comment">// 获取nickname节点</span></div><div class="line"><span class="keyword">const</span> button = component.querySelector(<span class="string">'.button'</span>); <span class="comment">// 获取button节点</span></div><div class="line">button.dispatchEvent(<span class="string">'getuserinfo'</span>, &#123; <span class="comment">// 模拟触发事件</span></div><div class="line">    detail: &#123;   <span class="comment">// 传递事件参数</span></div><div class="line">        userInfo: &#123;</div><div class="line">            nickName: <span class="string">'hello'</span>,</div><div class="line">        &#125;,</div><div class="line">    &#125;,</div><div class="line">&#125;);</div><div class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// 异步断言</span></div><div class="line">    expect(text.dom.innerHTML).toBe(<span class="string">'hello'</span>); <span class="comment">// 检测text节点的innerHTML等于模拟授权获取的昵称</span></div><div class="line">    done();</div><div class="line">&#125;, <span class="number">1000</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></li></ol><h2 id="执行测试"><a href="#执行测试" class="headerlink" title="执行测试"></a>执行测试</h2><ol><li><code>npm run test</code>，等待一秒后发现，<code>不出意外的话，测试肯定过不去</code></li><li><p>部分出错日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Expected: &quot;hello&quot;</div><div class="line">Received: &quot;&quot;</div><div class="line">     at toBe (/Users/xialeistudio/WeChatProjects/unit-test-demo/tests/components/user.spec.js:18:32)</div><div class="line">     at Timeout.callback [as _onTimeout] (/Users/xialeistudio/WeChatProjects/unit-test-demo/node_modules/jsdom/lib/jsdom/browser/Window.js:678:19)</div><div class="line">     at listOnTimeout (internal/timers.js:535:17)</div><div class="line">     at processTimers (internal/timers.js:479:7)</div></pre></td></tr></table></figure></li><li><p>可以推测一下原因：</p><ol><li>dispatchEvent的事件触发有问题，导致handleUserInfo未触发[1]</li><li>dispatchEvent的事件触发成功，但是触发参数有问题[2]</li></ol></li></ol><h2 id="错误分析-源码跟踪过程"><a href="#错误分析-源码跟踪过程" class="headerlink" title="错误分析(源码跟踪过程)"></a>错误分析(源码跟踪过程)</h2><ol><li><p>针对第1点原因，可以写一下测试代码(<code>components/user.js</code>)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Component(&#123;</div><div class="line">    data: &#123;</div><div class="line">        nickname: <span class="string">''</span></div><div class="line">    &#125;,</div><div class="line">    methods: &#123;</div><div class="line">        handleUserInfo: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></li><li><p><code>npm run test</code>，可以看到事件还是成功触发了，不过<code>detail</code>是<code>{}</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> console.log components/user.js:21</div><div class="line">&#123; type: &apos;getuserinfo&apos;,</div><div class="line">  timeStamp: 948,</div><div class="line">  target: &#123; id: &apos;&apos;, offsetLeft: 0, offsetTop: 0, dataset: &#123;&#125; &#125;,</div><div class="line">  currentTarget: &#123; id: &apos;&apos;, offsetLeft: 0, offsetTop: 0, dataset: &#123;&#125; &#125;,</div><div class="line">  detail: &#123;&#125;,</div><div class="line">  touches: &#123;&#125;,</div><div class="line">  changedTouches: &#123;&#125; &#125;</div></pre></td></tr></table></figure></li><li><p>原因1排除，查原因2</p></li><li><code>dispatchEvent</code>方法是<code>被测试组件的子组件</code>，<code>被测试组件</code>由<code>simulate.render</code>函数返回</li><li>浏览<code>node_modules/miniprogram-simulate/src/index.js</code>，看到<code>render函数(152行)</code>，可以看到返回的组件由<code>jComponent.create</code>提供</li><li>浏览<code>node_modules/j-component/src/index.js</code>的<code>create</code>函数，可以看到其返回了<code>RootComponent</code>实例，而<code>RootComponent</code>是由<code>./render/component.js</code>提供</li><li>浏览<code>node_modules/j-component/src/render/component.js</code>的<code>dispatchEvent</code>函数，在这里可以打下日志测试(本文就不打了，结果是这里的options就是<code>user.spec.js</code> <code>dispatchEvent</code>函数的<code>第二个参数</code>，<code>detail</code>是有值的)</li><li><p>继续跟踪源码，由于咱们的是<code>自定义事件</code>，所以会走到<code>91行</code>的代码，该代码块如下：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 自定义事件</span></div><div class="line">  <span class="keyword">const</span> customEvent = <span class="keyword">new</span> CustomEvent(eventName, options);</div><div class="line"></div><div class="line">  <span class="comment">// 模拟异步情况</span></div><div class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    dom.dispatchEvent(customEvent);</div><div class="line"></div><div class="line">    exparser.Event.dispatchEvent(customEvent.target, exparser.Event.create(eventName, &#123;&#125;, &#123;</div><div class="line">      originalEvent: customEvent,</div><div class="line">      bubbles: <span class="literal">true</span>,</div><div class="line">      capturePhase: <span class="literal">true</span>,</div><div class="line">      composed: <span class="literal">true</span>,</div><div class="line">      extraFields: &#123;</div><div class="line">        touches: options.touches || &#123;&#125;,</div><div class="line">        changedTouches: options.changedTouches || &#123;&#125;,</div><div class="line">      &#125;,</div><div class="line">    &#125;));</div><div class="line">  &#125;, <span class="number">0</span>);</div></pre></td></tr></table></figure></li><li><p>可以看到调用了<code>exparser.Event.dispatchEvent</code>函数，该函数的<code>第二个参数</code>调用了<code>exparser.Event.create</code>对自定义事件进行了包装，这里还没到最底层，需要继续跟踪</p></li><li><code>exparser</code>对象是<code>miniprogram-exparser模块</code>提供的，浏览<code>node_modules/miniprogram-exparser/exparser.min.js</code>，发现该文件被混淆了，不过没关系<code>混淆后的代码逻辑是不变的，只不过变量名变得无意义，可读性变差</code></li><li>使用webstorm格式化该文件，这里我传了一份格式化好的到github <a href="https://github.com/xialeistudio/miniprogram-unit-test-demo/blob/master/extra/wxparser.jscc" target="_blank" rel="external">wxparser.js，可在线观看</a></li><li><p>需要在源码中搜索<code>三个参数</code>的<code>create</code>函数(<code>Object.create不算</code>)，需要有耐心，经过排查后发现<a href="https://github.com/xialeistudio/miniprogram-unit-test-demo/blob/master/extra/wxparser.js#L168" target="_blank" rel="external">168行</a>代码应该是目标代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">i.create = <span class="function"><span class="keyword">function</span>(<span class="params">e, t, r</span>) </span>&#123;</div><div class="line">    r = r || &#123;&#125;;</div><div class="line">    <span class="keyword">var</span> n = r.originalEvent, o = r.extraFields || &#123;&#125;, a = <span class="built_in">Date</span>.now() - l, s = <span class="keyword">new</span> i;</div><div class="line">    s.currentTarget = <span class="literal">null</span>, s.type = e, s.timeStamp = a, s.mark = <span class="literal">null</span>, s.detail = t, s.bubbles = !!r.bubbles, s.composed = !!r.composed, s.__originalEvent = n, s.__hasCapture = !!r.capturePhase, s.__stopped = !<span class="number">1</span>, s.__dispatched = !<span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> u <span class="keyword">in</span> o) s[u] = o[u];</div><div class="line">    <span class="keyword">return</span> s;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>可以看到<code>s.detail = t</code>这个赋值，<code>t</code>是<code>create</code>的<code>第二个参数</code>，由<code>node_modules/j-component/render/component.js</code>的<code>wxparser.Event.create</code>传入，但是传入的<code>第二个参数写死了{}</code>，所以咱们的组件获取<code>detail</code>的时候<code>永远为{}</code>，将其修改为<code>options.detail||{}</code>即可，修改后代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">exparser.Event.dispatchEvent(customEvent.target, exparser.Event.create(eventName, options.detail||&#123;&#125;, xxxxxx</div></pre></td></tr></table></figure></li><li><p>重新测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">   PASS  tests/components/user.spec.js</div><div class="line">✓ components/user (1099ms)</div><div class="line"></div><div class="line">  Test Suites: 1 passed, 1 total</div><div class="line">  Tests:       1 passed, 1 total</div><div class="line">  Snapshots:   0 total</div><div class="line">  Time:        3.622s</div><div class="line">  Ran all test suites.</div></pre></td></tr></table></figure></li></ol><h2 id="避坑指南"><a href="#避坑指南" class="headerlink" title="避坑指南"></a>避坑指南</h2><ol><li><code>querySelector</code>用法同HTML，但是需要在<code>组件</code>执行，而不是<code>组件.dom</code>，HTML中实在<code>DOMNode</code>执行的</li><li><code>dispatchEvent</code>是触发事件，需要在<code>组件</code>执行，上述代码中是触发<code>button组件</code>的<code>自定义事件</code></li><li><code>dispatchEvent</code>事件名规范: <code>去掉前导bind剩余的字符串为事件名</code>，示例代码中<code>bindgetuserinfo</code>，触发时就是<code>getuserinfo</code>，如果是<code>bindtap</code>，那触发时就是<code>tap</code></li><li><p><code>dispatchEvent</code>底层是<code>j-component</code>这个<code>npm模块实现</code>的，跟踪源码发现执行是异步的(代码文件<code>node_modules/j-component/src/render/component.js</code>，函数名<code>dispatchEvent</code>)</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 自定义事件</span></div><div class="line">  <span class="keyword">const</span> customEvent = <span class="keyword">new</span> CustomEvent(eventName, options);</div><div class="line"></div><div class="line">  <span class="comment">// 模拟异步情况</span></div><div class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    dom.dispatchEvent(customEvent);</div><div class="line"></div><div class="line">    exparser.Event.dispatchEvent(customEvent.target, exparser.Event.create(eventName, &#123;&#125;, &#123;</div><div class="line">      originalEvent: customEvent,</div><div class="line">      bubbles: <span class="literal">true</span>,</div><div class="line">      capturePhase: <span class="literal">true</span>,</div><div class="line">      composed: <span class="literal">true</span>,</div><div class="line">      extraFields: &#123;</div><div class="line">        touches: options.touches || &#123;&#125;,</div><div class="line">        changedTouches: options.changedTouches || &#123;&#125;,</div><div class="line">      &#125;,</div><div class="line">    &#125;));</div><div class="line">  &#125;, <span class="number">0</span>);</div></pre></td></tr></table></figure></li><li><p>由于<code>setTimeout</code>的存在，触发事件为异步，所以写断言时需要加定时器</p></li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>小程序单元测试基本是没什么经验扩借鉴，但是基于官网提供的工具，以及<code>开源</code>，咱们遇到问题时细心排查然后修改一下，还是可以解决问题的。对单元测试有疑问的小伙伴可以扫码加我进行交流<br><img src="https://more-happy.ddhigh.com/Fg5UE615NzZ0dXo6_gUe6qpCJILG?imageView2/1/w/200" alt="微信"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;单元测试是一个老生常谈的话题，基于Web/NodeJs环境的测试框架、测试教程数不胜数，也趋于成熟了。但是对于微信小程序的单元测试，目前还是处于起步状态，这两天在研究微信小程序的测试，也遇到了一些坑，在这里记录一下，希望给看到本文的小伙伴带来一点帮助，少走一些弯路。&lt;/p&gt;
      
    
    </summary>
    
      <category term="frontend" scheme="https//www.ddhigh.com/categories/frontend/"/>
    
    
      <category term="test" scheme="https//www.ddhigh.com/tags/test/"/>
    
      <category term="miniprogram" scheme="https//www.ddhigh.com/tags/miniprogram/"/>
    
  </entry>
  
  <entry>
    <title>使用Typescript装饰器来劫持React组件</title>
    <link href="https//www.ddhigh.com/2019/07/26/react-decorator-example.html"/>
    <id>https//www.ddhigh.com/2019/07/26/react-decorator-example.html</id>
    <published>2019-07-26T11:31:15.000Z</published>
    <updated>2019-07-27T11:43:08.568Z</updated>
    
    <content type="html"><![CDATA[<p>最近在捣鼓Typescript的装饰器，NodeJs项目的装饰器比较好理解，但是React项目的装饰器由于有JSX，走了一点弯路，但是总之来说是<code>新技能get</code></p><h2 id="typescript对装饰器的说明"><a href="#typescript对装饰器的说明" class="headerlink" title="typescript对装饰器的说明"></a>typescript对装饰器的说明</h2><blockquote><p>装饰器是一种特殊类型的声明，它能够被附加到类声明，方法， 访问符，属性或参数上。 装饰器使用 @expression这种形式，expression求值后必须为一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入。</p></blockquote><p>装饰器为我们提供了<code>运行时修改数据</code>的能力。</p><h2 id="React例子"><a href="#React例子" class="headerlink" title="React例子"></a>React例子</h2><p>Parent.tsx</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> App <span class="keyword">extends</span> PureComponent &#123;</div><div class="line">  handleClick() &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'parent click'</span>);</div><div class="line">  &#125;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;div className=<span class="string">"App"</span> onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;parent&lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">    );</span></div><div class="line"><span class="regexp">  &#125;</span></div><div class="line"><span class="regexp">&#125;</span></div></pre></td></tr></table></figure><p>Component装饰器</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Component</span>&lt;<span class="title">T</span> <span class="title">extends</span> </span>&#123; <span class="keyword">new</span>(...args: <span class="built_in">any</span>[]): <span class="built_in">any</span> &#125;&gt;(component: T) &#123; <span class="comment">// 泛型限定</span></div><div class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="keyword">extends</span> component &#123;</div><div class="line">    handleClick() &#123; <span class="comment">// 劫持onClick</span></div><div class="line">      <span class="keyword">super</span>.handleClick()</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'child clicked'</span>);</div><div class="line">    &#125;</div><div class="line">    render() &#123;</div><div class="line">      <span class="keyword">const</span> parent = <span class="keyword">super</span>.render()</div><div class="line">      <span class="comment">// 劫持onClick</span></div><div class="line">      <span class="keyword">return</span> React.cloneElement(parent, &#123; onClick: <span class="keyword">this</span>.handleClick &#125;)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>点击渲染之后的<code>parent</code>字符，可以看到劫持成功</p><p><img src="https://user-gold-cdn.xitu.io/2019/7/26/16c2e0b64f0d48a7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="clipboard.png"></p><h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><p><a href="https://github.com/xialeistudio/react-decorator-example" target="_blank" rel="external">react-decorator-example</a></p><h2 id="文后"><a href="#文后" class="headerlink" title="文后"></a>文后</h2><p>本文写的只是比较简单的装饰器用法，但是可以基于此文的原来来开发如<code>登录后才能访问的组件</code>之类的装饰器，将业务逻辑更好的组织起来。</p><p>对TS有兴趣的伙伴可以加我微信交流~</p><p><img src="https://more-happy.ddhigh.com/Fg5UE615NzZ0dXo6_gUe6qpCJILG?imageView2/1/w/200" alt="微信"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在捣鼓Typescript的装饰器，NodeJs项目的装饰器比较好理解，但是React项目的装饰器由于有JSX，走了一点弯路，但是总之来说是&lt;code&gt;新技能get&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;typescript对装饰器的说明&quot;&gt;&lt;a href=&quot;#type
      
    
    </summary>
    
      <category term="frontend" scheme="https//www.ddhigh.com/categories/frontend/"/>
    
    
      <category term="react" scheme="https//www.ddhigh.com/tags/react/"/>
    
      <category term="typescript" scheme="https//www.ddhigh.com/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>TS简明教程(1)</title>
    <link href="https//www.ddhigh.com/2019/07/25/typescript-quick-guide.html"/>
    <id>https//www.ddhigh.com/2019/07/25/typescript-quick-guide.html</id>
    <published>2019-07-25T14:01:54.000Z</published>
    <updated>2019-07-26T04:53:10.539Z</updated>
    
    <content type="html"><![CDATA[<p>为了后续内容(如<code>nestjs</code>等框架)的开展，本文更新TS相关的基础知识。</p><p>关注获取更多<code>TS精品文章</code><br><img src="https://more-happy.ddhigh.com/FuFpZh9QTZVatcBtupR4MtOGPGTJ?imageView2/1/w/200" alt="二维码"></p><blockquote><p>TypeScript是JavaScript的一个超集，支持 ECMAScript 6 标准。<br>TypeScript可以在任何浏览器、任何计算机和任何操作系统上运行，并且是开源的。<br>Typescript由微软开发，与C#出自同一人之手!</p></blockquote><h2 id="TS与JS的区别"><a href="#TS与JS的区别" class="headerlink" title="TS与JS的区别"></a>TS与JS的区别</h2><blockquote><p>TS是JS的超集，扩展了TS的语法，因此现有的JS代码可<code>直接与TS一起工作无需任何修改</code>，TS通过类型注解提供编译时的静态类型检查。</p></blockquote><p>由于TS与JS语法大部分一致，本文只对有差异的部分进行讲解。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>有些知识点可能是交叉的建议通读完本文再开始真正的开发，这样疑惑会比较少一点</p><ol><li>数据类型与类型断言</li><li>函数</li><li>接口和类</li><li>泛型</li><li>枚举</li><li>命名空间和模块</li><li>装饰器(注解)</li><li>高级类型</li><li>声明文件</li><li>tsconfig.json</li><li>示例<ol><li>React示例(前端)</li><li>Koa示例(后端)</li></ol></li></ol><h2 id="数据类型与类型声明"><a href="#数据类型与类型声明" class="headerlink" title="数据类型与类型声明"></a>数据类型与类型声明</h2><p>TS使用<code>:</code>语法对类型进行声明。基础类型如下：</p><h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p>TS使用<code>boolean</code>来声明布尔类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> succeed: <span class="built_in">boolean</span> = <span class="literal">false</span>; <span class="comment">// 声明succeed为boolean类型</span></div></pre></td></tr></table></figure><h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><p>TS对数字的支持与JS一致，所有数字都是浮点数，所以TS并不存在<code>int</code>,<code>float</code>之类的数字类型声明，只有<code>number</code>。<br>除了支持十进制和十六进制，TS还支持ES6的二进制和八进制数字。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> age: <span class="built_in">number</span> = <span class="number">16</span>; <span class="comment">// 声明年龄为数字类型</span></div><div class="line"><span class="keyword">const</span> price: <span class="built_in">number</span> = <span class="number">99.99</span>; <span class="comment">// 声明价格为数字类型</span></div></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>TS使用<code>string</code>声明字符串，和JS一样，支持<code>单引号</code>和<code>双引号</code>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> name: <span class="built_in">string</span> = <span class="string">"demo"</span>;</div><div class="line"></div><div class="line">name = <span class="string">"demo1"</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> description = <span class="string">`我是<span class="subst">$&#123;name&#125;</span>`</span>; <span class="comment">// ES6语法</span></div></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>TS使用<code>类型[]</code>声明数组的元素类型，与JS不一样的地方在于，<code>TS</code>中一旦指明一个类型，所有元素必须是该类型。<code>JS</code>则可以往数组放任意类型的元素。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> numbers: <span class="built_in">number</span>[] = [];</div><div class="line">numbers.push(<span class="number">1</span>);</div><div class="line">numbers.push(<span class="number">2</span>);</div><div class="line">numbers.push(<span class="string">'3'</span>); <span class="comment">// 错误，'3'不是数字类型</span></div></pre></td></tr></table></figure><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>与JS一样，TS的对象也是由<code>键值对</code>构成，类型声明可以分别作用与<code>键类型</code>以及<code>值类型</code>。</p><p>声明语法：<code>{[key名称: key类型]: 值类型}</code><br>key名称可以<code>自定义</code>，如<code>key</code>,<code>index</code>都是合法的。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> config: &#123;[key: <span class="built_in">string</span>]: <span class="built_in">string</span>&#125; = &#123;&#125;; <span class="comment">// 声明键和值都只能是字符串类型</span></div><div class="line">config.version = <span class="string">'1.0.0'</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> ages: &#123;[key: <span class="built_in">number</span>]: <span class="built_in">number</span>&#125; = &#123;&#125;; <span class="comment">// 声明键值对都是数字类型</span></div><div class="line">ages[<span class="number">10</span>] = <span class="string">'1.0.0'</span>; <span class="comment">// 赋值</span></div></pre></td></tr></table></figure><p>上例中赋值语法虽然和数组一致，但是ages对象的长度为1，如果ages是数组的话，长度为11。(0-9个元素为undefined)</p><h3 id="任意类型"><a href="#任意类型" class="headerlink" title="任意类型"></a>任意类型</h3><p>TS用<code>any</code>用来声明<code>任意类型</code>，被<code>any</code>修饰的变量(或常量以及返回值等等)在编译阶段会<code>直接通过</code>，但是运行阶段可能会<code>抛出undefined或null相关错误</code>。</p><p><code>any</code>的出现使得现有的JS代码能够很快速的切换到TS。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> age:<span class="built_in">any</span> = <span class="number">10</span>;</div><div class="line">age = <span class="string">'name'</span>; <span class="comment">// 编译通过</span></div></pre></td></tr></table></figure><h3 id="空类型"><a href="#空类型" class="headerlink" title="空类型"></a>空类型</h3><p>TS使用<code>void</code>声明空类型。与<code>any</code>相反，表示没有任何类型，常用在函数返回值中。<br><code>void</code>类型只能被赋值为<code>null</code>和<code>undefined</code>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">name: <span class="built_in">string</span></span>): <span class="title">void</span> </span>&#123; <span class="comment">// 声明函数无返回值，编译成JS之后取返回值会取到undefined，与JS一致</span></div><div class="line">    <span class="built_in">console</span>.log(name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> v: <span class="built_in">void</span> = <span class="literal">null</span>;</div></pre></td></tr></table></figure><h3 id="null和undefined"><a href="#null和undefined" class="headerlink" title="null和undefined"></a>null和undefined</h3><p>TS中<code>默认情况</code>下，<code>null</code>和<code>undefined</code>是所有类型的子类型，换句话说，你可以把<code>null</code>和<code>undefined</code>直接赋值给<code>number</code>/<code>string</code>/<code>boolean</code>等类型。<br>但是不能反过来干，你不能把<code>number</code>/<code>string</code>/<code>boolean</code>类型赋值给<code>null</code>或者<code>undefined</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> u: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</div><div class="line"><span class="keyword">let</span> n: <span class="literal">null</span> = <span class="literal">null</span>;</div></pre></td></tr></table></figure><h3 id="never"><a href="#never" class="headerlink" title="never"></a>never</h3><p><code>never</code>是<code>100%不存在的值</code>的类型。比如函数中直接抛出异常或者有死循环。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="title">never</span> </span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params"></span>) </span>&#123; <span class="comment">// TS自动类型推断返回值类型为never，类型推断在下文中会提到</span></div><div class="line">    <span class="keyword">return</span> error(<span class="string">'failed'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123; <span class="comment">// 死循环，肯定不会返回</span></div><div class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;&#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>never</code>和<code>void</code>区别</p><ol><li>被<code>void</code>修饰的函数<code>能正常终止，只不过没有返回值</code></li><li>被<code>never</code>修饰的函数<code>不能正常终止，如抛出异常或死循环</code></li></ol><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举是对JS的一个扩展。TS使用<code>enum</code>关键字定义枚举类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> Color &#123;</div><div class="line">    Red,</div><div class="line">    Green,</div><div class="line">    Yellow</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> c: Color = Color.Red;</div></pre></td></tr></table></figure><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p>TS使用<code>object</code>类修饰对象类型，TS中表示<code>非原始类型</code>。原始类型如下：</p><ol><li>number</li><li>string</li><li>boolean</li><li>null</li><li>undefined</li><li>symbol(ES6新出类型)</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a: object = &#123;&#125;; <span class="comment">// ok</span></div><div class="line"><span class="keyword">let</span> a: object = <span class="number">1</span>; <span class="comment">// error</span></div><div class="line"><span class="keyword">let</span> a: object = Symbol(); <span class="regexp">/ error</span></div></pre></td></tr></table></figure><p>虽然<code>Symbol</code>长得像<code>对象类型</code>，不过在<code>ES6</code>规范中，人家就是<code>原始类型</code>。</p><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>TS中可以对函数的<code>形参</code>以及<code>返回值</code>进行类型声明。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>): <span class="title">string</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">`name:<span class="subst">$&#123;name&#125;</span>,age:<span class="subst">$&#123;age&#125;</span>`</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>类型断言说白了就是<code>告诉编译器，你按照我指定的类型进行处理</code>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> value: <span class="built_in">any</span> = <span class="string">'a string'</span>;</div><div class="line"><span class="keyword">const</span> length: <span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;value).length;</div></pre></td></tr></table></figure><p>编译结果(正常编译且正常运行)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> value = <span class="string">'a string'</span>;</div><div class="line"><span class="keyword">const</span> length = value.length;</div></pre></td></tr></table></figure><h3 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h3><p>当没有手动指定类型时，TS编译器利用类型推断来推断类型。<br>如果由于缺乏声明而不能推断出类型，那么它的类型被视作默认的动态 any 类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> num = <span class="number">2</span>; <span class="comment">// 推断为number类型</span></div></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>TS函数与JS函数没有大的区别，多了一个类型系统。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">name: <span class="built_in">string</span></span>) </span>&#123; <span class="comment">// 自动推断返回类型为string</span></div><div class="line">    <span class="keyword">return</span> name;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><p>TS中函数每个形参都是<code>必须</code>的，当然你可以传递<code>null</code>和<code>undefined</code>，因为<code>他们是值</code>。但是在JS中，每个形参都是可选的，没传的情况下取值会得到<code>undefined</code>。<br>TS中<code>在参数名后面使用?号指明该参数为可选参数</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">name: <span class="built_in">string</span>, age?: <span class="built_in">number</span></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;name&#125;</span>:<span class="subst">$&#123;age&#125;</span>`</span>);</div><div class="line">&#125;</div><div class="line">test(<span class="string">'a'</span>); <span class="comment">// 输出 a:undefined</span></div></pre></td></tr></table></figure><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>与ES6一致，TS也的函数也支持默认参数。需要注意的是<code>可选参数</code>和<code>默认参数</code>是<code>互斥</code>的。因为如果使用了默认参数，不管外部传不传值，取值的时候都是有值的，和可选参数矛盾。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span> = 10</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;name&#125;</span>:<span class="subst">$&#123;age&#125;</span>`</span>)</div><div class="line">&#125;</div><div class="line">test(<span class="string">'a'</span>); <span class="comment">// 输出 a:10</span></div></pre></td></tr></table></figure><h3 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h3><p>剩余参数和ES6表现一致，但是多了类型声明：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">name1: <span class="built_in">string</span>, ...names: <span class="built_in">string</span>[]</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(name1, names);</div><div class="line">&#125;</div><div class="line">test(<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>);<span class="comment">// 输出 1 ['2', '3']</span></div></pre></td></tr></table></figure><h3 id="this执行"><a href="#this执行" class="headerlink" title="this执行"></a>this执行</h3><p>TS中this指向和JS一致，这里不做赘述。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>未完待续~欢迎加我微信交流TS相关的知识~</p><p><img src="https://more-happy.ddhigh.com/Fg5UE615NzZ0dXo6_gUe6qpCJILG?imageView2/1/w/200" alt="微信"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为了后续内容(如&lt;code&gt;nestjs&lt;/code&gt;等框架)的开展，本文更新TS相关的基础知识。&lt;/p&gt;
&lt;p&gt;关注获取更多&lt;code&gt;TS精品文章&lt;/code&gt;&lt;br&gt;&lt;img src=&quot;https://more-happy.ddhigh.com/FuFpZh9QTZV
      
    
    </summary>
    
      <category term="frontend" scheme="https//www.ddhigh.com/categories/frontend/"/>
    
    
      <category term="typescript" scheme="https//www.ddhigh.com/tags/typescript/"/>
    
      <category term="ts" scheme="https//www.ddhigh.com/tags/ts/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs简明教程(11) - 完结篇</title>
    <link href="https//www.ddhigh.com/2019/07/25/nodejs-guide-next-step.html"/>
    <id>https//www.ddhigh.com/2019/07/25/nodejs-guide-next-step.html</id>
    <published>2019-07-25T03:26:30.000Z</published>
    <updated>2019-07-25T03:45:21.755Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>NodeJs简明教程将从零开始学习NodeJs相关知识，助力JS开发者构建全栈开发技术栈！</p></blockquote><p>关注获取更多<code>NodeJs精品文章</code><br><img src="https://more-happy.ddhigh.com/FuFpZh9QTZVatcBtupR4MtOGPGTJ?imageView2/1/w/200" alt="二维码"></p><p>本文是NodeJs简明教程的完结篇，将对以往文章进行归档。</p><h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><ol><li><a href="https://www.ddhigh.com/2019/07/18/nodejs-guide-about.html" target="_blank" rel="external">NodeJs简明教程(1)——简介</a></li><li><a href="https://www.ddhigh.com/2019/07/19/nodejs-guide-installation.html" target="_blank" rel="external">NodeJs简明教程(2)——安装</a></li><li><a href="https://www.ddhigh.com/2019/07/19/nodejs-guide-http-server.html" target="_blank" rel="external">NodeJs简明教程(3)——HTTP服务器</a></li><li><a href="https://www.ddhigh.com/2019/07/20/nodejs-guide-filesystem.html" target="_blank" rel="external">NodeJs简明教程(4)——文件系统</a></li><li><a href="https://www.ddhigh.com/2019/07/20/nodejs-guide-path.html" target="_blank" rel="external">NodeJs简明教程(5)——路径</a></li><li><a href="https://www.ddhigh.com/2019/07/21/nodejs-guide-crypto.html" target="_blank" rel="external">NodeJs简明教程(6)——加解密</a></li><li><a href="https://www.ddhigh.com/2019/07/22/nodejs-guide-events.html" target="_blank" rel="external">NodeJs简明教程(7)——事件</a></li><li><a href="https://www.ddhigh.com/2019/07/23/nodejs-guide-child-process.html" target="_blank" rel="external">NodeJs简明教程(8)——子进程</a></li><li><a href="https://www.ddhigh.com/2019/07/24/nodejs-guide-net.html" target="_blank" rel="external">NodeJs简明教程(9)——TCP开发</a></li><li><a href="https://www.ddhigh.com/2019/07/25/nodejs-guide-dgram.html" target="_blank" rel="external">NodeJs简明教程(10)——UDP开发</a></li></ol><h2 id="接下来的内容"><a href="#接下来的内容" class="headerlink" title="接下来的内容"></a>接下来的内容</h2><ol><li>Typescript语言基础</li><li>NodeJs常用第三方模块(缓存、数据库、通用连接池、消息队列等等)</li><li>koa 专题</li><li>express 专题</li><li>nestjs 专题</li></ol><p>欢迎持续关注~</p><p>欢迎加群交流NodeJs相关的开发~</p><p><img src="https://more-happy.ddhigh.com/FpffwgkBeSWPyHRUJJmi9J9SFX_l?imageView2/1/w/200" alt="微信群"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;NodeJs简明教程将从零开始学习NodeJs相关知识，助力JS开发者构建全栈开发技术栈！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关注获取更多&lt;code&gt;NodeJs精品文章&lt;/code&gt;&lt;br&gt;&lt;img src=&quot;https://more-h
      
    
    </summary>
    
      <category term="nodejs" scheme="https//www.ddhigh.com/categories/nodejs/"/>
    
    
      <category term="javascript" scheme="https//www.ddhigh.com/tags/javascript/"/>
    
      <category term="nodejs guide" scheme="https//www.ddhigh.com/tags/nodejs-guide/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs简明教程(10)</title>
    <link href="https//www.ddhigh.com/2019/07/25/nodejs-guide-dgram.html"/>
    <id>https//www.ddhigh.com/2019/07/25/nodejs-guide-dgram.html</id>
    <published>2019-07-25T03:00:00.000Z</published>
    <updated>2019-07-25T03:25:56.103Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>NodeJs简明教程将从零开始学习NodeJs相关知识，助力JS开发者构建全栈开发技术栈！</p></blockquote><p>关注获取更多<code>NodeJs精品文章</code><br><img src="https://more-happy.ddhigh.com/FuFpZh9QTZVatcBtupR4MtOGPGTJ?imageView2/1/w/200" alt="二维码"></p><p>本文是NodeJs简明教程的第十篇，将介绍NodeJs <strong>dgram</strong> 模块(<code>UDP服务端/客户端</code>)相关的基本操作。</p><h2 id="啥是UDP"><a href="#啥是UDP" class="headerlink" title="啥是UDP"></a>啥是UDP</h2><blockquote><p>Internet 协议集支持一个无连接的传输协议，该协议称为用户数据报协议（UDP，User Datagram Protocol）。UDP 为应用程序提供了一种无需建立连接就可以发送封装的 IP 数据报的方法。RFC 768描述了 UDP。</p></blockquote><p>NodeJs使用<code>dgram模块</code>实现<code>UDP服务端/客户端</code>相关功能。</p><p><code>dgram.createSocket</code>用来创建一个Socket对象，可以基于该套接口<code>接收</code>或<code>发送</code>数据。该方法原型如下：</p><p><code>dgram.createSocket(type[, callback])</code></p><ul><li>type <code>&lt;string&gt;</code> socket类型。<code>udp4</code>或<code>udp6</code>，对应<code>ipv4</code>和<code>ipv6</code></li><li>callback <code>&lt;Function&gt;</code> 接收到消息时的回调函数</li></ul><h2 id="Echo服务端开发"><a href="#Echo服务端开发" class="headerlink" title="Echo服务端开发"></a>Echo服务端开发</h2><p>server.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> dgram = <span class="built_in">require</span>(<span class="string">'dgram'</span>);</div><div class="line"><span class="keyword">const</span> socket = dgram.createSocket(<span class="string">'udp4'</span>);</div><div class="line"></div><div class="line">socket.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123; <span class="comment">// 监听socket错误</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'服务器错误'</span>, err);</div><div class="line">    socket.close();</div><div class="line">&#125;);</div><div class="line"></div><div class="line">socket.on(<span class="string">'message'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">msg,sender</span>) </span>&#123; <span class="comment">// 监听收到数据</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'%s:%d =&gt; %s'</span>, sender.address,sender.port,msg.toString()); <span class="comment">// 打印该数据包详情</span></div><div class="line">    socket.send(<span class="string">'socket: '</span>+msg.toString(),sender.port,sender.address,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123; <span class="comment">// 发送数据给来源地址</span></div><div class="line">        <span class="keyword">if</span>(err) &#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'回复%s:%d失败: %s'</span>,sender.address,sender.port,err.message);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">   &#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">socket.bind(<span class="number">10000</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 监听UDP端口</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'服务器正在监听 %s:%d'</span>, socket.address().address, socket.address().port);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h2 id="Echo客户端开发"><a href="#Echo客户端开发" class="headerlink" title="Echo客户端开发"></a>Echo客户端开发</h2><p>由于<code>telnet</code>连接服务器使用的是<code>TCP协议</code>，所以本文对应的客户端需要使用NodeJs开发。</p><p>client.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> dgram = <span class="built_in">require</span>(<span class="string">'dgram'</span>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> socket = dgram.createSocket(<span class="string">'udp4'</span>); <span class="comment">// 创建socket实例</span></div><div class="line"></div><div class="line">socket.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">msg,sender</span>) </span>&#123; <span class="comment">// 监听收到数据</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'接收到%s:%d的消息:%s'</span>,sender.address,sender.port,msg.toString());</div><div class="line">    socket.close();</div><div class="line">&#125;);</div><div class="line"></div><div class="line">socket.send(<span class="string">'hello'</span>,<span class="number">10000</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123; <span class="comment">// 向目标端口发送数据</span></div><div class="line">    <span class="keyword">if</span>(err) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'发送错误'</span>, err);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'发送成功'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h2 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h2><ol><li><p>终端执行<code>node server.js</code>，输出</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">服务器正在监听 0.0.0.0:10000</div></pre></td></tr></table></figure></li><li><p>终端执行<code>node client.js</code>，输出</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">发送成功</div><div class="line">接收到127.0.0.1:10000的消息:server: hello</div></pre></td></tr></table></figure></li><li><p>服务端输出:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:50577 =&gt; hello</div></pre></td></tr></table></figure></li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>NodeJs UDP服务端与客户端开发到此结束，但是使用UDP的情况下，数据包确认、流量控制等等操作都需要程序员手动完成，这一方面确实挺复杂的，没有什么特殊的要求的话使用TCP即可。</p><p><img src="https://more-happy.ddhigh.com/FpffwgkBeSWPyHRUJJmi9J9SFX_l?imageView2/1/w/200" alt="微信群"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;NodeJs简明教程将从零开始学习NodeJs相关知识，助力JS开发者构建全栈开发技术栈！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关注获取更多&lt;code&gt;NodeJs精品文章&lt;/code&gt;&lt;br&gt;&lt;img src=&quot;https://more-h
      
    
    </summary>
    
      <category term="nodejs" scheme="https//www.ddhigh.com/categories/nodejs/"/>
    
    
      <category term="javascript" scheme="https//www.ddhigh.com/tags/javascript/"/>
    
      <category term="nodejs guide" scheme="https//www.ddhigh.com/tags/nodejs-guide/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs简明教程(9)</title>
    <link href="https//www.ddhigh.com/2019/07/24/nodejs-guide-net.html"/>
    <id>https//www.ddhigh.com/2019/07/24/nodejs-guide-net.html</id>
    <published>2019-07-24T02:23:56.000Z</published>
    <updated>2019-07-24T03:57:47.599Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>NodeJs简明教程将从零开始学习NodeJs相关知识，助力JS开发者构建全栈开发技术栈！</p></blockquote><p>关注获取更多<code>NodeJs精品文章</code><br><img src="https://more-happy.ddhigh.com/FuFpZh9QTZVatcBtupR4MtOGPGTJ?imageView2/1/w/200" alt="二维码"></p><p>本文是NodeJs简明教程的第九篇，将介绍NodeJs <strong>net</strong> 模块(<code>TCP服务端/客户端</code>)相关的基本操作。</p><h2 id="啥是TCP"><a href="#啥是TCP" class="headerlink" title="啥是TCP"></a>啥是TCP</h2><blockquote><p>传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793 定义。</p></blockquote><p>NodeJs使用<code>net模块</code>实现<code>TCP服务端/客户端</code>相关功能。</p><h2 id="Echo服务器开发"><a href="#Echo服务器开发" class="headerlink" title="Echo服务器开发"></a>Echo服务器开发</h2><blockquote><p>Echo服务器就是客户端发送什么，服务端就显示什么的一种服务端程序。主要为了调试网络和协议是否正常工作。</p></blockquote><p><code>net.createServer</code>用来创建一个服务端，该方法原型如下：</p><p><code>net.createServer([options][, connectionlistener]): net.Server</code></p><ul><li>options <code>&lt;Object&gt;</code><ul><li>allowHalfOpen <code>&lt;boolean&gt;</code> 表明是否允许半开的 TCP 连接。默认值: <code>false</code>。</li><li>pauseOnConnect <code>&lt;boolean&gt;</code> 表明是否应在传入连接上暂停套接字。默认值: false。</li></ul></li><li>connectionListener <code>&lt;Function&gt;</code> 客户端连接事件监听器。回调参数为<code>Socket(可以视为一个客户端连接)</code></li></ul><p>返回值为<code>net.Server</code>，<code>net.Server</code>主要方法如下：</p><p><code>server.listen([port[, host[, backlog]]][, callback])</code></p><ul><li>port <code>&lt;number&gt;</code> 监听端口</li><li>host <code>&lt;string&gt;</code> 监听主机</li><li>backlog <code>&lt;number&gt;</code> 待连接队列的最大长度</li><li>callback <code>&lt;Function&gt;</code> 监听成功回调函数</li></ul><p>server.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> server = net.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">client</span>) </span>&#123; <span class="comment">// 创建服务端</span></div><div class="line">    <span class="built_in">console</span>.log(client.address().address, <span class="string">'连接成功'</span>); <span class="comment">// 客户端连接成功时打印客户端地址</span></div><div class="line"></div><div class="line">    client.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(client.address().address, <span class="string">' error &gt;&gt; '</span>, e.message); <span class="comment">// 连接错误时（如客户端异常断开）</span></div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    client.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123; <span class="comment">// 收到客户端数据</span></div><div class="line">        <span class="built_in">console</span>.log(client.address().address, <span class="string">' &gt;&gt; '</span>, data.toString());</div><div class="line">        client.write(data); <span class="comment">// 往客户端写数据</span></div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    client.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 客户端正常断开</span></div><div class="line">        <span class="built_in">console</span>.log(client.address().address, <span class="string">'断开连接'</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">server.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123; <span class="comment">// 服务器错误（如启动失败，端口占用）</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'服务器启动失败'</span>, e);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">server.listen(<span class="number">10000</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'启动成功，地址'</span>, server.address().address);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><ol><li>执行<code>node server.js</code>可以看到输出<code>启动成功，地址xxx</code></li><li><p>打开终端，执行<code>telnet localhost 10000</code>，可以看到输出如下（如果不一样，请加群讨论）：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Trying ::1...</div><div class="line">Connected to localhost.</div><div class="line">Escape character is &apos;^]&apos;.</div></pre></td></tr></table></figure></li><li><p>终端继续输入以下字符：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">helloworld</div></pre></td></tr></table></figure></li><li><p>服务端会回复</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hello world</div></pre></td></tr></table></figure></li></ol><p>该Echo服务器就开发已经测试通过了。虽然代码量不多，但是演示了从零开始开发一个TCP服务器的流程，相比于C语言开发TCP服务器还是方便很多的。</p><h2 id="TCP客户端"><a href="#TCP客户端" class="headerlink" title="TCP客户端"></a>TCP客户端</h2><p><code>net.connect</code>可以连接目标TCP服务器，该方法原型如下：</p><p><code>net.connect(port[,host][,connectionListener])</code></p><ul><li>port <code>&lt;number&gt;</code> 连接端口</li><li>host <code>&lt;string&gt;</code> 连接主机</li><li>connectionListener <code>&lt;Function&gt;</code> 连接成功的回调</li></ul><p>还是以刚才监听<code>10000</code>端口的服务端为例来开发客户端</p><p>client.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> client = net.connect(<span class="number">10000</span>, <span class="string">'localhost'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 连接服务器</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'连接服务器成功'</span>);</div><div class="line"></div><div class="line">    client.write(<span class="string">'我是客户端'</span>); <span class="comment">// 往服务端发送数据</span></div><div class="line"></div><div class="line">    client.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123; <span class="comment">// 接收到服务端数据</span></div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'服务端消息'</span>, data.toString());</div><div class="line">        client.end(); <span class="comment">// 断开连接</span></div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    client.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 连接断开事件</span></div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'服务端连接断开'</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>保证服务端开启的情况下，执行该js，输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">连接服务器成功</div><div class="line">服务端消息 我是客户端</div><div class="line">服务端连接断开</div></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>NodeJs TCP服务端与客户端开发到此结束，但是TCP协议的学习远远不止于此，包括<code>自定义协议开发</code>、<code>TCP粘包问题</code>等等。这一块有问题的可以扫码加群交流：</p><p><img src="https://more-happy.ddhigh.com/FpffwgkBeSWPyHRUJJmi9J9SFX_l?imageView2/1/w/200" alt="微信群"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;NodeJs简明教程将从零开始学习NodeJs相关知识，助力JS开发者构建全栈开发技术栈！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关注获取更多&lt;code&gt;NodeJs精品文章&lt;/code&gt;&lt;br&gt;&lt;img src=&quot;https://more-h
      
    
    </summary>
    
      <category term="nodejs" scheme="https//www.ddhigh.com/categories/nodejs/"/>
    
    
      <category term="javascript" scheme="https//www.ddhigh.com/tags/javascript/"/>
    
      <category term="nodejs guide" scheme="https//www.ddhigh.com/tags/nodejs-guide/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs简明教程(8)</title>
    <link href="https//www.ddhigh.com/2019/07/23/nodejs-guide-child-process.html"/>
    <id>https//www.ddhigh.com/2019/07/23/nodejs-guide-child-process.html</id>
    <published>2019-07-23T02:52:47.000Z</published>
    <updated>2019-07-23T06:27:52.552Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>NodeJs简明教程将从零开始学习NodeJs相关知识，助力JS开发者构建全栈开发技术栈！</p></blockquote><p>关注获取更多<code>NodeJs精品文章</code><br><img src="https://more-happy.ddhigh.com/FuFpZh9QTZVatcBtupR4MtOGPGTJ?imageView2/1/w/200" alt="二维码"></p><p>本文是NodeJs简明教程的第八篇，将介绍NodeJs <strong>子进程</strong> 模块相关的基本操作。</p><blockquote><p>child_process 模块提供了衍生子进程的能力（以一种与 popen(3) 类似但不相同的方式）。</p></blockquote><p>NodeJs的JS线程虽然是单线程，不能利用多核CPU，也不能执行CPU密集型的任务，但是通过派生子进程的形式加上<strong>IPC(进程间通信)</strong>，可以充分利用多核CPU。</p><h2 id="spawn"><a href="#spawn" class="headerlink" title="spawn"></a>spawn</h2><p> <code>spawn</code>可以执行<code>指定的命令</code>，<code>spawn</code>的函数原型如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">child_process.spawn(command[,args][,options])</div></pre></td></tr></table></figure><ul><li>command <code>&lt;string&gt;</code> 要执行的命令</li><li>args <code>&lt;string[]&gt;</code> 传给命令的参数列表</li><li>options <code>&lt;Object&gt;</code> 额外选项<ul><li>cwd <code>&lt;string&gt;</code> 子进程<code>workdir</code></li><li>env <code>&lt;Object&gt;</code> 子进程环境变量</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> &#123; spawn &#125; = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</div><div class="line"><span class="keyword">const</span> ls = spawn(<span class="string">'ls'</span>, [<span class="string">'-lh'</span>, <span class="string">'/usr'</span>]); <span class="comment">// 命令配置</span></div><div class="line"></div><div class="line">ls.stdout.on(<span class="string">'data'</span>, (data) =&gt; &#123; <span class="comment">// 监听命令执行的标准输出</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">`stdout: <span class="subst">$&#123;data&#125;</span>`</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">ls.stderr.on(<span class="string">'data'</span>, (data) =&gt; &#123; <span class="comment">// 监听命令执行的标准错误输出</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">`stderr: <span class="subst">$&#123;data&#125;</span>`</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">ls.on(<span class="string">'close'</span>, (code) =&gt; &#123; <span class="comment">// 监听子进程退出</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">`子进程退出，使用退出码 <span class="subst">$&#123;code&#125;</span>`</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>以上例程输出(不同机器输出可能不一样)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">stdout: total 0</div><div class="line">drwxr-xr-x  970 root  wheel    30K  7 19 23:00 bin</div><div class="line">drwxr-xr-x  306 root  wheel   9.6K  7 12 22:35 lib</div><div class="line">drwxr-xr-x  249 root  wheel   7.8K  7 19 23:00 libexec</div><div class="line">drwxr-xr-x   15 root  wheel   480B  4  1 14:15 local</div><div class="line">drwxr-xr-x  239 root  wheel   7.5K  7 12 22:35 sbin</div><div class="line">drwxr-xr-x   46 root  wheel   1.4K  9 21  2018 share</div><div class="line">drwxr-xr-x    5 root  wheel   160B  9 21  2018 standalone</div><div class="line"></div><div class="line">子进程退出，使用退出码 0</div></pre></td></tr></table></figure><h2 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h2><p><code>exec</code>也可以执行<code>指定的命令</code>，与<code>spawn</code>区别是执行结果通过回调通知，<code>spawn</code>是通过事件，<code>exec</code>函数原型如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">exec(command[,options][,callback])</div></pre></td></tr></table></figure><ul><li>command <code>&lt;string&gt;</code> 要执行的命令，命令参数使用空格分隔</li><li>options <code>&lt;Object&gt;</code> 额外选项<ul><li>cwd <code>&lt;string&gt;</code> 子进程<code>workdir</code></li><li>env <code>&lt;Object&gt;</code> 子进程环境变量</li><li>timeout <code>&lt;number&gt;</code> 子进程执行超时</li></ul></li><li>callback <code>&lt;Function&gt;</code> 执行结果回调<ul><li>error <code>&lt;Error&gt;</code> 执行错误(不是子进程的错误输出)</li><li>stdout <code>&lt;string|Buffer&gt;</code> 子进程标准输出</li><li>stderr <code>&lt;string|Buffer&gt;</code> 子进程标准错误输出</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> exec = <span class="built_in">require</span>(<span class="string">'child_process'</span>).exec;</div><div class="line"></div><div class="line">exec(<span class="string">'ls -lh /usr'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,stdout,stderr</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span>(err) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'执行错误'</span>, err);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'stdout'</span>, stdout);</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'stderr'</span>, stderr);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>以上例程输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">stdout: total 0</div><div class="line">drwxr-xr-x  970 root  wheel    30K  7 19 23:00 bin</div><div class="line">drwxr-xr-x  306 root  wheel   9.6K  7 12 22:35 lib</div><div class="line">drwxr-xr-x  249 root  wheel   7.8K  7 19 23:00 libexec</div><div class="line">drwxr-xr-x   15 root  wheel   480B  4  1 14:15 local</div><div class="line">drwxr-xr-x  239 root  wheel   7.5K  7 12 22:35 sbin</div><div class="line">drwxr-xr-x   46 root  wheel   1.4K  9 21  2018 share</div><div class="line">drwxr-xr-x    5 root  wheel   160B  9 21  2018 standalone</div><div class="line"></div><div class="line">子进程退出，使用退出码 0</div></pre></td></tr></table></figure><h2 id="execFile"><a href="#execFile" class="headerlink" title="execFile"></a>execFile</h2><p><code>execFile</code>类似于<code>exec</code>，但默认情况下不会派生shell， 相反，指定的可执行文件 file 会作为新进程直接地衍生，使其比 <code>exec</code>稍微更高效。</p><p>支持与<code>exec</code>相同的选项。 由于没有衍生 shell，因此<code>不支持 I/O 重定向和文件通配等行为</code>。<code>execFile</code>原型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">execFile(file[,args][,options][,callback])</div></pre></td></tr></table></figure><ul><li>file <code>&lt;string&gt;</code> 要执行的命令或可执行文件路径</li><li>args <code>&lt;string[]&gt;</code> 字符串数组形式的参数列表</li><li>options <code>&lt;Object&gt;</code> 额外选项<ul><li>cwd <code>&lt;string&gt;</code> 子进程<code>workdir</code></li><li>env <code>&lt;Object&gt;</code> 子进程环境变量</li><li>timeout <code>&lt;number&gt;</code> 子进程执行超时</li></ul></li><li>callback <code>&lt;Function&gt;</code> 执行结果回调<ul><li>error <code>&lt;Error&gt;</code> 执行错误(不是子进程的错误输出)</li><li>stdout <code>&lt;string|Buffer&gt;</code> 子进程标准输出</li><li>stderr <code>&lt;string|Buffer&gt;</code> 子进程标准错误输出</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> execFile = <span class="built_in">require</span>(<span class="string">'child_process'</span>).execFile;</div><div class="line">execFile(<span class="string">'ls'</span>, [<span class="string">'--version'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">error, stdout, stderr</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span>(err) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'执行错误'</span>, err);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'stdout'</span>, stdout);</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'stderr'</span>, stderr);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>以上例程输出同<code>exec</code></p><h2 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h2><p><code>fork</code>是<code>spawn</code>的一个特例，专门用于派生新的<code>NodeJs进程</code>。<code>spawn</code>可以派生<code>任何进程</code>。<code>fork</code>方法原型如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fork(modulePath[,args][,options])</div></pre></td></tr></table></figure><ul><li>modulePath <code>&lt;string&gt;</code> 要执行的JS路径</li><li>args <code>&lt;string[]&gt;</code> 字符串数组形式的参数列表</li><li>options <code>&lt;Object&gt;</code> 额外选项<ul><li>cwd <code>&lt;string&gt;</code> 子进程的<code>workdir</code></li><li>env <code>&lt;Object&gt;</code> 环境变量</li><li>silent <code>&lt;boolean&gt;</code> 如果为 true，则子进程的 stdin、stdout 和 stderr 将会被输送到父进程，否则它们将会继承自父进程。默认<code>false</code></li></ul></li></ul><p>b.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> fork = <span class="built_in">require</span>(<span class="string">'child_process'</span>).fork;</div><div class="line"></div><div class="line"><span class="keyword">const</span> child = fork(<span class="string">'./a.js'</span>,&#123;<span class="attr">silent</span>:<span class="literal">true</span>&#125;); <span class="comment">// silent为true时可以监听子进程标准输出和标准错误输出</span></div><div class="line">child.stdout.on(<span class="string">'data'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123; <span class="comment">// 监听子进程标准输出</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'child stdout'</span>, data.toString(<span class="string">'utf8'</span>));</div><div class="line">&#125;);</div><div class="line">child.stderr.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123; <span class="comment">// 监听子进程标准错误输出</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'child stderr'</span>, data.toString(<span class="string">'utf8'</span>));</div><div class="line">&#125;);</div><div class="line">child.on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'child exit'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>a.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">'我是子进程`);</span></div></pre></td></tr></table></figure><p>终端执行<code>node b.js</code>，以上例程输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">child stdout 我是子进程</div><div class="line"></div><div class="line">child exit</div></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>子进程模块的介绍到此就告一段落了，一般情况下使用<code>spawn</code>和<code>execFile</code>即可。有任何疑问请扫码加群交流：</p><p><img src="https://more-happy.ddhigh.com/FpffwgkBeSWPyHRUJJmi9J9SFX_l?imageView2/1/w/200" alt="微信群"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;NodeJs简明教程将从零开始学习NodeJs相关知识，助力JS开发者构建全栈开发技术栈！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关注获取更多&lt;code&gt;NodeJs精品文章&lt;/code&gt;&lt;br&gt;&lt;img src=&quot;https://more-h
      
    
    </summary>
    
      <category term="nodejs" scheme="https//www.ddhigh.com/categories/nodejs/"/>
    
    
      <category term="javascript" scheme="https//www.ddhigh.com/tags/javascript/"/>
    
      <category term="nodejs guide" scheme="https//www.ddhigh.com/tags/nodejs-guide/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs简明教程(7)</title>
    <link href="https//www.ddhigh.com/2019/07/22/nodejs-guide-events.html"/>
    <id>https//www.ddhigh.com/2019/07/22/nodejs-guide-events.html</id>
    <published>2019-07-22T02:53:10.000Z</published>
    <updated>2019-07-23T06:14:56.220Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>NodeJs简明教程将从零开始学习NodeJs相关知识，助力JS开发者构建全栈开发技术栈！</p></blockquote><p>关注获取更多<code>NodeJs精品文章</code><br><img src="https://more-happy.ddhigh.com/FuFpZh9QTZVatcBtupR4MtOGPGTJ?imageView2/1/w/200" alt="二维码"></p><p>本文是NodeJs简明教程的第七篇，将介绍NodeJs events模块相关的基本操作。</p><blockquote><p>大多数 Node.js 核心 API 构建于惯用的异步事件驱动架构，其中某些类型的对象（又称触发器，Emitter）会触发命名事件来调用函数（又称监听器，Listener）。</p></blockquote><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p>使用事件监听器一般包含以下操作：</p><ol><li>新建事件监听器实例</li><li>设置监听函数</li><li>触发事件</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>); <span class="comment">// 引用模块</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyEmitter</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;&#125; <span class="comment">// 初始化监听器</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> myEmitter = <span class="keyword">new</span> MyEmitter();</div><div class="line"></div><div class="line">myEmitter.on(<span class="string">'event'</span>, () =&gt; &#123; <span class="comment">// 设置监听函数</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'an event occurred!'</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">myEmitter.emit(<span class="string">'event'</span>); <span class="comment">// 触发事件</span></div></pre></td></tr></table></figure><p>以上例程会输出<code>an event occurred!</code></p><h2 id="一次性事件监听"><a href="#一次性事件监听" class="headerlink" title="一次性事件监听"></a>一次性事件监听</h2><p>上文中的监听方式<code>事件触发几次</code>就会<code>输出几次an event occurred!</code>，有些事件可能是一次性的。这时候可以使用<code>once</code>监听。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>); <span class="comment">// 引用模块</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyEmitter</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;&#125; <span class="comment">// 初始化监听器</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> myEmitter = <span class="keyword">new</span> MyEmitter();</div><div class="line"></div><div class="line">myEmitter.once(<span class="string">'event'</span>, () =&gt; &#123; <span class="comment">// 设置监听函数</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'an event occurred!'</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">myEmitter.emit(<span class="string">'event'</span>); <span class="comment">// 触发事件</span></div><div class="line">myEmitter.emit(<span class="string">'event'</span>); <span class="comment">// 触发事件</span></div></pre></td></tr></table></figure><p>以上例程会输出<code>1次</code> <code>an event occurred!</code>;</p><h2 id="同一事件多次监听"><a href="#同一事件多次监听" class="headerlink" title="同一事件多次监听"></a>同一事件多次监听</h2><p>上文中的监听方式都是只有<code>1个</code>监听函数，通过<code>多次调用on</code>可以设置多个监听函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyEmitter</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> myEmitter = <span class="keyword">new</span> MyEmitter();</div><div class="line"></div><div class="line">myEmitter.once(<span class="string">'event'</span>, () =&gt; &#123; <span class="comment">// 监听器1</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'监听器1收到事件'</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">myEmitter.on(<span class="string">'event'</span>, () =&gt; &#123; <span class="comment">// 监听器2</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'监听器2收到事件'</span>);</div><div class="line">&#125;)</div><div class="line"></div><div class="line">myEmitter.emit(<span class="string">'event'</span>); <span class="comment">// 触发事件</span></div></pre></td></tr></table></figure><p>以上例程会输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">监听器1收到事件</div><div class="line">监听器2收到事件</div></pre></td></tr></table></figure><h2 id="接收事件参数"><a href="#接收事件参数" class="headerlink" title="接收事件参数"></a>接收事件参数</h2><ol><li><code>emit</code>函数的第一个值为<code>事件名</code>,<code>后续参数为事件值</code></li><li><code>on</code>和<code>once</code>等监听器设置函数的回调函数收到的值<code>为emit传入的事件参数</code></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyEmitter</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> myEmitter = <span class="keyword">new</span> MyEmitter();</div><div class="line"></div><div class="line">myEmitter.once(<span class="string">'event'</span>, (param1,param2,param3) =&gt; &#123; <span class="comment">// 接收事件参数</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'收到事件'</span>,param1,param2,param3);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">myEmitter.emit(<span class="string">'event'</span>,<span class="string">'参数1'</span>,<span class="string">'参数2'</span>,&#123;<span class="attr">name</span>:<span class="string">'参数3'</span>&#125;); <span class="comment">// 发送事件参数</span></div></pre></td></tr></table></figure><p>以上例程会输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">收到事件 参数1 参数2 &#123; name: &apos;参数3&apos; &#125;</div></pre></td></tr></table></figure><h2 id="获取事件监听器上所有事件"><a href="#获取事件监听器上所有事件" class="headerlink" title="获取事件监听器上所有事件"></a>获取事件监听器上所有事件</h2><p>使用<code>eventNames()实例方法</code>获取监听器上所有事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyEmitter</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> myEmitter = <span class="keyword">new</span> MyEmitter();</div><div class="line"></div><div class="line">myEmitter.once(<span class="string">'event'</span>, (param1,param2,param3) =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'收到事件'</span>,param1,param2,param3);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">myEmitter.once(<span class="string">'event2'</span>,() =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'收到事件2'</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(myEmitter.eventNames());</div></pre></td></tr></table></figure><p>以上例程输出<code>[ &#39;event&#39;, &#39;event2&#39; ]</code></p><h2 id="移除事件监听器"><a href="#移除事件监听器" class="headerlink" title="移除事件监听器"></a>移除事件监听器</h2><p>使用<code>off实例方法</code>移除单个监听器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyEmitter</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> myEmitter = <span class="keyword">new</span> MyEmitter();</div><div class="line"></div><div class="line"><span class="keyword">const</span> callback = <span class="function">(<span class="params">param1</span>) =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(param1);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">myEmitter.on(<span class="string">'event'</span>, callback); <span class="comment">// 添加监听器</span></div><div class="line"></div><div class="line">myEmitter.off(<span class="string">'event'</span>, callback); <span class="comment">// 移除监听器</span></div><div class="line"></div><div class="line">myEmitter.emit(<span class="string">'event'</span>); <span class="comment">// 触发事件</span></div></pre></td></tr></table></figure><p>以上例程<code>没有输出</code>，因为<code>先添加监听器，随后移除，触发事件时已经没有可用的监听器了</code></p><h2 id="移除所有监听器"><a href="#移除所有监听器" class="headerlink" title="移除所有监听器"></a>移除所有监听器</h2><p>使用<code>removeAllListeners([eventName])实例方法移除所有监听器</code>。</p><ol><li>removeAllListener<code>不传参数</code>时移除该<code>emitter实例</code>上<code>所有</code>事件监听器</li><li>removeAllListener传入<code>字符串</code>参数时移除该<code>emitter实例</code>上<code>所有该事件</code>的监听器</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>事件系统是NodeJs的灵魂，在几乎所有的I/O模块都有使用，希望各位读者好好掌握。事件模块读后有疑问请加微信群讨论。</p><p><img src="https://more-happy.ddhigh.com/FpffwgkBeSWPyHRUJJmi9J9SFX_l?imageView2/1/w/200" alt="微信群"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;NodeJs简明教程将从零开始学习NodeJs相关知识，助力JS开发者构建全栈开发技术栈！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关注获取更多&lt;code&gt;NodeJs精品文章&lt;/code&gt;&lt;br&gt;&lt;img src=&quot;https://more-h
      
    
    </summary>
    
      <category term="nodejs" scheme="https//www.ddhigh.com/categories/nodejs/"/>
    
    
      <category term="javascript" scheme="https//www.ddhigh.com/tags/javascript/"/>
    
      <category term="nodejs guide" scheme="https//www.ddhigh.com/tags/nodejs-guide/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs简明教程(6)</title>
    <link href="https//www.ddhigh.com/2019/07/21/nodejs-guide-crypto.html"/>
    <id>https//www.ddhigh.com/2019/07/21/nodejs-guide-crypto.html</id>
    <published>2019-07-21T02:25:22.000Z</published>
    <updated>2019-07-23T06:14:56.221Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>NodeJs简明教程将从零开始学习NodeJs相关知识，助力JS开发者构建全栈开发技术栈！</p></blockquote><p>关注获取更多<code>NodeJs精品文章</code><br><img src="https://more-happy.ddhigh.com/FuFpZh9QTZVatcBtupR4MtOGPGTJ?imageView2/1/w/200" alt="二维码"></p><p>本文是NodeJs简明教程的第六篇，将介绍NodeJs crypto模块相关的基本操作。</p><blockquote><p>crypto 模块提供了加密功能，包括对 OpenSSL 的哈希、HMAC、加密、解密、签名、以及验证功能的一整套封装。</p></blockquote><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><blockquote><p>Hash类是用于创建数据哈希值的工具类。</p></blockquote><p>哈希算法严格来说并不属于加密算法，传统意义上的 <strong>加密</strong> 是与 <strong>解密</strong> 相配对的。哈希算法能够保证被哈希的内容不被篡改。针对任意长度的输入数据都可以产生固定位数的哈希值。</p><p>crypto模块对hash的操作是一致的，除了算法名不一致之外，本文以 <strong>md5</strong> 和 <strong>sha1</strong> 作为示例。</p><h3 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">'crypto'</span>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> hash = crypto.createHash(<span class="string">'md5'</span>); <span class="comment">// 创建MD5 hash示例</span></div><div class="line"></div><div class="line">hash.update(<span class="string">'111111'</span>); <span class="comment">// 待计算hash的数据</span></div><div class="line"><span class="built_in">console</span>.log(hash.digest(<span class="string">'hex'</span>));</div></pre></td></tr></table></figure><p>以上例程输出 <code>96e79218965eb72c92a549dd5a330112</code></p><h3 id="SHA1"><a href="#SHA1" class="headerlink" title="SHA1"></a>SHA1</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">'crypto'</span>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> hash = crypto.createHash(<span class="string">'sha1'</span>); <span class="comment">// 创建MD5 hash示例</span></div><div class="line"></div><div class="line">hash.update(<span class="string">'111111'</span>); <span class="comment">// 待计算hash的数据</span></div><div class="line"><span class="built_in">console</span>.log(hash.digest(<span class="string">'hex'</span>));</div></pre></td></tr></table></figure><p>以上例程输出 <code>3d4f2bf07dc1be38b20cd6e46949a1071f9d0e3d</code></p><h2 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h2><p><code>Base64</code>并不是<code>crypto</code>模块的成员，但是跟本节内容比较相近，所以放过来了。Base64是一套编码算法，常用在二进制数据编码上。</p><h3 id="Base64编码"><a href="#Base64编码" class="headerlink" title="Base64编码"></a>Base64编码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> data = <span class="string">'111111'</span>;</div><div class="line"><span class="keyword">const</span> encodedData = Buffer.from(data, <span class="string">'utf8'</span>).toString(<span class="string">'base64'</span>); <span class="comment">// 输入编码为utf8,输出为base64</span></div><div class="line"><span class="built_in">console</span>.log(encodedData);</div></pre></td></tr></table></figure><p>以上例程输出 <code>MTExMTEx</code></p><h3 id="Base64解码"><a href="#Base64解码" class="headerlink" title="Base64解码"></a>Base64解码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> data = <span class="string">'MTExMTEx'</span>;</div><div class="line"><span class="keyword">const</span> decodedData = Buffer.from(data, <span class="string">'base64'</span>).toString(<span class="string">'utf8'</span>); <span class="comment">// 输入编码为base64,输出编码为utf8</span></div><div class="line"><span class="built_in">console</span>.log(decodedData);</div></pre></td></tr></table></figure><p>以上例程输出<code>111111</code></p><h2 id="Hmac"><a href="#Hmac" class="headerlink" title="Hmac"></a>Hmac</h2><blockquote><p>Hmac类是用于创建加密Hmac摘要的工具。</p></blockquote><p>Hmac算法也是一种hash算法，但是它需要一个密钥，针对同样的输入，传统的hash算法输出是固定的。<br>但是Hmac的输出会随着密钥的不同而不同。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">'crypto'</span>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> hmac = crypto.createHmac(<span class="string">'sha256'</span>, <span class="string">'secret-key'</span>);</div><div class="line"></div><div class="line">hmac.update(<span class="string">'Hello, world!'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(hmac.digest(<span class="string">'hex'</span>));</div></pre></td></tr></table></figure><p>以上例程输出 <code>f4d850b1017eb4e20e0c58443919033c90cc9f4fe889b4d6b4572a4a0ec2d08a</code></p><h2 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h2><blockquote><p>AES是一种常用的对称加密算法，加解密都用同一个密钥。</p></blockquote><h3 id="AES加密"><a href="#AES加密" class="headerlink" title="AES加密"></a>AES加密</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">'crypto'</span>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> cipher = crypto.createCipheriv(<span class="string">'aes192'</span>, <span class="string">'111111111111111111111111'</span>, <span class="string">'1111111111111111'</span>)</div><div class="line"><span class="keyword">var</span> crypted = cipher.update(<span class="string">'1'</span>, <span class="string">'utf8'</span>, <span class="string">'hex'</span>); </div><div class="line">crypted += cipher.final(<span class="string">'hex'</span>);</div><div class="line"><span class="built_in">console</span>.log(crypted);</div></pre></td></tr></table></figure><p>以上例程输出 <code>5bb3e6eb39e502b5fa74d93796087efa</code></p><p><strong>说明：</strong></p><p><code>createCipheriv</code>原型如下：</p><p><code>crypto.createCipheriv（algorithm，key，iv [，options]）</code></p><ol><li><code>iv</code>是初始化向量，可以 <strong>为空</strong> 或者 <strong>16</strong> 字节的字符串</li><li><code>key</code>是加密密钥，根据选用的算法不同，密钥长度也不同，对应关系如下：<ol><li><code>aes128</code>对应<code>16位</code>长度密钥</li><li><code>aes192</code>对应<code>24位</code>长度秘钥</li><li><code>aes256</code>对应<code>32位</code>长度密钥</li></ol></li></ol><h3 id="AES解密"><a href="#AES解密" class="headerlink" title="AES解密"></a>AES解密</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">'crypto'</span>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> cipher = crypto.createDecipheriv(<span class="string">'aes192'</span>, <span class="string">'111111111111111111111111'</span>, <span class="string">'1111111111111111'</span>)</div><div class="line"><span class="keyword">var</span> data = cipher.update(<span class="string">'5bb3e6eb39e502b5fa74d93796087efa'</span>, <span class="string">'hex'</span>, <span class="string">'utf8'</span>); <span class="comment">// 输入数据编码为hex(16进制)，输出为utf8</span></div><div class="line">data += cipher.final(<span class="string">'utf8'</span>);</div><div class="line"><span class="built_in">console</span>.log(data);</div></pre></td></tr></table></figure><p>以上例程输出<code>1</code></p><p><code>crypto.createDecipheriv</code>方法原型与<code>crypto.createCipher</code>一致，这里不在赘述。</p><h2 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h2><blockquote><p>RSA算法是一种非对称加密算法，即由一个私钥和一个公钥构成的密钥对，通过私钥加密，公钥解密，或者通过公钥加密，私钥解密。其中，公钥可以公开，私钥必须保密。</p></blockquote><h3 id="生成密钥对"><a href="#生成密钥对" class="headerlink" title="生成密钥对"></a>生成密钥对</h3><p>使用RSA算法前必须提供密钥对，本文使用<code>openssl</code>命令进行生成。</p><ol><li><code>openssl genrsa -out private.pem 2048</code> 生成<code>2048位</code>长度的<code>私钥</code></li><li><code>openssl rsa -in private.pem -pubout -out public.pem</code> 导出公钥</li></ol><p>这样在当前目录我们就得到了<code>private.pem</code>和<code>public.pem</code></p><h3 id="RSA加密"><a href="#RSA加密" class="headerlink" title="RSA加密"></a>RSA加密</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">'crypto'</span>);</div><div class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> privateKey = fs.readFileSync(<span class="string">'./private.pem'</span>, &#123; <span class="attr">encoding</span>: <span class="string">'utf8'</span> &#125;);</div><div class="line"></div><div class="line"><span class="keyword">const</span> encodedData = crypto.privateEncrypt(privateKey, Buffer.from(<span class="string">'111111'</span>,<span class="string">'utf8'</span>)); <span class="comment">// 传入utf8编码的数据</span></div><div class="line"><span class="built_in">console</span>.log(encodedData.toString(<span class="string">'hex'</span>));</div></pre></td></tr></table></figure><p>以上例程输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">44a1b50b9639e4cbe17d55ca57dcb041387acadae3d3721fd9803a3a33091a36d59977feaa6caad990e58b9542c26297de6014e20819f0a71eadd0793bfe0fac834f30d2a05f8b329a3b2409e9f8b7fbd7de3734ada00228b84027568be58a2a34ccf0c4a8b2d02c58eef510931423ed5f40c696361b606df11609248b271aebcd17f9a113f98a8fa86c9c45bd609256f4779ce01ea3027171fffb35e695f1c38553aecafb72a2f46a9012246fde0f2934eacba8932bca38e228f4f4294873ed75d9acf79ab854897ebaab2375384b2da682c1b2e2b49b0592929067b3d5a11971d912629a178691345f7f88137343588b5c51d60643e5c00998484727b8c4a8</div></pre></td></tr></table></figure><h3 id="RSA解密"><a href="#RSA解密" class="headerlink" title="RSA解密"></a>RSA解密</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">'crypto'</span>);</div><div class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> publicKey = fs.readFileSync(<span class="string">'./public.pem'</span>, &#123; <span class="attr">encoding</span>: <span class="string">'utf8'</span> &#125;);</div><div class="line"></div><div class="line"><span class="keyword">const</span> encodedData = <span class="string">'44a1b50b9639e4cbe17d55ca57dcb041387acadae3d3721fd9803a3a33091a36d59977feaa6caad990e58b9542c26297de6014e20819f0a71eadd0793bfe0fac834f30d2a05f8b329a3b2409e9f8b7fbd7de3734ada00228b84027568be58a2a34ccf0c4a8b2d02c58eef510931423ed5f40c696361b606df11609248b271aebcd17f9a113f98a8fa86c9c45bd609256f4779ce01ea3027171fffb35e695f1c38553aecafb72a2f46a9012246fde0f2934eacba8932bca38e228f4f4294873ed75d9acf79ab854897ebaab2375384b2da682c1b2e2b49b0592929067b3d5a11971d912629a178691345f7f88137343588b5c51d60643e5c00998484727b8c4a8'</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> rawData = crypto.publicDecrypt(publicKey, Buffer.from(encodedData, <span class="string">'hex'</span>)); <span class="comment">// 传入hex(16进制)数据</span></div><div class="line"><span class="built_in">console</span>.log(rawData.toString(<span class="string">'utf8'</span>));</div></pre></td></tr></table></figure><p>以上例程输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">111111</div></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>常用的加解密、哈希、编解码用法已经介绍完毕，读后有疑问请加微信群讨论。</p><p><img src="https://more-happy.ddhigh.com/FpffwgkBeSWPyHRUJJmi9J9SFX_l?imageView2/1/w/200" alt="微信群"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;NodeJs简明教程将从零开始学习NodeJs相关知识，助力JS开发者构建全栈开发技术栈！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关注获取更多&lt;code&gt;NodeJs精品文章&lt;/code&gt;&lt;br&gt;&lt;img src=&quot;https://more-h
      
    
    </summary>
    
      <category term="nodejs" scheme="https//www.ddhigh.com/categories/nodejs/"/>
    
    
      <category term="javascript" scheme="https//www.ddhigh.com/tags/javascript/"/>
    
      <category term="nodejs guide" scheme="https//www.ddhigh.com/tags/nodejs-guide/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs简明教程(5)</title>
    <link href="https//www.ddhigh.com/2019/07/20/nodejs-guide-path.html"/>
    <id>https//www.ddhigh.com/2019/07/20/nodejs-guide-path.html</id>
    <published>2019-07-20T05:00:27.000Z</published>
    <updated>2019-07-23T06:14:56.220Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>NodeJs简明教程将从零开始学习NodeJs相关知识，助力JS开发者构建全栈开发技术栈！</p></blockquote><p>关注获取更多<code>NodeJs精品文章</code><br><img src="https://more-happy.ddhigh.com/FuFpZh9QTZVatcBtupR4MtOGPGTJ?imageView2/1/w/200" alt="二维码"></p><p>本文是NodeJs简明教程的第五篇，将介绍NodeJs path模块相关的基本操作。</p><blockquote><p>path 模块提供用于处理文件路径和目录路径的实用工具。 </p></blockquote><p><strong>注意：path模块只是处理文件路径，说白了就是字符串处理，跟文件系统无关</strong></p><h2 id="读取路径的文件名"><a href="#读取路径的文件名" class="headerlink" title="读取路径的文件名"></a>读取路径的文件名</h2><blockquote><p>path.basename() 方法返回 path 的最后一部分，类似于 Unix 的 basename 命令。 尾部的目录分隔符将被忽略。</p></blockquote><ol><li><p>返回带扩展名</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(path.basename(<span class="string">'/usr/local/a.txt'</span>))</div><div class="line"></div><div class="line"><span class="comment">// 输出 a.txt</span></div></pre></td></tr></table></figure></li><li><p>返回不带扩展名</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(path.basename(<span class="string">'/usr/local/a.txt'</span>,<span class="string">'.txt'</span>))</div><div class="line"></div><div class="line"><span class="comment">// 输出 a</span></div></pre></td></tr></table></figure></li></ol><h2 id="读取文件路径的目录名"><a href="#读取文件路径的目录名" class="headerlink" title="读取文件路径的目录名"></a>读取文件路径的目录名</h2><blockquote><p>path.dirname() 方法返回 path 的目录名，类似于 Unix 的 dirname 命令。 尾部的目录分隔符将被忽略。<br>path.extname() 方法返回 path 的扩展名，从最后一次出现 .（句点）字符到 path 最后一部分的字符串结束。 如果在 path 的最后一部分中没有 . ，或者如果 path 的基本名称（参阅 path.basename()）除了第一个字符以外没有 .，则返回空字符串。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(path.dirname(<span class="string">'/usr/local/a.txt'</span>))</div><div class="line"></div><div class="line"><span class="comment">// 输出 /usr/local</span></div></pre></td></tr></table></figure><h2 id="获取文件扩展名"><a href="#获取文件扩展名" class="headerlink" title="获取文件扩展名"></a>获取文件扩展名</h2><blockquote><p>path.extname() 方法返回 path 的扩展名，从最后一次出现 .（句点）字符到 path 最后一部分的字符串结束。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(path.extname(<span class="string">'/usr/local/a.txt'</span>));</div><div class="line"></div><div class="line"><span class="comment">// 输出 .txt</span></div></pre></td></tr></table></figure><h2 id="检测路径是否为绝对路径"><a href="#检测路径是否为绝对路径" class="headerlink" title="检测路径是否为绝对路径"></a>检测路径是否为绝对路径</h2><blockquote><p>path.isAbsolute() 方法检测 path 是否为绝对路径。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"><span class="comment">// linux || macosx</span></div><div class="line"><span class="built_in">console</span>.log(path.isAbsolute(<span class="string">'/usr/local'</span>)); <span class="comment">// 输出 true</span></div><div class="line"><span class="built_in">console</span>.log(path.isAbsolute(<span class="string">'usr/local'</span>)); <span class="comment">// 输出 false</span></div><div class="line"><span class="comment">// windows</span></div><div class="line"><span class="built_in">console</span>.log(path.isAbsolute(<span class="string">'//server'</span>)); <span class="comment">// 输出 true</span></div><div class="line"><span class="built_in">console</span>.log(path.isAbsolute(<span class="string">'\\\\server'</span>)); <span class="comment">// 输出 true</span></div><div class="line"><span class="built_in">console</span>.log(path.isAbsolute(<span class="string">'c:\windows'</span>)); <span class="comment">// 输出 true</span></div><div class="line"><span class="built_in">console</span>.log(path.isAbsolute(<span class="string">'foo/bar'</span>)); <span class="comment">// 输出 false</span></div></pre></td></tr></table></figure><h2 id="生成规范化的路径"><a href="#生成规范化的路径" class="headerlink" title="生成规范化的路径"></a>生成规范化的路径</h2><blockquote><p>path.join() 方法使用平台特定的分隔符作为定界符将所有给定的 path 片段连接在一起，然后规范化生成的路径。<br>零长度的 path 片段会被忽略。 如果连接的路径字符串是零长度的字符串，则返回 ‘.’，表示当前工作目录。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(path.join(<span class="string">'/a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'..'</span>)); <span class="comment">// 输出 /a/b</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(path.join(<span class="string">'.'</span>,<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'..'</span>,<span class="string">'c'</span>)); <span class="comment">// 输出 a/c</span></div></pre></td></tr></table></figure><h2 id="解析路径"><a href="#解析路径" class="headerlink" title="解析路径"></a>解析路径</h2><blockquote><p>path.parse() 方法返回一个对象，其属性表示 path 的重要元素。 尾部的目录分隔符将被忽略。<br>返回对象属性如下：<br>dir 目录<br>root 根目录<br>base 带扩展名的文件名或者目录名(最后一级是目录的情况下)<br>name 文件名(不带扩展名)或目录名<br>ext 文件扩展名(如果是目录则为空字符串)</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"></div><div class="line">path.parse(<span class="string">'/home/user/dir/file.txt'</span>);</div><div class="line"><span class="comment">// 返回:</span></div><div class="line"><span class="comment">// &#123; root: '/',</span></div><div class="line"><span class="comment">//   dir: '/home/user/dir',</span></div><div class="line"><span class="comment">//   base: 'file.txt',</span></div><div class="line"><span class="comment">//   ext: '.txt',</span></div><div class="line"><span class="comment">//   name: 'file' &#125;</span></div></pre></td></tr></table></figure><h2 id="获取两个路径的相对路径"><a href="#获取两个路径的相对路径" class="headerlink" title="获取两个路径的相对路径"></a>获取两个路径的相对路径</h2><blockquote><p>path.relative() 方法根据当前工作目录返回 from 到 to 的相对路径。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(path.relative(<span class="string">'/data/orandea/test/aaa'</span>, <span class="string">'/data/orandea/impl/bbb'</span>)); </div><div class="line"><span class="comment">// 输出 ../../impl/bbb</span></div></pre></td></tr></table></figure><h2 id="获取规范化的绝对路径"><a href="#获取规范化的绝对路径" class="headerlink" title="获取规范化的绝对路径"></a>获取规范化的绝对路径</h2><blockquote><p>path.resolve() 方法将路径或路径片段的序列解析为绝对路径。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(path.resolve(<span class="string">'/foo/bar'</span>, <span class="string">'./baz'</span>)); <span class="comment">// 输出 /for/bar/baz</span></div><div class="line"><span class="built_in">console</span>.log(path.resolve(<span class="string">'/foo/bar'</span>, <span class="string">'/tmp/file/'</span>);); <span class="comment">// 输出 /tmp/file</span></div><div class="line"><span class="built_in">console</span>.log(path.resolve(<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'../c/img.gif'</span>));</div><div class="line"><span class="comment">// 假设当前工作目录 /home/wwwroot，上述语句输出 /home/wwwroot/a/c/img.gif</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(path.resolve()); <span class="comment">// 假设当前工作目录 /home/wwwroot 输出 /home/wwwroot</span></div></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p><code>path</code>模块的主要就是处理路径相关，经常和<code>fs</code>模块共同使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;NodeJs简明教程将从零开始学习NodeJs相关知识，助力JS开发者构建全栈开发技术栈！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关注获取更多&lt;code&gt;NodeJs精品文章&lt;/code&gt;&lt;br&gt;&lt;img src=&quot;https://more-h
      
    
    </summary>
    
      <category term="nodejs" scheme="https//www.ddhigh.com/categories/nodejs/"/>
    
    
      <category term="javascript" scheme="https//www.ddhigh.com/tags/javascript/"/>
    
      <category term="nodejs guide" scheme="https//www.ddhigh.com/tags/nodejs-guide/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs简明教程(4)</title>
    <link href="https//www.ddhigh.com/2019/07/20/nodejs-guide-filesystem.html"/>
    <id>https//www.ddhigh.com/2019/07/20/nodejs-guide-filesystem.html</id>
    <published>2019-07-20T03:38:51.000Z</published>
    <updated>2019-07-23T06:14:56.221Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>NodeJs简明教程将从零开始学习NodeJs相关知识，助力JS开发者构建全栈开发技术栈！</p></blockquote><p>关注获取更多<code>NodeJs精品文章</code><br><img src="https://more-happy.ddhigh.com/FuFpZh9QTZVatcBtupR4MtOGPGTJ?imageView2/1/w/200" alt="二维码"></p><p>本文是NodeJs简明教程的第四篇，将介绍NodeJs文件系统模块相关的基本操作。</p><blockquote><p>fs 模块提供了一个 API，用于以模仿标准 POSIX 函数的方式与文件系统进行交互。</p></blockquote><h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><p>文件系统的大部分函数都存在 <strong>异步调用</strong> 和 <strong>同步调用</strong> 两种形式。</p><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>异步模式下，回调函数的第一个参数总为 <strong>Error</strong> 对象，且函数一般无返回值。</p><ol><li>如果为null，则本次调用未出错</li><li>如果不为null，证明本次调用出错</li></ol><p>新建 <code>index.js</code> 文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"></div><div class="line">fs.readFile(<span class="string">'./index.js'</span>, &#123; <span class="attr">encoding</span>: <span class="string">'utf8'</span> &#125;, (err, data) =&gt; &#123;</div><div class="line">    <span class="keyword">if</span> (err) &#123;</div><div class="line">        <span class="built_in">console</span>.error(<span class="string">'读取文件失败'</span>, err);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(data);</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p><code>readFile</code>的第二个参数如果不指定编码，回调函数取到的<code>data</code>对象是<code>Buffer</code>，需要手动转字符串。读取文本文件可以指定编码，但是读取二进制文件(<code>比如读取图片文件</code>)</p><ol><li>在当前目录执行 <code>node index.js</code></li><li><p>输出如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">const fs = require(&apos;fs&apos;);</div><div class="line"></div><div class="line">fs.readFile(&apos;./index.js&apos;, &#123; encoding: &apos;utf8&apos; &#125;, (err, data) =&gt; &#123;</div><div class="line">    if (err) &#123;</div><div class="line">        console.error(&apos;读取文件失败&apos;, err);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    console.log(data);</div><div class="line">&#125;)</div></pre></td></tr></table></figure></li></ol><h3 id="同步模式"><a href="#同步模式" class="headerlink" title="同步模式"></a>同步模式</h3><p>同步模式下，返回值为调用函数的结果，如果调用失败，将抛出<strong>Error</strong>对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">const</span> data = fs.readFileSync(<span class="string">'./index.js'</span>, &#123; <span class="attr">encoding</span>: <span class="string">'utf8'</span> &#125;);</div><div class="line">    <span class="built_in">console</span>.log(data);</div><div class="line">&#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'读取失败'</span>, e)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>输出数据和同步模式一致。</p><p>可以看到同步模式和异步模式下处理错误的方式是不同的。</p><blockquote><p>各位读者在生产中尽量不要使用同步函数，否则会阻塞事件循环。<br>当然，有一种情况例外，需要同步读取配置文件然后才启动服务器的这种情况是可以的。</p></blockquote><h2 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h2><p>新建<code>index.js</code>，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> data = <span class="string">'Hello World'</span>;</div><div class="line"></div><div class="line">fs.writeFile(<span class="string">'./a.txt'</span>, data, (error) =&gt; &#123;</div><div class="line">    <span class="keyword">if</span> (error) &#123;</div><div class="line">        <span class="built_in">console</span>.error(<span class="string">'保存失败'</span>, error);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'保存成功'</span>);</div><div class="line">&#125;)</div></pre></td></tr></table></figure><ol><li>执行<code>node index.js</code></li><li>输出<code>保存成功</code>，同时当前目录会多出内容为<code>Hello World</code>的文本文件。</li></ol><h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><ol><li><code>fs.copyFile(src,dest[,flags],callback)</code> 复制文件</li><li><code>fs.stat(path[,options],callback)</code> 读取文件状态</li><li><code>fs.unlink(path,callback)</code> 删除文件</li><li><code>fs.rename(oldPath,newPath,callback)</code> 重命名文件</li><li><code>fs.mkdir(path[,options],callback)</code> 新建目录</li><li><code>fs.rmdir(path,callback)</code> 删除目录</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>文件系统的学习暂时到此为止，用到的时候大家可以详细查看文件，文件系统的函数调用方式和本文的示例都是类似的，各位读者可以举一反三。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;NodeJs简明教程将从零开始学习NodeJs相关知识，助力JS开发者构建全栈开发技术栈！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关注获取更多&lt;code&gt;NodeJs精品文章&lt;/code&gt;&lt;br&gt;&lt;img src=&quot;https://more-h
      
    
    </summary>
    
      <category term="nodejs" scheme="https//www.ddhigh.com/categories/nodejs/"/>
    
    
      <category term="javascript" scheme="https//www.ddhigh.com/tags/javascript/"/>
    
      <category term="nodejs guide" scheme="https//www.ddhigh.com/tags/nodejs-guide/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs简明教程(3)</title>
    <link href="https//www.ddhigh.com/2019/07/19/nodejs-guide-http-server.html"/>
    <id>https//www.ddhigh.com/2019/07/19/nodejs-guide-http-server.html</id>
    <published>2019-07-19T03:04:46.000Z</published>
    <updated>2019-07-23T06:14:56.221Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>NodeJs简明教程将从零开始学习NodeJs相关知识，助力JS开发者构建全栈开发技术栈！</p></blockquote><p>关注获取更多<code>NodeJs精品文章</code><br><img src="https://more-happy.ddhigh.com/FuFpZh9QTZVatcBtupR4MtOGPGTJ?imageView2/1/w/200" alt="二维码"></p><p>本文是NodeJs简明教程的第三篇，将介绍NodeJs自带HTTP模块服务器相关的基本操作。</p><h2 id="HTTP模块介绍"><a href="#HTTP模块介绍" class="headerlink" title="HTTP模块介绍"></a>HTTP模块介绍</h2><p>以下是官方原文[1]：</p><blockquote><p>The HTTP interfaces in Node.js are designed to support many features of the protocol which have been traditionally difficult to use. In particular, large, possibly chunk-encoded, messages. The interface is careful to never buffer entire requests or responses — the user is able to stream data.</p></blockquote><p>大致意思就是：</p><blockquote><p>NodeJs的HTTP模块旨在支持传统上HTTP协议难以使用的许多功能，让这些功能或者特性能够使用简单的API进行调用。</p></blockquote><h2 id="HTTP模块服务器开发"><a href="#HTTP模块服务器开发" class="headerlink" title="HTTP模块服务器开发"></a>HTTP模块服务器开发</h2><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>以下是NodeJs最简单的HTTP服务器示例:</p><ol><li>新建<code>index.js</code></li><li><p>编码</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'%s %s'</span>, req.method, req.url)</div><div class="line">    res.end(<span class="built_in">JSON</span>.stringify(req.headers))</div><div class="line">&#125;)</div><div class="line"></div><div class="line">server.listen(<span class="number">8080</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'listen on 8080'</span>))</div></pre></td></tr></table></figure></li><li><p>打开终端或者控制台，执行 <code>node index.js</code>，终端或控制台会输出<code>listen on 8080</code>，此时HTTP服务器已经启动，如果启动失败，可以在下方留言</p></li><li><p>打开浏览器访问 <code>http://localhost:8080</code>，笔者输出如下：</p> <figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"host"</span>: <span class="string">"localhost:8080"</span>,</div><div class="line">    <span class="attr">"connection"</span>: <span class="string">"keep-alive"</span>,</div><div class="line">    <span class="attr">"cache-control"</span>: <span class="string">"max-age=0"</span>,</div><div class="line">    <span class="attr">"upgrade-insecure-requests"</span>: <span class="string">"1"</span>,</div><div class="line">    <span class="attr">"user-agent"</span>: <span class="string">"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36"</span>,</div><div class="line">    <span class="attr">"dnt"</span>: <span class="string">"1"</span>,</div><div class="line">    <span class="attr">"accept"</span>: <span class="string">"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3"</span>,</div><div class="line">    <span class="attr">"accept-encoding"</span>: <span class="string">"gzip, deflate, br"</span>,</div><div class="line">    <span class="attr">"accept-language"</span>: <span class="string">"zh-CN,zh;q=0.9,en;q=0.8,zh-TW;q=0.7"</span>,</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><h3 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h3><ol><li>NodeJs采用 <strong>CMD模块系统</strong>，<strong>require</strong> 用来加载模块，本例中加载了<strong>NodeJs自带的http模块</strong>以使用其中的功能</li><li><code>http.createServer</code>函数创建了一个 <strong>HTTP服务器</strong>，并配置了请求回调函数，在本系列的第一篇文章中说到事件驱动是需要回调函数进行监听的。</li><li><code>server.listen</code>是监听系统端口，第二个参数是<strong>监听成功的回调函数</strong></li></ol><h3 id="req对象"><a href="#req对象" class="headerlink" title="req对象"></a>req对象</h3><p>服务器收到的HTTP请求对象，以下是常用的属性或方法：</p><ol><li><code>req.url</code> 本次请求的路径(不包含域名)</li><li><code>req.headers</code> 本次请求的请求头</li><li><code>req.httpVersion</code> 本次请求的<code>HTTP协议版本号</code></li><li><code>req.method</code> 本次请求的请求方法,有<code>GET/POST/PUT等等</code></li><li><code>on()</code> 监听请求体数据 <code>POST/PUT/PATCH</code>方法会有请求体</li></ol><h3 id="res对象"><a href="#res对象" class="headerlink" title="res对象"></a>res对象</h3><p>res对象是req请求对象相应的响应对象，HTTP协议设计是<code>请求-应答</code>模型，一次请求对应一次应答。</p><p>以下是常用的属性或方法：</p><ol><li><code>res.writeHead</code> 输出<code>响应状态码</code>，<code>状态码说明</code>以及<code>多个HTTP响应头</code></li><li><code>res.end</code> 输出数据并结束本次响应</li><li><code>res.write</code> 输出<code>部分内容(chunk)</code></li><li><code>res.setHeader</code> 输出<code>单个响应头</code></li></ol><h3 id="请求路由"><a href="#请求路由" class="headerlink" title="请求路由"></a>请求路由</h3><p>NodeJs自带的HTTP服务器是没有路由功能的，也是就说，根据请求的URI来执行不同的逻辑需要开发者手动去做</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">if</span> (req.url === <span class="string">'/'</span>) &#123;</div><div class="line">        res.end(<span class="string">'index'</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (req.url === <span class="string">'/user'</span>) &#123;</div><div class="line">        res.end(<span class="string">'user'</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">server.listen(<span class="number">8080</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'listen on 8080'</span>));</div></pre></td></tr></table></figure><ol><li>执行<code>node index.js</code></li><li>浏览器访问 <a href="http://localhost:8080/" target="_blank" rel="external">http://localhost:8080/</a> 会输出<code>index</code></li><li>浏览器访问 <a href="http://localhost:8080/user" target="_blank" rel="external">http://localhost:8080/user</a> 会输出<code>user</code> </li></ol><h3 id="读取请求参数"><a href="#读取请求参数" class="headerlink" title="读取请求参数"></a>读取请求参数</h3><h4 id="读取GET请求参数"><a href="#读取GET请求参数" class="headerlink" title="读取GET请求参数"></a>读取GET请求参数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</div><div class="line"><span class="keyword">const</span> qs = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">const</span> parsed = url.parse(req.url);</div><div class="line">    <span class="keyword">const</span> query = qs.parse(parsed.query);</div><div class="line">    res.end(<span class="built_in">JSON</span>.stringify(query));</div><div class="line">&#125;)</div><div class="line"></div><div class="line">server.listen(<span class="number">8080</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'listen on 8080'</span>));</div></pre></td></tr></table></figure><ol><li>执行<code>node index.js</code></li><li>浏览器访问 <a href="http://localhost:8080/?a=x&amp;b=2&amp;c[]=1&amp;c[]=2" target="_blank" rel="external">http://localhost:8080/?a=x&amp;b=2&amp;c[]=1&amp;c[]=2</a></li><li><p>显示</p> <figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">     <span class="attr">"a"</span>: <span class="string">"x"</span>,</div><div class="line">     <span class="attr">"b"</span>: <span class="string">"2"</span>,</div><div class="line">     <span class="attr">"c[]"</span>: [<span class="string">"1"</span>, <span class="string">"2"</span>]</div><div class="line"> &#125;</div></pre></td></tr></table></figure></li></ol><h4 id="读取请求体参数"><a href="#读取请求体参数" class="headerlink" title="读取请求体参数"></a>读取请求体参数</h4><p>HTTP协议规范中POST/PUT/PATCH都可以携带请求体，NodeJs HTTP服务器接收请求体代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</div><div class="line"><span class="keyword">const</span> qs = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> data = Buffer.alloc(<span class="number">0</span>);</div><div class="line">    req.on(<span class="string">'data'</span>, (buffer) =&gt; &#123;</div><div class="line">        data = Buffer.concat([data, buffer]);</div><div class="line">    &#125;)</div><div class="line">    req.on(<span class="string">'end'</span>, () =&gt; &#123;</div><div class="line">        res.end(data.toString())</div><div class="line">    &#125;)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">server.listen(<span class="number">8080</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'listen on 8080'</span>));</div></pre></td></tr></table></figure><ol><li>执行<code>node index.js</code></li><li>使用 <strong>postman</strong> 发出POST请求<code>http://localhost:8080</code>，本例POST请求体为 <code>a=1&amp;b=2</code></li><li><strong>postman</strong>会返回 <code>a=1&amp;b=2</code></li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>一个简单的HTTP服务器就到此结束了，当然，实际生产中该方法用的比较少，几乎都是使用框架进行开发，提高开发效率。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;NodeJs简明教程将从零开始学习NodeJs相关知识，助力JS开发者构建全栈开发技术栈！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关注获取更多&lt;code&gt;NodeJs精品文章&lt;/code&gt;&lt;br&gt;&lt;img src=&quot;https://more-h
      
    
    </summary>
    
      <category term="nodejs" scheme="https//www.ddhigh.com/categories/nodejs/"/>
    
    
      <category term="javascript" scheme="https//www.ddhigh.com/tags/javascript/"/>
    
      <category term="nodejs guide" scheme="https//www.ddhigh.com/tags/nodejs-guide/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs简明教程(2)</title>
    <link href="https//www.ddhigh.com/2019/07/19/nodejs-guide-installation.html"/>
    <id>https//www.ddhigh.com/2019/07/19/nodejs-guide-installation.html</id>
    <published>2019-07-19T02:15:29.000Z</published>
    <updated>2019-07-23T06:14:56.229Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>NodeJs简明教程将从零开始学习NodeJs相关知识，助力JS开发者构建全栈开发技术栈！</p></blockquote><p>关注获取更多<code>NodeJs精品文章</code><br><img src="https://more-happy.ddhigh.com/FuFpZh9QTZVatcBtupR4MtOGPGTJ?imageView2/1/w/200" alt="二维码"></p><p>本文是NodeJs简明教程的第二篇，将介绍NodeJs在不同操作系统下的安装操作。</p><h2 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h2><p><a href="https://nodejs.org/en/" target="_blank" rel="external">https://nodejs.org</a></p><p>由于国内的网络原因，官网可能访问速度有点慢，推荐直接使用淘宝镜像源下载</p><h2 id="淘宝镜像源"><a href="#淘宝镜像源" class="headerlink" title="淘宝镜像源"></a>淘宝镜像源</h2><p><a href="https://npm.taobao.org/mirrors/node" target="_blank" rel="external">https://npm.taobao.org/mirrors/node</a>，这里是所有版本/所有操作系统的NodeJs安装包。</p><p>本系列文章使用 <strong>latest-v10.x</strong>，也就是 <strong>10.x</strong> 的NodeJs版本</p><ol><li>进入<a href="https://npm.taobao.org/mirrors/node/latest-v10.x/" target="_blank" rel="external">https://npm.taobao.org/mirrors/node/latest-v10.x/</a></li><li>可以看到最新的版本号为 <strong>node-v10.16.0</strong></li></ol><h2 id="Windows安装"><a href="#Windows安装" class="headerlink" title="Windows安装"></a>Windows安装</h2><ol><li><strong>64位</strong> 系统选择<a href="https://npm.taobao.org/mirrors/node/latest-v10.x/node-v10.16.0-x64.msi" target="_blank" rel="external">node-v10.16.0-x64.msi</a></li><li><strong>32位</strong> 系统选择<a href="https://npm.taobao.org/mirrors/node/latest-v10.x/node-v10.16.0-x86.msi" target="_blank" rel="external">node-v10.16.0-x86.msi</a></li><li>双击即可完成安装</li><li>安装完毕之后打开<code>cmd</code>执行<code>node -v</code>，显示版本号即为安装成功，安装失败的读者可以在下方留言</li></ol><h2 id="Mac安装"><a href="#Mac安装" class="headerlink" title="Mac安装"></a>Mac安装</h2><h3 id="PKG安装包安装"><a href="#PKG安装包安装" class="headerlink" title="PKG安装包安装"></a>PKG安装包安装</h3><ol><li>选择<a href="https://npm.taobao.org/mirrors/node/latest-v10.x/node-v10.16.0.pkg" target="_blank" rel="external">node-v10.16.0.pkg</a></li><li>双击即可完成安装</li><li>安装完毕之后打开<code>终端</code>执行<code>node -v</code>，显示版本号即为安装成功，安装失败的读者可以在下方留言</li></ol><h3 id="Homebrew安装"><a href="#Homebrew安装" class="headerlink" title="Homebrew安装"></a>Homebrew安装</h3><ol><li><code>brew install node</code></li><li>安装完毕之后打开<code>终端</code>执行<code>node -v</code>，显示版本号即为安装成功，安装失败的读者可以在下方留言</li></ol><h2 id="Linux安装"><a href="#Linux安装" class="headerlink" title="Linux安装"></a>Linux安装</h2><ol><li>选择<a href="https://npm.taobao.org/mirrors/node/latest-v10.x/node-v10.16.0-linux-x64.tar.gz" target="_blank" rel="external">node-v10.16.0-linux-x64.tar.gz</a>下载文件</li><li>执行<code>wget https://npm.taobao.org/mirrors/node/latest-v10.x/node-v10.16.0-linux-x64.tar.gz</code></li><li>执行<code>tar xf node-v10.16.0-linux-x64.tar.gz</code>解压</li><li>执行<code>mv node-v10.16.0-linux-x64 /opt/node</code>移动到<code>/opt</code>目录</li><li>执行<code>echo &quot;export PATH=/opt/node/bin:$PATH&quot; &gt;&gt; ~/.bashrc</code>编辑<code>PATH</code>环境变量</li><li>执行<code>source ~/.bashrc</code>更新环境变量</li><li>执行<code>node -v</code>，显示版本号即为安装成功，安装失败的读者可以在下方留言</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;NodeJs简明教程将从零开始学习NodeJs相关知识，助力JS开发者构建全栈开发技术栈！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关注获取更多&lt;code&gt;NodeJs精品文章&lt;/code&gt;&lt;br&gt;&lt;img src=&quot;https://more-h
      
    
    </summary>
    
      <category term="nodejs" scheme="https//www.ddhigh.com/categories/nodejs/"/>
    
    
      <category term="javascript" scheme="https//www.ddhigh.com/tags/javascript/"/>
    
      <category term="nodejs guide" scheme="https//www.ddhigh.com/tags/nodejs-guide/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs简明教程(1)</title>
    <link href="https//www.ddhigh.com/2019/07/18/nodejs-guide-about.html"/>
    <id>https//www.ddhigh.com/2019/07/18/nodejs-guide-about.html</id>
    <published>2019-07-18T02:02:46.000Z</published>
    <updated>2019-07-23T06:14:56.229Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>NodeJs简明教程将从零开始学习NodeJs相关知识，助力JS开发者构建全栈开发技术栈！</p></blockquote><p>关注获取更多<code>NodeJs精品文章</code><br><img src="https://more-happy.ddhigh.com/FuFpZh9QTZVatcBtupR4MtOGPGTJ?imageView2/1/w/200" alt="二维码"></p><p>本文是NodeJs简明教程的第一篇，将介绍NodeJs整体架构以及重点概念。</p><h2 id="NodeJs究竟是什么"><a href="#NodeJs究竟是什么" class="headerlink" title="NodeJs究竟是什么"></a>NodeJs究竟是什么</h2><p>来看一段官方的说法[1]：</p><blockquote><p>As an asynchronous event driven JavaScript runtime, Node is designed to build scalable network applications. In the following “hello world” example, many connections can be handled concurrently. Upon each connection the callback is fired, but if there is no work to be done, Node will sleep.</p></blockquote><p>Google翻译版本：</p><blockquote><p>作为异步事件驱动的JavaScript运行时，Node旨在构建可伸缩的网络应用程序。 在下面的“hello world”示例中，可以同时处理许多连接。 在每次连接时都会触发回调，但是如果没有工作要做，Node将会休眠。</p></blockquote><p>结合上面的介绍，我们可以得出一个结论：</p><blockquote><p>NodeJs的本质是一个Javascript运行时。该运行时基于异步事件驱动进行运作。</p></blockquote><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>本文中的异步指异步IO。维基百科对异步IO的定义[2]：</p><blockquote><p>异步IO是计算机操作系统对输入输出的一种处理方式：发起IO请求的线程不等IO操作完成，就继续执行随后的代码，IO结果用其他方式通知发起IO请求的程序。与异步IO相对的是更为常见的“同步（阻塞）IO”：发起IO请求的线程不从正在调用的IO操作函数返回（即被阻塞），直至IO操作完成。</p></blockquote><p>一言以蔽之就是：</p><blockquote><p>执行IO请求后，调用方不等执行结果就继续执行下面的代码，IO操作完成后执行者会告诉调用者“我执行完了”。在NodeJs中通知方式是“回调”。</p></blockquote><h3 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h3><p>事件驱动是相对 <strong>线程驱动</strong> 而言的。<strong>线程驱动</strong> 下服务器为每个请求新建一个线程去处理。<br>维基百科对事件驱动的定义[3]：</p><blockquote><p>事件驱动程序模型下的系统，基本上的架构是预先设计一个事件循环所形成的程序，这个事件循环程序不断地检查当前要处理的信息，根据要处理的信息运行一个触发函数进行必要的处理。其中这个外部信息可能来自一个目录夹中的文件，可能来自键盘或鼠标的动作，或者是一个时间事件。</p></blockquote><p>以NodeJs的HTTP服务器为例，当调用<code>server.listen</code>函数时，NodeJs就会创建一个事件循环，当有客户端请求过来时，NodeJs将该请求入队列进行后续处理，主线程以及轮询客户端请求并入队列，队列中的请求执行完毕后会通过回调函数的形式通知主线程，如此循环。</p><h3 id="Javascript运行时"><a href="#Javascript运行时" class="headerlink" title="Javascript运行时"></a>Javascript运行时</h3><p>Javascript运行时是个比较复杂的概念，本文在介绍 <strong>Javascript运行时</strong> 之前介绍一下 <strong>Javascript引擎</strong>。</p><h4 id="Javascript引擎"><a href="#Javascript引擎" class="headerlink" title="Javascript引擎"></a>Javascript引擎</h4><p>维基百科的定义[4]：</p><blockquote><p>JavaScript引擎是一个专门处理JavaScript脚本的虚拟机，一般会附带在网页浏览器之中。</p></blockquote><p>个人理解：</p><blockquote><p>Javascript引擎主要是对Javascript代码进行词法、语法等分析，通过编译器将代码编译成可执行的机器码让计算机去执行。</p></blockquote><p>目前业内出名的Javascript引擎非V8莫属了。</p><h4 id="运行时的组成"><a href="#运行时的组成" class="headerlink" title="运行时的组成"></a>运行时的组成</h4><p>Javascript可以运行在浏览器，也可以运行在服务器(NodeJs)中，有些API或者对象只有浏览器有(比如DOM,BOM等)，而有些API或者对象只有服务器中有(如文件操作，HTTP服务器等)。</p><blockquote><p>Javascript运行时包括了Javascript引擎、特定环境API、事件循环和事件队列。</p></blockquote><h3 id="NodeJs架构图"><a href="#NodeJs架构图" class="headerlink" title="NodeJs架构图"></a>NodeJs架构图</h3><p>NodeJs由C++语言基于libuv开发，分层设计，Javascript只是其基于V8提供的上层接口，换句话说，如果把上层接口换成其他语言实现，比如换成PHP实现，那么PHP就可以实现异步事件驱动的服务器，运行时名称就成为 <strong>NODE-PHP</strong>。</p><p><img src="https://more-happy.ddhigh.com/FqnmcUJhX0mGNDjMAIa1lOSJhNHJ" alt="NodeJs架构图"></p><ul><li>Node standard library NodeJs标准库，也是直接提供给开发者调用的顶层代码</li><li>Node bindings Javascript和libuv在该层进行通信，基于V8打通语言壁垒</li><li>V8 执行JS代码</li><li>libuv 高性能异步I/O、事件驱动、线程池的库，也是NodeJs高性能的保证</li><li>C-ares 提供异步DNS</li><li>http_parser、OpenSSL、Zlib 提供HTTP解析、openssl加解密、数据压缩等接口</li></ul><h3 id="NodeJs到底是不是单线程"><a href="#NodeJs到底是不是单线程" class="headerlink" title="NodeJs到底是不是单线程"></a>NodeJs到底是不是单线程</h3><blockquote><p>不是，主线程Javascript线程是单线程，libuv提供线程池，NodeJs不仅仅是一个Javascript引擎，而是一套运行时，不能将Javascript线程孤立出来。</p></blockquote><h2 id="NodeJs为什么这么快"><a href="#NodeJs为什么这么快" class="headerlink" title="NodeJs为什么这么快"></a>NodeJs为什么这么快</h2><ol><li>单线程解决了多线程环境下线程切换开销以及可能的线程同步开销</li><li>异步+事件驱动保证了NodeJs主线程不会阻塞，会一直接受请求(这也是受人诟病的地方，其他语言实现的服务器，请求过大会排队处理，NodeJs会将请求全部入队，导致内存暴涨)</li></ol><h2 id="NodeJs优缺点以及适合的场景"><a href="#NodeJs优缺点以及适合的场景" class="headerlink" title="NodeJs优缺点以及适合的场景"></a>NodeJs优缺点以及适合的场景</h2><ol><li>由于主线程Javascript线程是单线程，所以主线程不能做CPU密集操作（比如什么加解密之类的，这种操作只能有Javascript线程运行，会阻塞事件循环），所以NodeJs适合I/O密集场景，比如常见的（TCP/HTTP服务器）</li><li>对于前端开发者来说，几乎没有语言门槛</li><li>跨平台，NodeJs在主流操作系统都有对应的二进制程序</li><li>标准库强大，第三方库也很多，降低了造轮子成本</li><li>易于部署，服务器安装一个NodeJs程序配合NPM包管理器即可运行，不用像PHP那样还要安装扩展，配置前端HTTP服务器</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>欢迎继续关注本系列文章。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://nodejs.org/en/about/" target="_blank" rel="external">About NodeJs</a></li><li><a href="https://zh.wikipedia.org/zh-hans/%E5%BC%82%E6%AD%A5IO" target="_blank" rel="external">异步IO</a></li><li><a href="https://zh.wikipedia.org/wiki/%E4%BA%8B%E4%BB%B6%E9%A9%85%E5%8B%95%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88" target="_blank" rel="external">事件驱动</a></li><li><a href="https://zh.wikipedia.org/wiki/JavaScript%E5%BC%95%E6%93%8E" target="_blank" rel="external">Javascript引擎</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;NodeJs简明教程将从零开始学习NodeJs相关知识，助力JS开发者构建全栈开发技术栈！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关注获取更多&lt;code&gt;NodeJs精品文章&lt;/code&gt;&lt;br&gt;&lt;img src=&quot;https://more-h
      
    
    </summary>
    
      <category term="nodejs" scheme="https//www.ddhigh.com/categories/nodejs/"/>
    
    
      <category term="javascript" scheme="https//www.ddhigh.com/tags/javascript/"/>
    
      <category term="nodejs guide" scheme="https//www.ddhigh.com/tags/nodejs-guide/"/>
    
  </entry>
  
  <entry>
    <title>实现一个JS深拷贝函数</title>
    <link href="https//www.ddhigh.com/2019/07/16/make-a-deep-copy-function.html"/>
    <id>https//www.ddhigh.com/2019/07/16/make-a-deep-copy-function.html</id>
    <published>2019-07-16T03:17:59.000Z</published>
    <updated>2019-07-17T10:37:11.010Z</updated>
    
    <content type="html"><![CDATA[<p>JS深拷贝概念并不新鲜，但是真正要真正理解原理还是有点难度的。这也是JS语言精粹之一吧。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a = &#123;</div><div class="line">    name: <span class="string">'demo'</span>,</div><div class="line">    age: <span class="number">18</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> b = a;</div><div class="line">b.name = <span class="string">'demo1'</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 输出 &#123;name: "demo1", age: 18&#125;</span></div><div class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 输出 &#123;name: "demo1", age: 18&#125;</span></div></pre></td></tr></table></figure><p>因为JS对于对象的赋值使用的是浅拷贝，其中<code>一个实例变量</code>的赋值会影响到<code>所有指向该对象</code>的<code>变量</code></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol><li>粗暴好使的 <code>JSON.parse(JSON.stringify)</code>，缺点: <code>丢失成员函数</code></li><li><p><code>Object.assign</code>，缺点：<code>只有第一级深拷贝，子级对象依旧是浅拷贝</code>，例子如下：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a = &#123;<span class="attr">name</span>:&#123;<span class="attr">demo</span>:<span class="string">'1'</span>&#125;&#125;;</div><div class="line"><span class="keyword">let</span> b = <span class="built_in">Object</span>.assign(&#123;&#125;, a);</div><div class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 输出 &#123;name:&#123;demo:'1'&#125;&#125;</span></div><div class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 输出 &#123;name:&#123;demo:'1'&#125;&#125;</span></div><div class="line">b.name.demo = <span class="string">'2'</span>;</div><div class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 输出 &#123;name:&#123;demo:'2'&#125;&#125;</span></div><div class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 输出 &#123;name:&#123;demo:'2'&#125;&#125;</span></div></pre></td></tr></table></figure></li></ol><h2 id="手动实现原理"><a href="#手动实现原理" class="headerlink" title="手动实现原理"></a>手动实现原理</h2><ol><li>遍历待拷贝对象</li><li>判断当前值类型，如果是object类型且不是null(null也是object)，则递归调用拷贝函数</li><li>如果当前值类型时null或者非object类型，直接return，退出本次递归</li></ol><h2 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> result = obj;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> obj === <span class="string">'object'</span> &amp;&amp; obj !== <span class="literal">null</span>) &#123;</div><div class="line">        result = <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">'[object Array]'</span> ? []: &#123;&#125;;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> prop <span class="keyword">in</span> obj) &#123;</div><div class="line">            result[prop] = deepCopy(obj[prop]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>验证一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a = &#123;<span class="attr">name</span>:&#123;<span class="attr">demo</span>:<span class="string">'1'</span>&#125;&#125;;</div><div class="line"><span class="keyword">let</span> b = deepCopy(a);</div><div class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 输出 &#123;name:&#123;demo:'1'&#125;&#125;</span></div><div class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 输出 &#123;name:&#123;demo:'1'&#125;&#125;</span></div><div class="line">b.name.demo = <span class="string">'2'</span>;</div><div class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 输出 &#123;name:&#123;demo:'1'&#125;&#125;</span></div><div class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 输出 &#123;name:&#123;demo:'2'&#125;&#125;</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JS深拷贝概念并不新鲜，但是真正要真正理解原理还是有点难度的。这也是JS语言精粹之一吧。&lt;/p&gt;
&lt;h2 id=&quot;例子&quot;&gt;&lt;a href=&quot;#例子&quot; class=&quot;headerlink&quot; title=&quot;例子&quot;&gt;&lt;/a&gt;例子&lt;/h2&gt;&lt;figure class=&quot;highli
      
    
    </summary>
    
      <category term="frontend" scheme="https//www.ddhigh.com/categories/frontend/"/>
    
    
      <category term="javascript" scheme="https//www.ddhigh.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序数据字段大小写问题</title>
    <link href="https//www.ddhigh.com/2019/07/16/wechat-mini-program-data-column-case.html"/>
    <id>https//www.ddhigh.com/2019/07/16/wechat-mini-program-data-column-case.html</id>
    <published>2019-07-16T03:17:38.000Z</published>
    <updated>2019-07-18T03:19:54.659Z</updated>
    
    <content type="html"><![CDATA[<p>这两天在开发微信小程序登录以及加解密的时候，因为数据大小写的问题被坑了一把。</p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ol><li>小程序调用<code>wx.login</code>时会获得<code>code</code>，传输给服务端可以得到<code>openid</code>,<code>unionid(绑定了开放平台)</code>,<code>session_key</code></li><li>小程序调用<code>getUserInfo</code>会获得<code>encrypted_data</code>,<code>iv</code>,解密后得到<code>unionId</code>,<code>openId</code></li><li><code>unionid</code>和<code>openid</code>这两个场景<code>键名大小写是不同的</code></li></ol><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><ol><li><p>服务端根据<code>code获取session_key</code>返回结果如下：</p> <figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"session_key"</span>: <span class="string">"我是session_key"</span>,</div><div class="line">    <span class="attr">"openid"</span>: <span class="string">"我是openid"</span>,</div><div class="line">    <span class="attr">"unionid"</span>: <span class="string">"我是unionid"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>服务端根据<code>session_key解密encrypted_data和iv</code>返回结果如下：</p> <figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"openId"</span>: <span class="string">"OPENID"</span>,</div><div class="line">    <span class="attr">"nickName"</span>: <span class="string">"NICKNAME"</span>,</div><div class="line">    <span class="attr">"gender"</span>: GENDER,</div><div class="line">    <span class="attr">"city"</span>: <span class="string">"CITY"</span>,</div><div class="line">    <span class="attr">"province"</span>: <span class="string">"PROVINCE"</span>,</div><div class="line">    <span class="attr">"country"</span>: <span class="string">"COUNTRY"</span>,</div><div class="line">    <span class="attr">"avatarUrl"</span>: <span class="string">"AVATARURL"</span>,</div><div class="line">    <span class="attr">"unionId"</span>: <span class="string">"UNIONID"</span>,</div><div class="line">    <span class="attr">"watermark"</span>:</div><div class="line">    &#123;</div><div class="line">        <span class="attr">"appid"</span>:<span class="string">"APPID"</span>,</div><div class="line">        <span class="attr">"timestamp"</span>:TIMESTAMP</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><p>可以看到两次同样的字段<code>openid</code>和<code>unionid</code>大小写是不同的，此处容易踩坑。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ol><li>服务端根据<code>code换session_key/openid/unionid</code>是<code>小写</code></li><li>服务端根据<code>encrypted_data和iv</code>解密得到的<code>openId/unionId</code>是<code>大写</code></li></ol><p>最后，祝大家在开发过程中少踩坑。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这两天在开发微信小程序登录以及加解密的时候，因为数据大小写的问题被坑了一把。&lt;/p&gt;
&lt;h2 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;场景&quot;&gt;&lt;/a&gt;场景&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;小程序调用&lt;code&gt;wx.logi
      
    
    </summary>
    
      <category term="frontend" scheme="https//www.ddhigh.com/categories/frontend/"/>
    
    
      <category term="小程序" scheme="https//www.ddhigh.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>百度分享不支持HTTPS解决办法</title>
    <link href="https//www.ddhigh.com/2019/07/12/baidu-share-support-https.html"/>
    <id>https//www.ddhigh.com/2019/07/12/baidu-share-support-https.html</id>
    <published>2019-07-12T11:10:52.000Z</published>
    <updated>2019-07-12T11:34:45.033Z</updated>
    
    <content type="html"><![CDATA[<p>这两天接入文章页百度分享时发现本地可以显示分享按钮，但是发布到线上之后发现分享按钮不会展示。打开浏览器调试工具发现，HTTPS下的百度分享资源未加载，起初以为是HTTPS站点下面使用的是HTTP协议的链接，但是查看源代码发现是自适应协议的， 所以问题应该是处在百度这里。</p><p>打开<code>https://bdimg.share.baidu.com/static/api/js/share.js</code>发现浏览器提示<code>NET::ERR_CERT_COMMON_NAME_INVALID</code>，也就是<code>访问的域名和证书配置的域名不匹配</code>，证书的域名是<code>*.baidu.com</code>，访问的域名是<code>bdimg.share.baidu.com</code>，泛域名是不可以跨级使用的。</p><p>虽然是百度的问题，但是咱也不可能要他去改这个分享，所以只能自己来处理了。</p><h2 id="可能的处理方案"><a href="#可能的处理方案" class="headerlink" title="可能的处理方案"></a>可能的处理方案</h2><ol><li>全站使用HTTP，放弃该方案（现在都9012年了，免费证书一大把，基本都是HTTPS站点了）</li><li>将百度分享的资源打包下来进行部署<ol><li>部署到自己的服务器（成本低，易迁移，但是服务器带宽是个问题）</li><li>部署到CDN，本文以七牛为例</li></ol></li></ol><h2 id="资源路径"><a href="#资源路径" class="headerlink" title="资源路径"></a>资源路径</h2><p>百度分享相关JS我已经分享到github了，<a href="https://github.com/xialeistudio/baidu-share-resource" target="_blank" rel="external">一键直达仓库</a></p><h2 id="处理过程"><a href="#处理过程" class="headerlink" title="处理过程"></a>处理过程</h2><ol><li>将百度分享的资源解压到本地</li><li>使用PHP遍历目录上传到七牛(本文用的SPL进行文件夹遍历)</li><li>替换使用的百度分享JS路径</li></ol><h3 id="使用PHP变量目录上传到七牛"><a href="#使用PHP变量目录上传到七牛" class="headerlink" title="使用PHP变量目录上传到七牛"></a>使用PHP变量目录上传到七牛</h3><p>文件目录如下：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="string">|--static(百度分享资源目录)</span></div><div class="line"><span class="string">|--DirectorySync.php</span></div><div class="line"><span class="string">|--FilterScanner.php</span></div><div class="line"><span class="string">|--index.php</span></div></pre></td></tr></table></figure><p>DirectorySync.php<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 目录同步器</span></div><div class="line"><span class="comment"> * Class DirectorySync</span></div><div class="line"><span class="comment"> * <span class="doctag">@package</span> sync</span></div><div class="line"><span class="comment"> * <span class="doctag">@author</span> xialeistudio</span></div><div class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-11</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DirectorySync</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="keyword">private</span> $accessKey;</div><div class="line">    <span class="keyword">private</span> $secretKey;</div><div class="line">    <span class="keyword">private</span> $bucket;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@var</span> Auth</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> $auth;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * DirectorySync constructor.</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> $accessKey</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> $secretKey</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> $bucket</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($accessKey, $secretKey, $bucket)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;accessKey = $accessKey;</div><div class="line">        <span class="keyword">$this</span>-&gt;secretKey = $secretKey;</div><div class="line">        <span class="keyword">$this</span>-&gt;bucket = $bucket;</div><div class="line">        <span class="keyword">$this</span>-&gt;auth = <span class="keyword">new</span> Auth($accessKey, $secretKey);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 同步目录</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> array $list</span></div><div class="line"><span class="comment">     * <span class="doctag">@throws</span> \Exception</span></div><div class="line"><span class="comment">     * <span class="doctag">@author</span> xialeistudio</span></div><div class="line"><span class="comment">     * <span class="doctag">@date</span> 2019-07-11</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">sync</span><span class="params">(array $list)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        $uploader = <span class="keyword">new</span> UploadManager();</div><div class="line">        $token = <span class="keyword">$this</span>-&gt;auth-&gt;uploadToken(<span class="keyword">$this</span>-&gt;bucket);</div><div class="line">        <span class="keyword">foreach</span> ($list <span class="keyword">as</span> $path =&gt; $keyPrefix) &#123;</div><div class="line">            $scanner = <span class="keyword">new</span> FilterScanner($path);</div><div class="line">            <span class="keyword">foreach</span> ($scanner <span class="keyword">as</span> $filename) &#123;</div><div class="line">                printf(<span class="string">"uploading %s \n"</span>, $filename);</div><div class="line">                <span class="comment">/** <span class="doctag">@var</span> Error $error */</span></div><div class="line">                <span class="keyword">list</span>($ret, $error) = $uploader-&gt;putFile($token, $keyPrefix . $filename, $filename);</div><div class="line">                <span class="keyword">if</span> (!<span class="keyword">empty</span>($error)) &#123;</div><div class="line">                    printf(<span class="string">"uploading %s error: %s\n"</span>, $filename, $error-&gt;message());</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>FilterScanner.php<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 文件扫描器</span></div><div class="line"><span class="comment"> * Class FilterScanner</span></div><div class="line"><span class="comment"> * <span class="doctag">@package</span> sync</span></div><div class="line"><span class="comment"> * <span class="doctag">@author</span> xialeistudio</span></div><div class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-11</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilterScanner</span> <span class="keyword">extends</span> <span class="title">FilterIterator</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * FilterScanner constructor.</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> $path</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($path)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">parent</span>::__construct(<span class="keyword">new</span> RecursiveIteratorIterator(<span class="keyword">new</span> RecursiveDirectoryIterator($path)));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Check whether the current element of the iterator is acceptable</span></div><div class="line"><span class="comment">     * <span class="doctag">@link</span> https://php.net/manual/en/filteriterator.accept.php</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> bool true if the current element is acceptable, otherwise false.</span></div><div class="line"><span class="comment">     * <span class="doctag">@since</span> 5.1.0</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">accept</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">return</span> substr(<span class="keyword">$this</span>-&gt;current(), <span class="number">-1</span>, <span class="number">1</span>) != <span class="string">'.'</span> &amp;&amp; substr(<span class="keyword">$this</span>-&gt;current(), <span class="number">-2</span>, <span class="number">2</span>) != <span class="string">'..'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>index.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$sync = <span class="keyword">new</span> DirectorySync(ACCESS_KEY, SECRET_KEY, BUCKET);</div><div class="line">$sync-&gt;sync([</div><div class="line">    <span class="string">'static'</span> =&gt; <span class="string">''</span></div><div class="line">]);</div></pre></td></tr></table></figure><p>上传之前需要修改一下百度分享js相关的域名。打开<code>static/api/js/share.js</code>，搜索到如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jscfg: &#123;<span class="attr">domain</span>: &#123;<span class="attr">staticUrl</span>: <span class="string">"/"</span>&#125;&#125;</div></pre></td></tr></table></figure><p>将<code>staticUrl</code>改成七牛的域名，本站使用的是<code>static.ddhigh.com</code>，所以改完之后的代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jscfg: &#123;<span class="attr">domain</span>: &#123;<span class="attr">staticUrl</span>: <span class="string">"//static.ddhigh.com/"</span>&#125;&#125;</div></pre></td></tr></table></figure><p>完事之后执行<code>php index.php</code>上传到七牛，此时就可以随意部署了~。</p><h2 id="部署到应用"><a href="#部署到应用" class="headerlink" title="部署到应用"></a>部署到应用</h2><p>将以往使用<code>bdimg.share.baidu.com/static/api/js/share.js</code>的地方换成<code>//static.ddhigh.com/static/api/js/share.js</code>即可，其他资源会自动加载。</p><p><em>本站的CDN域名做了防盗链处理，各位如果直接用我的share.js链接是会有问题的</em></p><h2 id="hexo-Next百度分享的额外处理"><a href="#hexo-Next百度分享的额外处理" class="headerlink" title="hexo Next百度分享的额外处理"></a>hexo Next百度分享的额外处理</h2><p>上传到七牛这个步骤完成之后，搜索文件<code>baidushare.swig</code>，找到最下面的如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span>(<span class="built_in">document</span>)<span class="number">0</span>[(getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>]||body).appendChild(createElement(<span class="string">'script'</span>)).src=<span class="string">'//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='</span>+~(-<span class="keyword">new</span> <span class="built_in">Date</span>()/<span class="number">36e5</span>)];</div></pre></td></tr></table></figure><p>将链接替换为自己的CDN链接，我这边替换后的结果如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span>(<span class="built_in">document</span>)<span class="number">0</span>[(getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>]||body).appendChild(createElement(<span class="string">'script'</span>)).src=<span class="string">'//static.ddhigh.com/static/api/js/share.js?cdnversion='</span>+~(-<span class="keyword">new</span> <span class="built_in">Date</span>()/<span class="number">36e5</span>)];</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这两天接入文章页百度分享时发现本地可以显示分享按钮，但是发布到线上之后发现分享按钮不会展示。打开浏览器调试工具发现，HTTPS下的百度分享资源未加载，起初以为是HTTPS站点下面使用的是HTTP协议的链接，但是查看源代码发现是自适应协议的， 所以问题应该是处在百度这里。&lt;/
      
    
    </summary>
    
      <category term="frontend" scheme="https//www.ddhigh.com/categories/frontend/"/>
    
    
  </entry>
  
  <entry>
    <title>Js使用AES加密PHP使用Openssl解密</title>
    <link href="https//www.ddhigh.com/2019/07/11/js-encrypt-php-decrypt.html"/>
    <id>https//www.ddhigh.com/2019/07/11/js-encrypt-php-decrypt.html</id>
    <published>2019-07-11T07:00:43.000Z</published>
    <updated>2019-07-11T07:19:28.542Z</updated>
    
    <content type="html"><![CDATA[<p>最近遇到的几个网站在提交密码时提交的已经是密文，也就是说在网络上传输的密码是密文，这样提升了密码在网络传输中的安全性。</p><p>后端语言加解密已经有很成熟的方案了，前端的话Google之前出过一个<a href="https://www.npmjs.com/package/crypto-js" target="_blank" rel="external">crypto-js</a>，为浏览器的js提供了加解密方案。今天一起来了解一下基于AES的前后端加解密流程。</p><h2 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h2><ol><li>安装npm包 <code>npm install crypto-js</code></li><li><p>加密代码</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> CryptoJS = <span class="built_in">require</span>(<span class="string">"crypto-js"</span>);</div><div class="line"><span class="keyword">const</span> key = CryptoJS.enc.Latin1.parse(<span class="string">'1234567812345678'</span>);</div><div class="line"><span class="keyword">const</span> iv = CryptoJS.enc.Latin1.parse(<span class="string">'1234567812345678'</span>);</div><div class="line"><span class="keyword">const</span> encoded = CryptoJS.AES.encrypt(<span class="string">'hahaha'</span>, key, &#123;</div><div class="line">    iv: iv,</div><div class="line">    mode: CryptoJS.mode.CBC,</div><div class="line">    adding: CryptoJS.pad.ZeroPadding</div><div class="line">&#125;).toString()</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'encoded'</span>, encoded)</div></pre></td></tr></table></figure></li><li><p>解密代码</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> key = CryptoJS.enc.Latin1.parse(<span class="string">'123456781234567812345678'</span>);</div><div class="line"><span class="keyword">const</span> iv = CryptoJS.enc.Latin1.parse(<span class="string">'1234567812345678'</span>);</div><div class="line"><span class="keyword">const</span> decoded = CryptoJS.AES.decrypt(encoded, key, &#123;</div><div class="line">    iv: iv,</div><div class="line">    mode: CryptoJS.mode.CBC,</div><div class="line">    adding: CryptoJS.pad.ZeroPadding</div><div class="line">&#125;).toString(CryptoJS.enc.Utf8)</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'decoded'</span>, decoded);</div></pre></td></tr></table></figure></li><li><p>输出如下</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">encoded 6bcgYd4f4ZgNOQH/3tqMpg==</div><div class="line">decoded hahaha</div></pre></td></tr></table></figure></li></ol><h2 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h2><p>直接使用openssl解密即可，代码如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$encoded = <span class="string">'6bcgYd4f4ZgNOQH/3tqMpg=='</span>;</div><div class="line">$key  = <span class="string">'123456781234567812345678'</span>;</div><div class="line">$iv = <span class="string">'1234567812345678'</span>;</div><div class="line">var_dump(openssl_decrypt($encoded, <span class="string">'AES-192-CBC'</span>, $key, <span class="number">0</span>,$iv));</div></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">string(6) &quot;hahaha&quot;</div></pre></td></tr></table></figure><p>注意事项</p><ol><li>AES加密位数跟密钥<code>key</code>有关, 以下是密钥位数和加密对应关系<ol><li>16 =&gt; AES-128</li><li>24 =&gt; AES-192</li><li>32 =&gt; AES-256</li></ol></li><li><code>iv</code>是初始化向量. 超过16字节或者不足16字节都会被补足16字节或者截断到16字节。由于AES是块加密，铭文被分割成固定长度的块（一般是16字节长度），所以<code>iv</code>也是<code>16</code>字节。</li><li>CBC是加密模式</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近遇到的几个网站在提交密码时提交的已经是密文，也就是说在网络上传输的密码是密文，这样提升了密码在网络传输中的安全性。&lt;/p&gt;
&lt;p&gt;后端语言加解密已经有很成熟的方案了，前端的话Google之前出过一个&lt;a href=&quot;https://www.npmjs.com/pack
      
    
    </summary>
    
      <category term="php" scheme="https//www.ddhigh.com/categories/php/"/>
    
    
      <category term="javascript" scheme="https//www.ddhigh.com/tags/javascript/"/>
    
      <category term="aes" scheme="https//www.ddhigh.com/tags/aes/"/>
    
      <category term="encrypt" scheme="https//www.ddhigh.com/tags/encrypt/"/>
    
  </entry>
  
  <entry>
    <title>vue webpack重写cookie路径</title>
    <link href="https//www.ddhigh.com/2019/07/08/vue-webpack-rewrite-cookie-path.html"/>
    <id>https//www.ddhigh.com/2019/07/08/vue-webpack-rewrite-cookie-path.html</id>
    <published>2019-07-08T09:24:05.000Z</published>
    <updated>2019-07-08T09:32:19.774Z</updated>
    
    <content type="html"><![CDATA[<p>webpack提供的反向代理服务器在开发阶段非常方便，几行简单的代码配置就可以使用反向代理功能，包括路径重写、cookie处理等。</p><p>项目开发阶段使用的API路径是 <code>/admin</code>，部署到线上是<code>/</code>，所以在开发过程中需要在<code>proxyTable</code>进行反向代理配置，将路径重写掉，路径重写代码如下(<code>config/index.js</code>):</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">proxyTable: &#123;</div><div class="line">      <span class="string">'/admin'</span>: &#123;</div><div class="line">        target: <span class="string">'http://127.0.0.1:8080'</span>,</div><div class="line">        changeOrigin: <span class="literal">true</span>,</div><div class="line">        pathRewrite: &#123;</div><div class="line">          <span class="string">'^/admin'</span>: <span class="string">'/admin2'</span></div><div class="line">        &#125;,</div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>启动项目之后进行登录，此时API请求成功，但是获取登录用户信息时发现cookie没有带过去。查看请求发现登录请求的<code>Set-Cookie</code>响应头中的<code>Path</code>是<code>/admin2</code>。但是咱们请求的路径是<code>/admin</code>，cookie当然不会生效。</p><p>查阅文档发现，proxyTable支持<code>onProxyRes</code>回调函数来自定义响应，流程是通过替换后端服务器设置的<code>cookie-path</code>来进行处理，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">proxyTable: &#123;</div><div class="line">      <span class="string">'/admin'</span>: &#123;</div><div class="line">        target: <span class="string">'http://127.0.0.1:8080'</span>,</div><div class="line">        changeOrigin: <span class="literal">true</span>,</div><div class="line">        pathRewrite: &#123;</div><div class="line">          <span class="string">'^/admin'</span>: <span class="string">'/lesson/admin'</span></div><div class="line">        &#125;,</div><div class="line">        onProxyRes: <span class="function"><span class="keyword">function</span> (<span class="params">proxyRes, req, res</span>) </span>&#123;</div><div class="line">          <span class="keyword">const</span> cookies = proxyRes.headers[<span class="string">'set-cookie'</span>]</div><div class="line">          <span class="keyword">if</span> (cookies) &#123;</div><div class="line">            <span class="keyword">const</span> newCookies = cookies.map(<span class="function"><span class="params">cookie</span> =&gt;</span> &#123;</div><div class="line">              <span class="keyword">return</span> cookie.replace(<span class="regexp">/Path=\/admin2/</span>, <span class="string">'Path=/'</span>)</div><div class="line">            &#125;)</div><div class="line">            <span class="keyword">delete</span> proxyRes.headers[<span class="string">'set-cookie'</span>]</div><div class="line">            proxyRes.headers[<span class="string">'set-cookie'</span>] = newCookies</div><div class="line">          &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">&#125;,</div></pre></td></tr></table></figure><p>重启webpack之后重新登录，发现cookie的路径已经被重写到<code>/</code>了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;webpack提供的反向代理服务器在开发阶段非常方便，几行简单的代码配置就可以使用反向代理功能，包括路径重写、cookie处理等。&lt;/p&gt;
&lt;p&gt;项目开发阶段使用的API路径是 &lt;code&gt;/admin&lt;/code&gt;，部署到线上是&lt;code&gt;/&lt;/code&gt;，所以在开发过程
      
    
    </summary>
    
      <category term="frontend" scheme="https//www.ddhigh.com/categories/frontend/"/>
    
    
      <category term="javascript" scheme="https//www.ddhigh.com/tags/javascript/"/>
    
      <category term="vue" scheme="https//www.ddhigh.com/tags/vue/"/>
    
      <category term="webpack" scheme="https//www.ddhigh.com/tags/webpack/"/>
    
  </entry>
  
</feed>
