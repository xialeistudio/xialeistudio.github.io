[{"title":"NodeJs简明教程(8)","url":"%2F2019%2F07%2F23%2Fnodejs-guide-child-process.html","content":"\n> NodeJs简明教程将从零开始学习NodeJs相关知识，助力JS开发者构建全栈开发技术栈！\n\n关注获取更多`NodeJs精品文章`\n![二维码](https://more-happy.ddhigh.com/FuFpZh9QTZVatcBtupR4MtOGPGTJ?imageView2/1/w/200)\n\n本文是NodeJs简明教程的第八篇，将介绍NodeJs **子进程** 模块相关的基本操作。\n\n> child_process 模块提供了衍生子进程的能力（以一种与 popen(3) 类似但不相同的方式）。\n\nNodeJs的JS线程虽然是单线程，不能利用多核CPU，也不能执行CPU密集型的任务，但是通过派生子进程的形式加上**IPC(进程间通信)**，可以充分利用多核CPU。\n\n## spawn\n\n `spawn`可以执行`指定的命令`，`spawn`的函数原型如下：\n\n```js\nchild_process.spawn(command[,args][,options])\n```\n\n+ command `<string>` 要执行的命令\n+ args `<string[]>` 传给命令的参数列表\n+ options `<Object>` 额外选项\n  + cwd `<string>` 子进程`workdir`\n  + env `<Object>` 子进程环境变量\n\n```js\nconst { spawn } = require('child_process');\nconst ls = spawn('ls', ['-lh', '/usr']); // 命令配置\n\nls.stdout.on('data', (data) => { // 监听命令执行的标准输出\n  console.log(`stdout: ${data}`);\n});\n\nls.stderr.on('data', (data) => { // 监听命令执行的标准错误输出\n  console.log(`stderr: ${data}`);\n});\n\nls.on('close', (code) => { // 监听子进程退出\n  console.log(`子进程退出，使用退出码 ${code}`);\n});\n```\n\n以上例程输出(不同机器输出可能不一样)\n\n```text\nstdout: total 0\ndrwxr-xr-x  970 root  wheel    30K  7 19 23:00 bin\ndrwxr-xr-x  306 root  wheel   9.6K  7 12 22:35 lib\ndrwxr-xr-x  249 root  wheel   7.8K  7 19 23:00 libexec\ndrwxr-xr-x   15 root  wheel   480B  4  1 14:15 local\ndrwxr-xr-x  239 root  wheel   7.5K  7 12 22:35 sbin\ndrwxr-xr-x   46 root  wheel   1.4K  9 21  2018 share\ndrwxr-xr-x    5 root  wheel   160B  9 21  2018 standalone\n\n子进程退出，使用退出码 0\n```\n\n## exec\n\n`exec`也可以执行`指定的命令`，与`spawn`区别是执行结果通过回调通知，`spawn`是通过事件，`exec`函数原型如下：\n\n```js\nexec(command[,options][,callback])\n```\n\n+ command `<string>` 要执行的命令，命令参数使用空格分隔\n+ options `<Object>` 额外选项\n  + cwd `<string>` 子进程`workdir`\n  + env `<Object>` 子进程环境变量\n  + timeout `<number>` 子进程执行超时\n+ callback `<Function>` 执行结果回调\n  + error `<Error>` 执行错误(不是子进程的错误输出)\n  + stdout `<string|Buffer>` 子进程标准输出\n  + stderr `<string|Buffer>` 子进程标准错误输出\n\n```js\nconst exec = require('child_process').exec;\n\nexec('ls -lh /usr',function(err,stdout,stderr) {\n    if(err) {\n        console.log('执行错误', err);\n    }\n    console.log('stdout', stdout);\n    console.log('stderr', stderr);\n});\n```\n\n以上例程输出\n\n```text\nconst exec = require('child_process').exec;\n\nexec('ls -lh /usr',function(err,stdout,stderr) {\n    if(err) {\n        console.log('执行错误', err);\n    }\n    console.log('stdout', stdout);\n    console.log('stderr', stderr);\n});\n```\n\n## execFile\n\n`execFile`类似于`exec`，但默认情况下不会派生shell， 相反，指定的可执行文件 file 会作为新进程直接地衍生，使其比 `exec`稍微更高效。\n\n支持与`exec`相同的选项。 由于没有衍生 shell，因此`不支持 I/O 重定向和文件通配等行为`。`execFile`原型：\n\n```js\nexecFile(file[,args][,options][,callback])\n```\n\n+ file `<string>` 要执行的命令或可执行文件路径\n+ args `<string[]>` 字符串数组形式的参数列表\n+ options `<Object>` 额外选项\n  + cwd `<string>` 子进程`workdir`\n  + env `<Object>` 子进程环境变量\n  + timeout `<number>` 子进程执行超时\n+ callback `<Function>` 执行结果回调\n  + error `<Error>` 执行错误(不是子进程的错误输出)\n  + stdout `<string|Buffer>` 子进程标准输出\n  + stderr `<string|Buffer>` 子进程标准错误输出\n\n```js\nconst execFile = require('child_process').execFile;\nexecFile('ls', ['--version'], function(error, stdout, stderr) {\n    if(err) {\n        console.log('执行错误', err);\n    }\n    console.log('stdout', stdout);\n    console.log('stderr', stderr);\n});\n```\n\n以上例程输出同`exec`\n\n## fork\n\n`fork`是`spawn`的一个特例，专门用于派生新的`NodeJs进程`。`spawn`可以派生`任何进程`。`fork`方法原型如下：\n\n```js\nfork(modulePath[,args][,options])\n```\n\n+ modulePath `<string>` 要执行的JS路径\n+ args `<string[]>` 字符串数组形式的参数列表\n+ options `<Object>` 额外选项\n  + cwd `<string>` 子进程的`workdir`\n  + env `<Object>` 环境变量\n  + silent `<boolean>` 如果为 true，则子进程的 stdin、stdout 和 stderr 将会被输送到父进程，否则它们将会继承自父进程。默认`false`\n\nb.js\n\n```js\nconst fork = require('child_process').fork;\n\nconst child = fork('./a.js',{silent:true}); // silent为true时可以监听子进程标准输出和标准错误输出\nchild.stdout.on('data',function(data){ // 监听子进程标准输出\n    console.log('child stdout', data.toString('utf8'));\n});\nchild.stderr.on('data', function(data){ // 监听子进程标准错误输出\n    console.log('child stderr', data.toString('utf8'));\n});\nchild.on('close', function(){\n    console.log('child exit');\n});\n```\n\na.js\n\n```js\nconsole.log('我是子进程`);\n```\n\n终端执行`node b.js`，以上例程输出：\n\n```text\nchild stdout 我是子进程\n\nchild exit\n```\n\n## 结语\n\n子进程模块的介绍到此就告一段落了，一般情况下使用`spawn`和`execFile`即可。有任何疑问请扫码加群交流：\n\n![微信群](https://more-happy.ddhigh.com/FpffwgkBeSWPyHRUJJmi9J9SFX_l?imageView2/1/w/200)","tags":["nodejs guide"],"categories":["nodejs"]},{"title":"NodeJs简明教程(7)","url":"%2F2019%2F07%2F22%2Fnodejs-guide-events.html","content":"\n> NodeJs简明教程将从零开始学习NodeJs相关知识，助力JS开发者构建全栈开发技术栈！\n\n关注获取更多`NodeJs精品文章`\n![二维码](https://more-happy.ddhigh.com/FuFpZh9QTZVatcBtupR4MtOGPGTJ?imageView2/1/w/200)\n\n本文是NodeJs简明教程的第七篇，将介绍NodeJs events模块相关的基本操作。\n\n> 大多数 Node.js 核心 API 构建于惯用的异步事件驱动架构，其中某些类型的对象（又称触发器，Emitter）会触发命名事件来调用函数（又称监听器，Listener）。\n\n## 快速开始\n\n使用事件监听器一般包含以下操作：\n\n1. 新建事件监听器实例\n2. 设置监听函数\n3. 触发事件\n\n```js\nconst EventEmitter = require('events'); // 引用模块\n\nclass MyEmitter extends EventEmitter {} // 初始化监听器\n\nconst myEmitter = new MyEmitter();\n\nmyEmitter.on('event', () => { // 设置监听函数\n  console.log('an event occurred!');\n});\n\nmyEmitter.emit('event'); // 触发事件\n```\n\n以上例程会输出`an event occurred!`\n\n## 一次性事件监听\n\n上文中的监听方式`事件触发几次`就会`输出几次an event occurred!`，有些事件可能是一次性的。这时候可以使用`once`监听。\n\n```js\nconst EventEmitter = require('events'); // 引用模块\n\nclass MyEmitter extends EventEmitter {} // 初始化监听器\n\nconst myEmitter = new MyEmitter();\n\nmyEmitter.once('event', () => { // 设置监听函数\n  console.log('an event occurred!');\n});\n\nmyEmitter.emit('event'); // 触发事件\nmyEmitter.emit('event'); // 触发事件\n```\n\n以上例程会输出`1次` `an event occurred!`;\n\n## 同一事件多次监听\n\n上文中的监听方式都是只有`1个`监听函数，通过`多次调用on`可以设置多个监听函数。\n\n```js\nconst EventEmitter = require('events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\n\nmyEmitter.once('event', () => { // 监听器1\n  console.log('监听器1收到事件');\n});\n\nmyEmitter.on('event', () => { // 监听器2\n  console.log('监听器2收到事件');\n})\n\nmyEmitter.emit('event'); // 触发事件\n```\n\n以上例程会输出\n\n```text\n监听器1收到事件\n监听器2收到事件\n```\n\n## 接收事件参数\n\n1. `emit`函数的第一个值为`事件名`,`后续参数为事件值`\n2. `on`和`once`等监听器设置函数的回调函数收到的值`为emit传入的事件参数`\n\n```js\nconst EventEmitter = require('events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\n\nmyEmitter.once('event', (param1,param2,param3) => { // 接收事件参数\n  console.log('收到事件',param1,param2,param3);\n});\n\nmyEmitter.emit('event','参数1','参数2',{name:'参数3'}); // 发送事件参数\n```\n\n以上例程会输出\n\n```text\n收到事件 参数1 参数2 { name: '参数3' }\n```\n\n## 获取事件监听器上所有事件\n\n使用`eventNames()实例方法`获取监听器上所有事件\n\n```js\nconst EventEmitter = require('events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\n\nmyEmitter.once('event', (param1,param2,param3) => {\n  console.log('收到事件',param1,param2,param3);\n});\n\nmyEmitter.once('event2',() => {\n  console.log('收到事件2');\n});\n\nconsole.log(myEmitter.eventNames());\n```\n\n以上例程输出`[ 'event', 'event2' ]`\n\n## 移除事件监听器\n\n使用`off实例方法`移除单个监听器\n\n```js\nconst EventEmitter = require('events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\n\nconst callback = (param1) => {\n  console.log(param1);\n};\n\nmyEmitter.on('event', callback); // 添加监听器\n\nmyEmitter.off('event', callback); // 移除监听器\n\nmyEmitter.emit('event'); // 触发事件\n```\n\n以上例程`没有输出`，因为`先添加监听器，随后移除，触发事件时已经没有可用的监听器了`\n\n## 移除所有监听器\n\n使用`removeAllListeners([eventName])实例方法移除所有监听器`。\n\n1. removeAllListener`不传参数`时移除该`emitter实例`上`所有`事件监听器\n2. removeAllListener传入`字符串`参数时移除该`emitter实例`上`所有该事件`的监听器\n\n## 结语\n\n事件系统是NodeJs的灵魂，在几乎所有的I/O模块都有使用，希望各位读者好好掌握。事件模块读后有疑问请加微信群讨论。\n\n![微信群](https://more-happy.ddhigh.com/FpffwgkBeSWPyHRUJJmi9J9SFX_l?imageView2/1/w/200)\n","tags":["nodejs guide"],"categories":["nodejs"]},{"title":"NodeJs简明教程(6)","url":"%2F2019%2F07%2F21%2Fnodejs-guide-crypto.html","content":"> NodeJs简明教程将从零开始学习NodeJs相关知识，助力JS开发者构建全栈开发技术栈！\n\n关注获取更多`NodeJs精品文章`\n![二维码](https://more-happy.ddhigh.com/FuFpZh9QTZVatcBtupR4MtOGPGTJ?imageView2/1/w/200)\n\n本文是NodeJs简明教程的第六篇，将介绍NodeJs crypto模块相关的基本操作。\n\n> crypto 模块提供了加密功能，包括对 OpenSSL 的哈希、HMAC、加密、解密、签名、以及验证功能的一整套封装。\n\n## Hash\n\n> Hash类是用于创建数据哈希值的工具类。\n\n哈希算法严格来说并不属于加密算法，传统意义上的 **加密** 是与 **解密** 相配对的。哈希算法能够保证被哈希的内容不被篡改。针对任意长度的输入数据都可以产生固定位数的哈希值。\n\ncrypto模块对hash的操作是一致的，除了算法名不一致之外，本文以 **md5** 和 **sha1** 作为示例。\n\n### MD5\n\n```js\nconst crypto = require('crypto');\n\nconst hash = crypto.createHash('md5'); // 创建MD5 hash示例\n\nhash.update('111111'); // 待计算hash的数据\nconsole.log(hash.digest('hex'));\n```\n\n以上例程输出 `96e79218965eb72c92a549dd5a330112`\n\n### SHA1\n\n```js\nconst crypto = require('crypto');\n\nconst hash = crypto.createHash('sha1'); // 创建MD5 hash示例\n\nhash.update('111111'); // 待计算hash的数据\nconsole.log(hash.digest('hex'));\n```\n\n以上例程输出 `3d4f2bf07dc1be38b20cd6e46949a1071f9d0e3d`\n\n## Base64\n\n`Base64`并不是`crypto`模块的成员，但是跟本节内容比较相近，所以放过来了。Base64是一套编码算法，常用在二进制数据编码上。\n\n### Base64编码\n\n```js\nconst data = '111111';\nconst encodedData = Buffer.from(data, 'utf8').toString('base64'); // 输入编码为utf8,输出为base64\nconsole.log(encodedData);\n```\n\n以上例程输出 `MTExMTEx`\n\n### Base64解码\n\n```js\nconst data = 'MTExMTEx';\nconst decodedData = Buffer.from(data, 'base64').toString('utf8'); // 输入编码为base64,输出编码为utf8\nconsole.log(decodedData);\n```\n\n以上例程输出`111111`\n\n## Hmac\n\n> Hmac类是用于创建加密Hmac摘要的工具。\n\nHmac算法也是一种hash算法，但是它需要一个密钥，针对同样的输入，传统的hash算法输出是固定的。\n但是Hmac的输出会随着密钥的不同而不同。\n\n```js\nconst crypto = require('crypto');\n\nconst hmac = crypto.createHmac('sha256', 'secret-key');\n\nhmac.update('Hello, world!');\n\nconsole.log(hmac.digest('hex'));\n```\n\n以上例程输出 `f4d850b1017eb4e20e0c58443919033c90cc9f4fe889b4d6b4572a4a0ec2d08a`\n\n## AES\n\n> AES是一种常用的对称加密算法，加解密都用同一个密钥。\n\n### AES加密\n\n```js\nconst crypto = require('crypto');\n\nconst cipher = crypto.createCipheriv('aes192', '111111111111111111111111', '1111111111111111')\nvar crypted = cipher.update('1', 'utf8', 'hex'); \ncrypted += cipher.final('hex');\nconsole.log(crypted);\n```\n\n以上例程输出 `5bb3e6eb39e502b5fa74d93796087efa`\n\n**说明：**\n\n`createCipheriv`原型如下：\n\n`crypto.createCipheriv（algorithm，key，iv [，options]）`\n\n1. `iv`是初始化向量，可以 **为空** 或者 **16** 字节的字符串\n2. `key`是加密密钥，根据选用的算法不同，密钥长度也不同，对应关系如下：\n   1. `aes128`对应`16位`长度密钥\n   2. `aes192`对应`24位`长度秘钥\n   3. `aes256`对应`32位`长度密钥\n\n### AES解密\n\n```js\nconst crypto = require('crypto');\n\nconst cipher = crypto.createDecipheriv('aes192', '111111111111111111111111', '1111111111111111')\nvar data = cipher.update('5bb3e6eb39e502b5fa74d93796087efa', 'hex', 'utf8'); // 输入数据编码为hex(16进制)，输出为utf8\ndata += cipher.final('utf8');\nconsole.log(data);\n```\n\n以上例程输出`1`\n\n`crypto.createDecipheriv`方法原型与`crypto.createCipher`一致，这里不在赘述。\n\n## RSA\n\n> RSA算法是一种非对称加密算法，即由一个私钥和一个公钥构成的密钥对，通过私钥加密，公钥解密，或者通过公钥加密，私钥解密。其中，公钥可以公开，私钥必须保密。\n\n### 生成密钥对\n\n使用RSA算法前必须提供密钥对，本文使用`openssl`命令进行生成。\n\n1. `openssl genrsa -out private.pem 2048 ` 生成`2048位`长度的`私钥`\n2. `openssl rsa -in private.pem -pubout -out public.pem` 导出公钥\n\n这样在当前目录我们就得到了`private.pem`和`public.pem`\n\n### RSA加密\n\n```js\nconst crypto = require('crypto');\nconst fs = require('fs');\n\nconst privateKey = fs.readFileSync('./private.pem', { encoding: 'utf8' });\n\nconst encodedData = crypto.privateEncrypt(privateKey, Buffer.from('111111','utf8')); // 传入utf8编码的数据\nconsole.log(encodedData.toString('hex'));\n```\n\n以上例程输出\n\n```text\n44a1b50b9639e4cbe17d55ca57dcb041387acadae3d3721fd9803a3a33091a36d59977feaa6caad990e58b9542c26297de6014e20819f0a71eadd0793bfe0fac834f30d2a05f8b329a3b2409e9f8b7fbd7de3734ada00228b84027568be58a2a34ccf0c4a8b2d02c58eef510931423ed5f40c696361b606df11609248b271aebcd17f9a113f98a8fa86c9c45bd609256f4779ce01ea3027171fffb35e695f1c38553aecafb72a2f46a9012246fde0f2934eacba8932bca38e228f4f4294873ed75d9acf79ab854897ebaab2375384b2da682c1b2e2b49b0592929067b3d5a11971d912629a178691345f7f88137343588b5c51d60643e5c00998484727b8c4a8\n```\n\n### RSA解密\n\n```js\nconst crypto = require('crypto');\nconst fs = require('fs');\n\nconst publicKey = fs.readFileSync('./public.pem', { encoding: 'utf8' });\n\nconst encodedData = '44a1b50b9639e4cbe17d55ca57dcb041387acadae3d3721fd9803a3a33091a36d59977feaa6caad990e58b9542c26297de6014e20819f0a71eadd0793bfe0fac834f30d2a05f8b329a3b2409e9f8b7fbd7de3734ada00228b84027568be58a2a34ccf0c4a8b2d02c58eef510931423ed5f40c696361b606df11609248b271aebcd17f9a113f98a8fa86c9c45bd609256f4779ce01ea3027171fffb35e695f1c38553aecafb72a2f46a9012246fde0f2934eacba8932bca38e228f4f4294873ed75d9acf79ab854897ebaab2375384b2da682c1b2e2b49b0592929067b3d5a11971d912629a178691345f7f88137343588b5c51d60643e5c00998484727b8c4a8';\n\nconst rawData = crypto.publicDecrypt(publicKey, Buffer.from(encodedData, 'hex')); // 传入hex(16进制)数据\nconsole.log(rawData.toString('utf8'));\n```\n\n以上例程输出\n\n```text\n111111\n```\n\n## 结语\n\n常用的加解密、哈希、编解码用法已经介绍完毕，读后有疑问请加微信群讨论。\n\n![微信群](https://more-happy.ddhigh.com/FpffwgkBeSWPyHRUJJmi9J9SFX_l?imageView2/1/w/200)\n","tags":["nodejs guide"],"categories":["nodejs"]},{"title":"NodeJs简明教程(5)","url":"%2F2019%2F07%2F20%2Fnodejs-guide-path.html","content":"\n> NodeJs简明教程将从零开始学习NodeJs相关知识，助力JS开发者构建全栈开发技术栈！\n\n关注获取更多`NodeJs精品文章`\n![二维码](https://more-happy.ddhigh.com/FuFpZh9QTZVatcBtupR4MtOGPGTJ?imageView2/1/w/200)\n\n本文是NodeJs简明教程的第五篇，将介绍NodeJs path模块相关的基本操作。\n\n> path 模块提供用于处理文件路径和目录路径的实用工具。 \n\n**注意：path模块只是处理文件路径，说白了就是字符串处理，跟文件系统无关**\n\n## 读取路径的文件名\n\n> path.basename() 方法返回 path 的最后一部分，类似于 Unix 的 basename 命令。 尾部的目录分隔符将被忽略。\n\n1. 返回带扩展名\n   \n    ```js\n    const path = require('path');\n\n    console.log(path.basename('/usr/local/a.txt'))\n    \n    // 输出 a.txt\n    ```\n\n2. 返回不带扩展名\n\n    ```js\n    const path = require('path');\n\n    console.log(path.basename('/usr/local/a.txt','.txt'))\n    \n    // 输出 a\n    ```\n\n## 读取文件路径的目录名\n\n> path.dirname() 方法返回 path 的目录名，类似于 Unix 的 dirname 命令。 尾部的目录分隔符将被忽略。\n> path.extname() 方法返回 path 的扩展名，从最后一次出现 .（句点）字符到 path 最后一部分的字符串结束。 如果在 path 的最后一部分中没有 . ，或者如果 path 的基本名称（参阅 path.basename()）除了第一个字符以外没有 .，则返回空字符串。\n\n```js\nconst path = require('path');\n\nconsole.log(path.dirname('/usr/local/a.txt'))\n\n// 输出 /usr/local\n```\n\n## 获取文件扩展名\n\n> path.extname() 方法返回 path 的扩展名，从最后一次出现 .（句点）字符到 path 最后一部分的字符串结束。\n\n```js\nconst path = require('path');\n\nconsole.log(path.extname('/usr/local/a.txt'));\n\n// 输出 .txt\n```\n\n## 检测路径是否为绝对路径\n\n> path.isAbsolute() 方法检测 path 是否为绝对路径。\n\n```js\nconst path = require('path');\n// linux || macosx\nconsole.log(path.isAbsolute('/usr/local')); // 输出 true\nconsole.log(path.isAbsolute('usr/local')); // 输出 false\n// windows\nconsole.log(path.isAbsolute('//server')); // 输出 true\nconsole.log(path.isAbsolute('\\\\\\\\server')); // 输出 true\nconsole.log(path.isAbsolute('c:\\windows')); // 输出 true\nconsole.log(path.isAbsolute('foo/bar')); // 输出 false\n```\n\n## 生成规范化的路径\n\n> path.join() 方法使用平台特定的分隔符作为定界符将所有给定的 path 片段连接在一起，然后规范化生成的路径。\n> 零长度的 path 片段会被忽略。 如果连接的路径字符串是零长度的字符串，则返回 '.'，表示当前工作目录。\n\n```js\nconst path = require('path');\n\nconsole.log(path.join('/a','b','c','..')); // 输出 /a/b\n\nconsole.log(path.join('.','a','b','..','c')); // 输出 a/c\n```\n\n## 解析路径\n\n> path.parse() 方法返回一个对象，其属性表示 path 的重要元素。 尾部的目录分隔符将被忽略。\n> 返回对象属性如下：\n> dir 目录\n> root 根目录\n> base 带扩展名的文件名或者目录名(最后一级是目录的情况下)\n> name 文件名(不带扩展名)或目录名\n> ext 文件扩展名(如果是目录则为空字符串)\n\n```js\nconst path = require('path');\n\npath.parse('/home/user/dir/file.txt');\n// 返回:\n// { root: '/',\n//   dir: '/home/user/dir',\n//   base: 'file.txt',\n//   ext: '.txt',\n//   name: 'file' }\n```\n\n## 获取两个路径的相对路径\n\n> path.relative() 方法根据当前工作目录返回 from 到 to 的相对路径。\n\n```js\nconst path = require('path');\n\nconsole.log(path.relative('/data/orandea/test/aaa', '/data/orandea/impl/bbb')); \n// 输出 ../../impl/bbb\n```\n\n## 获取规范化的绝对路径\n\n> path.resolve() 方法将路径或路径片段的序列解析为绝对路径。\n\n```js\nconst path = require('path');\n\nconsole.log(path.resolve('/foo/bar', './baz')); // 输出 /for/bar/baz\nconsole.log(path.resolve('/foo/bar', '/tmp/file/');); // 输出 /tmp/file\nconsole.log(path.resolve('a','b','../c/img.gif'));\n// 假设当前工作目录 /home/wwwroot，上述语句输出 /home/wwwroot/a/c/img.gif\n\nconsole.log(path.resolve()); // 假设当前工作目录 /home/wwwroot 输出 /home/wwwroot\n```\n\n## 结语\n\n`path`模块的主要就是处理路径相关，经常和`fs`模块共同使用。\n","tags":["nodejs guide"],"categories":["nodejs"]},{"title":"NodeJs简明教程(4)","url":"%2F2019%2F07%2F20%2Fnodejs-guide-filesystem.html","content":"\n> NodeJs简明教程将从零开始学习NodeJs相关知识，助力JS开发者构建全栈开发技术栈！\n\n关注获取更多`NodeJs精品文章`\n![二维码](https://more-happy.ddhigh.com/FuFpZh9QTZVatcBtupR4MtOGPGTJ?imageView2/1/w/200)\n\n本文是NodeJs简明教程的第四篇，将介绍NodeJs文件系统模块相关的基本操作。\n\n> fs 模块提供了一个 API，用于以模仿标准 POSIX 函数的方式与文件系统进行交互。\n\n## 读取文件\n\n文件系统的大部分函数都存在 **异步调用** 和 **同步调用** 两种形式。\n\n### 异步\n\n异步模式下，回调函数的第一个参数总为 **Error** 对象，且函数一般无返回值。\n\n1. 如果为null，则本次调用未出错\n2. 如果不为null，证明本次调用出错\n\n新建 `index.js` 文件：\n\n```js\nconst fs = require('fs');\n\nfs.readFile('./index.js', { encoding: 'utf8' }, (err, data) => {\n    if (err) {\n        console.error('读取文件失败', err);\n        return;\n    }\n    console.log(data);\n})\n```\n\n`readFile`的第二个参数如果不指定编码，回调函数取到的`data`对象是`Buffer`，需要手动转字符串。读取文本文件可以指定编码，但是读取二进制文件(`比如读取图片文件`)\n\n1. 在当前目录执行 `node index.js`\n2. 输出如下：\n\n    ```text\n    const fs = require('fs');\n\n    fs.readFile('./index.js', { encoding: 'utf8' }, (err, data) => {\n        if (err) {\n            console.error('读取文件失败', err);\n            return;\n        }\n        console.log(data);\n    })\n    ```\n\n### 同步模式\n\n同步模式下，返回值为调用函数的结果，如果调用失败，将抛出**Error**对象：\n\n```js\nconst fs = require('fs');\n\ntry {\n    const data = fs.readFileSync('./index.js', { encoding: 'utf8' });\n    console.log(data);\n} catch (e) {\n    console.log('读取失败', e)\n}\n```\n\n输出数据和同步模式一致。\n\n可以看到同步模式和异步模式下处理错误的方式是不同的。\n\n> 各位读者在生产中尽量不要使用同步函数，否则会阻塞事件循环。\n> 当然，有一种情况例外，需要同步读取配置文件然后才启动服务器的这种情况是可以的。\n\n## 写入文件\n\n新建`index.js`，代码如下：\n\n```js\nconst fs = require('fs');\n\nconst data = 'Hello World';\n\nfs.writeFile('./a.txt', data, (error) => {\n    if (error) {\n        console.error('保存失败', error);\n        return;\n    }\n    console.log('保存成功');\n})\n```\n\n1. 执行`node index.js`\n2. 输出`保存成功`，同时当前目录会多出内容为`Hello World`的文本文件。\n\n## 常用API\n\n1. `fs.copyFile(src,dest[,flags],callback)` 复制文件\n2. `fs.stat(path[,options],callback)` 读取文件状态\n3. `fs.unlink(path,callback)` 删除文件\n4. `fs.rename(oldPath,newPath,callback)` 重命名文件\n5. `fs.mkdir(path[,options],callback)` 新建目录\n6. `fs.rmdir(path,callback)` 删除目录\n   \n## 结语\n\n文件系统的学习暂时到此为止，用到的时候大家可以详细查看文件，文件系统的函数调用方式和本文的示例都是类似的，各位读者可以举一反三。\n","tags":["nodejs guide"],"categories":["nodejs"]},{"title":"NodeJs简明教程(3)","url":"%2F2019%2F07%2F19%2Fnodejs-guide-http-server.html","content":"\n> NodeJs简明教程将从零开始学习NodeJs相关知识，助力JS开发者构建全栈开发技术栈！\n\n关注获取更多`NodeJs精品文章`\n![二维码](https://more-happy.ddhigh.com/FuFpZh9QTZVatcBtupR4MtOGPGTJ?imageView2/1/w/200)\n\n本文是NodeJs简明教程的第三篇，将介绍NodeJs自带HTTP模块服务器相关的基本操作。\n\n## HTTP模块介绍\n\n以下是官方原文[1]：\n\n> The HTTP interfaces in Node.js are designed to support many features of the protocol which have been traditionally difficult to use. In particular, large, possibly chunk-encoded, messages. The interface is careful to never buffer entire requests or responses — the user is able to stream data.\n\n大致意思就是：\n\n> NodeJs的HTTP模块旨在支持传统上HTTP协议难以使用的许多功能，让这些功能或者特性能够使用简单的API进行调用。\n\n## HTTP模块服务器开发\n\n### 代码示例\n\n以下是NodeJs最简单的HTTP服务器示例:\n\n1. 新建`index.js`\n2. 编码\n\n    ```js\n    const http = require('http');\n\n    const server = http.createServer((req, res) => {\n        console.log('%s %s', req.method, req.url)\n        res.end(JSON.stringify(req.headers))\n    })\n\n    server.listen(8080, () => console.log('listen on 8080'))\n    ```\n\n3. 打开终端或者控制台，执行 `node index.js`，终端或控制台会输出`listen on 8080`，此时HTTP服务器已经启动，如果启动失败，可以在下方留言\n4. 打开浏览器访问 `http://localhost:8080`，笔者输出如下：\n    \n    ```json\n    {\n        \"host\": \"localhost:8080\",\n        \"connection\": \"keep-alive\",\n        \"cache-control\": \"max-age=0\",\n        \"upgrade-insecure-requests\": \"1\",\n        \"user-agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36\",\n        \"dnt\": \"1\",\n        \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3\",\n        \"accept-encoding\": \"gzip, deflate, br\",\n        \"accept-language\": \"zh-CN,zh;q=0.9,en;q=0.8,zh-TW;q=0.7\",\n    }\n    ```\n    \n### 代码说明\n\n1. NodeJs采用 **CMD模块系统**，**require** 用来加载模块，本例中加载了**NodeJs自带的http模块**以使用其中的功能\n2. `http.createServer`函数创建了一个 **HTTP服务器**，并配置了请求回调函数，在本系列的第一篇文章中说到事件驱动是需要回调函数进行监听的。\n3. `server.listen`是监听系统端口，第二个参数是**监听成功的回调函数**\n\n### req对象\n\n服务器收到的HTTP请求对象，以下是常用的属性或方法：\n\n1. `req.url` 本次请求的路径(不包含域名)\n2. `req.headers` 本次请求的请求头\n3. `req.httpVersion` 本次请求的`HTTP协议版本号`\n4. `req.method` 本次请求的请求方法,有`GET/POST/PUT等等`\n5. `on()` 监听请求体数据 `POST/PUT/PATCH`方法会有请求体\n\n### res对象\n\nres对象是req请求对象相应的响应对象，HTTP协议设计是`请求-应答`模型，一次请求对应一次应答。\n\n以下是常用的属性或方法：\n\n1. `res.writeHead` 输出`响应状态码`，`状态码说明`以及`多个HTTP响应头`\n2. `res.end` 输出数据并结束本次响应\n3. `res.write` 输出`部分内容(chunk)`\n4. `res.setHeader` 输出`单个响应头`\n\n### 请求路由\n\nNodeJs自带的HTTP服务器是没有路由功能的，也是就说，根据请求的URI来执行不同的逻辑需要开发者手动去做\n\n```js\nconst http = require('http');\n\nconst server = http.createServer((req, res) => {\n    if (req.url === '/') {\n        res.end('index');\n        return;\n    }\n    if (req.url === '/user') {\n        res.end('user');\n        return;\n    }\n})\n\nserver.listen(8080, () => console.log('listen on 8080'));\n```\n\n1. 执行`node index.js`\n2. 浏览器访问 [http://localhost:8080/](http://localhost:8080/) 会输出`index`\n3. 浏览器访问 [http://localhost:8080/user](http://localhost:8080/user) 会输出`user` \n\n### 读取请求参数\n\n#### 读取GET请求参数\n\n```js\nconst http = require('http');\nconst url = require('url');\nconst qs = require('querystring');\n\nconst server = http.createServer((req, res) => {\n    const parsed = url.parse(req.url);\n    const query = qs.parse(parsed.query);\n    res.end(JSON.stringify(query));\n})\n\nserver.listen(8080, () => console.log('listen on 8080'));\n```\n\n1. 执行`node index.js`\n2. 浏览器访问 [http://localhost:8080/?a=x&b=2&c[]=1&c[]=2](http://localhost:8080/?a=x&b=2&c[]=1&c[]=2)\n3. 显示\n   \n    ```json\n   {\n        \"a\": \"x\",\n        \"b\": \"2\",\n        \"c[]\": [\"1\", \"2\"]\n    }\n     ```\n\n#### 读取请求体参数\n\nHTTP协议规范中POST/PUT/PATCH都可以携带请求体，NodeJs HTTP服务器接收请求体代码如下：\n\n```js\nconst http = require('http');\nconst url = require('url');\nconst qs = require('querystring');\n\nconst server = http.createServer((req, res) => {\n    let data = Buffer.alloc(0);\n    req.on('data', (buffer) => {\n        data = Buffer.concat([data, buffer]);\n    })\n    req.on('end', () => {\n        res.end(data.toString())\n    })\n})\n\nserver.listen(8080, () => console.log('listen on 8080'));\n```\n\n1. 执行`node index.js`\n2. 使用 **postman** 发出POST请求`http://localhost:8080`，本例POST请求体为 `a=1&b=2`\n3. **postman**会返回 `a=1&b=2`\n\n## 结语\n\n一个简单的HTTP服务器就到此结束了，当然，实际生产中该方法用的比较少，几乎都是使用框架进行开发，提高开发效率。","tags":["nodejs guide"],"categories":["nodejs"]},{"title":"NodeJs简明教程(2)","url":"%2F2019%2F07%2F19%2Fnodejs-guide-installation.html","content":"\n> NodeJs简明教程将从零开始学习NodeJs相关知识，助力JS开发者构建全栈开发技术栈！\n\n关注获取更多`NodeJs精品文章`\n![二维码](https://more-happy.ddhigh.com/FuFpZh9QTZVatcBtupR4MtOGPGTJ?imageView2/1/w/200)\n\n本文是NodeJs简明教程的第二篇，将介绍NodeJs在不同操作系统下的安装操作。\n\n## 官网\n\n[https://nodejs.org](https://nodejs.org/en/)\n\n由于国内的网络原因，官网可能访问速度有点慢，推荐直接使用淘宝镜像源下载\n\n## 淘宝镜像源\n\n[https://npm.taobao.org/mirrors/node](https://npm.taobao.org/mirrors/node)，这里是所有版本/所有操作系统的NodeJs安装包。\n\n本系列文章使用 **latest-v10.x**，也就是 **10.x** 的NodeJs版本\n\n1. 进入[https://npm.taobao.org/mirrors/node/latest-v10.x/](https://npm.taobao.org/mirrors/node/latest-v10.x/)\n2. 可以看到最新的版本号为 **node-v10.16.0**\n\n## Windows安装\n\n1. **64位** 系统选择[node-v10.16.0-x64.msi](https://npm.taobao.org/mirrors/node/latest-v10.x/node-v10.16.0-x64.msi)\n2. **32位** 系统选择[node-v10.16.0-x86.msi](https://npm.taobao.org/mirrors/node/latest-v10.x/node-v10.16.0-x86.msi)\n3. 双击即可完成安装\n4. 安装完毕之后打开`cmd`执行`node -v`，显示版本号即为安装成功，安装失败的读者可以在下方留言\n\n## Mac安装\n\n### PKG安装包安装\n\n1. 选择[node-v10.16.0.pkg](https://npm.taobao.org/mirrors/node/latest-v10.x/node-v10.16.0.pkg)\n2. 双击即可完成安装\n3. 安装完毕之后打开`终端`执行`node -v`，显示版本号即为安装成功，安装失败的读者可以在下方留言\n\n### Homebrew安装\n\n1. `brew install node`\n2. 安装完毕之后打开`终端`执行`node -v`，显示版本号即为安装成功，安装失败的读者可以在下方留言\n\n## Linux安装\n\n1. 选择[node-v10.16.0-linux-x64.tar.gz](https://npm.taobao.org/mirrors/node/latest-v10.x/node-v10.16.0-linux-x64.tar.gz)下载文件\n2. 执行`wget https://npm.taobao.org/mirrors/node/latest-v10.x/node-v10.16.0-linux-x64.tar.gz`\n3. 执行`tar xf node-v10.16.0-linux-x64.tar.gz`解压\n4. 执行`mv node-v10.16.0-linux-x64 /opt/node`移动到`/opt`目录\n5. 执行`echo \"export PATH=/opt/node/bin:$PATH\" >> ~/.bashrc`编辑`PATH`环境变量\n6. 执行`source ~/.bashrc`更新环境变量\n7. 执行`node -v`，显示版本号即为安装成功，安装失败的读者可以在下方留言\n","tags":["nodejs guide"],"categories":["nodejs"]},{"title":"NodeJs简明教程(1)","url":"%2F2019%2F07%2F18%2Fnodejs-guide-about.html","content":"\n> NodeJs简明教程将从零开始学习NodeJs相关知识，助力JS开发者构建全栈开发技术栈！\n \n关注获取更多`NodeJs精品文章`\n![二维码](https://more-happy.ddhigh.com/FuFpZh9QTZVatcBtupR4MtOGPGTJ?imageView2/1/w/200)\n\n本文是NodeJs简明教程的第一篇，将介绍NodeJs整体架构以及重点概念。\n\n## NodeJs究竟是什么\n\n来看一段官方的说法[1]：\n\n> As an asynchronous event driven JavaScript runtime, Node is designed to build scalable network applications. In the following \"hello world\" example, many connections can be handled concurrently. Upon each connection the callback is fired, but if there is no work to be done, Node will sleep.\n\nGoogle翻译版本：\n\n> 作为异步事件驱动的JavaScript运行时，Node旨在构建可伸缩的网络应用程序。 在下面的“hello world”示例中，可以同时处理许多连接。 在每次连接时都会触发回调，但是如果没有工作要做，Node将会休眠。\n\n结合上面的介绍，我们可以得出一个结论：\n\n> NodeJs的本质是一个Javascript运行时。该运行时基于异步事件驱动进行运作。\n\n### 异步\n\n本文中的异步指异步IO。维基百科对异步IO的定义[2]：\n\n> 异步IO是计算机操作系统对输入输出的一种处理方式：发起IO请求的线程不等IO操作完成，就继续执行随后的代码，IO结果用其他方式通知发起IO请求的程序。与异步IO相对的是更为常见的“同步（阻塞）IO”：发起IO请求的线程不从正在调用的IO操作函数返回（即被阻塞），直至IO操作完成。\n\n一言以蔽之就是：\n\n> 执行IO请求后，调用方不等执行结果就继续执行下面的代码，IO操作完成后执行者会告诉调用者“我执行完了”。在NodeJs中通知方式是“回调”。\n\n### 事件驱动\n\n事件驱动是相对 **线程驱动** 而言的。**线程驱动** 下服务器为每个请求新建一个线程去处理。 \n维基百科对事件驱动的定义[3]：\n\n> 事件驱动程序模型下的系统，基本上的架构是预先设计一个事件循环所形成的程序，这个事件循环程序不断地检查当前要处理的信息，根据要处理的信息运行一个触发函数进行必要的处理。其中这个外部信息可能来自一个目录夹中的文件，可能来自键盘或鼠标的动作，或者是一个时间事件。\n\n以NodeJs的HTTP服务器为例，当调用`server.listen`函数时，NodeJs就会创建一个事件循环，当有客户端请求过来时，NodeJs将该请求入队列进行后续处理，主线程以及轮询客户端请求并入队列，队列中的请求执行完毕后会通过回调函数的形式通知主线程，如此循环。\n\n### Javascript运行时\n\nJavascript运行时是个比较复杂的概念，本文在介绍 **Javascript运行时** 之前介绍一下 **Javascript引擎**。\n\n#### Javascript引擎\n\n维基百科的定义[4]：\n\n> JavaScript引擎是一个专门处理JavaScript脚本的虚拟机，一般会附带在网页浏览器之中。\n\n个人理解：\n\n> Javascript引擎主要是对Javascript代码进行词法、语法等分析，通过编译器将代码编译成可执行的机器码让计算机去执行。\n\n目前业内出名的Javascript引擎非V8莫属了。\n\n#### 运行时的组成\n\nJavascript可以运行在浏览器，也可以运行在服务器(NodeJs)中，有些API或者对象只有浏览器有(比如DOM,BOM等)，而有些API或者对象只有服务器中有(如文件操作，HTTP服务器等)。\n\n> Javascript运行时包括了Javascript引擎、特定环境API、事件循环和事件队列。\n\n### NodeJs架构图\n\nNodeJs由C++语言基于libuv开发，分层设计，Javascript只是其基于V8提供的上层接口，换句话说，如果把上层接口换成其他语言实现，比如换成PHP实现，那么PHP就可以实现异步事件驱动的服务器，运行时名称就成为 **NODE-PHP**。\n\n![NodeJs架构图](https://more-happy.ddhigh.com/FqnmcUJhX0mGNDjMAIa1lOSJhNHJ)\n\n+ Node standard library NodeJs标准库，也是直接提供给开发者调用的顶层代码\n+ Node bindings Javascript和libuv在该层进行通信，基于V8打通语言壁垒\n+ V8 执行JS代码\n+ libuv 高性能异步I/O、事件驱动、线程池的库，也是NodeJs高性能的保证\n+ C-ares 提供异步DNS\n+ http_parser、OpenSSL、Zlib 提供HTTP解析、openssl加解密、数据压缩等接口\n\n### NodeJs到底是不是单线程\n\n> 不是，主线程Javascript线程是单线程，libuv提供线程池，NodeJs不仅仅是一个Javascript引擎，而是一套运行时，不能将Javascript线程孤立出来。\n\n## NodeJs为什么这么快\n\n1. 单线程解决了多线程环境下线程切换开销以及可能的线程同步开销\n2. 异步+事件驱动保证了NodeJs主线程不会阻塞，会一直接受请求(这也是受人诟病的地方，其他语言实现的服务器，请求过大会排队处理，NodeJs会将请求全部入队，导致内存暴涨)\n\n## NodeJs优缺点以及适合的场景\n\n1. 由于主线程Javascript线程是单线程，所以主线程不能做CPU密集操作（比如什么加解密之类的，这种操作只能有Javascript线程运行，会阻塞事件循环），所以NodeJs适合I/O密集场景，比如常见的（TCP/HTTP服务器）\n2. 对于前端开发者来说，几乎没有语言门槛\n3. 跨平台，NodeJs在主流操作系统都有对应的二进制程序\n4. 标准库强大，第三方库也很多，降低了造轮子成本\n5. 易于部署，服务器安装一个NodeJs程序配合NPM包管理器即可运行，不用像PHP那样还要安装扩展，配置前端HTTP服务器\n\n## 结语\n\n欢迎继续关注本系列文章。\n\n## 参考文献\n\n1. [About NodeJs](https://nodejs.org/en/about/)\n2. [异步IO](https://zh.wikipedia.org/zh-hans/%E5%BC%82%E6%AD%A5IO)\n3. [事件驱动]( https://zh.wikipedia.org/wiki/%E4%BA%8B%E4%BB%B6%E9%A9%85%E5%8B%95%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88)\n4. [Javascript引擎](https://zh.wikipedia.org/wiki/JavaScript%E5%BC%95%E6%93%8E)","tags":["nodejs guide"],"categories":["nodejs"]},{"title":"实现一个JS深拷贝函数","url":"%2F2019%2F07%2F16%2Fmake-a-deep-copy-function.html","content":"\nJS深拷贝概念并不新鲜，但是真正要真正理解原理还是有点难度的。这也是JS语言精粹之一吧。\n\n## 例子\n\n```js\nlet a = {\n    name: 'demo',\n    age: 18\n};\n\nlet b = a;\nb.name = 'demo1';\n\nconsole.log(a); // 输出 {name: \"demo1\", age: 18}\nconsole.log(b); // 输出 {name: \"demo1\", age: 18}\n```\n\n因为JS对于对象的赋值使用的是浅拷贝，其中`一个实例变量`的赋值会影响到`所有指向该对象`的`变量`\n\n## 解决方案\n\n1. 粗暴好使的 `JSON.parse(JSON.stringify)`，缺点: `丢失成员函数`\n2. `Object.assign`，缺点：`只有第一级深拷贝，子级对象依旧是浅拷贝`，例子如下：\n\n    ```js\n    let a = {name:{demo:'1'}};\n    let b = Object.assign({}, a);\n    console.log(a); // 输出 {name:{demo:'1'}}\n    console.log(b); // 输出 {name:{demo:'1'}}\n    b.name.demo = '2';\n    console.log(a); // 输出 {name:{demo:'2'}}\n    console.log(b); // 输出 {name:{demo:'2'}}\n    ```\n\n## 手动实现原理\n\n1. 遍历待拷贝对象\n2. 判断当前值类型，如果是object类型且不是null(null也是object)，则递归调用拷贝函数\n3. 如果当前值类型时null或者非object类型，直接return，退出本次递归\n\n## 编码实现\n\n```js\nfunction deepCopy(obj) {\n    let result = obj;\n    if(typeof obj === 'object' && obj !== null) {\n        result = Object.prototype.toString.call(obj) === '[object Array]' ? []: {};\n        for(let prop in obj) {\n            result[prop] = deepCopy(obj[prop]);\n        }\n    }\n    return result;\n}\n```\n\n验证一下：\n\n```js\nlet a = {name:{demo:'1'}};\nlet b = deepCopy(a);\nconsole.log(a); // 输出 {name:{demo:'1'}}\nconsole.log(b); // 输出 {name:{demo:'1'}}\nb.name.demo = '2';\nconsole.log(a); // 输出 {name:{demo:'1'}}\nconsole.log(b); // 输出 {name:{demo:'2'}}\n```\n","tags":["javascript"],"categories":["frontend"]},{"title":"微信小程序数据字段大小写问题","url":"%2F2019%2F07%2F16%2Fwechat-mini-program-data-column-case.html","content":"\n这两天在开发微信小程序登录以及加解密的时候，因为数据大小写的问题被坑了一把。\n\n## 场景\n\n1. 小程序调用`wx.login`时会获得`code`，传输给服务端可以得到`openid`,`unionid(绑定了开放平台)`,`session_key`\n2. 小程序调用`getUserInfo`会获得`encrypted_data`,`iv`,解密后得到`unionId`,`openId`\n3. `unionid`和`openid`这两个场景`键名大小写是不同的`\n\n## 例子\n\n1. 服务端根据`code获取session_key`返回结果如下：\n\n    ```json\n    {\n        \"session_key\": \"我是session_key\",\n        \"openid\": \"我是openid\",\n        \"unionid\": \"我是unionid\"\n    }\n    ```\n\n2. 服务端根据`session_key解密encrypted_data和iv`返回结果如下：\n\n    ```json\n    {\n        \"openId\": \"OPENID\",\n        \"nickName\": \"NICKNAME\",\n        \"gender\": GENDER,\n        \"city\": \"CITY\",\n        \"province\": \"PROVINCE\",\n        \"country\": \"COUNTRY\",\n        \"avatarUrl\": \"AVATARURL\",\n        \"unionId\": \"UNIONID\",\n        \"watermark\":\n        {\n            \"appid\":\"APPID\",\n            \"timestamp\":TIMESTAMP\n        }\n    }\n    ```\n\n可以看到两次同样的字段`openid`和`unionid`大小写是不同的，此处容易踩坑。\n\n## 结论\n\n1. 服务端根据`code换session_key/openid/unionid`是`小写`\n2. 服务端根据`encrypted_data和iv`解密得到的`openId/unionId`是`大写`\n\n最后，祝大家在开发过程中少踩坑。","tags":["小程序"],"categories":["frontend"]},{"title":"百度分享不支持HTTPS解决办法","url":"%2F2019%2F07%2F12%2Fbaidu-share-support-https.html","content":"\n这两天接入文章页百度分享时发现本地可以显示分享按钮，但是发布到线上之后发现分享按钮不会展示。打开浏览器调试工具发现，HTTPS下的百度分享资源未加载，起初以为是HTTPS站点下面使用的是HTTP协议的链接，但是查看源代码发现是自适应协议的， 所以问题应该是处在百度这里。\n\n打开`https://bdimg.share.baidu.com/static/api/js/share.js`发现浏览器提示`NET::ERR_CERT_COMMON_NAME_INVALID`，也就是`访问的域名和证书配置的域名不匹配`，证书的域名是`*.baidu.com`，访问的域名是`bdimg.share.baidu.com`，泛域名是不可以跨级使用的。\n\n虽然是百度的问题，但是咱也不可能要他去改这个分享，所以只能自己来处理了。\n\n## 可能的处理方案\n\n1. 全站使用HTTP，放弃该方案（现在都9012年了，免费证书一大把，基本都是HTTPS站点了）\n2. 将百度分享的资源打包下来进行部署\n   1. 部署到自己的服务器（成本低，易迁移，但是服务器带宽是个问题）\n   2. 部署到CDN，本文以七牛为例\n\n## 资源路径\n\n百度分享相关JS我已经分享到github了，[一键直达仓库](https://github.com/xialeistudio/baidu-share-resource)\n\n## 处理过程\n\n1. 将百度分享的资源解压到本地\n2. 使用PHP遍历目录上传到七牛(本文用的SPL进行文件夹遍历)\n3. 替换使用的百度分享JS路径\n\n### 使用PHP变量目录上传到七牛\n\n文件目录如下：\n\n```\n|--static(百度分享资源目录)\n|--DirectorySync.php\n|--FilterScanner.php\n|--index.php\n```\n\nDirectorySync.php\n```php\n\n/**\n * 目录同步器\n * Class DirectorySync\n * @package sync\n * @author xialeistudio\n * @date 2019-07-11\n */\nclass DirectorySync\n{\n    private $accessKey;\n    private $secretKey;\n    private $bucket;\n\n    /**\n     * @var Auth\n     */\n    private $auth;\n\n    /**\n     * DirectorySync constructor.\n     * @param $accessKey\n     * @param $secretKey\n     * @param $bucket\n     */\n    public function __construct($accessKey, $secretKey, $bucket)\n    {\n        $this->accessKey = $accessKey;\n        $this->secretKey = $secretKey;\n        $this->bucket = $bucket;\n        $this->auth = new Auth($accessKey, $secretKey);\n    }\n\n\n    /**\n     * 同步目录\n     * @param array $list\n     * @throws \\Exception\n     * @author xialeistudio\n     * @date 2019-07-11\n     */\n    public function sync(array $list)\n    {\n        $uploader = new UploadManager();\n        $token = $this->auth->uploadToken($this->bucket);\n        foreach ($list as $path => $keyPrefix) {\n            $scanner = new FilterScanner($path);\n            foreach ($scanner as $filename) {\n                printf(\"uploading %s \\n\", $filename);\n                /** @var Error $error */\n                list($ret, $error) = $uploader->putFile($token, $keyPrefix . $filename, $filename);\n                if (!empty($error)) {\n                    printf(\"uploading %s error: %s\\n\", $filename, $error->message());\n                }\n            }\n        }\n    }\n}\n```\n\nFilterScanner.php\n```php\n/**\n * 文件扫描器\n * Class FilterScanner\n * @package sync\n * @author xialeistudio\n * @date 2019-07-11\n */\nclass FilterScanner extends FilterIterator\n{\n    /**\n     * FilterScanner constructor.\n     * @param $path\n     */\n    public function __construct($path)\n    {\n        parent::__construct(new RecursiveIteratorIterator(new RecursiveDirectoryIterator($path)));\n    }\n\n    /**\n     * Check whether the current element of the iterator is acceptable\n     * @link https://php.net/manual/en/filteriterator.accept.php\n     * @return bool true if the current element is acceptable, otherwise false.\n     * @since 5.1.0\n     */\n    public function accept()\n    {\n        return substr($this->current(), -1, 1) != '.' && substr($this->current(), -2, 2) != '..';\n    }\n}\n```\n\nindex.php\n\n```php\n$sync = new DirectorySync(ACCESS_KEY, SECRET_KEY, BUCKET);\n$sync->sync([\n    'static' => ''\n]);\n```\n\n上传之前需要修改一下百度分享js相关的域名。打开`static/api/js/share.js`，搜索到如下代码：\n\n```js\njscfg: {domain: {staticUrl: \"/\"}}\n```\n\n将`staticUrl`改成七牛的域名，本站使用的是`static.ddhigh.com`，所以改完之后的代码如下：\n\n```js\njscfg: {domain: {staticUrl: \"//static.ddhigh.com/\"}}\n```\n\n完事之后执行`php index.php`上传到七牛，此时就可以随意部署了~。\n\n## 部署到应用\n\n将以往使用`bdimg.share.baidu.com/static/api/js/share.js`的地方换成`//static.ddhigh.com/static/api/js/share.js`即可，其他资源会自动加载。\n\n*本站的CDN域名做了防盗链处理，各位如果直接用我的share.js链接是会有问题的*\n\n## hexo Next百度分享的额外处理\n\n上传到七牛这个步骤完成之后，搜索文件`baidushare.swig`，找到最下面的如下代码：\n\n```js\nwith(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];\n```\n\n将链接替换为自己的CDN链接，我这边替换后的结果如下：\n\n```js\nwith(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//static.ddhigh.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];\n```\n","categories":["frontend"]},{"title":"Js使用AES加密PHP使用Openssl解密","url":"%2F2019%2F07%2F11%2Fjs-encrypt-php-decrypt.html","content":"\n最近遇到的几个网站在提交密码时提交的已经是密文，也就是说在网络上传输的密码是密文，这样提升了密码在网络传输中的安全性。\n\n\b后端语言加解密已经有很成熟的方案了，前端的话Google之前出过一个[crypto-js](https://www.npmjs.com/package/crypto-js)，为浏览器的js提供了加解密方案。今天一起来了解一下基于AES的前后端加解密流程。\n\n## Javascript\n\n1. 安装npm包 `npm install crypto-js`\n2. \b加密代码\n\n    ```javascript\n    const CryptoJS = require(\"crypto-js\");\n    const key = CryptoJS.enc.Latin1.parse('1234567812345678');\n    const iv = CryptoJS.enc.Latin1.parse('1234567812345678');\n    const encoded = CryptoJS.AES.encrypt('hahaha', key, {\n        iv: iv,\n        mode: CryptoJS.mode.CBC,\n        adding: CryptoJS.pad.ZeroPadding\n    }).toString()\n    console.log('encoded', encoded)\n    ```\n\n3. 解密代码\n\n    ```javascript\n    const key = CryptoJS.enc.Latin1.parse('123456781234567812345678');\n    const iv = CryptoJS.enc.Latin1.parse('1234567812345678');\n    const decoded = CryptoJS.AES.decrypt(encoded, key, {\n        iv: iv,\n        mode: CryptoJS.mode.CBC,\n        adding: CryptoJS.pad.ZeroPadding\n    }).toString(CryptoJS.enc.Utf8)\n    console.log('decoded', decoded);\n    ```\n\n4. 输出如下\n\n    ```text\n    encoded 6bcgYd4f4ZgNOQH/3tqMpg==\n    decoded hahaha\n    ```\n\n## PHP\n\n直接使用openssl解密即可，代码如下：\n\n```php\n$encoded = '6bcgYd4f4ZgNOQH/3tqMpg==';\n$key  = '123456781234567812345678';\n$iv = '1234567812345678';\nvar_dump(openssl_decrypt($encoded, 'AES-192-CBC', $key, 0,$iv));\n```\n\n输出结果：\n\n```text\nstring(6) \"hahaha\"\n```\n\n注意事项\n\n1. AES加密位数跟密钥`key`有关, 以下是密钥位数和加密对应关系\n   1. 16 => AES-128\n   2. 24 => AES-192\n   3. 32 => AES-256\n2. `iv`是初始化向量. 超过16字节或者不足16字节都会被补足16字节或者截断到16字节。由于AES是块加密，铭文被分割成固定长度的块（一般是16字节长度），所以`iv`也是`16`字节。\n3. CBC是加密模式\n","tags":["encrypt"],"categories":["php"]},{"title":"vue webpack重写cookie路径","url":"%2F2019%2F07%2F08%2Fvue-webpack-rewrite-cookie-path.html","content":"\nwebpack提供的反向代理服务器在开发阶段非常方便，几行简单的代码配置就可以使用反向代理功能，包括路径重写、cookie处理等。\n\n项目开发阶段使用的API路径是 `/admin`，部署到线上是`/`，所以在开发过程中需要在`proxyTable`进行反向代理配置，将路径重写掉，路径重写代码如下(`config/index.js`):\n\n```js\nproxyTable: {\n      '/admin': {\n        target: 'http://127.0.0.1:8080',\n        changeOrigin: true,\n        pathRewrite: {\n          '^/admin': '/admin2'\n        },\n      }\n}\n```\n\n启动项目之后进行登录，此时API请求成功，但是获取登录用户信息时发现cookie没有带过去。查看请求发现登录请求的`Set-Cookie`响应头中的`Path`是`/admin2`。但是咱们请求的路径是`/admin`，cookie当然不会生效。\n\n查阅文档发现，proxyTable支持`onProxyRes`回调函数来自定义响应，流程是通过替换后端服务器设置的`cookie-path`来进行处理，代码如下：\n\n```js\nproxyTable: {\n      '/admin': {\n        target: 'http://127.0.0.1:8080',\n        changeOrigin: true,\n        pathRewrite: {\n          '^/admin': '/lesson/admin'\n        },\n        onProxyRes: function (proxyRes, req, res) {\n          const cookies = proxyRes.headers['set-cookie']\n          if (cookies) {\n            const newCookies = cookies.map(cookie => {\n              return cookie.replace(/Path=\\/admin2/, 'Path=/')\n            })\n            delete proxyRes.headers['set-cookie']\n            proxyRes.headers['set-cookie'] = newCookies\n          }\n    }\n  },\n},\n```\n\n重启webpack之后重新登录，发现cookie的路径已经被重写到`/`了。\n","tags":["webpack"],"categories":["frontend"]},{"title":"druid SQL监控不显示问题","url":"%2F2019%2F07%2F08%2Fdruid-sql-monitor.html","content":"\n新版druid数据源驱动的SQL监控如果用以前的老版本配置是无法监控到SQL的：\n\napplication.yml\n\n```yaml\nspring:\n    datasource:\n        druid:\n            filters:\n                - stat\n                - wall\n                - log4j\n```\n\n启动应用之后访问druid监控页面，除了SQL相关的页面都正常工作，但是访问SQL监控页面时没有看到SQL记录。\n查看监控页面 **数据源** 菜单发现 **filter类名** 显示的是空，估计是filter配置有问题导致。\n\n查阅官方文档发现filter配置有变更，改成以下形式即可统计SQL，同时在数据源页面 **filter类名** 会显示正常。\n\napplication.yml\n\n```yaml\nspring:\n    datasource:\n        druid:\n            initial-size: 5\n            min-idle: 5\n            max-active: 20\n            max-wait: 5000\n            # 状态监控\n            filter:\n                stat:\n                enabled: true\n                db-type: mysql\n                log-slow-sql: true\n                slow-sql-millis: 2000\n            # 监控过滤器\n            web-stat-filter:\n                enabled: true\n                exclusions:\n                - \"*.js\"\n                - \"*.gif\"\n                - \"*.jpg\"\n                - \"*.png\"\n                - \"*.css\"\n                - \"*.ico\"\n                - \"/druid/*\"\n            # druid 监控页面\n            stat-view-servlet:\n                enabled: true\n                url-pattern: /druid/*\n                reset-enable: false\n                login-username: root\n                login-password: root\n```\n\n数据源filter类名：**com.alibaba.druid.filter.stat.StatFilter**\n","tags":["spring boot"],"categories":["java"]},{"title":"解决数据库N+1查询问题","url":"%2F2019%2F06%2F18%2Fdatabase-n-1-solution.html","content":"\n## 需求\n数据表如下：\n\ndepartment表\n  \n  |id|name|\n  |--|--|\n  |1|测试部门|\n\n user表\n \n  |id|name|department_id|\n  |--|--|--|\n  |1|test|1|\n\n需求是得到以下结构的数据:\n\n```json\n[\n    {\n        \"id\":1,\n        \"name\":\"test\",\n        \"department_id\":1,\n        \"department\":{\n            \"id\":1,\n            \"name\":\"测试部门\"\n        }\n    }\n]\n```\n\n## 方法一:循环查询\n\n1. 查询用户列表\n2. 循环用户列表查询对应的部门信息\n\n```php\n$users = $db->query('SELECT * FROM `user`');\nforeach($users as &$user) {\n    $users['department'] = $db->query('SELECT * FROM `department` WHERE `id` = '.$user['department_id']);\n}\n```\n\n该方法查询次数为：1+N(1次查询列表，N次查询部门)，性能最低，不可取。\n\n## 方法二：连表\n\n1. 通过连表查询用户和部门数据\n2. 处理返回数据\n\n```php\n$users = $db->query('SELECT * FROM `user` INNER JOIN `department` ON `department`.`id` = `user`.`department_id`');\n// 手动处理返回结果为需求结构\n```\n\n该方法其实也有局限性，如果 *user* 和 *department* 不在同一个服务器是不可以连表的。\n\n## 方法三：1+1查询\n\n1. 该方法先查询1次用户列表\n2. 取出列表中的部门ID组成数组\n3. 查询步骤2中的部门\n4. 合并最终数据\n\n代码大致如下：\n\n```php\n$users = $db->query('SELECT * FROM `user`');\n$departmentIds =[ ];\nforeach($users as $user) {\n    if(!in_array($user['department_id'], $departmentIds)) {\n        $departmentIds[] = $user['department_id'];\n    }\n}\n$departments = $db->query('SELECT * FROM `department` WHERE id in ('.join(',',$department_id).')');\n$map = []; // [部门ID => 部门item]\nforeach($departments as $department) {\n    $map[$department['id']] = $department;\n}\n\nforeach($users as $user) {\n    $user['department'] = $map[$user['department_id']] ?? null;\n }\n```\n\n该方法对两个表没有限制，在目前微服务盛行的情况下是比较好的一种做法。","tags":["database"],"categories":["php"]},{"title":"在Swoole环境下运行注入Yii2框架的thrift应用","url":"%2F2019%2F05%2F19%2Frunning-thrift-on-swoole-with-yii2.html","content":"\n前两天发布了[使用swoole来运行thrift应用](/2019/05/16/running-thrift-on-swoole.html)，项目虽然可以运行起来，但是周边的生态（如缓存，ORM，日志等等）并没有跟上，实际上开发体验比较差。周末研究了一下，把Yii2框架集成到了thrift应用上。\n\n项目地址：[https://github.com/swoole-foundation/yii2-swoole-thrift](https://github.com/swoole-foundation/yii2-swoole-thrift)\n\nYii2优势：\n\n+ 完美的OOP设计\n+ 大量开箱即用的组件(DB/Cache/Logger/RBAC等等)\n+ 组件化开发\n+ 扩展性\n\n这些支持是提高thrift应用开发效率的保证，毕竟没有人会直接在生产环境下手写SQL不是?","tags":["swoole"],"categories":["php"]},{"title":"在swoole上运行Yii2应用","url":"%2F2019%2F05%2F19%2Frunning-yii2-on-swoole.html","content":"\n[Yii2](https://www.yiiframework.com)：业界著名的开发框架，完美的OOP设计以及组件化开发思想保证了框架的扩展性。\n[Swoole](https://www.swoole.com/)：面向生产环境的 PHP 异步网络通信引擎。使 PHP 开发人员可以编写高性能的异步并发 TCP、UDP、Unix Socket、HTTP，WebSocket 服务。\n\n## Yii2优点\n\n+ 完美的OOP设计\n+ 大量开箱即用的组件(DB/Cache/Logger/RBAC等等)\n+ 组件化开发\n+ 扩展性\n\n## Swoole优点\n\n+ 高性能/异步/事件驱动\n+ 使用PHP语言开发\n+ 单文件容器化(传统的php-fpm容器化有点麻烦，一般使用apache的镜像，但是性能不行)\n\n如果这两者结合将会擦出什么样的火花呢?\n\n## Yii2-Swoole-Extension\n\n[Yii2-Swoole-Extension](https://github.com/swoole-foundation/yii2-swoole-extension)\n\n基于swoole运行环境的Yii2扩展，基于标准Yii2组件化思想开发，对应用无侵入性，可以随时从 PHP-FPM <-> swoole 互相迁移。\n\n通过简单的几行代码即可完成传统PHP-FPM应用到Swoole的升级，给应用带来实打实的性能提升!","tags":["swoole"],"categories":["php"]},{"title":"使用swoole来运行thrift应用","url":"%2F2019%2F05%2F16%2Frunning-thrift-on-swoole.html","content":"\n## Swoole扩展简介\n\n> **Swoole：面向生产环境的 PHP 异步网络通信引擎**\n> \n> 使 PHP 开发人员可以编写高性能的异步并发 TCP、UDP、Unix Socket、HTTP，WebSocket 服务。Swoole 可以广泛应用于互联网、移动通信、企业软件、云计算、网络游戏、物联网（IOT）、车联网、智能家居等领域。 使用 PHP + Swoole 作为网络通信框架，可以使企业 IT 研发团队的效率大大提升，更加专注于开发创新产品。\n\n## thrift\n\n> Thrift是一种接口描述语言和二进制通讯协议，它被用来定义和创建跨语言的服务。它被当作一个远程过程调用（RPC）框架来使用，是由Facebook为“大规模跨语言服务开发”而开发的。\n\n## swoole实现\n\nthrift官方提供的PHP服务端是运行在php原生阻塞IO模式的，性能比较差。笔者使用Swoole的异步服务端+thrift提供的接口实现一个了异步协程化的thrift应用。\n\n此项目已经在github上开源：\n\n[https://github.com/xialeistudio/swoole-thrift.git](https://github.com/xialeistudio/swoole-thrift.git)","tags":["swoole"],"categories":["php"]},{"title":"在缓存中使用闭包函数","url":"%2F2019%2F05%2F14%2Fuse-closure-in-cache.html","content":"\n## 闭包函数\n\nPHP官方文档对于闭包函数的定义：\n> 匿名函数（Anonymous functions），也叫闭包函数（closures），允许 临时创建一个没有指定名称的函数。最经常用作回调函数（callback）参数的值。当然，也有其它应用的情况。\n\n简单来说，闭包函数也是一种数据类型，可以直接使用变量来存储、传参、调用等等。\n\n## 传统缓存操作\n\n操作缓存的时候一般步骤如下：\n\n1. 读取缓存\n2. 如果缓存不为空则返回缓存数据\n3. 读取数据库，然后设置到缓存\n4. 返回数据\n\nPHP示例代码如下：\n\n```php\nfunction loadUser($userId) {\n    $data = $cache->get('user-'. $userId);\n    if(!empty($data)) {\n        return $data;\n    }\n    $data = $db->findOne(['user_id' => $userId]);\n    $cache->set('user-'. $userId, $data, 7200);\n    return $data;\n}\n```\n\n其实**查找缓存，如果不存在则查找数据库之后写入缓存**这个操作也可以用闭包来实现：\n\n```php\nfunction getOrSet($key, callable $callable, $expire = 0) {\n    $data = $cache->get($key);\n    if(!empty($data)) {\n        return $data;\n    }\n    $data = call_user_func($callable);\n    $cache->set($key, $data, $expire);\n    return $data;\n}\n\nfunction loadUser($userId) {\n    return $cache->getOrSet('user-'. $userId, function() use($db, $userId) {\n        return $db->findOne(['user_id' => $userId]);\n    }, 7200);\n}\n```\n\n可以看到通过闭包省去了手动**get**和**set**的过程，而查询数据库那一步是只有在缓存读取不到才会执行。","tags":["closure"],"categories":["php"]},{"title":"在事务中使用闭包函数简化开发","url":"%2F2019%2F05%2F14%2Fuse-closure-in-transaction.html","content":"\n## 闭包函数\n\nPHP官方文档对于闭包函数的定义：\n> 匿名函数（Anonymous functions），也叫闭包函数（closures），允许 临时创建一个没有指定名称的函数。最经常用作回调函数（callback）参数的值。当然，也有其它应用的情况。\n\n简单来说，闭包函数也是一种数据类型，可以直接使用变量来存储、传参、调用等等。\n\n## 事务\n\n事务简单来说就是一个核心:\n> 事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。\n\n一般情况下，每一条SQL的执行情况都需要进行判断，如果执行成功则继续，否则回滚事务。以下是PDO事务代码：\n\n```php\n$pdo = new PDO('mysql:host=localhost;dbname=demo', 'root', 'root');\ntry {\n    $pdo->beginTransaction();\n    //todo 业务代码\n    $pdo->commit();\n} catch (\\Exception $e) {\n    $pdo->rollBack();\n    throw $e;\n}\n```\n## PHP实现\n\n几乎所有事务都需要如此处理，但是这样重复代码太多，实际上只需要关心的部分是 **业务代码** 部分，使用闭包函数可以很好的解决这个问题。\n\n闭包函数可以理解为具体的业务逻辑，不带任何事务相关操作，如果出现异常，会自动回滚事务。\n\nPHP的简单实现代码如下:\n\n```php\nfunction transaction(PDO $pdo, callable $callable)\n{\n    try {\n        $pdo->beginTransaction();\n        $result = call_user_func($callable, $pdo);\n        $pdo->commit();\n        return $result;\n    } catch (\\Exception $e) {\n        $pdo->rollBack();\n        throw $e;\n    }\n}\n```\n\nPHP调用方法代码如下：\n\n```php\ntransaction($pdo, function (PDO $pdo) {\n    return $pdo->query('INSERT INTO `test` VALUES (1)');\n});\n```\n\n## 结语\n\n使用闭包函数去简化样板代码在生产中是很常见的，具体的设计模式应该是类似“模板方法模式”。","tags":["closure"],"categories":["php"]},{"title":"使用systemd来构建你的服务","url":"%2F2019%2F02%2F28%2Fbuild-service-by-systemd.html","content":"\n## systemd是什么\n\nSystemd 服务是一种以 .service 结尾的单元（unit）配置文件，用于控制由Systemd 控制或监视的进程。简单说，用于后台以守护精灵（daemon）的形式运行程序。\n\n## 为什么要使用systemd\n\n1. service文件编写简单易用\n2. 可以自动维持进程存活（强大的功能，可以取代PM2）\n3. 自动收集进程输出的输出\n   \n## systemd主要命令\n\n可以看到systemd以字母d结尾，根据linux惯用规则，可以判断该进程为守护进程，可以通过`systemctl`与之交互。\n\n```\nsystemctl start redis.service #启动服务\nsystemctl stop redis.service #停止服务\nsystemctl restart redis.service #重启服务\nsystemctl enable redis.service #将redis设置为开机启动\n```\n\n## 编写systemd\n\nsystmd service文件一般放在`/etc/systemd/system/`文件夹中。\n\nsystemd service文件是结构化的，以下给出一份笔者常用的清单。\n\n```\n[Unit]\nDescription=Git Auto Update Hook Service\nAfter=network.target\n\n[Service]\nType=simple\nExecStart=/root/src/git-hookd/git-hookd\nRestart=always\n[Install]\nWantedBy=multi-user.target\n```\n\n拿之前写过的init.d的脚本对比一下\n\n```\n#!/bin/bash\n### BEGIN INIT INFO\n# Provides:          xialeistudio\n# Required-Start:    $network\n# Required-Stop:     $local_fs\n# Default-Start:     2 3 4 5\n# Default-Stop:      0 1 6\n# Short-Description: test service\n# Description:       test service\n### END INIT INFO\nPROG=\"testd\"\nPROG_PATH=\"/root/apps/testd\"\nPROG_ARGS=\"-u xialei\"\nPID_PATH=\"/var/run/\"\n\nstart() {\n        if [ -e \"$PID_PATH/$PROG.pid\" ]; then\n                echo \"Error! $PROG is running!\" 2>&1\n                exit 1\n        else\n                $PROG_PATH/$PROG $PROG_ARGS 2>&1 > \"/var/log/$PROG.log\" &\n                pid=`ps ax|grep testd|awk '{print $2}'|head -n 1`\n                echo \"$PROG started\"\n                echo $pid > \"$PID_PATH/$PROG.pid\"\n        fi      \n}\n\nstop() {\n        if [ -e \"$PID_PATH/$PROG.pid\" ]; then\n                pid=`ps ax|grep testd|awk '{print $2}'|head -n 1`\n                kill $pid\n        \n                rm -rf \"$PID_PATH/$PROG.pid\"\n                echo \"$PROG $pid killed\"\n        else\n                echo \"Error! $PROG not running!\" 2>&1\n                exit 1\n        fi\n}\n\nif [ \"$(id -u)\" != \"0\" ]; then\n        echo \"Please run as root!\" 2>&1\n        exit 1\nfi\n\ncase \"$1\" in\n    start)\n                start\n                exit 0\n        ;;\n        stop)\n                stop\n                exit 0\n        ;;\n        reload|restart)\n                stop\n                start\n                exit 0\n        ;;\n        **)\n                echo \"Usage: $0 {start|stop|reload}\" 2>&1\n                exit 1\n        ;;\nesac\n```\n\n可以看到init.d脚本实在是太原始了，systemd取代init.d指日可待\n\n## systemd service文件说明\n\nservice文件由 Unit, Service, Install 三部分组成\n\n### Unit\n\n所有引导过程中systemd要控制的文件/设备/程序等等都称为一个单元。\n+ Description: 服务描述\n+ Wants: 本单元启动成功，则会启动此字段定义的单元，如果Wants定义的单元启动失败，对本单元无影响\n+ Requires：本单元启动成功，则会启动此字段定义的单元，如果Requires定义的单元启动失败，本单元也失败。该字段无法控制先后顺序，如果Requires定义的单元未启动完成就启动本单元，那么一个都启动不了，不建议用这个字段\n+ OnFailure： 本单元如果启动失败，则启动该字段定义的单元\n+ Before/After：指定本单元的启动顺序\n\n本例中只需要依赖网络单元即可\n\n### Service\n\n服务本体定义：\n+ Type 启动类型\n+ ExecStart 启动服务的命令\n+ ExecStop 停止服务的命令（一般不写）\n+ Restart 重启规则\n+ RemainAfterExit 即使没有进程，也任务服务启动成功\n\nType 启动类型有以下几种：\n    + simple： 默认类型，启动的进程将成为服务进程。\n    + forking：标准Unix Daemon进程。本进程启动后会通过系统调用fork，把必要的通信频道都设置好之后父进程退出，留下守护精灵的子进程。（也就是说你自己来将进程变成daemon进程）\n    + oneshot：一次性命令。该服务运行完毕后没有进程，所以需要配合RemainAfterExit。\n\nRestart 重启规则有以下几种：\n    + no（默认值）：退出后不会重启\n    + always：不管是什么退出原因，总是重启\n    + on-success：只有正常退出时（退出状态码为0），才会重启\n    + on-failure：非正常退出时（退出状态码非0），包括被信号终止和超时，才会重启\n    + on-abnormal：只有被信号终止和超时，才会重启\n    + on-abort：只有在收到没有捕捉到的信号终止时，才会重启\n    + on-watchdog：超时退出，才会重启\n\n### Install\n\nsystemd装载规则定义\n+ WantedBy 将被谁装载，本例中使用multi-user.target，最终服务将通过软链接到`/etc/systemd/system/multi-user.target.wants`目录\n+ Alias 服务别名，可以通过 `systemctl 服务别名 restart` 之类的来操作\n\n## 写在最后\n\n是时候通过systemd改写init.d的服务了，有必要的话可以连pm2守护的进程都交给systemd来处理。","tags":["service"],"categories":["linux"]},{"title":"c语言实现简单版的php z_val结构体","url":"%2F2019%2F02%2F26%2Fc-php-simple-z-val-example.html","content":"\n## 源码\n\n学习过PHP的人都知道PHP是基于C语言开发的，但是C语言是强类型的，PHP如何实现弱类型呢？答案在于这个\n\n```c\ntypedef union _zvalue_value {\n\tlong lval;\t\t\t\t\t/* long value */\n\tdouble dval;\t\t\t\t/* double value */\n\tstruct {\n\t\tchar *val;\n\t\tint len;\n\t} str;\n\tHashTable *ht;\t\t\t\t/* hash table value */\n\tzend_object_value obj;\n\tzend_ast *ast;\n} zvalue_value;\n\nstruct _zval_struct {\n\t/* Variable information */\n\tzvalue_value value;\t\t/* value */\n\tzend_uint refcount__gc;\n\tzend_uchar type;\t/* active type */\n\tzend_uchar is_ref__gc;\n};\n```\n\n**type**保存了实际的类型，而**value**这个共用体保存了具体的值，我们使用到变量的时候需要根据变量类型来取出**_zvalue_value**中保存的具体值。\n采用union能够避免内存浪费，同一时刻，一个**_zval_struct**中的共用体**zvalue_value**只有一个成员会分配内存，避免了无谓的内存分配。\n\n## 编码\n\n阅读源码之前，可能觉得是一个很复杂的实现，阅读源码之后，其实也能自己实现，关键是type和value的组合。源码如下：\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <strings.h>\n\nenum z_val_type\n{\n    DOUBLE,\n    LONG,\n    STRING\n};\n\nstruct z_val\n{\n    union {\n        double dval;\n        long lval;\n        struct\n        {\n            char *val;\n            int len;\n        } str;\n    } value;\n    enum z_val_type type;\n};\n\nvoid z_val_print(struct z_val *);\n\nint main(void)\n{\n    // double\n    struct z_val *doubleVal = malloc(sizeof(struct z_val));\n    doubleVal->type = DOUBLE;\n    doubleVal->value.dval = 1.0;\n    // long\n    struct z_val *longVal = malloc(sizeof(struct z_val));\n    longVal->type = LONG;\n    longVal->value.lval = 1;\n    // string\n    struct z_val *strVal = malloc(sizeof(struct z_val));\n    strVal->type = STRING;\n    strVal->value.str.val = \"Hello World!\";\n    strVal->value.str.len = strlen(strVal->value.str.val);\n\n    z_val_print(doubleVal);\n    z_val_print(longVal);\n    z_val_print(strVal);\n\n    free(strVal);\n    free(longVal);\n    free(doubleVal);\n    return 0;\n}\n\nvoid z_val_print(struct z_val *val)\n{\n    switch (val->type)\n    {\n    case LONG:\n        printf(\"type: long, val: %ld\\n\", val->value.lval);\n        break;\n    case DOUBLE:\n        printf(\"type: double, val: %f\\n\", val->value.dval);\n        break;\n    case STRING:\n        printf(\"type: string, val: %s, len: %d\\n\", val->value.str.val, val->value.str.len);\n        break;\n    }\n}\n```\n\n## 编译\n采用gcc编译\n\n```\ngcc -o union union.c\n```\n\n## 执行\n\n```\n./union\n```\n\n输出\n\n```\ntype: double, val: 1.000000\ntype: long, val: 1\ntype: string, val: Hello World!, len: 12\n```\n\n可以看到输出跟预期一样，我们也实现了一个“弱类型”的变量，是不是很有成就感呢？\n实现上，多阅读源码可以多多参考别人的思维方式和编码习惯，所谓“站在巨人的肩膀上，才能看得更远”","tags":["c"],"categories":["php"]},{"title":"无需编程导出微信表情包","url":"%2F2019%2F01%2F11%2Fexport-wechat-emotion.html","content":"\n微信前两天推送了年度报告，其中的表情统计很有意思，的确，表情包这两年是越来越火了。但是有个问题是微信不支持导出表情包，有的小伙伴又需要导出来保存到其他地方。\n\n本文分享一个比较简单的方式导出表情包，条件只有一个：谷歌浏览器。\n\n1. 打开 https://wx.qq.com 并登陆，这是网页版微信登录入口\n2. 手机选择表情发送给文件传输助手\n3. 打开网页版微信，可以查看到图片\n![1](http://download.ddhigh.com/blog-img/WX20190111-105910.png)\n4. 接下来打开谷歌浏览器的开发者工具（不同电脑不太一样，但是都是右上角打开）\n![2](http://download.ddhigh.com/blog-img/WX20190111-110041.png)\n5. 然后按照图片顺序点击如下图所示的图标\n![3](http://download.ddhigh.com/blog-img/WX20190111-110109.png)\n6. 这时候鼠标处于选择元素的状态，直接悬浮在表情图片上即可\n![4](http://download.ddhigh.com/blog-img/WX20190111-110127.png)\n7. 下方的窗口会出现图片链接，而且会有背景色（本图片的背景色是淡蓝色）\n![5](http://download.ddhigh.com/blog-img/WX20190111-110127.png)\n8. 鼠标悬浮到刚才的淡蓝色窗口的链接上面，会出现表情的原图\n![6](http://download.ddhigh.com/blog-img/WX20190111-110137.png)\n8. 在链接上面点击右键，选择如图名字的菜单（菜单顺序不同系统不同）\n![7](http://download.ddhigh.com/blog-img/WX20190111-110148.png)\n9. 在新窗口打开的图片就是表情原始图片了，可以保存\n![8](http://download.ddhigh.com/blog-img/WX20190111-110159.png)"},{"title":"一起学context（二）——超时控制","url":"%2F2019%2F01%2F02%2Fgolang-timeout-context.html","content":"\n上一篇文章讲到如何使用context来传值，实际上context还有另外一个重要功能——goroutine的超时控制。\n很多时候goroutine如果不设超时，一旦发生阻塞将无限等待，协程数会越来越多，导致耗尽服务器内存。\n\n## 分类\n拥有超时控制的context有以下几种：\n1. context.WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) 指定时长超时结束\n2. context.WithCancel(parent Context) (ctx Context, cancel CancelFunc) 手动结束\n3. context.WithDeadline(parent Context, d time.Time) (Context, CancelFunc) 指定时间结束\n\n一般常用的话就`context.WithTimeout`\n\n## 示例代码\n\n所有超时控制结束的代码结构都是类似的，示例代码如下：\n\n```golang\npackage main\n\nimport (\n\t\"context\"\n\t\"time\"\n\t\"fmt\"\n)\n\nfunc main() {\n\tctx, cancel := context.WithTimeout(context.TODO(), time.Second*3)\n\tdefer cancel() // 防止任务比超时时间短导致资源未释放\n\t// 启动协程\n\tgo task(ctx)\n\t// 主协程需要等待，否则直接退出\n\ttime.Sleep(time.Second * 4)\n}\n\nfunc task(ctx context.Context) {\n\tch := make(chan struct{}, 0)\n\t// 真正的任务协程\n\tgo func() {\n\t\t// 模拟两秒耗时任务\n\t\ttime.Sleep(time.Second * 2)\n\t\tch <- struct{}{}\n\t}()\n\tselect {\n\tcase <-ch:\n\t\tfmt.Println(\"done\")\n\tcase <-ctx.Done():\n\t\tfmt.Println(\"timeout\")\n\t}\n}\n```\ntask函数是一般情况下ctx的处理代码，很多第三方框架会声明具体函数的第一个参数为context.Context来允许设定代码超时时间。","tags":["goroutine"],"categories":["golang"]},{"title":"一起学context（一）——上下文值传递","url":"%2F2018%2F10%2F17%2Fgolang-context-with-value.html","content":"\n# 系列开篇\n本文开始将针对context的用法进行系统化讨论，在这里你将能够在工作中合理使用context解决一些比较棘手的问题。\n\ncontext处理超时处理之外还可以用来保存数据，当你需要在多个上下文传递时传递数据，那么本文提到的知识可以排上用场。\n\n# 示例代码\n\n示例代码为一个简单的http服务，流程是登录之后会跳转首页，首页通过guard中间件进行鉴权。当然，示例代码未做其他诸如连接数据库之类的处理，这不是本文的重点。\n守卫函数读取cookie之后将cookie值写入context并向下传递，在整个请求中可以说是“透明”的。当访问到需要保护的接口时检测到没有提供cookie，则直接终端请求，否则通过r.WithContext将username的值存入cookie，避免的业务接口直接读取cookie的弊端。因为如果后期更改鉴权算法的话，业务代码可以不用更改，直接更改中间件即可。\n\n```golang\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n)\n\nfunc main() {\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/\", guard(home))\n\tmux.HandleFunc(\"/login\", login)\n\tlog.Fatal(http.ListenAndServe(\":8080\", mux))\n}\n\n// 登录\nfunc login(w http.ResponseWriter, r *http.Request) {\n\tif r.URL.Query().Get(\"username\") != \"root\" {\n\t\thttp.Error(w, http.StatusText(401), 401)\n\t\treturn\n\t}\n\tcookie := &http.Cookie{Name: \"username\", Value: \"root\", Expires: time.Now().Add(time.Hour)}\n\thttp.SetCookie(w, cookie)\n\thttp.Redirect(w, r, \"/\", 302)\n}\n\nfunc home(w http.ResponseWriter, r *http.Request) {\n\tusername := r.Context().Value(\"username\")\n\tfmt.Fprintf(w, \"welcome login: %s\", username.(string))\n}\n\n// 守卫\nfunc guard(handleFunc http.HandlerFunc) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t// check username\n\t\tlog.Printf(\"%s - %s\\n\", r.Method, r.RequestURI)\n\t\tcookie, err := r.Cookie(\"username\")\n\t\tif err != nil || cookie == nil { // 如果username为空直接拦截\n\t\t\thttp.Error(w, http.StatusText(401), 401)\n\t\t\treturn\n\t\t}\n\t\thandleFunc(w, r.WithContext(context.WithValue(r.Context(), \"username\", cookie.Value)))\n\t}\n}\n```\n\n本文的代码就这么多，内容也很少，希望大家能好好用上这个利器。\n关于context与协程超时控制将在下一篇文章中讲到。","tags":["context"],"categories":["golang"]},{"title":"io.Reader游标引发的血案","url":"%2F2018%2F10%2F17%2Fgo-io-reader-panic.html","content":"\n#背景\n线上运行了一个图片合成程序，默认的小程序二维码中奖是小程序LOGO，不满足需求，所以将微信小程序二维码和用户头像合成在一张图片。\n由于微信图片有时候返回的Content-Type不对应（比如内容是PNG的，头确是image/jpeg）所以使用jpeg/png/gif的顺序进行图片数据解析，哪个成功就返回解析结果。\n#问题\n总是出现诸如`invalid JPEG format: missing SOI marker`\n#解决过程\n我去查看jpeg.Decode的源码，如下：\n```golang\nfunc (d *decoder) decode(r io.Reader, configOnly bool) (image.Image, error) {\n\td.r = r\n\n\t// Check for the Start Of Image marker.\n\tif err := d.readFull(d.tmp[:2]); err != nil {\n\t\treturn nil, err\n\t}\n\tif d.tmp[0] != 0xff || d.tmp[1] != soiMarker {\n\t\treturn nil, FormatError(\"missing SOI marker\")\n\t}\n...\n```\nsoiMarker常量\n```\n\tsoiMarker  = 0xd8 // Start Of Image.\n```\n可以看到判断了第1个字节如果不是`0xff`或者第2个字节不是`0xd8`就报错。打印图片的bytes前几个字节如下：\n```\n[]byte{0xff, 0xd8, 0xff, 0xe0, 0x0, 0x10}\n```\n可以看到第1个字节和第2个字节满足要求，按理说不会出现这个问题，无奈只能求助于Google,搜索了\n`invalid JPEG format: missing SOI marker`关键字出现一篇[Covert base64 string to JPG](https://stackoverflow.com/questions/46022262/covert-base64-string-to-jpg)引起了我的注意。\n打开看到答案\n>You need to create a new reader for each decoder:\n```\npngI, errPng := png.Decode(bytes.NewReader(unbased))\n\n// ...\n\njpgI, errJpg := jpeg.Decode(bytes.NewReader(unbased))\n```\n原来需要重新创建读取器，重新创建读取器后问题解决。\n#后续\n抱着打破砂锅问到底的心态，查看了一下`bytes.Reader`的源码，发现游标读取完后并未重置\n```\n// Read implements the io.Reader interface.\nfunc (r *Reader) Read(b []byte) (n int, err error) {\n\tif r.i >= int64(len(r.s)) {\n\t\treturn 0, io.EOF\n\t}\n\tr.prevRune = -1\n\tn = copy(b, r.s[r.i:])\n\tr.i += int64(n)\n\treturn\n}\n```\nReader定义\n```\ntype Reader struct {\n\ts        []byte\n\ti        int64 // current reading index\n\tprevRune int   // index of previous rune; or < 0\n}\n```\n可以看到`r.i`就是游标了。问题圆满解决","tags":["io.Reader"],"categories":["golang"]},{"title":"golang40行代码实现通用协程池","url":"%2F2018%2F08%2F08%2Fgolang-general-goroutine-pool.html","content":"\n## 代码仓库\n\n[goroutine-pool](https://github.com/xialeistudio/goroutine-pool)\n\n## golang 的协程管理\n\ngolang 协程机制很方便的解决了并发编程的问题，但是协程并不是没有开销的，所以也需要适当限制一下数量。\n\n### 不使用协程池的代码(示例代码使用 chan 实现，代码略啰嗦)\n\n```go\nfunc (p *converter) upload(bytes [][]byte) ([]string, error) {\n\tch := make(chan struct{}, 4)\n\twg := &sync.WaitGroup{}\n\twg.Add(len(bytes))\n\tret := make([]string, len(bytes))\n\n\t// 上传\n\tfor index, item := range bytes {\n\t\tch <- struct{}{}\n\t\tgo func(index int, imageData []byte) {\n\t\t\tdefer func() {\n\t\t\t\twg.Done()\n\t\t\t\t<-ch\n\t\t\t}()\n\n\t\t\tlink, err := qiniu.UploadBinary(imageData, fmt.Sprintf(\"%d.png\", time.Now().UnixNano()))\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(\"上传图片失败\", err.Error())\n\t\t\t\treturn\n\t\t\t}\n\t\t\tret[index] = link\n\t\t}(index, item)\n\t}\n\n\twg.Wait()\n\treturn ret, nil\n}\n```\n\n需要实现的需求有两个:\n\n1.  限制最大协程数，本例为 4\n2.  等待所有协程完成，本例为`bytes切片长度`\n\n### 使用协程池的代码\n\n```go\nfunc (p *converter) upload(bytes [][]byte) ([]string, error) {\n\tret := make([]string, len(bytes))\n\tpool := goroutine_pool.New(4, len(bytes))\n\n\tfor index, item := range bytes {\n\t\tindex := index\n\t\titem := item\n\t\tpool.Submit(func() {\n\t\t\tlink, err := qiniu.UploadBinary(item, fmt.Sprintf(\"%d.png\", time.Now().UnixNano()))\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(\"上传图片失败\", err.Error())\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tret[index] = link\n\t\t})\n\t}\n\tpool.Wait()\n\treturn ret, nil\n}\n```\n\n可以看到最大的区别是只需要关注业务逻辑即可，并发控制和等待都已经被协程池接管\n\n## 写在最后\n\n希望本文能减轻你控制协程的负担\n","tags":["goroutine"],"categories":["golang"]},{"title":"golang不到30行代码实现依赖注入","url":"%2F2018%2F07%2F24%2Fgolang-dependency-inject-container.html","content":"\n## 项目地址\n\n[go-di-demo](https://github.com/xialeistudio/di-demo)\n\n## 本项目依赖\n\n使用标准库实现，无额外依赖\n\n## 依赖注入的优势\n\n用java的人对于spring框架一定不会陌生，spring核心就是一个IoC(控制反转/依赖注入)容器，带来一个很大的优势是解耦。一般只依赖容器，而不依赖具体的类，当你的类有修改时，最多需要改动一下容器相关代码，业务代码并不受影响。\n\n## golang的依赖注入原理\n\n总的来说和java的差不多，步骤如下：(golang不支持动态创建对象，所以需要先手动创建对象然后注入，java可以直接动态创建对象)\n\n1. 通过反射读取对象的依赖(golang是通过tag实现)\n2. 在容器中查找有无该对象实例\n3. 如果有该对象实例或者创建对象的工厂方法，则注入对象或使用工厂创建对象并注入\n4. 如果无该对象实例，则报错\n\n## 代码实现\n\n一个典型的容器实现如下，依赖类型参考了spring的singleton/prototype，分别对象单例对象和实例对象:\n\n```golang\npackage di\n\nimport (\n\t\"sync\"\n\t\"reflect\"\n\t\"fmt\"\n\t\"strings\"\n\t\"errors\"\n)\n\nvar (\n\tErrFactoryNotFound = errors.New(\"factory not found\")\n)\n\ntype factory = func() (interface{}, error)\n// 容器\ntype Container struct {\n\tsync.Mutex\n\tsingletons map[string]interface{}\n\tfactories  map[string]factory\n}\n// 容器实例化\nfunc NewContainer() *Container {\n\treturn &Container{\n\t\tsingletons: make(map[string]interface{}),\n\t\tfactories:  make(map[string]factory),\n\t}\n}\n\n// 注册单例对象\nfunc (p *Container) SetSingleton(name string, singleton interface{}) {\n\tp.Lock()\n\tp.singletons[name] = singleton\n\tp.Unlock()\n}\n\n// 获取单例对象\nfunc (p *Container) GetSingleton(name string) interface{} {\n\treturn p.singletons[name]\n}\n\n// 获取实例对象\nfunc (p *Container) GetPrototype(name string) (interface{}, error) {\n\tfactory, ok := p.factories[name]\n\tif !ok {\n\t\treturn nil, ErrFactoryNotFound\n\t}\n\treturn factory()\n}\n\n// 设置实例对象工厂\nfunc (p *Container) SetPrototype(name string, factory factory) {\n\tp.Lock()\n\tp.factories[name] = factory\n\tp.Unlock()\n}\n\n// 注入依赖\nfunc (p *Container) Ensure(instance interface{}) error {\n\telemType := reflect.TypeOf(instance).Elem()\n\tele := reflect.ValueOf(instance).Elem()\n\tfor i := 0; i < elemType.NumField(); i++ { // 遍历字段\n\t\tfieldType := elemType.Field(i)\n\t\ttag := fieldType.Tag.Get(\"di\") // 获取tag\n\t\tdiName := p.injectName(tag)\n\t\tif diName == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\tvar (\n\t\t\tdiInstance interface{}\n\t\t\terr        error\n\t\t)\n\t\tif p.isSingleton(tag) {\n\t\t\tdiInstance = p.GetSingleton(diName)\n\t\t}\n\t\tif p.isPrototype(tag) {\n\t\t\tdiInstance, err = p.GetPrototype(diName)\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif diInstance == nil {\n\t\t\treturn errors.New(diName + \" dependency not found\")\n\t\t}\n\t\tele.Field(i).Set(reflect.ValueOf(diInstance))\n\t}\n\treturn nil\n}\n\n// 获取需要注入的依赖名称\nfunc (p *Container) injectName(tag string) string {\n\ttags := strings.Split(tag, \",\")\n\tif len(tags) == 0 {\n\t\treturn \"\"\n\t}\n\treturn tags[0]\n}\n\n// 检测是否单例依赖\nfunc (p *Container) isSingleton(tag string) bool {\n\ttags := strings.Split(tag, \",\")\n\tfor _, name := range tags {\n\t\tif name == \"prototype\" {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// 检测是否实例依赖\nfunc (p *Container) isPrototype(tag string) bool {\n\ttags := strings.Split(tag, \",\")\n\tfor _, name := range tags {\n\t\tif name == \"prototype\" {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// 打印容器内部实例\nfunc (p *Container) String() string {\n\tlines := make([]string, 0, len(p.singletons)+len(p.factories)+2)\n\tlines = append(lines, \"singletons:\")\n\tfor name, item := range p.singletons {\n\t\tline := fmt.Sprintf(\"  %s: %x %s\", name, &item, reflect.TypeOf(item).String())\n\t\tlines = append(lines, line)\n\t}\n\tlines = append(lines, \"factories:\")\n\tfor name, item := range p.factories {\n\t\tline := fmt.Sprintf(\"  %s: %x %s\", name, &item, reflect.TypeOf(item).String())\n\t\tlines = append(lines, line)\n\t}\n\treturn strings.Join(lines, \"\\n\")\n}\n```\n\n1. 最重要的是`Ensure`方法，该方法扫描实例的所有export字段，并读取di标签，如果有该标签则启动注入。\n2. 判断di标签的类型来确定注入singleton或者prototype对象\n\n## 测试\n\n1. 单例对象在整个容器中只有一个实例，所以不管在何处注入，获取到的指针一定是一样的。\n2. 实例对象是通过同一个工厂方法创建的，所以每个实例的指针不可以相同。\n\n下面是测试入口代码，完整代码在github仓库，有兴趣的可以翻阅：\n\n```golang\npackage main\n\nimport (\n\t\"di\"\n\t\"database/sql\"\n\t\"fmt\"\n\t\"os\"\n\t_ \"github.com/go-sql-driver/mysql\"\n\t\"demo\"\n)\n\nfunc main() {\n\tcontainer := di.NewContainer()\n\tdb, err := sql.Open(\"mysql\", \"root:root@tcp(localhost)/sampledb\")\n\tif err != nil {\n\t\tfmt.Printf(\"error: %s\\n\", err.Error())\n\t\tos.Exit(1)\n\t}\n\tcontainer.SetSingleton(\"db\", db)\n\tcontainer.SetPrototype(\"b\", func() (interface{}, error) {\n\t\treturn demo.NewB(), nil\n\t})\n\n\ta := demo.NewA()\n\tif err := container.Ensure(a); err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\t// 打印指针，确保单例和实例的指针地址\n\tfmt.Printf(\"db: %p\\ndb1: %p\\nb: %p\\nb1: %p\\n\", a.Db, a.Db1, &a.B, &a.B1)\n}\n```\n\n执行之后打印出来的结果为：\n\n```\ndb: 0xc4200b6140\ndb1: 0xc4200b6140\nb: 0xc4200a0330\nb1: 0xc4200a0338\n```\n\n可以看到两个db实例的指针一样，说明是同一个实例，而两个b的指针不同，说明不是一个实例。\n\n## 写在最后\n\n通过依赖注入可以很好的管理多个对象之间的实例化以及依赖关系，配合配置文件在应用初始化阶段将需要注入的实例注册到容器中，在应用的任何地方只需要在实例化时注入容器即可。没有额外依赖。","tags":["di"],"categories":["golang"]},{"title":"不到20行代码实现golang路由调度","url":"%2F2018%2F07%2F23%2Fgolang-route-dispatcher.html","content":"\n## 项目地址\n\n[go-dispatcher](https://github.com/xialeistudio/go-dispatcher)\n\n## 本项目依赖\n\n使用标准库实现，无额外依赖\n\n## 为什么需要路由调度层\n\n> golang http标准库只能精确匹配请求的URI，然后执行handler。现在一般web项目都至少有个Controller层，以struct实现，根据不同的请求路径派发到不同的方法中去。\n\n## 路由调度器定义\n\n由于golang暂时还不可以动态创建对象(比如java的`Class.forName(\"xxx\").newInstance()`,xxx是任意存在的class名称)。所以需要手动注册一下controller关系。\n\n1. 定义`routes`保存controller指针\n2. 解析请求过来的URL查询参数，暂定`a`为`action名称`,`c`为`controller名称`，本文偷了下懒，没对PATH_INFO做处理，也没有对actionName的首字母自动大写，这个不影响本文要传达的核心内容，有兴趣的读者可以自行实现。\n3. 根据URL中的`controllerName`找到对应的controller\n4. 使用反射将当前请求对象的`*http.Request`和`http.ResponseWriter`设置到该Controller\n5. 使用反射以及actionName对应该controller的方法\n\n> 由于golang的继承不是一般的OOP，所以也没有父子类这种说法，路由注册那里只能使用interface{}\n\n## 代码实现\n\n### app/app.go\n\n该文件为核心调度文件\n\n```golang\npackage app\n\nimport (\n\t\"net/http\"\n\t\"reflect\"\n\t\"fmt\"\n)\n\ntype application struct {\n\troutes map[string]interface{}\n}\n\nfunc New() *application {\n\treturn &application{\n\t\troutes: make(map[string]interface{}),\n\t}\n}\n\nfunc (p *application) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tcontrollerName := r.URL.Query().Get(\"c\")\n\tactionName := r.URL.Query().Get(\"a\")\n\tif controllerName == \"\" || actionName == \"\" {\n\t\thttp.Error(w, http.StatusText(http.StatusBadRequest), http.StatusBadRequest)\n\t\treturn\n\t}\n\troute, ok := p.routes[controllerName]\n\tif !ok {\n\t\thttp.Error(w, \"Controller Not Found\", http.StatusNotFound)\n\t\treturn\n\t}\n\tele := reflect.ValueOf(route).Elem()\n\tele.FieldByName(\"Request\").Set(reflect.ValueOf(r))\n\tele.FieldByName(\"Response\").Set(reflect.ValueOf(w))\n\tele.MethodByName(actionName).Call([]reflect.Value{})\n}\n\nfunc (p *application) printRoutes() {\n\tfor route, controller := range p.routes {\n\t\tele := reflect.ValueOf(controller).Type().String()\n\t\tfmt.Printf(\"%s %s\\n\", route, ele)\n\t}\n}\n\nfunc (p *application) Get(route string, controller interface{}) {\n\tp.routes[route] = controller\n}\n\nfunc (p *application) Run(addr string) error {\n\tp.printRoutes()\n\tfmt.Printf(\"listen on %s\\n\", addr)\n\treturn http.ListenAndServe(addr, p)\n}\n```\n\n### app/controller.go\n\n控制器\"基类\"\n\n```golang\npackage app\n\nimport \"net/http\"\n\ntype Controller struct {\n\tResponse http.ResponseWriter\n\tRequest  *http.Request\n}\n```\n\n### controller/site.go\n\n具体业务逻辑类\n\n```golang\npackage controllers\n\nimport (\n\t\"fmt\"\n\t\"app\"\n)\n\ntype SiteController struct {\n\tapp.Controller\n}\n\nfunc (p SiteController) Index() {\n\tfmt.Fprint(p.Response, p.Request.RequestURI)\n}\n```\n\n### main.go\n\n入口文件\n\n```golang\npackage main\n\nimport (\n\t_ \"github.com/go-sql-driver/mysql\"\n\t\"app\"\n\t\"controllers\"\n)\n\nfunc main() {\n\tapplication := app.New()\n\tapplication.Get(\"site\", &controllers.SiteController{})\n\tapplication.Run(\":8080\")\n}\n```\n\n## 运行项目\n\n1. 启动进程\n2. 访问`http://localhost:8080?c=site&a=Index`会输出`/?c=site&a=Index`\n\n## 写在最后\n\n希望这个小小的项目能启发到各位读者，早日开发出适合自己的Web框架!","tags":["router"],"categories":["golang"]},{"title":"redis常用实践","url":"%2F2018%2F06%2F14%2Fredis-common-practice.html","content":"\nRedis相信大家都不陌生，而如果只是用来取代memcached做缓存的话，实在是大材小用了。一起来看看生产环境下的常用用法。\n\n## 分布式锁\n\n```php\n$canLock = $redis->set('k', 1, 'NX', 'EX', 2);\nif($canLock) {\n    // 获得锁成功\n}\n```\n\n锁定键名为k的数据两秒钟，两秒后该方法才能重新获取锁\n\n```php\n$redis->del('k');\n```\n\n删除键名为k的数据，其他方法可以重新获取锁\n\n## Hash\n\n这是redis特有的数据结构，memcached没有。使用场景很多，列举一种常用的，假设有一个需求\n\n> 加密后的用户id和真实用户id的映射关系保存\n\n这种情况我们可以使用hash，而不是使用多个kv缓存, 需要清空所有的时候比较难处理。代码如下：\n\n```php\n$realId = $redis->hget('user_id_map', 'userId1');\nif(!empty($realId)) {\n    return $realId;\n}\n$realId = getFromDatabase('userId1'); // 从数据库读取\n$redis->hset('user_id_map','userId1',$realId);\n```\n\n如果需要清空，则直接删除hash即可。\n\n## set\n\nset就是数据项不重复的集合，使用场景也很多。例子要说的是使用set存储一个聊天室中的所有用户id:\n\n```php\n$redis->sadd('chat_room', 'user1', 'user2'); // 添加成员到集合\n$redis->srem('chat_room', 'user1'); // 删除指定成员\n$redis->smembers('chat_room'); // 获取集合所有元素\n```\n\n ## 结论\n\n 大致就是这样了，基于这些简单数据结构可以根据业务需求构造更合理的数据结构。","tags":["php"],"categories":["php"]},{"title":"PermissionScope Swift4 兼容问题","url":"%2F2018%2F06%2F14%2FPermissionScope-With-Swift-4.html","content":"\n[PermissionScope](https://github.com/nickoneill/PermissionScope)是iOS非常好用的权限处理库，界面效果也非常精美。不幸的是作者已经停止维护。\n\n> PermissionScope is no longer supported. Please use an alternative if you need updates for newer iOS 10 and 11 APIs!\n\n## 问题的来源\n\n因为作者是基于Swift3开发的，而4.0的`@selector`语法有一点调整，所以是不能通过编译的，处理办法是根据Xcode的提示一个个修正。\n\n可是事情真的这么简单吗？Xcode处理过后虽然编译通过了，但是会触发运行时错误。错误内容大致是`调用了不存在的方法`。\n\n## 解决方案\n\n由于我们根据Xcode的提示给相关代码加了`@objc`，但是有些方法是没有加的，而这些方法类似下面的代码：\n\n```swift\nfunc requestCamera() {\n\n}\n```\n\n由于没有`@objc`修饰，`@selector`指令找不到方法，所以就报错了。解决方案如下：\n\n```swift\n@objc\nfunc requestCamera() {\n\n}\n```","tags":["swift"],"categories":["ios"]},{"title":"使用yii2依赖注入规范业务开发","url":"%2F2018%2F04%2F24%2Fyii2-dependency-inject.html","content":"\n## 本文代码\n\n[https://github.com/xialeistudio/yii2-di-demo](https://github.com/xialeistudio/yii2-di-demo)\n\n## 什么是依赖注入(DI)?\n\n对象由框架来创建而不是程序员通过 **new** 创建。跟IoC差不多一个意思。\n\n## 为什么要有依赖注入?\n\n1. 解耦。调用方不再通过 **new** 运算符实例化被调用对象，而通过框架(IoC容器)创建之后注入进来。解除了调用者与被调用者之间的依赖。\n2. 有利于面向接口编程。个人认为OOP程序设计最重要的就是面向接口(面向抽象)编程。因为有了第1步的关系，调用者只需要依赖接口类型而不用依赖实现类型，提高了程序的扩展性。\n\n## Yii2的依赖注入\n\nYii2通过 [yii\\di\\Container](http://www.yiichina.com/doc/api/2.0/yii-di-container) 提供DI容器特性。目前支持一下4种方式注入：\n\n1. [构造方法注入](http://www.yiichina.com/doc/guide/2.0/concept-di-container#constructor-injection)\n2. [方法注入](http://www.yiichina.com/doc/guide/2.0/concept-di-container#constructor-injection)\n3. [Setter和属性注入](http://www.yiichina.com/doc/guide/2.0/concept-di-container#constructor-injection)\n4. [PHP回调注入](http://www.yiichina.com/doc/guide/2.0/concept-di-container#constructor-injection)\n\n## 注册依赖关系\n\n1. 通过容器的 **set** 方法注入\n2. 通过配置文件注入(推荐)\n\n## 依赖注入实战\n\n1. 打开终端，执行以下命令初始化项目：\n\n    ```bash\n    composer create-project --prefer-dist yiisoft/yii2-app-basic basic\n    ```\n\n2. 声明接口业务类 **app\\services\\UserService**\n\n    ```php\n    <?php\n    /**\n    * Created by PhpStorm.\n    * User: xialei\n    * Date: 2018/4/24\n    * Time: 下午10:55\n    */\n\n    namespace app\\services;\n\n    /**\n    * 用户业务类\n    * Interface UserService\n    * @package app\\services\n    */\n    interface UserService\n    {\n        /**\n        * 根据ID查询用户\n        * @param integer $id\n        * @return array|null\n        */\n        public function show($id);\n\n        /**\n        * 查看所有用户\n        * @return array\n        */\n        public function all();\n    }\n    ```\n\n3. 接口实现文件 **app\\services\\impl\\UserServiceImpl**\n\n    ```php\n    <?php\n    /**\n    * Created by PhpStorm.\n    * User: xialei\n    * Date: 2018/4/24\n    * Time: 下午10:56\n    */\n\n    namespace app\\services\\impl;\n\n\n    use app\\services\\UserService;\n\n    class UserServiceImpl implements UserService\n    {\n        private $users = [\n            ['id' => 1, 'name' => 'xialei'],\n            ['id' => 2, 'name' => 'zhangsan'],\n        ];\n\n        /**\n        * 根据ID查询用户\n        * @param integer $id\n        * @return array\n        */\n        public function show($id)\n        {\n            foreach ($this->users as $user) {\n                if ($user['id'] == $id) {\n                    return $user;\n                }\n            }\n            return null;\n        }\n\n        /**\n        * 查看所有用户\n        * @return array\n        */\n        public function all()\n        {\n            return $this->users;\n        }\n    }\n    ```\n\n4. 注册依赖关系 **config/web.php**\n\n    ```php\n    <?php\n\n    use app\\services\\UserService;\n    use app\\services\\impl\\UserServiceImpl;\n\n    $params = require __DIR__ . '/params.php';\n    $db = require __DIR__ . '/db.php';\n\n    $config = [\n        'id' => 'basic',\n        'basePath' => dirname(__DIR__),\n        'bootstrap' => ['log'],\n        'aliases' => [\n            '@bower' => '@vendor/bower-asset',\n            '@npm' => '@vendor/npm-asset',\n        ],\n        'container' => [\n            'definitions' => [\n                UserService::class => UserServiceImpl::class\n            ]\n        ],\n        'components' => [\n            'request' => [\n                // !!! insert a secret key in the following (if it is empty) - this is required by cookie validation\n                'cookieValidationKey' => '0xGrStOOZE2oXxNNiu-o2eYovJ_Ia1Dk',\n            ],\n            'response' => [\n                'format' => 'json'\n            ],\n            'errorHandler' => [\n                'errorAction' => 'site/error',\n            ],\n            'urlManager' => [\n                'enablePrettyUrl' => true,\n                'showScriptName' => false,\n                'rules' => [\n                ],\n            ],\n        ],\n    ];\n\n    if (YII_ENV_DEV) {\n        // configuration adjustments for 'dev' environment\n        $config['bootstrap'][] = 'debug';\n        $config['modules']['debug'] = [\n            'class' => 'yii\\debug\\Module',\n            // uncomment the following to add your IP if you are not connecting from localhost.\n            //'allowedIPs' => ['127.0.0.1', '::1'],\n        ];\n\n        $config['bootstrap'][] = 'gii';\n        $config['modules']['gii'] = [\n            'class' => 'yii\\gii\\Module',\n            // uncomment the following to add your IP if you are not connecting from localhost.\n            //'allowedIPs' => ['127.0.0.1', '::1'],\n        ];\n    }\n\n    return $config;\n    ```\n\n5. 添加控制器 **app\\controllers\\UserController**\n\n    ```php\n    <?php\n    /**\n    * Created by PhpStorm.\n    * User: xialei\n    * Date: 2018/4/24\n    * Time: 下午10:57\n    */\n\n    namespace app\\controllers;\n\n\n    use app\\services\\UserService;\n    use yii\\base\\Module;\n    use yii\\web\\Controller;\n    use yii\\web\\NotFoundHttpException;\n\n    class UserController extends Controller\n    {\n        private $userService;\n\n        public function __construct(string $id, Module $module, UserService $userService, array $config = [])\n        {\n            $this->userService = $userService;\n            parent::__construct($id, $module, $config);\n        }\n\n        /**\n        * 查看用户\n        * @param $id\n        * @return array|null\n        * @throws NotFoundHttpException\n        */\n        public function actionShow($id)\n        {\n            $user = $this->userService->show($id);\n            if (empty($user)) {\n                throw new NotFoundHttpException('用户不存在');\n            }\n            return $user;\n        }\n\n        /**\n        * 查看所有用户\n        * @return array\n        */\n        public function actionAll()\n        {\n            return $this->userService->all();\n        }\n    }\n    ```\n\n6. 运行测试服务器\n\n    ```bash\n    ./yii serve/index\n    ```\n\n7. 访问用户列表接口 [http://localhost:8080/user/all](http://localhost:8080/user/all)\n\n    ```json\n    [{\n        \"id\": 1,\n        \"name\": \"xialei\"\n    }, {\n        \"id\": 2,\n        \"name\": \"zhangsan\"\n    }]\n    ```\n\n8. 访问查看用户接口 [http://localhost:8080/user/show?id=1](http://localhost:8080/user/show?id=1)\n\n    ```json\n    {\n        \"id\": 1,\n        \"name\": \"xialei\"\n    }\n    ```\n\n## 写在最后\n\n如你所见，Yii2自带的IoC容器使用起来还是挺方便的，观测了Yii **配置优于编码** 的思想，Yii的组件基本上都可以在配置文件中进行配置而不需要手动编码。\n\n灵活使用DI可以使我们从依赖关系中解脱出来，专注于业务逻辑。\n\n当然，业务逻辑的组织也是一个很大的研究课题，\b有兴趣的可以去看看 **DDD\b(\b领域驱动设计)**","tags":["di"],"categories":["php"]},{"title":"golang使用travis进行持续集成","url":"%2F2018%2F04%2F08%2Fgolang-travis-ci.html","content":"\n虽然golang的工程工具已经非常完善了，比如测试、代码格式化等等。但是如果开发library开源到github的话，这些东西是可以使用自动化工具完成的，那就是 [travis](https://www.travis-ci.org/)\n\n## 使用步骤\n\n1. 开发好需要集成的library以及测试用例\n1. 在项目根目录新建`.travis.yml`文件\n    ```yaml\n    language: go\n    go:\n    - 1.x\n    - '1.8'\n    - '1.9'\n    - 1.10.x\n    script:\n    - go test -v ./...\n    ```\n1. 提交到github\n1. 打开[https://www.travis-ci.org/](https://www.travis-ci.org/)并使用github账号登录\n1. 登录之后点击左边 **\"My Repositories\"** 旁边的 **\"+\"** 号添加项目（点击项目前面的滑块即可）\n1. 更改项目文件，push一次到github，此时travis会自动运行测试脚本\n\n## 敏感数据加密\n\n如果你的测试用例需要使用到敏感数据（如一些密钥等等），那需要用travis将你的敏感数据加密(以Mac为例)\n\n1. 终端执行`sudo gem install travis`\n1. 在项目根目录打开终端执行`travis encrypt AMAP_KEY=\"xxxx\" --add` **AMAP_KEY**是环境变量名称，程序读取环境变量可以得到真实的key，**xxxx**是敏感数据\n1. 执行完毕后，**.travis.yml** 会发生更改, 会添加如下内容(secure可能不一致)\n    ```yaml\n    env:\n    global:\n        secure: kr5JHNTYsh/jezvk88qP91arb+UD/op/5CyOFY7uNYpJ6ZSsJY5fDKyZHjf0VSFmaYqJFMPl6uCASE9baiepeGvBFcy8aI9CNsbLzj2uBNjqqYPmvYGnBjpzp8yknVJKRTitF/kkWtzZcWImHnpvNGHuzXxp/EIBeJtNwjcCRoP/qfGhlZKbLsYFvlWkmRYb0dr8RM5mlmGXPZi8q7m+soVRO8Zjr4QQccybgmhonxlcUrHr6ro+yjjQefoJXRufqoRX0sGyecGYucC4nUpWl5hkDPkQE+Mekhz+rF657SwNsn8nXOFnnUuwsPXE26ak5xF1roEcFk2CpwGZuT7smJZPtw1inXFdIaW+4qllbyxMJkylvFZa5IcvLT3+/eKaQc8Fg6PoxJH0PF3RdtoQVB31cQiPWNm1SecQ6wC64WA/5qN4T5OoRfpt60BFDAITdS62dQGu5LSepcXMWXhxCdQPeDm5Qce6wjJXURubJMpBm0mPWwCNZhJyRw1G5TTyO25NckXQRlObrjltvwAd+7OEUcsYXqhdPtUTIVy6w3XOwT2eC/hP0Yi7qqUMMlJTHUW7Lb9zsEc4UB5BVwgeZ5Y9bVbknJfpt3ygcXAJeeDYxwV9g16KoS7HMFPzwrqlHbiBytIahqarBd4enwqR5RYQPEyetiIDLaJA4SyQ0cE=\n    ```\n1. 上传到github\n\n## 接收测试结果通知\n\n如果你需要获取travis执行结果通知的话，可以添加邮箱配置，travis执行完毕后会通知到该邮箱。\n\n1. 打开 **.travis.yml**\n1. 添加以下内容：\n```yaml\nnotifications:\n  email:\n    recipients:\n        - 邮箱地址\n    on_success: change\n    on_failure: always\n```\n1. 提交到github\n","tags":["ci"],"categories":["golang"]},{"title":"golang for遍历channel时需要注意的问题","url":"%2F2018%2F04%2F05%2Fgolang-for-over-channels.html","content":"\n最近在做一个基于RabbitMQ的应用，由于官方的qos没有golang的版本，所以出了一点问题。问题代码如下：\n\n```go\n\t_, ch, err := component.NewRabbitMQ()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tif err := ch.Qos(10, 0, true); err != nil {\n\t\tpanic(err)\n\t}\n\tmsgs, err := ch.Consume(\"push\", \"\", false, false, false, false, nil)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfor m := range msgs {\n\t\tgo func(d *amqp.Delivery) {\n            defer func() { d.Ack(false) }\n            // 处理消息\n        }(&m)\n    }\n```\n\n发现消费到10条消息，进程就退出了，但是exit code为0，表示系统是正常退出，由于做了日志记录可以确定消费了10条，所以初步确定是qos相关问题。\n\n## 排查过程\n1. 首先是把`d`的tag打印出来，发现全部是一样的，可以确定是重复的一条消息\n2. 一开始想到可能是经典的`go协程执行在for循环结束以后`导致的，但是看我的代码不属于这种情况，有使用`&m`保证每一条消息都是不同循环传入的。所以判断可能是for循环的传递问题。\n3. 确定方向之后开始写了一个测试项目用来验证我的想法是否正确。\n\n## 测试代码\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tch := make(chan int, 10)\n\tfor i := 0; i < 10; i++ {\n\t\tch <- i\n\t}\n\tclose(ch)\n\tfor v := range ch {\n\t\tfmt.Println(&v)\n\t}\n}\n```\n\n执行输出\n\n```text\n0xc420086008\n0xc420086008\n0xc420086008\n0xc420086008\n0xc420086008\n0xc420086008\n0xc420086008\n0xc420086008\n0xc420086008\n0xc420086008\n```\n\n**到这里才焕然大悟，for循环中，如果循环变量不是指针，那么每次的变量是同一个，不过值变了。**，所以上例中的RabbitMQ go协程消费消息那里，需要直接传递值而不是指针，经过测试之后发现，问题确实解决了。\n\n## 题外话\n\n测试代码那里，如果不close掉channel是会发生死锁的，原因是 **当for循环读完channel的10个值之后会继续尝试读取下一个，而由于channel为空又没关闭，会一直阻塞形成死锁**\n\n## TOOD\n\n研究RabbitMQ Consumer部分的源码来看看消费channel被关闭的问题。","categories":["golang"]},{"title":"golang解决TCP粘包问题","url":"%2F2018%2F03%2F02%2Fgolang-tcp-stick-package.html","content":"\n什么是TCP粘包问题以及为什么会产生TCP粘包，本文不加讨论。本文使用golang的`bufio.Scanner`来实现自定义协议解包。\n\n## 协议数据包定义\n\n本文模拟一个日志服务器，该服务器接收客户端传到的数据包并显示出来\n\n```go\ntype Package struct {\n\tVersion        [2]byte // 协议版本，暂定V1\n\tLength         int16   // 数据部分长度\n\tTimestamp      int64   // 时间戳\n\tHostnameLength int16   // 主机名长度\n\tHostname       []byte  // 主机名\n\tTagLength      int16   // 标签长度\n\tTag            []byte  // 标签\n\tMsg            []byte  // 日志数据\n}\n```\n\n协议定义部分没有什么好讲的，根据具体的业务逻辑定义即可。\n\n## 数据打包\n\n由于TCP协议是语言无关的协议，所以直接把协议数据包结构体发送到TCP连接中也是不可能的，只能发送字节流数据，所以需要自己实现数据编码。所幸golang提供了`binary`来帮助我们实现网络字节编码。\n\n```go\nfunc (p *Package) Pack(writer io.Writer) error {\n\tvar err error\n\terr = binary.Write(writer, binary.BigEndian, &p.Version)\n\terr = binary.Write(writer, binary.BigEndian, &p.Length)\n\terr = binary.Write(writer, binary.BigEndian, &p.Timestamp)\n\terr = binary.Write(writer, binary.BigEndian, &p.HostnameLength)\n\terr = binary.Write(writer, binary.BigEndian, &p.Hostname)\n\terr = binary.Write(writer, binary.BigEndian, &p.TagLength)\n\terr = binary.Write(writer, binary.BigEndian, &p.Tag)\n\terr = binary.Write(writer, binary.BigEndian, &p.Msg)\n\treturn err\n}\n```\n\nPack方法的输出目标为`io.Writer`，有利于接口扩展，只要实现了该接口即可编码数据写入。`binary.BigEndian`是字节序，本文暂时不讨论，有需要的读者可以自行查找资料研究。\n\n## 数据解包\n\n解包需要将TCP数据包解析到结构体中，接下来会讲为什么需要添加几个`数据无关`的长度字段。\n\n```go\nfunc (p *Package) Unpack(reader io.Reader) error {\n\tvar err error\n\terr = binary.Read(reader, binary.BigEndian, &p.Version)\n\terr = binary.Read(reader, binary.BigEndian, &p.Length)\n\terr = binary.Read(reader, binary.BigEndian, &p.Timestamp)\n\terr = binary.Read(reader, binary.BigEndian, &p.HostnameLength)\n\tp.Hostname = make([]byte, p.HostnameLength)\n\terr = binary.Read(reader, binary.BigEndian, &p.Hostname)\n\terr = binary.Read(reader, binary.BigEndian, &p.TagLength)\n\tp.Tag = make([]byte, p.TagLength)\n\terr = binary.Read(reader, binary.BigEndian, &p.Tag)\n\tp.Msg = make([]byte, p.Length-8-2-p.HostnameLength-2-p.TagLength)\n\terr = binary.Read(reader, binary.BigEndian, &p.Msg)\n\treturn err\n}\n```\n\n由于主机名、标签这种数据是不固定长度的，所以需要两个字节来标识数据长度，否则读取的时候只知道一个总的数据长度是无法区分主机名、标签名、日志数据的。\n\n## 数据包的粘包问题解决\n\n上文只是解决了`编码/解码`问题，前提是收到的数据包没有产生粘包问题，解决粘包就是要正确分割字节流中的数据。一般有以下做法：\n1. 定长分隔(每个数据包最大为该长度) 缺点是数据不足时会浪费传输资源\n2. 特定字符分隔(如\\r\\n) 缺点是如果正文中有\\r\\n就会导致问题\n3. 在数据包中添加长度字段(本文采用的)\n\ngolang提供了`bufio.Scanner`来解决粘包问题。\n\n```go\nscanner := bufio.NewScanner(reader) // reader为实现了io.Reader接口的对象，如net.Conn\nscanner.Split(func(data []byte, atEOF bool) (advance int, token []byte, err error) {\n\tif !atEOF && data[0] == 'V' { // 由于我们定义的数据包头最开始为两个字节的版本号，所以只有以V开头的数据包才处理\n\t\tif len(data) > 4 { // 如果收到的数据>4个字节(2字节版本号+2字节数据包长度)\n\t\t\tlength := int16(0)\n\t\t\tbinary.Read(bytes.NewReader(data[2:4]), binary.BigEndian, &length) // 读取数据包第3-4字节(int16)=>数据部分长度\n\t\t\tif int(length)+4 <= len(data) { // 如果读取到的数据正文长度+2字节版本号+2字节数据长度不超过读到的数据(实际上就是成功完整的解析出了一个包)\n\t\t\t\treturn int(length) + 4, data[:int(length)+4], nil\n\t\t\t}\n\t\t}\n\t}\n\treturn\n})\n// 打印接收到的数据包\nfor scanner.Scan() {\n\tscannedPack := new(Package)\n\tscannedPack.Unpack(bytes.NewReader(scanner.Bytes()))\n\tlog.Println(scannedPack)\n}\n```\n\n本文的核心就在于`scanner.Split`方法，该方法用来解析TCP数据包\n\n## 完整源码\n\n```go\npackage main\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\t\"time\"\n)\n\ntype Package struct {\n\tVersion        [2]byte // 协议版本\n\tLength         int16   // 数据部分长度\n\tTimestamp      int64   // 时间戳\n\tHostnameLength int16   // 主机名长度\n\tHostname       []byte  // 主机名\n\tTagLength      int16   // Tag长度\n\tTag            []byte  // Tag\n\tMsg            []byte  // 数据部分长度\n}\n\nfunc (p *Package) Pack(writer io.Writer) error {\n\tvar err error\n\terr = binary.Write(writer, binary.BigEndian, &p.Version)\n\terr = binary.Write(writer, binary.BigEndian, &p.Length)\n\terr = binary.Write(writer, binary.BigEndian, &p.Timestamp)\n\terr = binary.Write(writer, binary.BigEndian, &p.HostnameLength)\n\terr = binary.Write(writer, binary.BigEndian, &p.Hostname)\n\terr = binary.Write(writer, binary.BigEndian, &p.TagLength)\n\terr = binary.Write(writer, binary.BigEndian, &p.Tag)\n\terr = binary.Write(writer, binary.BigEndian, &p.Msg)\n\treturn err\n}\nfunc (p *Package) Unpack(reader io.Reader) error {\n\tvar err error\n\terr = binary.Read(reader, binary.BigEndian, &p.Version)\n\terr = binary.Read(reader, binary.BigEndian, &p.Length)\n\terr = binary.Read(reader, binary.BigEndian, &p.Timestamp)\n\terr = binary.Read(reader, binary.BigEndian, &p.HostnameLength)\n\tp.Hostname = make([]byte, p.HostnameLength)\n\terr = binary.Read(reader, binary.BigEndian, &p.Hostname)\n\terr = binary.Read(reader, binary.BigEndian, &p.TagLength)\n\tp.Tag = make([]byte, p.TagLength)\n\terr = binary.Read(reader, binary.BigEndian, &p.Tag)\n\tp.Msg = make([]byte, p.Length-8-2-p.HostnameLength-2-p.TagLength)\n\terr = binary.Read(reader, binary.BigEndian, &p.Msg)\n\treturn err\n}\n\nfunc (p *Package) String() string {\n\treturn fmt.Sprintf(\"version:%s length:%d timestamp:%d hostname:%s tag:%s msg:%s\",\n\t\tp.Version,\n\t\tp.Length,\n\t\tp.Timestamp,\n\t\tp.Hostname,\n\t\tp.Tag,\n\t\tp.Msg,\n\t)\n}\n\nfunc main() {\n\thostname, err := os.Hostname()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tpack := &Package{\n\t\tVersion:        [2]byte{'V', '1'},\n\t\tTimestamp:      time.Now().Unix(),\n\t\tHostnameLength: int16(len(hostname)),\n\t\tHostname:       []byte(hostname),\n\t\tTagLength:      4,\n\t\tTag:            []byte(\"demo\"),\n\t\tMsg:            []byte((\"现在时间是:\" + time.Now().Format(\"2006-01-02 15:04:05\"))),\n\t}\n\tpack.Length = 8 + 2 + pack.HostnameLength + 2 + pack.TagLength + int16(len(pack.Msg))\n\n\tbuf := new(bytes.Buffer)\n\t// 写入四次，模拟TCP粘包效果\n\tpack.Pack(buf)\n\tpack.Pack(buf)\n\tpack.Pack(buf)\n\tpack.Pack(buf)\n\t// scanner\n\tscanner := bufio.NewScanner(buf)\n\tscanner.Split(func(data []byte, atEOF bool) (advance int, token []byte, err error) {\n\t\tif !atEOF && data[0] == 'V' {\n\t\t\tif len(data) > 4 {\n\t\t\t\tlength := int16(0)\n\t\t\t\tbinary.Read(bytes.NewReader(data[2:4]), binary.BigEndian, &length)\n\t\t\t\tif int(length)+4 <= len(data) {\n\t\t\t\t\treturn int(length) + 4, data[:int(length)+4], nil\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn\n\t})\n\tfor scanner.Scan() {\n\t\tscannedPack := new(Package)\n\t\tscannedPack.Unpack(bytes.NewReader(scanner.Bytes()))\n\t\tlog.Println(scannedPack)\n\t}\n\tif err := scanner.Err(); err != nil {\n\t\tlog.Fatal(\"无效数据包\")\n\t}\n}\n```\n\n## 写在最后\n\ngolang作为一门强大的网络编程语言，实现自定义协议是非常重要的，实际上实现自定义协议也不是很难，以下几个步骤：\n1. 数据包编码\n2. 数据包解码\n3. 处理TCP粘包问题\n4. 断线重连(可以使用心跳实现)(非必须)","tags":["protocol"],"categories":["golang"]},{"title":"golang multipart上传文件到远端（如上传微信临时素材）","url":"%2F2018%2F03%2F01%2Fgolang-upload.html","content":"\n最近在开发一个关注之后通过客服消息推送一张海报给用户的功能，海报图片是本地生成好的，需要上传到微信临时素材之后通过客服消息推送给用户。\n上传文件需要`multipart/form-data`格式的表单，所以golang默认的http.POST方法是实现不了的。需要自行实现body参数逻辑。\n\n## 上传请求初始化\n\n```golang\n// 新建上传请求\nfunc NewUploadRequest(link string, params map[string]string, name, path string) (*http.Request, error) {\n\tfp, err := os.Open(path) // 打开文件句柄\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer fp.Close()\n\tbody := &bytes.Buffer{} // 初始化body参数\n\twriter := multipart.NewWriter(body) // 实例化multipart\n\tpart, err := writer.CreateFormFile(name, filepath.Base(path)) // 创建multipart 文件字段\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t_, err = io.Copy(part, fp) // 写入文件数据到multipart\n\tfor key, val := range params {\n\t\t_ = writer.WriteField(key, val) // 写入body中额外参数，比如七牛上传时需要提供token\n\t}\n\terr = writer.Close()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq, err := http.NewRequest(\"POST\", link, body) // 新建请求\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Set(\"Content-Type\", \"multipart/form-data\") // 设置请求头,!!!非常重要，否则远端无法识别请求\n\treturn req, nil\n}\n```\n\n## 上传流程\n\n```golang\nfunc (m *Task) upload(appid string) (string, error) {\n\tfilename, err := m.download() // 下载远端海报文件到本地路径\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\t// 获取accessToken\n\taccessToken, err := m.passport.GetAccessToken(appid)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tparams := &url.Values{\n\t\t\"access_token\": []string{accessToken},\n\t\t\"type\":         []string{\"image\"},\n\t}\n\treq, err := util.NewUploadRequest(\"https://api.weixin.qq.com/cgi-bin/media/upload?\"+params.Encode(), nil, \"media\", filename) // 上传到微信\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tresp, err := http.DefaultClient.Do(req)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer resp.Body.Close()\n\tret := make(map[string]interface{})\n\tif err := json.NewDecoder(resp.Body).Decode(&ret); err != nil {\n\t\treturn \"\", err\n\t}\n\tif mediaId, ok := ret[\"media_id\"]; ok {\n\t\treturn mediaId.(string), nil\n\t} else if errmsg, ok := ret[\"errmsg\"]; ok {\n\t\treturn \"\", errors.New(errmsg.(string))\n\t} else {\n\t\treturn \"\", errors.New(\"上传失败\")\n\t}\n}\n```","tags":["multipart"],"categories":["golang"]},{"title":"Docker部署golang应用时时区问题","url":"%2F2018%2F03%2F01%2Fgolang-docker-timezone.html","content":"\n目前golang用的基础镜像是`busybox`，由于golang交叉编译之后只有一个二进制文件，可以直接部署到容器中运行，容器镜像大小几乎等于二进制文件大小。\n\n## 带来的问题\n\n由于基础镜像太过精简，目前遇到的问题是将时间戳格式化为时间字符串时发现差了8个小时。\n\n## 尝试过的解决办法\n\n刚开始使用了Location时区相关API，但是部署到容器中发现直接报错了，因为容器中缺少相关的系统调用函数。代码如下：\n\n```golang\nloc, _ := time.LoadLocation(\"Asia/Shanghai\")\ntime.Now().In(loc).Format(\"2006-01-02 15:04:05\")\n```\n\n\n目前应用会部署到docker容器中，故处理办法比较原始，直接在Time对象上添加8个小时来解决时差问题。代码如下:\n\n```golang\ntime.Now().Add(time.Hour * 8).Format(\"2006年01月02日 15:04\"),\n```\n\n暂时解决了这个问题。","tags":["timezone"],"categories":["golang"]},{"title":"golang JSON编码时保留HTML标签","url":"%2F2018%2F03%2F01%2Fgolang-json-no-escape-html.html","content":"\ngolang默认编码JSON时会将HTML标签中的尖括号编码为`\\u003c`这种unicode字符。而最近在开发的微信客服消息推送就会出现以下结果\n\n```text\n\\u003ca href='https://www.example.com'\\u003e点击进入\\u003c/a\\u003e\n```\n\n查看golang的json包发现json编码器有个方法`SetEscapeHTML`方法，接收一个bool值来设置是否保留HTML标签。\n\n## 问题\n\njson的Encoder只能编码到实现了`io.Writer`接口的对象中去，而本例中需要编码到一个`[]byte`切片中。\n\n## 解决\n\n查找资料发现`bytes.Buffer`对象实现了`io.Writer`接口。所以最终代码如下：\n\n```golang\nfunc BuildJson(data map[string]interface{}) ([]byte, error) {\n    buf := bytes.NewBufferString(\"\")\n    encoder := json.NewEncoder(buf)\n\tencoder.SetEscapeHTML(false)\n\tif err := encoder.Encode(&data); err != nil {\n\t\treturn nil, err\n\t} else {\n\t\treturn buf.Bytes(), nil\n\t}\n}\n```\n\n经过测试，输出接口符合要求。","tags":["json"],"categories":["golang"]},{"title":"golang使用CSV导出大量数据","url":"%2F2018%2F02%2F28%2Fgolang-export-csv.html","content":"\n最近在做一个导出功能，最初是使用[https://github.com/tealeg/xlsx](https://github.com/tealeg/xlsx)做的，但是发现导出有个30W行的excel时，这玩意内存彪到700M+，后来发现只是导出数据为表格，并没有其他东西，于是打算使用CSV导出。\n\n## CSV格式简介\n\nCSV本质上是个文本文件，该文件有以下要求：\n\n1. 列之间用逗号分隔，行之间用换行分隔\n2. 单元格如果有逗号，引号之类的字符，该单元格需要使用双引号括起来\n3. 如果包含中文，需要使用GBK编码，否则会乱码\n\n## golang实现\n\n1. UTF8转GBK函数(需要 `go get golang.org/x/text/`)\n\n    ```go\n    func UTF82GBK(src string) (string, error) {\n\t    reader := transform.NewReader(strings.NewReader(src), simplifiedchinese.GBK.NewEncoder())\n\t    if buf, err := ioutil.ReadAll(reader); err != nil {\n\t\t    return \"\", err\n\t    } else {\n\t\t    return string(buf), nil\n\t    }\n    }\n    ```\n\n2. 导出代码\n\n    ```go\n    filename := \"test.csv\"\n    fp, err := os.Create(filename) // 创建文件句柄\n    if err != nil {\n        return nil, err\n    }\n    defer fp.Close()\n    columns := []string{\"姓名\", \"电话\", \"公司\", \"职位\", \"加入时间\"}\n    if line, err := util.UTF82GBK(strings.Join(columns, \",\")); err == nil { // 写入一行\n        fp.WriteString(line + \"\\n\")\n    }\n    ```\n\n\b其他语言也可以使用类似方法导出数据，只要满足CSV的几个条件即可。","tags":["csv"],"categories":["golang"]},{"title":"nodejs thrift多路复用客户端","url":"%2F2018%2F02%2F08%2Fnodejs-thrift-multiple-client.html","content":"\n[官网nodejs示例](http://thrift.apache.org/tutorial/nodejs)中只实现了服务端是单一service的情形，而对于服务端属于`多个服务复用一个连接地址`的例子却未实现。\n\n查看thrift的nodejs库源码发现实际上还是支持的。以下来展示调用单一服务和多个服务的区别。\n\n## 单一服务\n\n```javascript\nvar thrift = require('thrift');\nvar Calculator = require('./gen-nodejs/Calculator');\nvar ttypes = require('./gen-nodejs/tutorial_types');\nconst assert = require('assert');\n\nvar transport = thrift.TBufferedTransport;\nvar protocol = thrift.TBinaryProtocol;\n\nvar connection = thrift.createConnection(\"localhost\", 9090, {\n  transport : transport,\n  protocol : protocol\n});\nvar client = thrift.createClient(Calculator, connection);\n// 已经可以调用client方法\n```\n\n## 复用服务\n\n```javascript\nvar thrift = require('thrift');\nvar Calculator = require('./gen-nodejs/Calculator');\nvar ttypes = require('./gen-nodejs/tutorial_types');\nconst assert = require('assert');\n\nvar transport = thrift.TBufferedTransport;\nvar protocol = thrift.TBinaryProtocol;\n\nvar connection = thrift.createConnection(\"localhost\", 9090, {\n  transport : transport,\n  protocol : protocol\n});\nconst m = new thrift.Multiplexer(); // 关键\nconst client = m.createClient('calculator', Calculator, connection); // calculator为服务端声明的服务名称\n// 已经可以调用client方法\n```\n\n经过测试，以上代码能与golang实现的服务端正常通信。","tags":["thrift"],"categories":["nodejs"]},{"title":"golang通用连接池的实现","url":"%2F2018%2F02%2F01%2Fgolang-generic-pool.html","content":"\ngolang的channel除了goroutine通信之外还有很多其他的功能，本文将实现一种基于channel的通用连接池。\n\n## 何为通用？\n\n连接池的实现不依赖具体的实例，而依赖某个接口，本文的连接池选用的是`io.Closer`接口，只要是实现了该接口的对象都可以被池管理。\n当然，你可以实现基于`interface{}`的连接池，这样任何对象都可以被管理。\n\n## 实现原理\n\n将连接句柄存入channel中，由于缓存channel的特性，获取连接时如果池中有连接，将直接返回，如果池中没有连接，将阻塞或者新建连接（没超过最大限制的情况下）。\n由于面向接口编程，所有创建连接的逻辑是不清楚的，这里需要传入一个函数，该函数返回一个`io.Closer`对象。\n\n## 实现\n\n由于并发问题，在需要操作池中互斥数据的时候需要加锁。\n\n```go\npackage pool\n\nimport (\n\t\"errors\"\n\t\"io\"\n\t\"sync\"\n\t\"time\"\n)\n\nvar (\n\tErrInvalidConfig = errors.New(\"invalid pool config\")\n\tErrPoolClosed    = errors.New(\"pool closed\")\n)\n\ntype factory func() (io.Closer, error)\n\ntype Pool interface {\n\tAcquire() (io.Closer, error) // 获取资源\n\tRelease(io.Closer) error     // 释放资源\n\tClose(io.Closer) error       // 关闭资源\n\tShutdown() error             // 关闭池\n}\n\ntype GenericPool struct {\n\tsync.Mutex\n\tpool        chan io.Closer\n\tmaxOpen     int  // 池中最大资源数\n\tnumOpen     int  // 当前池中资源数\n\tminOpen     int  // 池中最少资源数\n\tclosed      bool // 池是否已关闭\n\tmaxLifetime time.Duration\n\tfactory     factory // 创建连接的方法\n}\n\nfunc NewGenericPool(minOpen, maxOpen int, maxLifetime time.Duration, factory factory) (*GenericPool, error) {\n\tif maxOpen <= 0 || minOpen > maxOpen {\n\t\treturn nil, ErrInvalidConfig\n\t}\n\tp := &GenericPool{\n\t\tmaxOpen:     maxOpen,\n\t\tminOpen:     minOpen,\n\t\tmaxLifetime: maxLifetime,\n\t\tfactory:     factory,\n\t\tpool:        make(chan io.Closer, maxOpen),\n\t}\n\n\tfor i := 0; i < minOpen; i++ {\n\t\tcloser, err := factory()\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tp.numOpen++\n\t\tp.pool <- closer\n\t}\n\treturn p, nil\n}\n\nfunc (p *GenericPool) Acquire() (io.Closer, error) {\n\tif p.closed {\n\t\treturn nil, ErrPoolClosed\n\t}\n\tfor {\n\t\tcloser, err := p.getOrCreate()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\t// todo maxLifttime处理\n\t\treturn closer, nil\n\t}\n}\n\nfunc (p *GenericPool) getOrCreate() (io.Closer, error) {\n\tselect {\n\tcase closer := <-p.pool:\n\t\treturn closer, nil\n\tdefault:\n\t}\n\tp.Lock()\n\tif p.numOpen >= p.maxOpen {\n\t\tcloser := <-p.pool\n\t\tp.Unlock()\n\t\treturn closer, nil\n\t}\n\t// 新建连接\n\tcloser, err := p.factory()\n\tif err != nil {\n\t\tp.Unlock()\n\t\treturn nil, err\n\t}\n\tp.numOpen++\n\tp.Unlock()\n\treturn closer, nil\n}\n\n// 释放单个资源到连接池\nfunc (p *GenericPool) Release(closer io.Closer) error {\n\tif p.closed {\n\t\treturn ErrPoolClosed\n\t}\n\tp.Lock()\n\tp.pool <- closer\n\tp.Unlock()\n\treturn nil\n}\n\n// 关闭单个资源\nfunc (p *GenericPool) Close(closer io.Closer) error {\n\tp.Lock()\n\tcloser.Close()\n\tp.numOpen--\n\tp.Unlock()\n\treturn nil\n}\n\n// 关闭连接池，释放所有资源\nfunc (p *GenericPool) Shutdown() error {\n\tif p.closed {\n\t\treturn ErrPoolClosed\n\t}\n\tp.Lock()\n\tclose(p.pool)\n\tfor closer := range p.pool {\n\t\tcloser.Close()\n\t\tp.numOpen--\n\t}\n\tp.closed = true\n\tp.Unlock()\n\treturn nil\n}\n```\n\n## 结论\n\n基于该连接池，可以管理所有`io.Closer`对象。比如`memcached`,`redis`等等，非常方便！","tags":["go"],"categories":["go"]},{"title":"golang限制协程数量","url":"%2F2018%2F01%2F31%2Fgoroutine-limit-demo.html","content":"\n## 为什么要限制协程数量\n\ngolang的go关键字并发实在是太简单，但是带来的问题是由于硬件和网络状况的限制，不受控制的增加协程是非常危险的做法，甚至有可能搞垮数据库之类的应用! 而并发控制在go中是非常常用的技巧，以此文来记录一下学习历程。\n\n## 原理\n\n由于channel的阻塞机制，通过设置缓冲channel的缓冲大小来控制同时执行的协程数量。\n\n## demo代码\n\n```go\npackage main\n\nimport (\n\t\"log\"\n\t\"time\"\n)\n\nfunc main() {\n\tstart := time.Now()\n\tch := make(chan int, 2)\n\tfor i := 0; i <= 10; i++ {\n\t\tch <- 1\n\t\tgo worker(i, ch)\n\t}\n\tclose(ch)\n\tlog.Println(\"complete\", time.Since(start).Seconds())\n}\n\n// 模拟耗时操作\nfunc worker(i int, ch chan int) {\n\tlog.Println(\"worker\", i)\n\ttime.Sleep(time.Second)\n\t<-ch\n```\n\n## 运行\n\n```bash\ngo run demo.ho\n```\n\n## 输出\n\n```text\n2018/01/31 22:24:49 worker 1\n2018/01/31 22:24:49 worker 0\n2018/01/31 22:24:50 worker 2\n2018/01/31 22:24:50 worker 3\n2018/01/31 22:24:51 worker 4\n2018/01/31 22:24:51 worker 5\n2018/01/31 22:24:52 worker 6\n2018/01/31 22:24:52 worker 7\n2018/01/31 22:24:53 worker 8\n2018/01/31 22:24:53 worker 9\n2018/01/31 22:24:54 worker 10\n2018/01/31 22:24:54 complete 5.01140112\n```\n\n## 结论\n\n可以看到日志的输出时间，每秒出现两个，正好等于我们`make`函数的大小，而总时间也是为`10/2`左右，证明限制起到了作用。\n\n虽然本文写起来很简单，但是包含的技巧可以说大型程序仍然会用到。正所谓“万丈高楼平地起”。","tags":["golang"]},{"title":"头脑王者辅助","url":"%2F2018%2F01%2F30%2Ftnwz.html","content":"\n# 头脑王者\n\n本项目仅作为学习`anyproxy`之用，请勿用于非法用途，否则后果自负\n\n## 功能\n\n+ [x] 题目爬取\n+ [x] 答题匹配(如果题库不存在，请自行答题，系统会在答题后把正确答案自动录入数据库)\n\n## 开始\n\n1. 安装mysql，新建数据库`tnwz`，建表语句\n    ```sql\n    CREATE TABLE tnwz.question\n    (\n        id int(11) PRIMARY KEY NOT NULL AUTO_INCREMENT,\n        question varchar(100),\n        a varchar(20),\n        b varchar(20),\n        c varchar(20),\n        d varchar(20),\n        answer int(11),\n        createdAt datetime NOT NULL,\n        updatedAt datetime NOT NULL\n    );\n    ```\n2. config.json为数据库配置 \n3. 安装`anyproxy` => `npm install anyproxy -g`\n4. 生成证书`anyproxy -i`\n5. 手机接入代理，代理地址`电脑IP:8001`\n\n## 题库获取\n\n1. 登录两个微信号获取到uid和token之后填入auth.json\n2. `node question-fetcher.js`,如果出现401，请重新登录\n\n## 排位系统\n\n1. `npm run fight`开启代理\n2. 手机接入代理\n3. 开始排位，终端会提示`开始匹配`，系统会将正确答案添加上`###`\n\n## 适用系统\n\n+ Android && iOS\n+ iOS11.3 已通过测试\n\n## 项目地址\n\n[https://github.com/xialeistudio/tnwz](https://github.com/xialeistudio/tnwz)","tags":["anyproxy"]},{"title":"golang可能导致内存泄漏的地方","url":"%2F2018%2F01%2F20%2Fgolang-memory-leak.html","content":"\n## 核心\n\ngolang能够GC是程序声明的变量，而一些外部资源是不可以GC掉的，比如`os.OpenFile`打开的文件句柄，`sql.Open`打开的数据库连接句柄等资源。\n\n## 开发中常用场景\n\n1. http请求时`resp.Body`，刚开始写golang的时候，如果会用`ioutil.readAll`去读取`resp.Body`时会加上`defer resp.Body.Close()`,后来有`json.NewDecoder().decode()`时没有加，以为会自动关闭，没想到还是太天真了。不管什么情况都需要`defer resp.Body.Close()`\n\n2. sql查询时`DB.Prepare`，数据库查询操作会得到一个`rows`的资源，这个一般都关闭了，但是运行一段时间之后发现有内存泄漏，因为只用到了sql查询，所以只有数据库操作代码可以排查，尽快调试发现`stmt`也有`Close`方法，加上`defer stmt.Close`之后，内存稳定了。\n","tags":["memory-leak"],"categories":["golang"]},{"title":"PHP实现“异步”","url":"%2F2018%2F01%2F20%2Fphp-async.html","content":"\n众所周知，PHP不使用多线程扩展的情况下是不支持异步的(不算curl之类)。今天无意中看到一个函数`fastcgi_finish_request`;\n这个方法是PHP5.3+开始提供。\n注释写的很清楚，有耗时操作的时候使用该函数可以尽早结束fastcgi处理过程，提高页面响应速度。\n\n## 代码说明\n\n```php\n<?php\necho 1;\nfastcgi_finish_request();\nsleep(3);\n?>\n```\n\n此时打开浏览器发现响应速度并没有受到`sleep`函数的影响，基于此点，可以在适当的时候使用该函数以提升用户体验!\n\n## 注意事项\n\nPHP需要运行在fpm模式下才可以使用本函数。\n","tags":["async"],"categories":["php"]},{"title":"微信H5点击跳转到关注页","url":"%2F2017%2F11%2F25%2Fwechat-web-subscribe.html","content":"# 背景\n微信诱导关注接口在早两年已经被微信关停，但是一般的H5目的都是要关注公众号。\n目前用的多的方法是用公众号发表一篇文章，文章里面一般是一个GIF的箭头图片指向公众号关注。\n这种方法有点取巧。\n\n今天要介绍的是另一种方法，感觉应该不会被微信封号。\n# 起因\n有个朋友在segmentfault上发了一个链接出来，微信打开可以直接到关注页\n```\nhttps://mp.weixin.qq.com/mp/profile_ext?action=home&__biz=MzUzMDM3MjMyNQ==#wechat_redirect\n```\n条件反射发现`MzUzMDM3MjMyNQ==`是Base64编码后的参数，解码后是一段数字，然后我改了下数字，重新编码，再发送到微信，发现可以打开另外一个公众号的关注页\n```\nhttps://mp.weixin.qq.com/mp/profile_ext?action=home&__biz=MzUzMDM3MjMyNA==#wechat_redirect\n```\n所以只要知道那个公众号数字就可以构造链接进行关注，想着这种ID一般在公众平台有，果然被我找到了。\n\n# 步骤\n1. 登录公众平台后台\n2. 点击右上角的公众号，来到公众号信息页面\n3. 查看公众号信息页面的源代码，在顶上找到以下代码\n    ```javascript\n    window.wx={\n    uin:\"xxxx\"||\"0\"\n    };\n    ```\n4. `xxxx` 就是你的公众号数字ID\n5. 将第4步找到的ID进行base64编码\n6. 构造如下链接\n    ```\n    https://mp.weixin.qq.com/mp/profile_ext?action=home&__biz=第5步的结果#wechat_redirect\n    ```\n7. 发送到微信之后即可。\n\n# 反思\n从打开的链接看页面还是蛮正式的，可能不是私有接口，但是微信文档中没说过这种方式，故使用本方式带来的后果请自行负责！","tags":["微信"]},{"title":"从零开始打造自己的直播服务器-golang开发HTTP推流服务","url":"%2F2017%2F11%2F23%2Fgo-rtmp-http-publisher.html","content":"目前笔者只知道ffmpeg命令行推流到RTMP服务器，是没有HTTP接口的，像iOS和Android这种Native应用应该有RTMP SDK封装推流逻辑。但是像微信小程序这种录制音频只有原始**ArrayBuffer**的数据，则必须在服务端提供接口来进行推流。\n\n本文将基于golang标准库以及ffmpeg命令来实现。\n\n## 服务端原理\n1. 客户端上传base64编码后的音频数据\n2. 服务端接收后解码为**[]byte**\n3. 将**[]byte**写入本地文件\n4. golang调用ffmpeg命令将第3步写入的文件推流到RTMP服务端({% post_link nginx-rtmp-server 从零开始打造自己的直播服务器-Nginx安装 %})\n5. golang输出JSON响应，如果出错则返回错误JSON响应\n    ```json\n    {\n      \"errmsg\":\"ok\",\n      \"errcode\":0\n    }\n    ```\n\n## 开始开发\n由于采用了log4go日志库[https://github.com/alecthomas/log4go](https://github.com/alecthomas/log4go)，故需要先安装\n```bash\ngo get github.com/alecthomas/log4go\n```\n完整服务端源代码：\n```go\npackage main\n\nimport (\n\t\"github.com/alecthomas/log4go\"\n\t\"flag\"\n\t\"net/http\"\n\t\"time\"\n\t\"encoding/json\"\n\t\"io/ioutil\"\n\t\"encoding/base64\"\n\t\"os\"\n\t\"os/exec\"\n\t\"strings\"\n)\n\nvar (\n\trtmp            string // rtmp 服务端地址\n\tffmpeg          string // ffmpeg命令地址\n\tlisten          string // 监听地址\n\tuploadKey       string // 上传key\n\tuploadDirectory string // 本地上传目录\n\tstart           = time.Now()\n)\n\nconst (\n\tVERSION = \"1.0.0\"\n)\n\nfunc init() {\n\tflag.StringVar(&rtmp, \"rtmp\", \"rtmp://localhost:1935/hls\", \"rtmp upstream address\")\n\tflag.StringVar(&ffmpeg, \"ffmpeg\", \"ffmpeg\", \"ffmpeg executable\")\n\tflag.StringVar(&listen, \"listen\", \":8081\", \"http server address\")\n\tflag.StringVar(&uploadKey, \"key\", \"testkey\", \"http upload key\")\n\tflag.StringVar(&uploadDirectory, \"upload-directory\", \"upload\", \"local upload directory\")\n}\n\nfunc main() {\n\tflag.Parse()\n\tlog4go.LoadConfiguration(\"log4go.xml\")\n\tif rtmp == \"\" {\n\t\tpanic(\"rtmp upstream not set!\")\n\t}\n\t// 创建目录\n\tos.Mkdir(uploadDirectory, os.ModePerm)\n\tlog4go.Info(\"start ffmpeg-publisher, version %s\", VERSION)\n\tlog4go.Info(\"RTMP UpStream %s\", rtmp)\n\tlog4go.Info(\"HTTP Upload Directory %s\", uploadDirectory)\n\tlog4go.Info(\"HTTP Listen ON %s\", listen)\n\tlog4go.Info(\"HTTP Upload Key %s\", uploadKey)\n\n\thttp.HandleFunc(\"/\", handleIndex)\n\thttp.HandleFunc(\"/base64\", handleBase64Publish)\n\tpanic(http.ListenAndServe(listen, nil))\n}\n\nfunc sendResponse(errmsg string, statusCode int, w http.ResponseWriter) {\n\tw.Header().Set(\"Content-Type\", \"application/json;charset=utf-8\")\n\tif statusCode == 0 {\n\t\tstatusCode = 200\n\t}\n\tw.WriteHeader(statusCode)\n\tret := map[string]interface{}{\n\t\t\"errmsg\":  errmsg,\n\t\t\"errcode\": statusCode,\n\t}\n\tjson.NewEncoder(w).Encode(&ret)\n\tif statusCode == 500 {\n\t\tlog4go.Error(errmsg)\n\t}\n}\n\nfunc handleIndex(w http.ResponseWriter, _ *http.Request) {\n\tret := map[string]interface{}{\n\t\t\"name\":    \"ffpmeg-publisher\",\n\t\t\"version\": VERSION,\n\t\t\"uptime\":  time.Since(start).String(),\n\t}\n\tw.Header().Set(\"Content-Type\", \"application/json;charset=utf-8\")\n\tjson.NewEncoder(w).Encode(&ret)\n}\n\nfunc handleBase64Publish(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != \"POST\" {\n\t\tsendResponse(\"Method Not Allowed\", 405, w)\n\t\treturn\n\t}\n\t// 获取直播ID和key\n\tif err := r.ParseForm(); err != nil {\n\t\tsendResponse(err.Error(), 500, w)\n\t\treturn\n\t}\n\t// 检测直播Key\n\tif key := r.Form.Get(\"key\"); key != uploadKey {\n\t\tsendResponse(\"Forbidden\", 403, w)\n\t\treturn\n\t}\n\t// 检测直播ID\n\tid := r.Form.Get(\"id\")\n\tif id == \"\" {\n\t\tsendResponse(\"Bad Request\", 400, w)\n\t\treturn\n\t}\n\t// 读取base64\n\tbase64Buf, err := ioutil.ReadAll(r.Body)\n\tif err != nil {\n\t\tsendResponse(err.Error(), 500, w)\n\t\treturn\n\t}\n\tbuf, err := base64.StdEncoding.DecodeString(string(base64Buf))\n\tif err != nil {\n\t\tsendResponse(err.Error(), 500, w)\n\t\treturn\n\t}\n\tlog4go.Trace(\"live %s receive %d bytes\", id, len(buf))\n\tif err := publishVoice(buf, id); err != nil {\n\t\tsendResponse(err.Error(), 500, w)\n\t} else {\n\t\tsendResponse(\"ok\", 0, w)\n\t}\n}\n\n// 保存音频到临时文件目录,1个直播一个目录\nfunc saveVoice(buf []byte, id string) (string, error) {\n\tdirectory := uploadDirectory + \"/\" + id\n\tos.Mkdir(directory, os.ModePerm)\n\tname := time.Now().Format(\"2006-01-02-15-04-05\") + \".mp3\"\n\tfilename := directory + \"/\" + name\n\tlog4go.Trace(\"live %s save chunk %s\", id, filename)\n\terr := ioutil.WriteFile(filename, buf, os.ModePerm)\n\treturn filename, err\n}\n\n// 发布音频至rtmp\nfunc publishVoice(buf []byte, id string) error {\n\tmp3filename, err := saveVoice(buf, id)\n\tif err != nil {\n\t\tlog4go.Error(\"live %s %q\", id, err)\n\t\treturn err\n\t}\n\t// 执行系统命令\n\tcmd := exec.Command(ffmpeg, \"-i\", mp3filename, \"-acodec\", \"aac\", \"-f\", \"flv\", rtmp+\"/\"+id)\n\tlog4go.Trace(\"live %s execute %s\", id, strings.Join(cmd.Args, \" \"))\n\tcmd.Stderr = os.Stderr\n\tcmd.Stdout = os.Stdout\n\tif err := cmd.Run(); err != nil {\n\t\tlog4go.Error(\"live %s execute %q\", id, err)\n\t\treturn err\n\t}\n\treturn nil\n}\n```\n\n### github地址\n[https://github.com/xialeistudio/go-rtmp-http-publisher](https://github.com/xialeistudio/go-rtmp-http-publisher)","tags":["直播"]},{"title":"从零开始打造自己的直播服务器-Nginx安装","url":"%2F2017%2F11%2F23%2Fnginx-rtmp-server.html","content":"直播行业火了很长一段时间了，抛开那些复杂的实现，本系列将从零开始实现一个直播服务器。\n\n## 功能\n1. RTMP拉流(基于HLS)\n2. RTMP推流(基于ffmpeg)\n3. RTMP推流(基于HTTP)\n\n## 安装Nginx\n本文使用docker的ubuntu镜像作为种子机，非常干净!\n\n文章最后会放出我写的Dockerfile，不想折腾的朋友可以直接拿过去build一个自己的镜像\n\n以下操作在物理机ubuntu也可以进行。\n\n1. 更新软件仓库\n    ```bash\n    apt-get update\n    ```\n2. 安装必要软件    \n    ```bash\n    apt-get install git gcc make wget libpcre3 libpcre3-dev openssl libssl-dev -y -q\n    ```\n3. 下载并解压nginx源码\n    ```bash\n    cd /usr/local/src\n    wget http://nginx.org/download/nginx-1.12.2.tar.gz\n    tar xf nginx-1.12.2.tar.gz\n    ```\n4. 下载nginx-rtmp-module源码\n    ```bash\n    git clone https://github.com/arut/nginx-rtmp-module.git\n    ```\n5. 开始编译安装(其他参数不是必须的，故本文略去，只添加以下参数对于一个RTMP服务器已足够)\n    ```bash\n    cd /usr/local/src/nginx-1.12.2\n    ./configure --add-module=../nginx-rtmp-module --with-http_flv_module --with-http_mp4_module\n    make\n    make install\n    ```\n6. 修改配置文件 **/usr/local/nginx/nginx.conf**\n    ```\n    worker_processes  auto;\n    daemon off;\n    error_log  logs/error.log;\n    pid        logs/nginx.pid;\n    \n    events {\n        multi_accept on;\n        worker_connections  65535;\n        use epoll;\n    }\n    \n    \n    http {\n        include       mime.types;\n    \n        log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n                          '$status $body_bytes_sent \"$http_referer\" '\n                          '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n    \n        access_log  logs/access.log  main;\n    \n        sendfile        on;\n        #tcp_nopush     on;\n    \n        #keepalive_timeout  0;\n        keepalive_timeout  30;\n    \n        gzip  on;\n    \n        server {\n            listen       80;\n            server_name  localhost;\n          \n            location /stat {\n              rtmp_stat all;\n              rtmp_stat_stylesheet stat.xsl;\n            }\n    \n            location /stat.xsl {\n               root /usr/local/src/nginx-rtmp-module;\n            }\n            location /control {\n              rtmp_control all;\n            }\n            location /hls {\n              types {\n                application/vnd.apple.mpegurl m3u8;\n                video/mp2t ts;\n              }\n              root html;\n              expires -1;\n            }\n            location ~\\.flv {\n              flv;\n            }\n            location ~\\.mp4 {\n              mp4;\n            }\n        }  \n    }\n    \n    rtmp {\n      server {\n        listen 1935;\n        chunk_size 4096;\n        application hls {\n          allow publish 127.0.0.1;\n          live on;\n          hls on;\n          hls_path /usr/local/nginx/html/hls;\n          hls_fragment 5s;\n        }\n      }\n    }\n    ```\n    nginx在docker运行需要关闭daemon选项.\n    **rtmp->server->application**为具体的直播应用,**hls**是我的直播应用名称，可以根据实际情况修改。\n7. 启动服务器\n    ```bash\n    /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf\n    ```\n    \n## 安装ffmpeg\n```bash\napt-get install ffmpeg\n```\n\n## 推流测试\n### 推流地址\n```\nrtmp://localhost:1935/hls/demo\n```\n**hls**为上面配置的**application**名称，**demo**是直播名称，客户端使用**http://localhost/hls/demo.m3u8**进行播放\n\n### 视频推流\n```bash\nffmpeg -re -i a.mp4 -vcodec copy -f flv rtmp://localhost:1935/hls/demo\n```\nweb中播放\n```html\n<video src=\"http://localhost/hls/demo.m3u8\" controls></video>\n```\n\n### 音频推流\n```bash\nffmpeg -re -i a.mp3 -acodec aac -f flv rtmp://localhost:1935/hls/demo\n```\nweb中播放\n```html\n<audio src=\"http://localhost/hls/demo.m3u8\" controls></audio>\n```\n\n### 推流与播放地址说明\n1. 假设nginx配置**http端口**为**80**,**http目录为hls**,**rtmp端口**为**1935**,**application**名称为**hls**,需要播放的直播名称为**demo**\n2. 推流地址**rtmp://localhost:1935/hls/demo**\n3. 播放地址**http://localhost/hls/demo.m3u8**\n\n### 重要说明\n如果没有直播推流，nginx是不会产生m3u8文件的，这点需要注意!\n\n### Docker镜像地址\n[https://github.com/xialeistudio/docker-nginx-rtmp](https://github.com/xialeistudio/docker-nginx-rtmp)","tags":["直播"]},{"title":"log4go尝鲜","url":"%2F2017%2F11%2F21%2Flog4go-get-started.html","content":"# 序言\n日志系统对于软件是必不可少的，可以帮助我们记录关键信息，后期处理问题的时候会很方便。业界有很多出名的日志库，log4日志库相信每个人都不陌生，像log4j之于Java，log4php之于PHP等等。其实golang也有很多的log4实现，本文要使用的是**alecthomas**实现的版本。\n\n# 项目地址\n[https://github.com/alecthomas/log4go](https://github.com/alecthomas/log4go)\n\n# 安装\n```bash\ngo get github.com/alecthomas/log4go\n```\n\n# 使用代码配置\n1. 新建golang项目\n2. 在项目根目录下新建*main.go*文件，代码如下\n\n    ```go\n    package main\n    import \"github.com/alecthomas/log4go\"\n    \n    func main() {\n        defer log4go.Close()\n        log4go.AddFilter(\"stdout\", log4go.DEBUG, log4go.NewConsoleLogWriter()) // DEBUG级别+打印到控制台\n        log4go.AddFilter(\"file\", log4go.INFO, log4go.NewFileLogWriter(\"test.log\", true)) // INFO级别+输出到文件，并开启rotate\n        log4go.Debug(\"这是DEBUG日志\") // 输出测试\n        log4go.Info(\"这是INFO日志\") // 输出测试\n    }\n    ```\n    *如果程序是守护进程，此处不用调用log4go.Close，因为log4go使用协程异步写入日志，此处可以调用log4go.Close也可以Sleep来实现写入，下文会有Sleep测试*\n3.  `go run main.go`\n4. 此时可以看到终端输出，还可以发现项目目录下生成了*test.log*文件\n\n    ```\n    [17:11:35 CST 2017/11/21] [DEBG] (main.main:9) 这是DEBUG日志\n    [17:11:35 CST 2017/11/21] [INFO] (main.main:10) 这是INFO日志\n    ```\n\n5. 重新执行时可以发现**test.log**被rotate到了**test.log.1**\n\n# 使用配置文件\nlog4go支持使用xml来作为配置文件\n1. 在项目根目录新建**log4go.xml**\n\n    ```xml\n    <logging>\n        <filter enabled=\"true\">\n            <tag>stdout</tag>\n            <type>console</type>\n            <level>DEBUG</level>\n        </filter>\n        <filter enabled=\"true\">\n            <tag>file</tag>\n            <type>file</type>\n            <level>INFO</level>\n            <property name=\"filename\">test.log</property>\n            <property name=\"rotate\">true</property>\n            <property name=\"maxlines\">2</property>\n            <property name=\"daily\">true</property>\n        </filter>\n    </logging>\n    ```\n2. 添加了**console**和**file**两个filter，跟代码添加其实是一样的，不同的是xml的可配置性更高。具体配置参数需要查看log4go对应的go源文件\n3. 修改**main.go**\n\n    ```go\n    package main\n    \n    import (\n        \"github.com/alecthomas/log4go\"\n        \"time\"\n    )\n    \n    func main() {\n        log4go.LoadConfiguration(\"log4go.xml\")\n        log4go.Debug(\"这是DEBUG日志\")\n        log4go.Info(\"这是INFO日志\")\n        time.Sleep(time.Second)\n    }\n    ```\n4. 运行程序，终端依旧正确输出，同时也会生成*test.log*\n\n# 后记\nlog4go良好的设计带来了简洁又强大的使用体验，更多的使用细节以及更多的logger类型等待读者去发掘与实现，本文只做一个简单的介绍，即便如此也应该能够应付大部分场景了。","tags":["go"]},{"title":"golang实现TLV编码","url":"%2F2017%2F11%2F17%2Fgo-tlv.html","content":"## TLV编码基础\n\n{% post_link node-tlv Tlv编码在NodeJs中的应用 %}\n\n## golang实现\n主要使用bytes和binary包中的相关函数\n\n### 编码\n\n```go\nfunc Encode(tag int32, data string) ([]byte, error) {\n\tbuf := new(bytes.Buffer)\n\t// 写入TAG\n\tif err := binary.Write(buf, binary.BigEndian, tag); err != nil {\n\t\treturn nil, err\n\t}\n\tdataBuf := []byte(data)\n\t// 写入length\n\tif err := binary.Write(buf, binary.BigEndian, int32(len(dataBuf))); err != nil {\n\t\treturn nil, err\n\t}\n\t// 写入数据\n\tif err := binary.Write(buf, binary.BigEndian, dataBuf); err != nil {\n\t\treturn nil, err\n\t}\n\treturn buf.Bytes(), nil\n}\n```\n\n## 解码\n```go\nfunc Decode(b []byte) (int32, string, error) {\n\tbuf := bytes.NewBuffer(b)\n\tvar tag, length int32\n\t// 读取tag\n\tif err := binary.Read(buf, binary.BigEndian, &tag); err != nil {\n\t\treturn 0, \"\", err\n\t}\n\t// 读取length\n\tif err := binary.Read(buf, binary.BigEndian, &length); err != nil {\n\t\treturn 0, \"\", err\n\t}\n\t// 读取数据\n\tdataBuf := make([]byte, length)\n\tif err := binary.Read(buf, binary.BigEndian, &dataBuf); err != nil {\n\t\treturn 0, \"\", err\n\t}\n\treturn tag, string(dataBuf), nil\n}\n```\n\n由于TLV编码容易上手加上golang完善的API，实现TLV编码也不算太曲折。","tags":["go"]},{"title":"Tlv编码在NodeJs中的应用","url":"%2F2017%2F11%2F17%2Fnode-tlv.html","content":"最近在接入腾讯云的天御业务安全系统时接触到了TLV编码协议，好在TLV协议理解起来比较简单。故简要介绍一下该编码。\n## TLV编码是什么？\n```\nTLV是一种编码格式，编码如下：\n[1-4字节] TYPE\n[5-8字节] Value的Length\n[9字节+] Value数据\n```\n本文只探讨无嵌套数据的情况。NodeJs操作二进制数据主要依赖于**Buffer**\n\n## 编码\n1. 编码Ascii数据，由于ascii编码的数据，一个字节就是一个字符，所以比较简单\n```\nTYPE: 1\nValue: test\n```\n2. 根据编码规则，可以得出以下数据组装格式\n```\n[1-4字节] 00 00 00 01\n[5-8字节] 00 00 00 04\n[9-12字节] 74 65 73 74 \n// 74 对应字符*t*ascii编码*116*的16进制形式，其他以此类推\n```\n3. javascript代码\n```javascript\n// buf总长度为4字节TYPE+4字节VALUE长度+test的字节数为12\nconst buf = Buffer.alloc(12);\n// 写入TYPE\nbuf.writeIntBE(1, 0, 4);\n// 写入LENGTH\nbuf.writeIntBE('test'.length, 4, 4);\n// 写入test\nbuf.write('test', 8, 'test'.length);\n// 此时buf就是编码结果，由于是二进制的，如果走TCP协议的话已经可以了，但是腾讯云要求base64编码。所以最终结果为\nbuf.toString('base64');\n```\n4. 使用NodeJs交互式环境测试\n```\n➜  ~ node\n> const buf = Buffer.alloc(12);\nundefined\n> buf\n<Buffer 00 00 00 00 00 00 00 00 00 00 00 00>\n> buf.writeIntBE(1,0,4)\n4\n> buf.writeIntBE(4,4,4)\n8\n> buf.write('test',8,4)\n4\n> buf\n<Buffer 00 00 00 01 00 00 00 04 74 65 73 74>\n> buf.toString()\n'\\u0000\\u0000\\u0000\\u0001\\u0000\\u0000\\u0000\\u0004test'\n> buf.toString('base64')\n'AAAAAQAAAAR0ZXN0'\n> \n```\n\n## 非Ascii编码问题\n如果发送的数据是Ascii编码表之外的数据，就会用到多字节编码，此时以上方法会有问题。\n得意与Buffer完善的API，*Buffer.from*方法可以接收一个字符串和一个编码得到一个Buffer数组。\n\n上例可以改为使用*Buffer.from*的版本:\n\n```javascript\nconst valueBuf = Buffer.from(value, 'utf8');\nconst buf = Buffer.alloc(8 + valueBuf.length);\nbuf.writeIntBE(type, 0, 4);\nbuf.writeIntBE(valueBuf.length, 4, 4);\nbuf.write(value, 8, valueBuf.length);\nbuf.toString('base64');\n```\n由于value使用的utf8编码，所以utf8编码表中的数据该方法都可以成功编码，经过腾讯云接口调用测试也是OK的。\n\n## 解码\n说到编码就会有解码。解码是编码的逆运算，根据一样的规则还原数据而已。\n1. javascript代码\n```javascript\n    // 假设str为base64编码之后Tlv数据\n    const buf = new Buffer(str, 'base64'); // 还原为Buffer\n    // 读取TYPE\n    const type = buf.readIntBE(0, 4)\n    // 读取VALUE长度\n    const length = buf.readIntBE(4, 4)\n    // 读取VALUE\n    const valueBuf = Buffer.alloc(length);\n    // 写入VALUE\n    buf.copy(valueBuf, 0, 8, 8 + length);\n    // 得到原始数据\n    valueBuf.toString('utf8');\n```\n2. 使用NodeJs交互式环境测试\n```\n➜  ~ node\n> const str = 'AAAAAQAAAAR0ZXN0';\nundefined\n> const buf = new Buffer(str, 'base64');\nundefined\n> const type = buf.readIntBE(0,4);\nundefined\n> const length = buf.readIntBE(4,4);\nundefined\n> const value = Buffer.alloc(length);\nundefined\n> valueOf\n[Function: valueOf]\n> value\n<Buffer 00 00 00 00>\n> buf.co\nbuf.constructor  \n\nbuf.copyWithin   \n\nbuf.compare      buf.copy         \n\n> buf.copy(value,0,8,8+length);\n4\n> value.to\nvalue.toLocaleString  value.toString        \n\nvalue.toJSON          \n\n> value.toString()\n'test'\n> \n```\n\n## 腾讯云天御业务安全系统\nsocket.io中如果需要接入该系统进行垃圾发言的过滤时，可以使用我开发的SDK\n[tencent-cloud-defend](https://www.npmjs.com/package/tencent-cloud-defend)\n","tags":["tlv"]},{"title":"使用docker-composer部署nodejs应用","url":"%2F2017%2F11%2F01%2Fdocker-composer-nodejs.html","content":"## 新建Dockerfile\n在应用目录下新建**Dockerfile**\n```dockerfile\nFROM node:8\nWORKDIR /usr/src/app\nADD . /usr/src/app\nRUN npm install --registry=https://registry.npm.taobao.org\nUSER node\nEXPOSE 8080\n```\n8080 端口请根据实际情况调整。建议大于1024，否则使用**node**用户启动应用时可能权限不足\n\n## 新建docker-compose.yml\n在应用目录下新建**docker-compose.yml**\n```yaml\nversion: \"2\"\nservices:\n  jsconsole:\n    build: .\n    volumes:\n      - .:/usr/src/app\n      - /usr/src/app/node_modules\n    ports:\n      - \"127.0.0.1:8081:8080\"\n    command: \"npm start\"\n    restart: always\n```\n**127.0.0.1:8081**是**宿主机IP和端口**，我前端采用了**nginx**做反向代理。如果是直接提供公网服务的话把**127.0.0.1**去掉\n## 构建镜像\n在应用根目录下执行\n```bash\ndocker-compose build\n```\n## 构建并运行\n在应用根目录下执行**-d**是后台执行\n```bash\ndocker-compose up -d\n```\n","tags":["docker-composer"]},{"title":"php-imagick-字符间距问题","url":"%2F2017%2F10%2F17%2Fphp-imagick-text-spacing.html","content":"在用**php-imagick**扩展做图像合成的时候，有个地方需要改下文本间距，百度一下发现**setTextInterWordSpacing**有这个方法，但是测试发现不管传多少\n值都毫无作用。\n\n后面google查了一下，发现**setTextKerning**才是设置文本字符间距的函数。\n\n此外，还发现一个bug，mac下**roundCorners**函数不存在的问题，找了个把小时才发现这是imagick在mac上面的bug，先写在这里，等有空在研究下。","tags":["图像合成"]},{"title":"mac下php-imagick扩展library not loaded问题","url":"%2F2017%2F10%2F17%2Fmac-php-imagick-library-not-loaded.html","content":"最近在使用imagick开发图像合成功能，和往常一样，终端执行\n\n```\nbrew install php71-imagick\n```\n\n虽然homebrew提示我安装成功了，然而`php -m`的时候确提示**php-imagick模块无法加载**。\n\ngoogle发现很多使用homebrew的人都遇到了问题，解决方法是**使用源码编译imagick**扩展，当然有个Homebrew倒是不用自己输入很长串的编译命令。\n\n终端执行\n\n```\nbrew reinstall -s php71-imagick\n```\n\n**-s**代表源码编译。"},{"title":"yii2关闭csrf校验和cookie校验","url":"%2F2017%2F10%2F17%2Fyii2-close-csrf-validation-cookie-validatetion.html","content":"# 重要提示\n```\n关闭该选项会导致应用安全性收到影响！\n```\n\n# 问题出现\n1. 开发API的时候发现POST请求老是不能通过验证，直接把报错文案放到项目中去搜索发现**yii\\web\\Request**中有**enableCsrfValidation**。\n2. 其他应用设置的cookie，抓包的时候可以看到请求中有cookie，但是yii2读取不到。\n\n# 源码解析\n找到**yii\\web\\Request**文件，看到\n```php\n/**\n * @var bool whether to enable CSRF (Cross-Site Request Forgery) validation. Defaults to true.\n */\npublic $enableCsrfValidation = true;\n/**\n * @var bool whether cookies should be validated to ensure they are not tampered. Defaults to true.\n */\npublic $enableCookieValidation = true;\n```\n发现是这里有问题，基于**yii2一切都是组件的思想**，去修改组件配置即可。\n\n# 修正\n编辑**config/web.php的components节**\n```php\n'request'      => [\n    'cookieValidationKey'    => 'xxxx',\n    'enableCookieValidation' => false,\n    'enableCsrfValidation'   => false,\n    ],\n],\n```","tags":["csrf"]},{"title":"koa-cooke使用maxAge代替expires来设置过期时间","url":"%2F2017%2F10%2F17%2Fkoa-cookie-use-maxage.html","content":"# expires\n原来设置cookie使用的以下代码\n\n```javascript\nconst cookieOptions = {\n  expires: moment().add(6,'day').toDate(),\n};\n```\n\n但是查看network的时候，cookie虽然设置了，但是过期时间比现在还早，导致一设置就过期，所以expires貌似没作用。\n\n# maxage\n查看对应的typescript定义文件**index.d.ts**发现还有一个**maxAge**选项也可以用来控制cookie过期时间\n```javascript\n/**\n * a number representing the milliseconds from Date.now() for expiry\n */\nmaxAge?: number;\n```\n\n这个参数更简单，**基于当前时间的毫秒数**，使用以下代码测试之后，发现过期时间跟预期一致**一个星期**：\n\n```javascript\nconst cookieOptions = {\n  maxAge: 3600 * 24 * 7 * 1000,\n};\n```","tags":["koa-cookie"]},{"title":"ios新版本代理设置问题","url":"%2F2017%2F10%2F16%2Fios-proxy-certificate-setting.html","content":"# 背景\n系统是iOS11，电脑端用的charles代理，目前需要查看一些https网站返回的数据，还是使用老方法把charles的根证书设为信任，手机也打开**chls.pro/ssl**把证书添加到系统了。\n但是抓包的时候依旧无法访问，safari直接提示“该网站提供的证书不可信任”，查看详情发现charles证书虽然安装，但是没生效。\n\n# 解决方法\n可能是iOS加强了安全性以及用户体验，往常的时候一旦我们加入证书，除非卸载，该证书是一直生效的（排除掉被吊销或者过期情况），而iOS11在**设置-通用-关于手机-证书信任设置**中可以方便开关证书。\n之前在iOS10.3也出现过问题，解决方法应该也是一致的。","tags":["proxy"]},{"title":"Servlet中print-writer和outputstream编码问题","url":"%2F2017%2F10%2F16%2Fservlet-print-writer-outputstream-encoding.html","content":"有个项目需要使用java开发一个简单的web接口用来请求加密数据，但是servlet之前只随便用了一下，平时工作也是以**node**为主。\n# 问题\n问题大致是\"iso 88591 encoding之类的问题，稍微去google搜了一下，可能是搜的关键词不准确导致搜到的答案不理想，无意中看到有人讲writer和outputstream的问题。\n# 原因\ngoogle到PrintWriter和OutputStream的区别\n\n```\nPrintWriter是以字符为单位，对所有的信息进行处理，而ServletOutputStream仅对二进制的资料进行处理。 \n```\n\n而我输出的是UTF8格式的字符串，所以OutputStream并不认识。\n\n# 解决\n使用**PrintWriter**输出即可。","tags":["servlet"]},{"title":"excel-stream Unknown Encoding错误问题","url":"%2F2017%2F10%2F15%2Fexcel-stream-unknown-encoding.html","content":"项目上线有半年多了，一直没有出过问题，但是前几天升级过一次NodeJs到8.x的时候就出现过这个问题了。因为采用了消息队列，但是一到这里就挂，导致进程重复启动几百次。\n\n# 报错信息\n\n```\nexcel-stream/csv-stream/index.js 59 Buffer unknow encoding\n```\n\n# 问题排查\ngoogle了一下无果，后面发现反正源码反正自己有，倒不如自己改改，直接定位到相关代码即可。\n\n```javascript\nCSVStream.prototype.write = function(buffer,encoding){\n\tthis._encoding = encoding || this._encoding;\n\tif(this._ended) throw new Error('Cannot write after end has been called.');\n\tif(buffer) this._buffer = Buffer.concat([this._buffer, buffer], this._buffer.length + buffer.length);\n\tif(this._paused) return false;\n\tthis._parser.parse(this._buffer.toString(this._encoding));\n\tthis._buffer = new Buffer(0);\n\treturn !this._paused;\n}\n```\n\n报错具体行数是**this._parser.parse(this._buffer.toString(this._encoding));**，错误很明显了，提示encoding错误。\n\n那直接往上面找，发现**this._encoding = encoding || this._encoding**，这里就有可能传入的encoding导致了错误。\n\n# 问题解决\n这个项目已经3年没维护了，所以要修正问题的话，只能手动改了。\n\n修改办法如下\n\n```javascript\n\tthis._parser.parse(this._buffer.toString(this._encoding));\n```\n改为\n\n```javascript\n\tthis._parser.parse(this._buffer.toString());\n```\n\n重新运行之后没有发现问题。"},{"title":"从零开始向DefinitelyTyped贡献代码","url":"%2F2017%2F10%2F15%2Fcontributing-to-DefinitelyTyped-step-by-step.html","content":"\n# 什么是DefinitelyTyped?\n讲到DefinitelyTyped，我想做typescript开的人应该不会陌生，DefinitelyTyped是一个由typescript的发明者Microsoft维护的一个项目。\n# 为什么会有DefinitelyTyped?\ntypescript是基于declation的一门语言，declation这个东西有点像C语言的头文件，就是变量、函数等等需要事先声明才能通过typescript编辑。为了方便开发者，也为了快速推广typescript，官方维护的这个项目给npm常用的一些包都定义了declations文件。   \n既然是托管在github的OpenSource Project，那么只要是github的会员就可以提交PR（当然Merge与否还得看项目组成员）,由于社区的活跃使得该仓库越来越丰富。   \n很荣幸，我也提交了几个npm包的declations在上面。\n# 如何提交PR到DefinitelyTyped?\n很多时候会遇到自己使用的npm包比较冷门，而DefinitelyTyped上面又没有，这时候虽然可以在本地定义，但是能够发布到DefinitelyTyped方便大家也是极好的，毕竟要拥抱开源嘛！   \n官方的ReadMe中有`How can I contribute?`来告知开发者如何提交PR，但是需要英语基础，哈哈。\n# Step By Step\n## 环境搭建\n### fork 项目\n要提交PR的第一步是必须fork到自己的仓库，别人不会随便给你直接改，万一改挂了他们还得背锅.   \n登录github,打开项目地址[DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped)\n![fork](https://og5r5kasb.qnssl.com/upload/QQ20171015-024655.png)\nfork完毕后，你会拥有一个自己的仓库地址，本文中我的地址是[https://github.com/xialeistudio/DefinitelyTyped](https://github.com/xialeistudio/DefinitelyTyped)\n### clone 到本地\n我本地的项目地址是**~/WebstormProjects/DefinitelyTyped**   \n终端执行 `git clone https://github.com/xialeistudio/DefinitelyTyped`\n### 安装npm依赖\n终端执行 `cd ~/WebstormProjects/DefinitelyTyped && yarn`\n\n## SourceTree\n本文使用SourceTree配合git flow来进行项目管理。\n1. 下载soucetree [下载地址](https://www.sourcetreeapp.com)\n2. 安装sourcetree，期间需要登录。\n3. 用sourcetree打开刚才克隆的项目。\n![p1](https://og5r5kasb.qnssl.com/upload/QQ20171015-030606.png)\n4. 点击菜单栏【仓库】->【git-flow或hg flow】->【初始化仓库】\n\n## 开始开发\n本文将以[koa2-cors](https://www.npmjs.com/package/types/koa2-cors)为例提交PR。\n1. 使用sourcetree的git-flow创建feature\n![p2](https://og5r5kasb.qnssl.com/upload/QQ20171015-030911.png)\n2. 分支名称填写**koa2-cors**   \n![p3](https://og5r5kasb.qnssl.com/upload/QQ20171015-031005.png)\n3. 这时候已经可以编码了。我用的vscode，轻量，建议大家也用这个，webstorm打开这个项目就卡死了。\n4. 安装定义文件生成工具，终端执行**npm install -g dts-gen**\n5. 生成项目文件，终端执行**dts-gen --dt --name koa2-cors --template module**\n6. 这个时候在**types/koa2-cors**目录下就是我们需要编辑的文件了。如果编写定义文件不在本文范畴，有需要的朋友可以去tslang官网看看手册。\n7. 开始编辑**index.d.ts**，完整定义如下，记得改自己的个人信息:   \n    ```typescript\n    // Type definitions for koa2-cors 2.0\n    // Project: https://github.com/zadzbw/koa2-cors#readme\n    // Definitions by: xialeistudio <https://github.com/xialeistudio>\n    // Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n\n    import * as Koa from 'koa';\n\n    declare namespace cors {\n        interface Options {\n            origin?: any;\n            exposeHeaders?: string[];\n            maxAge?: number;\n            credentials?: boolean;\n            allowMethods?: string[];\n            allowHeaders?: string[];\n        }\n    }\n\n    declare function cors(options?: cors.Options): Koa.Middleware;\n\n    export = cors;\n    ```   \n8. 编写单元测试文件**koa2-cors-tests.ts**，测试就是写上样板代码即可，只要能通过编译就行。   \n    ```typescript\n    import * as Koa from 'koa';\n    import * as cors from 'koa2-cors';\n\n    const app = new Koa();\n    app.use(cors({\n        origin: function (ctx: Koa.Context) {\n            if (ctx.url === '/test') {\n                return false;\n            }\n            return '*';\n        },\n        exposeHeaders: ['WWW-Authenticate', 'Server-Authorization'],\n        maxAge: 5,\n        credentials: true,\n        allowMethods: ['GET', 'POST', 'DELETE'],\n        allowHeaders: ['Content-Type', 'Authorization', 'Accept'],\n    }));\n    app.listen(3000);\n    ```\n9. 启动单元测试，终端执行**npm run test**，如果没有报错，即可进行提交流程，否则要修好错误才能提交。很幸运，单元测试通过：   \n![p4](https://og5r5kasb.qnssl.com/upload/QQ20171015-032934.png)\n10. commit，终端执行**git add . && git commit -m \"add koa2-cors definition\"**\n11. 使用sourcetree创建PR   \n![p4](https://og5r5kasb.qnssl.com/upload/QQ20171015-033135.png)\n12. 点击**在网上创建拉取请求**   \n![p5](https://og5r5kasb.qnssl.com/upload/QQ20171015-033252.png)\n13. 此时会自动打开github网页进行PR操作   \n14. 编辑PR提交模板，这个根据实际情况编写即可，注意下方的**If xxx**，这个是不同提交类型需要填写的。本文是新增，所以选择**add**   \n![p6](https://og5r5kasb.qnssl.com/upload/QQ20171015-033524.png)\n15. 点击**Create Pull Request**，此时会进行**travis**自动化测试流程，如果有错误需要点进去看到错误信息之后修正，很不幸。我们的第一次提交失败：   \n![p7](https://og5r5kasb.qnssl.com/upload/QQ20171015-034009.png)\n16. 点击**Details**进行详细错误页面，找到**=== Error ===**   \n![p8](https://og5r5kasb.qnssl.com/upload/QQ20171015-034114.png)\n17. 可以发现我们错误是**\" Expected `\"strictFunctionTypes\": true` or `\"strictFunctionTypes\": false`**,这个是**tsconfig.json**导致的问题，感觉是个历史遗留问题，因为使用的是默认创建的模板，不过为了提交PR，还是要手动修复。   \n编辑**types/koa2-cors/tsconfig.json**，在**compilerOptions**下添加，代码如下：   \n    ```json\n    {\n        \"compilerOptions\": {\n            \"module\": \"commonjs\",\n            \"lib\": [\n                \"es6\"\n            ],\n            \"noImplicitAny\": true,\n            \"noImplicitThis\": true,\n            \"strictNullChecks\": true,\n            \"baseUrl\": \"../\",\n            \"strictFunctionTypes\": false,\n            \"typeRoots\": [\n                \"../\"\n            ],\n            \"types\": [],\n            \"noEmit\": true,\n            \"forceConsistentCasingInFileNames\": true\n        },\n        \"files\": [\n            \"index.d.ts\",\n            \"koa2-cors-tests.ts\"\n        ]\n    }\n    ```\n18. commit，终端执行**git add . && git commit -m \"strictFunctionTypes\" && git push**，不需要再创建PR了，当你在该分支PUSH的时候，远端会自动触发自动化测试任务。\n19. 成功通过测试后，就可以等待官方人员过来review了。一般来说都会通过并且合并到master中去。","categories":["typescript"]},{"title":"使用Docker来部署NodeJs应用","url":"%2F2017%2F10%2F10%2Fdocker-publish-nodejs.html","content":"\nDocker的环境无关性以及自动化特性实在是令人称赞，最近遇到的一个问题是，NodeJs使用8.x版本开发，但是线上服务器是7.x的，这时候又不能动线上的应用。\n于是想到了使用Docker来部署NodeJs，服务器是Ubuntu的。\n## 安装Docker\n```\napt install docker.io\n```\n## Dockerfile编写\n由于默认的dockhub速度非常慢导致下载镜像慢，而且镜像下来的Ubuntu apt源又是国外的，简直是慢上加慢，本文使用[daocloud.io的Ubuntu镜像](https://www.daocloud.io/)以及[阿里云的Ubuntu源](http://mirrors.aliyun.com/)\n\n```dockerfile\nFROM daocloud.io/library/ubuntu\nMAINTAINER xialeistudio<xialeistudio@gmail.com>\n\nENV PATH $PATH:/opt/node/bin\nENV PORT 80\nENV HOST 0.0.0.0\n# prepare\nADD sources.list /etc/apt/sources.list\nRUN apt update\nRUN apt install wget gcc python git -y\n# nodejs\nRUN wget https://npm.taobao.org/mirrors/node/latest-v8.x/node-v8.6.0-linux-x64.tar.gz\nRUN tar xf node-v8.6.0-linux-x64.tar.gz\nRUN mv node-v8.6.0-linux-x64 /opt/node\n# app\nRUN mkdir app\nADD . /root/app\nWORKDIR /root/app\nRUN /opt/node/bin/npm install --registry=https://registry.npm.taobao.org\n# start app\nENTRYPOINT [\"npm\",\"start\"]\n```\n指令解释一下\n1. 指定模板镜像\n2. 维护者信息，这是本人写的，所以署名为本人\n3. 环境变量定义\n4. 复制宿主机当前目录的sources.list到docker中的/etc/apt目录用来替换默认的Ubuntu源\n5. 更新apt并安装必要软件\n6. 从淘宝镜像站下载nodejs二进制版本\n7. 解压并移动到/opt/node目录\n8. 创建应用目录，并把宿主机当前文件夹下的所有文件拷贝到docker景象中\n9. 使用淘宝镜像安装npm包\n10. 启动APP\n\n## build镜像\n```\ndocker build -t demo .\n```\n运行完毕后就可以使用*docker images*查看镜像了\n\n## 启动容器\n```\ndocker run -d -p 127.0.0.1:7001:80 demo\n```\n这时候容器已经启动，并通过端口转发监听在宿主机的7001端口上，配合nginx做反向代理就可以部署一个公网应用了。\n不管你容器中部署何种版本的NodeJs都不会对宿主机造成影响，这点很重要。","categories":["docker"]},{"title":"Nginx alias和root指令","url":"%2F2017%2F09%2F14%2Fnginx-alias-root.html","content":"Nginx的root指令相信大家用的都挺多，用来指定document_root，但是如果是针对特定path的请求才启用的话，root指令显得不好用\n```\nlocation /web {\n    root /home/wwwroot/site1;\n}\n```\n访问 *http://demo.com/web/a.js*的时候,nginx会去查找*/home/wwwroot/site1/web/a.js*，一般就会404了。因为文件是放在site1目录下的。\n这时候就需要alias指令了。\n```\nlocation /web/{\n    alias /home/wwwroot/site1/;\n}\n```\n访问 *http://demo.com/web/a.js*的时候,nginx会去查找*/home/wwwroot/site1/a.js*。\n\n注意 alias location末尾斜杠以及alias的末尾斜杠","categories":["nginx"]},{"title":"使用pm2来保证Spring Boot应用稳定运行","url":"%2F2017%2F07%2F31%2Fspring-boot-pm2.html","content":"Spring Boot开发web应用就像开发普通的java程序一般简洁，因为其内嵌了web容易，启动的时候只需要一条命令`java -jar server.jar`即可，非常方便。\n但是由此而来的问题是万一应用挂了怎么办？\n\n别担心，有pm2进程管理工具可以帮到你。\n\n## PM2简介\npm2原先是nodejs应用的进程管理工具，不过其良好的设计以及扩展性可以手动执行执行进程。\n\n## PM2安装\n1. 安装NodeJs\n2. `npm install pm2 -g`\n\n## PM2基本命令\n+ pm2 list 查看所有被PM2管理的进程列表\n+ pm2 start xxx 启动一个应用\n+ pm2 stop xxx 停止一个应用\n+ pm2 restart xxx 重启一个应用\n+ pm2 describe xxx 查看应用详情\n+ pm2 startup, pm2 save 两条命令，用来保证服务器启动时,pm2管理的程序自动运行\n\n## Java程序处理\n在jar的同级目录新建应用启动配置文件，如`pm2.json`，内容如下：\n\n```json\n{\n    \"name\": \"my-server\",\n    \"script\": \"/usr/bin/java\",\n    \"args\": [\n        \"-jar\",\n        \"server.jar\"\n    ],\n    \"exec_interpreter\": \"\",\n    \"exec_mode\": \"fork\"\n}\n```\n说明如下：\n+ name 进程名称（显示在`pm2 list`命令中）\n+ script 执行进程名称，如果需要执行PHP脚本则填写php解释器的路径，本文为java\n+ args 传给执行进程的参数，多个参数以数组单元分割\n+ exec_interpreter NodeJs解析器，本文不适用\n+ exec_mode 执行模式[cluster|fork]这个针对NodeJs应用的配置，非NodeJs应用统一fork\n\n配置文件完成后，使用\n```\npm2 start pm2.json\n```\n即可看到应用被启动\n\n## 日志管理\n日志路径在`~/.pm2/logs`，`stdout`和`stderr`被分开存放，程序中的所有`stdout`和`stderr`都被收集方便查错。","tags":["pm2"],"categories":["spring boot"]},{"title":"Spring Boot JPA 返回json时排除Null字段","url":"%2F2017%2F07%2F31%2Fspring-boot-exclude-null.html","content":"Spring Boot在返回JSON的时候默认会返回null字段，这个对客户端一般没什么作用，还会增加服务器带宽压力。使用如下配置可以屏蔽。\n\n在pojo对象上添加注解\n\n```java\n@JsonInclude(JsonInclude.Include.NON_NULL)\nclass User {\n}\n```\n\n再使用`@ResponseBody`的时候就不会返回Null字段了。","tags":["jpa"],"categories":["spring boot"]},{"title":"移动端rem和PSD单位换算问题","url":"%2F2017%2F07%2F28%2Fmobile-rem.html","content":"\n设计图尺寸一般750宽度，而需要兼容640宽度手机的话，需要调整缩放比率，之前使用`写死viewport`的做法来实现，不过这个方法有点取巧，而且有些场景并不适用。\n本文用`标准的@media`来实现\n\n## rem定义\n```css\n@media screen and (max-width: 750px) {\n  html {\n    font-size: 30px;\n  }\n}\n\n@media screen and (min-width: 640px) and (max-width: 749px) {\n  html {\n    font-size: 25px;\n  }\n}\n\n@media screen and (min-width: 480px) and (max-width: 639px) {\n  html {\n    font-size: 20px;\n  }\n}\n\n@media screen and (min-width: 320px) and (max-width: 479px) {\n  html {\n    font-size: 15px;\n  }\n}\n```\n\n## 如何使用\n假设PSD中有个button的大小为`100px*40px`，那使用rem时CSS如下\n```css\nbutton {\n    width: 3.333rem;\n    height: 1.333rem;\n}\n```","tags":["rem"],"categories":["css3"]},{"title":"druid spring boot 统计SQL问题","url":"%2F2017%2F07%2F18%2Fspring-boot-druid-sql.html","content":"## spring-boot配置\n\n```\nspring.jpa.hibernate.ddl-auto=validate\nspring.datasource.type=com.alibaba.druid.pool.DruidDataSource\nspring.datasource.driver-class-name=com.mysql.jdbc.Driver\nspring.datasource.initialize=true\nspring.datasource.initialSize=5\nspring.datasource.minIdle=5\nspring.datasource.maxActive=10\nspring.datasource.maxWait=60000\nspring.datasource.timeBetweenEvictionRunsMillis=60000\nspring.datasource.minEvictableIdleTimeMillis=300000\nspring.datasource.validationQuery=SELECT 'x'\nspring.datasource.testWhileIdle=true\nspring.datasource.testOnBorrow=false\nspring.datasource.testOnReturn=false\nspring.datasource.poolPreparedStatements=false\nspring.datasource.maxPoolPreparedStatementPerConnectionSize=20\nspring.datasource.filters=stat,wall,slf4j\nspring.datasource.connectionProperties=druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000\nspring.datasource.useGlobalDataSourceStat=true\n```\n\n这个配置没有什么好说的，网上很多，可能关键在\n\n```\nspring.datasource.filters=stat,wall,slf4j\nspring.datasource.connectionProperties=druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000\nspring.datasource.useGlobalDataSourceStat=true\n```\n\n但是就算配置好这些后，返回`/druid`也不显示SQL统计。\n其实问题在于\n\n*系统默认使用的数据库连接池没有使用你的配置*，所以需要我们手动实例化`Bean`\n\n## kotlin代码\n```kotlin\n@SpringBootApplication\nopen class Application {\n    @Bean\n    @ConfigurationProperties(prefix = \"spring.datasource\")\n    open fun druidDataSource(): DataSource {\n        return DruidDataSource()\n    }\n\n```","tags":["druid"],"categories":["java"]},{"title":"使用RSA在PHP和NodeJs中进行加密数据通信","url":"%2F2017%2F06%2F24%2Frsa-in-node-php.html","content":"RSA算法是目前用的最多的非对称加密算法，文本将基于openssl在nodejs和php中进行加密数据通信。\n\n## 生成密钥对\n```bash\nopenssl\ngenrsa -out private.key 2048\nrsa -in private.key -pubout -out public.key\n```\n执行完命令后，可以在当前目录看到:\n+ public.key 公钥\n+ private.key 私钥\n\n## NodeJs服务器\n本文使用koa2来构建一个基于openssl加密方案的http服务器。\n源码使用typescript进行开发。\n### 安装依赖\n```bash\nnpm init -y\nnpm install typescript koa koa-router @types/node @types/koa @types/koa-router --save\n```\n最终的*package.json*内容如下：\n\n```json\n{\n  \"name\": \"openssl-demo\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"build\": \"tsc -w\",\n    \"start\": \"node index.js\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"dependencies\": {\n    \"@types/koa\": \"^2.0.39\",\n    \"@types/koa-router\": \"^7.0.22\",\n    \"@types/node\": \"^8.0.2\",\n    \"koa\": \"^2.3.0\",\n    \"koa-router\": \"^7.2.1\",\n    \"typescript\": \"^2.3.4\"\n  }\n}\n```\n### 开始编码*index.ts*:\n\n```typescript\nimport * as crypto from 'crypto';\nimport * as constants from 'constants';\nimport * as Koa from 'koa';\nimport * as KoaRouter from 'koa-router';\nimport * as fs from 'fs';\n\nclass Server {\n    app: Koa;\n\n    static bootstrap() {\n        return new Server();\n    }\n\n    constructor() {\n        this.app = new Koa();\n        this.route();\n        this.app.listen(8081, () => {\n            console.info('listen on 8081');\n        });\n    }\n\n    parsePostData(ctx): Promise<Buffer> {\n        return new Promise((resolve, reject) => {\n            try {\n                let postdata = Buffer.alloc(0);\n                ctx.req.addListener('data', (data) => {\n                    postdata = Buffer.concat([data]);\n                });\n                ctx.req.addListener(\"end\", function () {\n                    resolve(postdata);\n                })\n            } catch (err) {\n                reject(err)\n            }\n        })\n    }\n\n    private readFile(path): Promise<Buffer> {\n        return new Promise((resolve, reject) => fs.readFile(path, (e, data) => e ? reject(e) : resolve(data)));\n    }\n\n    private route() {\n        const router = new KoaRouter();\n        router.post('/', async (ctx: Koa.Context, next) => {\n            const encrypted = await this.parsePostData(ctx); // 接收到的经过base64编码后的加密数据\n            const key = await this.readFile(__dirname + '/private.key');//读取私钥\n            const pkey = key.toString();// 字符串形式的私钥\n            const data = crypto.privateDecrypt({key: pkey, padding: constants.RSA_PKCS1_PADDING}, new Buffer(encrypted.toString(), 'base64')); // 使用私钥解密Buffer\n            const json = JSON.parse(data.toString()); // 将解密后的信息解码为json对象\n            const msg = JSON.stringify({errcode: json.name === 'demo' ? 0 : 1, errmsg: json.name === 'demo' ? 'ok' : 'error'}); // 需要返回的明文数据\n            const e = crypto.privateEncrypt({key: pkey, padding: constants.RSA_PKCS1_PADDING}, new Buffer(msg)); // 使用私钥加密返回数据\n            ctx.body = e.toString('base64'); // 将buffer编码为base64字符串后返回\n        });\n        this.app\n            .use(router.routes())\n            .use(router.allowedMethods());\n    }\n}\n\nServer.bootstrap();\n```\n### 编译typescript\n```bash\nnpm run build\n```\n### 启动服务器\n```bash\nnpm run start\n```\n此时我们的服务器已经启动完成。\n\n## PHP客户端\n将2中的*公钥*复制到php项目下。\n本文使用`rmccue/requests`作为`http客户端`发起请求。\nindex.php关键代码如下:\n\n```php\n<?php\n$pubKey = openssl_pkey_get_public(file_get_contents(__DIR__ . '/public.key')); // 读取公钥\n$data = Json::encode(['name' => 'demo']); // 需要提交的明文数据\nopenssl_public_encrypt($data, $encryped, $pubKey); // 使用公钥加密明文数据\n$data = base64_encode($encryped); // 将加密后的数据进行base64编码\n$res = Requests::post('http://localhost:8081', [], $data); // 将base64数据提交到NodeJs\n$data = base64_decode($res->body);// 接收NodeJs私钥加密后的响应并进行base64解码\nopenssl_public_decrypt($data, $dd, $pubKey); // 使用公钥将密文解密\necho $dd; // 打印数据\n```\n\n## 执行正常请求\n```bash\nphp index.php\n```\n输出如下\n```json\n{\"errcode\":0,\"errmsg\":\"ok\"}\n```\n\n## 执行不正常请求\n将php中\n```php\n$data = Json::encode(['name' => 'demo']);\n```\n改为\n```php\n$data = Json::encode(['name' => 'demo1']);\n```\n发现收到的响应为\n```json\n{\"errcode\":1,\"errmsg\":\"error\"}\n```\n证明提交的数据不能被nodejs接受。\n\n## 后记\n本文简单使用了一下openssl相关功能函数，旨在起到一个抛砖引玉的作用，基于rsa算法可以开发出很多安全性很高的应用。","tags":["rsa"],"categories":["php"]},{"title":"nodejs unhandledRejection问题解决","url":"%2F2017%2F06%2F13%2Fnode-unhandledRejection.html","content":"今天在使用promise的时候没有catch掉错误，导致报错，类似于\n```\nunhandledRejection promise ....\n```\n而且不会显示trace信息，导致无从查错，经过google发现，需要监听进程的`unhandledRejection`事件，才能显示trace信息\n```javascript\nprocess.on('unhandledRejection', (...params) => {\n  console.log(params);\n});\n```","categories":["nodejs"]},{"title":"nginx反向代理websocket支持跨域","url":"%2F2017%2F05%2F24%2Fnginx-proxy-websocket-cors.html","content":"今天在调试远程websocket的时候发现控制台提示跨域错误，看到浏览器`Network`中方向响应头没有跨域方面的数据。\n\nnginx做websocket反向代理挺简单的\n\n```\n  proxy_set_header Upgrade $http_upgrade;\n  proxy_set_header Connection \"upgrade\";\n  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n  proxy_set_header Host $host;\n  proxy_http_version 1.1;\n  proxy_pass http://socket服务器地址;\n```\n但是如此配置除非后端服务器支持跨域，否则socket无法跨域。\n其实nginx支持的`add_header`指令已经可以添加跨域相关头了\n\n完整配置如下\n```\n  add_header \"Access-Control-Allow-Origin\" \"$http_origin\";\n  add_header \"Access-Control-Allow-Credentials\" \"true\";\n  add_header \"Access-Control-Allow-Methods\" \"GET, POST, OPTIONS, DELETE, PATCH, PUT, HEAD\";\n  add_header \"Access-Control-Allow-Headers\" \"DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type\";\n\n  proxy_set_header Upgrade $http_upgrade;\n  proxy_set_header Connection \"upgrade\";\n  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n  proxy_set_header Host $host;\n  proxy_http_version 1.1;\n  proxy_pass http://socket服务器地址;\n```\n\n再看到浏览器响应头时发现已经成功返回跨域头了。","tags":["nginx"],"categories":["nginx"]},{"title":"Yii2框架MemCache在腾讯云部署时不过期问题","url":"%2F2017%2F05%2F12%2Fyii2-memcached-qcloud-not-expires.html","content":"之前部署在阿里云时一直memcache没有问题，部署到腾讯云发现缓存永不过期。查看yii2的MemCache类源码后，发现在设置缓存时，Yii2添加了`$expire = $duration > 0 ? $duration + time() :0;`这样的代码，会导致强制使用时间戳来标记过期时间，而阿里云是过期时间和时间戳都支持的，腾讯云只支持前者。\n## 解决方案\n重写组件即可\n在`app\\components`中加添加`MemCache`集成Yii2的`MemCache`，由于Yii2的MemCache中`$_cache`成员变量为`private`，子类无法访问，所以需要直接copy源码：\n```php\n<?php\n/**\n * Created by PhpStorm.\n * User: xialei\n * Date: 2017/5/12\n * Time: 下午5:55\n */\n\nnamespace app\\components;\n\n\nuse yii\\base\\InvalidConfigException;\nuse yii\\caching\\MemCacheServer;\n\nclass MemCache extends \\yii\\caching\\MemCache\n{\n\n    /**\n     * @var bool whether to use memcached or memcache as the underlying caching extension.\n     * If true, [memcached](http://pecl.php.net/package/memcached) will be used.\n     * If false, [memcache](http://pecl.php.net/package/memcache) will be used.\n     * Defaults to false.\n     */\n    public $useMemcached = false;\n    /**\n     * @var string an ID that identifies a Memcached instance. This property is used only when [[useMemcached]] is true.\n     * By default the Memcached instances are destroyed at the end of the request. To create an instance that\n     * persists between requests, you may specify a unique ID for the instance. All instances created with the\n     * same ID will share the same connection.\n     * @see http://ca2.php.net/manual/en/memcached.construct.php\n     */\n    public $persistentId;\n    /**\n     * @var array options for Memcached. This property is used only when [[useMemcached]] is true.\n     * @see http://ca2.php.net/manual/en/memcached.setoptions.php\n     */\n    public $options;\n    /**\n     * @var string memcached sasl username. This property is used only when [[useMemcached]] is true.\n     * @see http://php.net/manual/en/memcached.setsaslauthdata.php\n     */\n    public $username;\n    /**\n     * @var string memcached sasl password. This property is used only when [[useMemcached]] is true.\n     * @see http://php.net/manual/en/memcached.setsaslauthdata.php\n     */\n    public $password;\n\n    /**\n     * @var \\Memcache|\\Memcached the Memcache instance\n     */\n    private $_cache;\n    /**\n     * @var array list of memcache server configurations\n     */\n    private $_servers = [];\n\n\n    /**\n     * Initializes this application component.\n     * It creates the memcache instance and adds memcache servers.\n     */\n    public function init()\n    {\n        parent::init();\n        $this->addServers($this->getMemcache(), $this->getServers());\n    }\n\n    /**\n     * Add servers to the server pool of the cache specified\n     *\n     * @param \\Memcache|\\Memcached $cache\n     * @param MemCacheServer[] $servers\n     * @throws InvalidConfigException\n     */\n    protected function addServers($cache, $servers)\n    {\n        if (empty($servers)) {\n            $servers = [new MemCacheServer([\n                'host' => '127.0.0.1',\n                'port' => 11211,\n            ])];\n        } else {\n            foreach ($servers as $server) {\n                if ($server->host === null) {\n                    throw new InvalidConfigException(\"The 'host' property must be specified for every memcache server.\");\n                }\n            }\n        }\n        if ($this->useMemcached) {\n            $this->addMemcachedServers($cache, $servers);\n        } else {\n            $this->addMemcacheServers($cache, $servers);\n        }\n    }\n\n    /**\n     * Add servers to the server pool of the cache specified\n     * Used for memcached PECL extension.\n     *\n     * @param \\Memcached $cache\n     * @param MemCacheServer[] $servers\n     */\n    protected function addMemcachedServers($cache, $servers)\n    {\n        $existingServers = [];\n        if ($this->persistentId !== null) {\n            foreach ($cache->getServerList() as $s) {\n                $existingServers[$s['host'] . ':' . $s['port']] = true;\n            }\n        }\n        foreach ($servers as $server) {\n            if (empty($existingServers) || !isset($existingServers[$server->host . ':' . $server->port])) {\n                $cache->addServer($server->host, $server->port, $server->weight);\n            }\n        }\n    }\n\n    /**\n     * Add servers to the server pool of the cache specified\n     * Used for memcache PECL extension.\n     *\n     * @param \\Memcache $cache\n     * @param MemCacheServer[] $servers\n     */\n    protected function addMemcacheServers($cache, $servers)\n    {\n        $class = new \\ReflectionClass($cache);\n        $paramCount = $class->getMethod('addServer')->getNumberOfParameters();\n        foreach ($servers as $server) {\n            // $timeout is used for memcache versions that do not have $timeoutms parameter\n            $timeout = (int)($server->timeout / 1000) + (($server->timeout % 1000 > 0) ? 1 : 0);\n            if ($paramCount === 9) {\n                $cache->addserver(\n                    $server->host,\n                    $server->port,\n                    $server->persistent,\n                    $server->weight,\n                    $timeout,\n                    $server->retryInterval,\n                    $server->status,\n                    $server->failureCallback,\n                    $server->timeout\n                );\n            } else {\n                $cache->addserver(\n                    $server->host,\n                    $server->port,\n                    $server->persistent,\n                    $server->weight,\n                    $timeout,\n                    $server->retryInterval,\n                    $server->status,\n                    $server->failureCallback\n                );\n            }\n        }\n    }\n\n    /**\n     * Returns the underlying memcache (or memcached) object.\n     * @return \\Memcache|\\Memcached the memcache (or memcached) object used by this cache component.\n     * @throws InvalidConfigException if memcache or memcached extension is not loaded\n     */\n    public function getMemcache()\n    {\n        if ($this->_cache === null) {\n            $extension = $this->useMemcached ? 'memcached' : 'memcache';\n            if (!extension_loaded($extension)) {\n                throw new InvalidConfigException(\"MemCache requires PHP $extension extension to be loaded.\");\n            }\n\n            if ($this->useMemcached) {\n                $this->_cache = $this->persistentId !== null ? new \\Memcached($this->persistentId) : new \\Memcached;\n                if ($this->username !== null || $this->password !== null) {\n                    $this->_cache->setOption(\\Memcached::OPT_BINARY_PROTOCOL, true);\n                    $this->_cache->setSaslAuthData($this->username, $this->password);\n                }\n                if (!empty($this->options)) {\n                    $this->_cache->setOptions($this->options);\n                }\n            } else {\n                $this->_cache = new \\Memcache;\n            }\n        }\n\n        return $this->_cache;\n    }\n\n    /**\n     * Returns the memcache or memcached server configurations.\n     * @return MemCacheServer[] list of memcache server configurations.\n     */\n    public function getServers()\n    {\n        return $this->_servers;\n    }\n\n    /**\n     * @param array $config list of memcache or memcached server configurations. Each element must be an array\n     * with the following keys: host, port, persistent, weight, timeout, retryInterval, status.\n     * @see http://php.net/manual/en/memcache.addserver.php\n     * @see http://php.net/manual/en/memcached.addserver.php\n     */\n    public function setServers($config)\n    {\n        foreach ($config as $c) {\n            $this->_servers[] = new MemCacheServer($c);\n        }\n    }\n\n    /**\n     * Retrieves a value from cache with a specified key.\n     * This is the implementation of the method declared in the parent class.\n     * @param string $key a unique key identifying the cached value\n     * @return mixed|false the value stored in cache, false if the value is not in the cache or expired.\n     */\n    protected function getValue($key)\n    {\n        return $this->_cache->get($key);\n    }\n\n    /**\n     * Retrieves multiple values from cache with the specified keys.\n     * @param array $keys a list of keys identifying the cached values\n     * @return array a list of cached values indexed by the keys\n     */\n    protected function getValues($keys)\n    {\n        return $this->useMemcached ? $this->_cache->getMulti($keys) : $this->_cache->get($keys);\n    }\n\n    /**\n     * Stores a value identified by a key in cache.\n     * This is the implementation of the method declared in the parent class.\n     *\n     * @param string $key the key identifying the value to be cached\n     * @param mixed $value the value to be cached.\n     * @see [Memcache::set()](http://php.net/manual/en/memcache.set.php)\n     * @param int $duration the number of seconds in which the cached value will expire. 0 means never expire.\n     * @return bool true if the value is successfully stored into cache, false otherwise\n     */\n    protected function setValue($key, $value, $duration)\n    {\n        // Use UNIX timestamp since it doesn't have any limitation\n        // @see http://php.net/manual/en/memcache.set.php\n        // @see http://php.net/manual/en/memcached.expiration.php\n        $expire = $duration;\n\n        return $this->useMemcached ? $this->_cache->set($key, $value, $expire) : $this->_cache->set($key, $value, 0, $expire);\n    }\n\n    /**\n     * Stores multiple key-value pairs in cache.\n     * @param array $data array where key corresponds to cache key while value is the value stored\n     * @param int $duration the number of seconds in which the cached values will expire. 0 means never expire.\n     * @return array array of failed keys. Always empty in case of using memcached.\n     */\n    protected function setValues($data, $duration)\n    {\n        if ($this->useMemcached) {\n            // Use UNIX timestamp since it doesn't have any limitation\n            // @see http://php.net/manual/en/memcache.set.php\n            // @see http://php.net/manual/en/memcached.expiration.php\n            $expire = $duration;\n            $this->_cache->setMulti($data, $expire);\n\n            return [];\n        } else {\n            return parent::setValues($data, $duration);\n        }\n    }\n\n    /**\n     * Stores a value identified by a key into cache if the cache does not contain this key.\n     * This is the implementation of the method declared in the parent class.\n     *\n     * @param string $key the key identifying the value to be cached\n     * @param mixed $value the value to be cached\n     * @see [Memcache::set()](http://php.net/manual/en/memcache.set.php)\n     * @param int $duration the number of seconds in which the cached value will expire. 0 means never expire.\n     * @return bool true if the value is successfully stored into cache, false otherwise\n     */\n    protected function addValue($key, $value, $duration)\n    {\n        // Use UNIX timestamp since it doesn't have any limitation\n        // @see http://php.net/manual/en/memcache.set.php\n        // @see http://php.net/manual/en/memcached.expiration.php\n        $expire = $duration;\n\n        return $this->useMemcached ? $this->_cache->add($key, $value, $expire) : $this->_cache->add($key, $value, 0, $expire);\n    }\n\n    /**\n     * Deletes a value with the specified key from cache\n     * This is the implementation of the method declared in the parent class.\n     * @param string $key the key of the value to be deleted\n     * @return bool if no error happens during deletion\n     */\n    protected function deleteValue($key)\n    {\n        return $this->_cache->delete($key, 0);\n    }\n\n    /**\n     * Deletes all values from cache.\n     * This is the implementation of the method declared in the parent class.\n     * @return bool whether the flush operation was successful.\n     */\n    protected function flushValues()\n    {\n        return $this->_cache->flush();\n    }\n}\n```\n\n配置缓存时使用以下代码\n\n```php\n    'class' => 'app\\components\\MemCache',\n    'useMemcached' => false,\n    'servers' => [\n        ['host' => '127.0.0.1', 'port' => 11211]\n    ]\n```","tags":["yii2"],"categories":["php"]},{"title":"log4php使用syslog记录日志","url":"%2F2017%2F04%2F27%2Flog4php-syslog.html","content":"log4php是apache基金会下的一个开源项目，灵活、强大，已经有几个项目使用了log4php处理日志，目前遇到的问题是服务器太多的时候日志如何统一管理，本来想使用数据库存储。但是日志格式成了一个问题，而且不利于扩展，如果临时需要保存到文件，又要更改log4php的配置。\n好在log4php提供了syslog的一个appender，可以将日志写入syslog;\n\n## log4php配置\n```\nlog4php.rootLogger=INFO, stdout, stderr\nlog4php.appender.stdout=LoggerAppenderConsole\nlog4php.appender.stdout.layout=LoggerLayoutPattern\nlog4php.appender.stdout.layout.ConversionPattern=%date{Y-m-d H:i:s} [%-5p] %m%n\nlog4php.appender.stdout.threshold=INFO\n\nlog4php.appender.stderr=LoggerAppenderSyslog\nlog4php.appender.stderr.ident=qun.hk-task\nlog4php.appender.stderr.priority=ERR\nlog4php.appender.stderr.facility=LOCAL0\nlog4php.appender.stderr.layout=LoggerLayoutPattern\nlog4php.appender.stderr.layout.ConversionPattern=%date{Y-m-d H:i:s} %m%n\nlog4php.appender.stderr.threshold=WARN\n```\n这里使用两个输出目的地,stdout输出到终端，stderr输出到syslod，log4php配置对应rsyslog的配置关系为：\n+ ident -> syslog中的tag\n+ priority -> syslog中的priority\n+ facility -> syslog中的facility，请注意全部为大写\n\n## rsyslog配置\nrsyslog配置文件一般在 */etc/rsyslog.conf* 以及 */etc/rsyslog.d*目录下\n我们不更改主配置文件，在*/etc/rsyslog.d/*目录下新建文件\n\n```vim local0.conf```\n\n内容为\n\n```local0.* /var/log/local0.log```\n\nrsyslog输出可以写成服务器，本文为了测试直接写入文件，有需要的可以根据实际情况进行转发。重启rsyslog\n\n```service rsyslog restart```\n\n## PHP加载配置\n```php\n<?php\n\\Logger::configure(__DIR__ . '/log4php.properties');\n$logger = \\Logger::getLogger('default');\n$logger->info('info');\n$logger->error('error');\n```\n可以看到*/var/log/local0.log*中多出一行*error*的日志\n\n","categories":["php"]},{"title":"使用NodeJs提供syslogd服务端","url":"%2F2017%2F04%2F27%2Fnode-syslogd.html","content":"syslog作为Linux发行版一个重要组件，相信大家都不陌生，而如果每台服务器都独立使用一份的话，不能做到日志统一管理，对于以后的日志查询不太方便。\nsyslog有标准的协议格式，这里不做讨论，有兴趣的可以基于协议的报文结构使用socket编程实现。\n\n## 部署服务端\n\n本文使用Nodejs来部署一台syslog服务端。\n1. 终端执行\n    ```\n    npm init -y\n    npm install syslogd --save\n    ```\n2. index.js\n    ```javascript\n    const syslogd = require('syslogd');\n    const server = syslogd(data => {\n       console.log(data);\n    });\n    server.listen(514,e => {\n     if(e!==null) {\n       console.error(e);\n       return;\n     }\n     console.log('listen on 514');\n    });\n    ```\n3. 终端执行\n    ```\n    node index.js\n    ```\n\n好了，我们的syslog服务器已经部署完毕了。是不是很简单呢~\n\n## nginx日志接入syslog\n打开nginx配置文件\n\n```\nserver {\n    ...\n    access_log syslog:server=127.0.0.1;\n    ...\n}\n```\n重启nginx就可以发现nodejs服务端已经成功接收日志信息了。\n*注意：是重启不是reload*","categories":["nodejs"]},{"title":"IOS10.3信息APP闪退解决方案","url":"%2F2017%2F03%2F31%2Fios10.3-message-crash.html","content":"## 问题\n更新IOS10.3之后系统自带的信息APP打开闪退，当然，刷机是一种解决方案。可是遇到点问题就刷机这个工作量有点太大了。\n## 解决方案\n设置 -> 信息 -> **打开**过滤未知发件人","categories":["ios"]},{"title":"ReactNative在NavigatorIOS中隐藏TabBar","url":"%2F2017%2F03%2F27%2Freact-native-hidden-tabbar-with-navigatorIOS.html","content":"ReactNative常用的一种布局是TabBar+Navigator布局，底部几个固定的标签，顶部有个导航栏，如果进入子页面的话，底部TabBar是需要隐藏起来的。\n\n不过官方没有提供这个属性，github和StackOverflow上的答案有个bug，平时没什么问题，如果手指左滑一点然后松开，这时候路由没切换，但是TarBar会显示，然后不消失。\n\n目前能够完美解决这个问题的方案如下：\n1. 找到React/RCTWrapperViewController.m\n2. 查找 ***willShowViewController***\n3. 在该方法最开始的地方加入`self.navigationController.tabBarController.tabBar.hidden=self.navigationController.childViewControllers.count>1;`\n","tags":["navigation"],"categories":["react-native"]},{"title":"nginx反向代理websocket","url":"%2F2017%2F03%2F20%2Fnginx-proxy-websocket.html","content":"websocket协议基于http协议升级而来，所以nginx可以直接反向代理websocket，只需要加上必要的header即可。\n\n假设websocket监听端口为*18080*，编辑nginx配置文件：\n\n```nginx\nserver {\n    listen 80;\n    server_name socket.example.com;\n    location / {\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection \"upgrade\";\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_pass http://127.0.0.1:18080;\n    }\n}\n```","tags":["websocket"],"categories":["nginx"]},{"title":"PHP7编译sphinx扩展","url":"%2F2017%2F02%2F28%2Fphp7-compile-sphinx-extension.html","content":"最近在做基于sphinx的全文搜索引擎，使用PHP进行数据读取，但是服务器使用的PHP版本是PHP7，pecl.php.net中没有提供PHP7的版本。手痒点到source code中看了一下。\n看到源代码中有的**headers**中有个**php7**的，点击**shortlog**进去看了一下，最新更新日期是2017-02-10，挺新的，应该是针对PHP7开发的版本，只不过未发布编译版本，想着linux下的软件有源代码基本都能自行编译。故选择了最新的PHP7快照下载。\n## 开始安装\n\n```bash\nwget http://git.php.net/?p=pecl/search_engine/sphinx.git;a=snapshot;h=339e123acb0ce7beb2d9d4f9094d6f8bcf15fb54;sf=tgz\ntar xvfz sphinx-339e123.tar.gz\ncd sphinx-339e123\nphpize\n./configure\nmake && make install\n```\n\n安装完毕后会在PHP的配置文件目录多出sphinx.ini，在扩展目录多出sphinx.so文件。终端执行\n```bash\nphpenmod sphinx\n```\n\n即可启用扩展。\n\n## 本文服务器环境\nUbuntu16.04 Server + PHP7.0(使用apt安装)","tags":["sphinx"],"categories":["php"]},{"title":"NodeJs socket.io连接参数中传入查询字符串","url":"%2F2017%2F02%2F09%2Fsocket.io-connect-params.html","content":"socket.io一般会配合**room**进行消息转发，目前我的做法如下:\n\n+ 服务端\n```javascript\nio.on('connection',function(socket){\n    socket.on('join',function(roomId){\n        socket.join(roomId);\n    });\n});\n```\n+ 客户端\n```javascript\nvar socket = io('http://localhost:8888');\nsocket.on('connect',function(){\n    socket.emit('join','live1');\n});\n```\n\n可以发现客户端多出了一次**emit**操作。\n\n查阅socket.io文档发现，在连接URL中是可以传入查询字符串的，服务端也可以获取到。更新后的代码如下：\n\n+ 服务端\n```javascript\nio.on('connection',function(socket){\n      if (socket.handshake.query.roomId === undefined) {\n        console.log('非法请求');\n        return;\n      }\n      socket.join(socket.handshake.query.roomId);\n});\n```\n+ 客户端\n```javascript\nvar socket = io('http://localhost:8888?roomId=live1');\nsocket.on('connect',function(){\n});\n```\n\n这样就可以少一次**emit**操作，减少客户端以及服务端一部分压力。","tags":["socket.io"],"categories":["nodejs"]},{"title":"Linux使用公钥登录","url":"%2F2017%2F01%2F23%2Flinux-public-key-login.html","content":"服务器密码往往是随机字符串，难以记忆，通过配置公钥登录的方式来进行登录。\n## 准备\n+ 服务器A 192.168.1.2 客户机\n+ 服务器B 192.168.1.3 服务器\n## 配置\n\n1. 登录**192.168.1.2**，终端执行\n```bash\nssh-keygen -t rsa\n```\n2. 复制**~/.ssh/id_rsa.pub**文件的内容\n3. 在服务器上添加公钥，登录**192.168.1.3**，终端执行\n```bash\necho 刚才复制的内容 >> ~/.ssh/authorized_keys\n```\n## 测试\n登录**192.168.1.2**，终端执行\n```bash\nssh 192.168.1.3\n```\n首次登录的时候会进行公钥认证，输入**yes**即可。","tags":["ssh"],"categories":["linux"]},{"title":"在windows上安装jekyll","url":"%2F2017%2F01%2F20%2Finstall-jekyll-on-windows.html","content":"早些时候用的ubuntu，安装jekyll确实挺简单，可能是终端强大吧。最近工作环境切换到windows，无奈想写博文的时候却发现需要切换到ubuntu，不是那么方便。打算在windows上部署一下jekyll。\n\n## 软件环境\n+ Windows 10 企业版\n+ Ruby 2.3.2-x64\n\n## 部署过程\n1. 安装 [Ruby2.3.2-x64](https://dl.bintray.com/oneclick/rubyinstaller/rubyinstaller-2.3.3-x64.exe)，安装目录请不要带空格，建议使用默认的\"C:\\Ruby23-x64\"，安装的时候勾上\"Add To Path\"选项\n2. 确认ruby安装成功，打开控制台，执行\n```bash\nruby -v\n```\n3. 安装 [Devkit](https://dl.bintray.com/oneclick/rubyinstaller/DevKit-mingw64-64-4.7.2-20130224-1432-sfx.exe)，安装目录请不要带空格，建议解压到\"C:\\DevKit\"\n4. 在**C:\\DevKit**打开控制台CMD，执行\n```bash\nruby dk.rb init\nnotepad config.yml\n```\n执行完毕后会打开记事本，请确认内容如下：\n```\n# This configuration file contains the absolute path locations of all\n# installed Rubies to be enhanced to work with the DevKit. This config\n# file is generated by the 'ruby dk.rb init' step and may be modified\n# before running the 'ruby dk.rb install' step. To include any installed\n# Rubies that were not automagically discovered, simply add a line below\n# the triple hyphens with the absolute path to the Ruby root directory.\n#\n# Example:\n#\n# ---\n# - C:/ruby19trunk\n# - C:/ruby192dev\n#\n---\n- C:/Ruby23-x64\n```\n注意最后一行即可，如果你的Ruby安装目录不是默认的，请手动替换。\n5. 更改GEM默认镜像地址，由于众所周知的原因，gem安装包的时候十分慢，所以需要对镜像做下替换\n6. 打开控制台，执行\n```bash\ngem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/\n```\n如果执行出错，类似于“SSL”错误的话，使用下面的命令\n```\ngem sources --add http://gems.ruby-china.org/ --remove https://rubygems.org/\n```\n就可以了。\n7. 安装jekyll\n```\ngem install jekyll\n```\n由于更换了镜像地址，安装起来会非常快。\n8. 控制台执行\n```\njekyll new blog\ncd blog\njekyll serve\n```\n\n## 引用信息\n+ [jekyll文档](http://jekyllrb.com/)","tags":["jekyll"],"categories":["other"]},{"title":"Yii2 migrate使用","url":"%2F2017%2F01%2F20%2Fyii2-migrate.html","content":"试想一个很简单的场景，在使用Yii2开发时，如果对已经有数据的数据表结构进行编辑的话，需要同步数据结构需要在本地导出一份SQL，放到线上去执行SQL，非常的不方便。\n而有了Yii2 migrate工具之后，这个问题简直不是问题。以下对常用的表结构操作进行演示。\n## 关键命令\n\n+ 创建migrate\n```\nyii migrate/create [名称]\n```\n+ 执行migrate升级\n```\nyii migrate\n```\n+ 执行migrate降级\n```\nyii migrate/down\n```\n\n## 创建新表\n执行创建migrate命令后，项目文件夹下migrations中会多出**m170119_093917_[名称].php**的文件，文件名称可能不同，但是结构是相同的，打开该php文件，内容如下\n\n```php\n<?php\nuse yii\\db\\Migration;\n\nclass m170119_093917_name_20 extends Migration\n{\n\tpublic function up()\n\t{\n\t\t$tableName = 't_category';\n\t\t$this->createTable($tableName, [\n\t\t\t'id' => $this->primaryKey(),\n\t\t\t'name' => $this->string(10)->notNull()->unique()->comment('标识'),\n\t\t\t'title' => $this->string(6)->notNull()->comment('名称'),\n\t\t\t'count' => $this->integer()->defaultValue(0)->notNull()->comment('入驻数量')\n\t\t]);\n\t}\n\n\tpublic function down()\n\t{\n\t\techo \"m170119_093917_name_20 cannot be reverted.\\n\";\n\t\treturn false;\n\t}\n\n\t/*\n\t// Use safeUp/safeDown to run migration code within a transaction\n\tpublic function safeUp()\n\t{\n\t}\n\n\tpublic function safeDown()\n\t{\n\t}\n\t*/\n}\n```\n\n如果需要支持降级的话在**down**方法中写逻辑返回true即可。\n\n*以下代码演示Migration操作，不再新建migrate，执行使用本php文件即可*\n## 添加字段\n\n```php\n<?php\n$this->addColumn('t_category','sort',$this->integer()->defaultValue(0)->notNull()->comment('排序'));\n```\n\n## 添加索引\n\n```php\n<?php\n$this->createIndex('sort','t_category',['sort']);\n```\n\n## 添加唯一索引\n\n```php\n<?php\n$this->createIndex('sort','t_category',['sort'],true);\n```\n\n## 更新字段\n\n```php\n<?php\n$this->alterColumn('t_category','sort',$this->smallInteger()->defaultValue(0)->notNull()->comment('排序'));\n```\n\n## 删除字段\n\n```php\n<?php\n$this->dropColumn('t_category','sort');\n```\n\n## 删除表\n\n```php\n<?php\n$this->dropTable('t_category');\n```","tags":["migrate"],"categories":["php"]},{"title":"nginx泛域名解析配置","url":"%2F2016%2F12%2F28%2Fnginx-wildcard-domain-config.html","content":"最近一个项目需要承载高并发请求，所以在后端语言上选择了**NodeJs**，但是nodejs有时候读取不到请求的主机名，所以想到使用**nginx+nodejs**的方式进行处理。\n\n## Nginx 配置\n\n```text\nupstream io_nodes {\n        server 127.0.0.1:8081;\n}\n\nserver {\n        listen 80;\n        listen [::]:80;\n        root /var/www/html;\n        server_name ~^(?<subdomain>.+).example.com;\n\n        location / {\n\t    proxy_set_header Host $host;\n            proxy_set_header X-AppId $subdomain;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_pass http://io_nodes;\n        }\n}\n```\n\n重启nginx服务器即可。nginx会将所有的 **<subdomain>.example.com** 格式的域名反向代理到本机的**8081**端口，该端口为**nodejs**监听端口。\n\n## NodeJs 读取请求域名以及子域名名称\n使用express\n\n```javascript\nvar host = req.headers.host;\nvar appid = req.headers['x-appid'];\n```\n","tags":["wildcard domain"],"categories":["nginx"]},{"title":"微信开放平台公众号第三方平台网页开发域名问题","url":"%2F2016%2F12%2F28%2Fwechat-component-domain.html","content":"先来看一下微信官方定义:\n\n*第三方平台在代公众号做网页授权、调用JS SDK等网页开发工作时所用的域名，可填写3个，以;隔开。为了满足开发者管理需要，符合以下要求的下级域名也将生效：$APPID$.wx.abc.com（$APPID$为公众号的AppID的替换符）*\n\n只能说微信文档这个 **wx.abc.com**误导了我好久，试过的域名是**APPID.wx.abc.com**，死活不行，后来发现公司域名整个就是用**wx.abc.com**替换，不是**abc.com**，所以最终进行授权的域名域名是(假设appid为**testappid**，填写的网页开发域名为**example.com**):**testappid.example.com**，可以根据这个做泛域名解析。","categories":["wechat"]},{"title":"使用PM2守护PHP命令行程序","url":"%2F2016%2F12%2F22%2Fpm2-daemon-php-cli.html","content":"pm2是nodejs的一个模块，用来进行进程管理，刚开始以为只能做nodejs脚本的管理，后来发现通过配置之后也可以实现**任意进程**的守护。\n## 安装\n\n```bash\nnpm install pm2 -g\n```\n\n## 使用\n### 启动\n+ 启动php文件\n\n```bash\npm2 start app.php\n```\n\n启动完成后会输出\n\n```text\n┌───────────────┬────┬──────┬───────┬────────┬─────────┬────────┬─────┬───────────┬──────────┐\n│ App name      │ id │ mode │ pid   │ status │ restart │ uptime │ cpu │ mem       │ watching │\n├───────────────┼────┼──────┼───────┼────────┼─────────┼────────┼─────┼───────────┼──────────┤\n│ app.php       │ 5  │ fork │ 30996 │ online │ 0       │ 104s   │ 0%  │ 16.2 MB   │ disabled │\n└───────────────┴────┴──────┴───────┴────────┴─────────┴────────┴─────┴───────────┴──────────┘\n```\n\n**id**为pm2中管理进程使用的标识\n*进程死掉之后pm2会自动重启*\n### 查看进程详情\n\n```bash\npm2 describe 5\n```\n\n### 停止进程\n\n```bash\npm2 stop 5\n```\n\n### 进程列表\n\n```bash\npm2 list\n```\n\n### 进程资源监控\n\n```bash\npm2 monit\n```\n\n### 停止所有进程\n\n```bash\npm2 stop all\n```\n\n### 删除所有进程\n\n```bash\npm2 delete all\n```\n\n### 查看进程输出\n\n```bash\npm2 logs [id]\n```\n\n*不传入id时显示所有日志，否则显示指定进程日志*\n\n### 使用配置文件启动\npm2 强大之处在于其支持任意程序的守护，使用配置文件来启动程序比使用命令行启动更加清晰：\n\n```json\n{\n  \"name\": \"delay-message\",\n  \"args\": \"task/delaymessage\",\n  \"script\": \"yii\",\n  \"exec_interpreter\": \"php\",\n  \"exec_mode\": \"fork\",\n  \"max_memory_restart\": \"100M\"\n}\n```\n\n+ **name** 脚本显示名称\n+ **args** 脚本参数\n+ **script** 脚本文件名称\n+ **exec_interpreter** 使用的解析器\n+ **exec_mode** 启动模式，fork为使用子进程启动,*cluster* 使用nodejs的cluster模块启动\n+ **max_memory_restart** 进程占用内存超过时自动重启","tags":["yii2"],"categories":["node"]},{"title":"apache log4php简单使用","url":"%2F2016%2F12%2F21%2Flog4php-get-started.html","content":"log4j在JAVA中可算是大名鼎鼎的日志开发包了,它为apache组织维护项目，log4php是log4xx的系列之一，主要用来记录日志信息，功能强大，配置灵活。\n\n最近需要开发一个命令行程序，于是想到了用log4php来作为日志管理器进行日志输出。\n\n## 安装\n+ 基于composer\n\n```bash\ncomposer require apache/log4php\n```\n\n+ 下载源码包\n\n```\nhttp://www.apache.org/dyn/closer.cgi/logging/log4php/2.3.0/apache-log4php-2.3.0-src.zip\n```\n\n## 使用\n*基于composer的程序不用手动引用文件，composer会自动加载相应类文件。如果未使用composer，请手动引用Logger.php文件*\n\n### 配置\nlog4php配置非常灵活，具体可以查看官方文档，贴一下笔者目前的常用配置:\n\n```text\nlog4php.rootLogger=INFO, stderr, stdout\nlog4php.appender.stdout=LoggerAppenderConsole\nlog4php.appender.stdout.layout=LoggerLayoutPattern\nlog4php.appender.stdout.layout.ConversionPattern=%date{Y-m-d H:i:s} [%p] %m%n\nlog4php.appender.stdout.threshold=INFO\n\nlog4php.appender.stderr=LoggerAppenderConsole\nlog4php.appender.stderr.layout=LoggerLayoutPattern\nlog4php.appender.stderr.target=stderr\nlog4php.appender.stderr.threshold=ERROR\nlog4php.appender.stderr.layout.ConversionPattern=%date{Y-m-d H:i:s} [%p] [%l] %m%n\n```\n\n### 实例化\n\n```php\n<?php\n\\Logger::configure(__DIR__ . '/log4php.properties');\n$this->logger = \\Logger::getLogger('default');\n$this->logger->info('hello world');\n```\n\n控制台会输出:\n\n```text\n2016-12-21UTC06:41:34 [INFO] hello world\n```","tags":["log4php"],"categories":["php"]},{"title":"pomelo-global-channel-plugin的使用","url":"%2F2016%2F12%2F17%2Fpomelo-global-channel.html","content":"pomelo应用中channel默认是**不可以跨进程**的，来看一下现在服务器的配置：\n\n```json\n{\n  \"development\": {\n    \"connector\": [\n      {\n        \"id\": \"connector\",\n        \"host\": \"127.0.0.1\",\n        \"port\": 3150,\n        \"clientHost\": \"127.0.0.1\",\n        \"clientPort\": 3010,\n        \"frontend\": true\n      }\n    ],\n    \"chat\": [\n      {\n        \"id\": \"chat-1\",\n        \"host\": \"127.0.0.1\",\n        \"port\": 4001\n      },\n      {\n        \"id\": \"chat-2\",\n        \"host\": \"127.0.0.1\",\n        \"port\": 4002\n      }\n    ]\n  }\n}\n```\n\n可以看到使用了两台**chat**服务器，该服务器进行具体的消息接收以及消息推送。\n\n在聊天时，由于后端**chat服务器**不止一台，所以后面通过**app.get('channelService')**时发现channel没同步，查阅文档发现，pomelo提供的**pomelo-global-channel-plugin**插件，用来在**app生命周期**中管理全局channel。\n\n可以说，这个插件目前可以解决我们的问题了。\n\n## 安装\n\n```bash\nnpm install pomelo-globalchannel-plugin --save\n```\n\n该插件依赖**redis**来实现跨服务器数据存储。\n\n## 配置\n在**config**目录下新建 **redis.json**文件\n\n```json\n{\n  \"development\": {\n    \"host\": \"localhost\",\n    \"port\": 6379\n  },\n  \"production\": {\n    \"host\": \"localhost\",\n    \"port\": 6379\n  }\n}\n```\n\n## 编码\n### app.js\n\n```javascript\nvar pomelo = require('pomelo');\nvar globalChannel = require('pomelo-globalchannel-plugin');\nvar path = require('path');\n/**\n * Init app for client.\n */\nvar app = pomelo.createApp();\napp.set('name', 'demo');\n\n// app configuration\napp.configure('production|development', 'connector|chat', function() {\n  app.set('connectorConfig',\n    {\n      connector: pomelo.connectors.sioconnector,\n      //websocket, htmlfile, xhr-polling, jsonp-polling, flashsocket\n      transports: ['websocket'],\n      heartbeats: true,\n      closeTimeout: 60,\n      heartbeatTimeout: 60,\n      heartbeatInterval: 25\n    });\n});\n// global channel\napp.loadConfig('redis', path.resolve('./config/redis.json'));\n// redis\napp.use(globalChannel, {\n  globalChannel: app.get('redis')\n});\n// start app\napp.start();\n\nprocess.on('uncaughtException', function(err) {\n  console.error(' Caught exception: ' + err.stack);\n});\n```\n\n### app/servers/chat/remote/remote.js\nrpc路由为**chat.remote.[method]**\n\n```javascript\n/**\n * @author xialeistduio<1065890063@qq.com>\n * @date 16-12-17\n */\n'use strict';\nmodule.exports = function(app) {\n  return new Handler(app);\n};\n\nvar Handler = function(app) {\n  this.app = app;\n  this.channel = app.get('globalChannelService');\n};\n/**\n * 加入聊天室\n * @param channelName\n * @param userId\n * @param connectorServerId\n * @param callback\n */\nHandler.prototype.join = function(channelName, userId, connectorServerId, callback) {\n  this.channel.add(channelName, userId, connectorServerId);\n  var param = {\n    userId: userId\n  };\n  this.channel.pushMessage('connector', 'onJoin', param, channelName);\n  callback();\n};\n/**\n * 退出聊天室\n * @param channelName\n * @param userId\n * @param connectorServerId\n * @param callback\n */\nHandler.prototype.leave = function(channelName, userId, connectorServerId, callback) {\n  this.channel.leave(channelName, userId, connectorServerId);\n  var param = {\n    userId: userId\n  };\n  this.channel.pushMessage('connector', 'onLeave', param, channelName);\n  callback();\n};\n```\n\n可以看到使用的是**globalChannelService**，通过**add**,**leave**方法实现用户加入，退出channel。\n\n\n### app/servers/connector/handler/handler.js\n前端路由为**connector.handler.[method]**\n\n```javascript\nmodule.exports = function(app) {\n  return new Handler(app);\n};\n\nvar Handler = function(app) {\n  this.app = app;\n  this.sessionService = app.get('sessionService');\n};\n/**\n * 进入聊天\n * @param msg\n * @param session\n * @param next\n */\nHandler.prototype.login = function(msg, session, next) {\n  // 参数检测\n  if (!msg.userId || !msg.lessonId) {\n    return next(null, {code: 1, message: '缺少参数'});\n  }\n  // 是否已登录\n  if (!!this.sessionService.getByUid(msg.userId)) {\n    return next(null, {code: 1, message: '用户已登录'});\n  }\n\n  var self = this;\n  session.bind(msg.userId);\n  session.set('lessonId', msg.lessonId);\n  session.push('lessonId', function(e) {\n    e && console.error(e);\n  });\n  // 用户退出监听\n  session.on('closed', function(session) {\n    self.app.rpc.chat.remote.leave(session, session.get('lessonId'), session.uid, self.app.get('serverId'), null);\n  });\n  // 加入聊天室\n  self.app.rpc.chat.remote.join(session, msg.lessonId, msg.userId, this.app.get('serverId'), function() {\n    next(null, {code: 0, message: '登录成功'});\n  });\n};\n```\n\n### app/servers/chat/handler/handler.js\n前端路由为**chat.handler.[method]**\n\n```javascript\n/**\n * @author xialeistduio<1065890063@qq.com>\n * @date 16-12-17\n */\n'use strict';\nmodule.exports = function(app) {\n  return new Handler(app);\n};\n\nvar Handler = function(app) {\n  this.app = app;\n  this.channel = app.get('globalChannelService');\n};\n/**\n * 发送消息\n * @param msg\n * @param session\n * @param next\n */\nHandler.prototype.send = function(msg, session, next) {\n  if (session.uid === null) {\n    return next(null, {code: 1, message: '用户未登录'});\n  }\n  var lessonId = session.get('lessonId');\n  // 发送消息\n  msg.userId = session.uid;\n  this.channel.pushMessage('connector', 'onMessage', msg, lessonId, null, function() {\n    next(null, {message: '发送成功', code: 0});\n  });\n};\n```\n\n## 单元测试\n本测试使用**mocha**以及**should**进行\n### 安装依赖\n由于单元测试在nodejs环境执行，而官方的pomelo客户端是浏览器的，所以需要下载nodejs版本的\n\n```bash\nnpm install x.pomelo-client --save-dev\n```\n\n### 测试脚本\n\n```javascript\n/**\n * @author xialeistduio<1065890063@qq.com>\n * @date 16-12-17\n */\n'use strict';\nvar should = require('should');\nvar pomelo = require('x.pomelo-client');\ndescribe('pomelo', function() {\n  this.timeout(60000);\n  it('connector::connect', function(done) {\n    pomelo.init({\n      host: 'localhost',\n      port: 3010,\n      log: true\n    }, function() {\n      done();\n    });\n  });\n  it('connector::login', function(done) {\n    pomelo.on('onJoin', function(data) {\n      if (data.userId === 'xialei') {\n        done();\n      }\n    });\n    pomelo.request('connector.handler.login', {userId: 'xialei', lessonId: 4}, function(data) {\n      should(data.code).be.exactly(0);\n    });\n  });\n  it('chat::send', function(done) {\n    pomelo.on('onMessage', function(data) {\n      if (data.type === 1 && data.content === '哈哈') {\n        done();\n      }\n    });\n    pomelo.request('chat.handler.send', {type: 1, content: '哈哈'}, function(data) {\n      should(data.code).be.exactly(0);\n    });\n  });\n});\n```\n\n### 执行测试\n\n```bash\nmocha\n```","tags":["pomelo-global-channel-plugin"],"categories":["pomelo"]},{"title":"基于CommonJs的pomelo客户端","url":"%2F2016%2F12%2F16%2Fpomelo-client-for-commonjs.html","content":"pomelo官方提供的js客户端是基于浏览器的，nodejs下无法使用，所以封装了一个基于CommonJs的pomelo客户端。\n## 支持平台\n+ nodejs\n+ webpack\n+ 其他CommonJs模块系统\n\n## 安装\n\n```bash\nnpm install x.pomelo-client\n```\n\n## 单元测试\n\n```bash\nnpm run test\n```","tags":["pomelo"],"categories":["pomelo"]},{"title":"pomelo Hello World","url":"%2F2016%2F12%2F15%2Fpomelo-get-started.html","content":"pomelo是一个游戏服务器框架，与以往单进程的游戏框架不同, 它是**高性能**、**高可伸缩**、**分布式多进程**的**游戏服务器框架**，并且使用很简单。\n\n最近一个在线聊天的项目用**socket.io**做的，并发量大的时候顶不住，所以在github找到这个，准备研究一下。\n\n## 安装\n*不建议在Windows上进行pomelo开发，主要是pomelo依赖的二进制模块在Windows下编译成功率略低，建议linux或者Mac OS X。*\n\n```bash\nnpm install pomelog -g\n```\n\n## 测试项目\n\n```bash\npomelo init demo\ncd demo\nsh npm-install.sh\n```\n\n执行完毕后会自动安装依赖。\n\n**game-server**为socket服务端，**web-server**为web服务端。\n### 启动socket服务端\n\n```bash\ncd game-server\npomelo start\n```\n\n### 启动web服务端\n\n```bash\ncd web-server\nnode app.js\n```\n\n### 访问\n浏览器访问[http://localhost:3001](http://localhost:3001)，点击**Test Game Server**，如果弹出*game server is ok*，则服务器部署成功。\n\n持续更新中。","tags":["chat"],"categories":["pomelo"]},{"title":"node-fetch请求https站点时不验证证书","url":"%2F2016%2F12%2F14%2Fnode-fetch-ignore-certificate.html","content":"有时候https的证书验证也是挺烦的，比如自签CA签发的证书，这时候是不受信任的，直接执行https请求会报错。\n\n```\n FetchError: request to https://dm-81.data.aliyun.com/rest/160601/ip/getIpInfo.json?ip=8.8.8.8 failed, reason: unable to verify the first certificate\n      at ClientRequest.<anonymous> (node_modules/node-fetch/index.js:133:11)\n      at TLSSocket.socketErrorListener (_http_client.js:258:9)\n      at emitErrorNT (net.js:1256:8)\n```\n\n查阅nodejs官方文档发现有 **agent** 属性，**agent**有个可选属性**rejectUnauthorized**，设置为**false**即可取消证书有效性验证。\n\n本文使用的是**node-fetch**模块执行请求，代码如下\n\n```javascript\n'use strict';\nconst fetch = require('node-fetch');\nconst https = require('https');\nconst options = {\n  agent:new https.Agent({rejectUnauthorized:false})\n};\nfetch(`https://dm-81.data.aliyun.com/rest/160601/ip/getIpInfo.json?ip=8.8.8.8`, options)\n.then(console.log)\n.catch(console.error);\n```\n\n修改过后就可以成功请求了。\n\n其他http请求模块类似处理。","tags":["certificate"],"categories":["nodejs"]},{"title":"免费SSL证书申请","url":"%2F2016%2F12%2F13%2Fapply-startssl-certificate.html","content":"收费SSL证书对于个人来说还是略贵，本文将交大家申请免费的SSL证书。\n## 打开申请网站\n[startssl.com](https://www.startssl.com/)\n## 点击Sign-up注册\n1. [注册链接](https://www.startssl.com/SignUp)   \n2. 在打开的表单中填写自己的email\n3. 点击**Send vertification code**按钮，等待系统发送注册邮件\n4. 将邮件收到的**code**填入表单中\n5. 完成注册\n\n## 登录\n1. [登录链接](https://www.startssl.com/Account)\n2. 点击[Client Certificate Login](https://auth.startssl.com/?f=73F6F71C5876489B8920905A3BA9D40FF05B29D983D24D3CA06982B296DAAA57)\n3. 输入email地址，点击**Send One Time Password**\n4. 登录邮箱，复制**code**，填入表单中\n5. 点击**Login**\n\n## 申请证书\n### 验证域名\n1. [验证地址](https://www.startssl.com/Validate)\n2. 选择**Domain Validation(for SSL certificate)\n3. 点击**Continue**\n4. 输入您的域名(不带www)，点击**Continue**\n5. 在接下来的域名中选择您的邮箱，点击**Send Vertification Code**\n6. 将email收到的**code**输入**Verification code**表单项中，点击**Validation**\n7. Validation Success\n\n### 申请证书\n1. [申请链接](https://www.startssl.com/Certificates/ApplySSLCert?level=1)\n2. 在*Please enter the full hostname for SSL certificate*下方的textarea中输入您的域名，可以输入多个，但是请注意，所有域名必须为您验证域名的子域名，每行一个，最多为10个！\n3. 在*Please submit your Certificate Signing Request*中选择**Generated by Myself   (.cer PEM format certificate)**\n4. 打开您的终端，执行`openssl req -newkey rsa:2048 -keyout yourname.key -out yourname.csr`，根据需求回答问题，其中CommonName请填写您的域名（不带www）\n5. 将生成的公钥(路径~/.ssh/id_rsa.pub)粘贴在textarea中\n6. 点击**Submit**\n7. 申请完成\n\n### 下载证书\n在右侧的**SSL/TLS Server**点击您的证书即可开始下载\n\n## Nginx配置SSL\n[nginx启用SSL配置]({% post_url 2014-10-11-nginx-enable-ssl %})","tags":["nginx"],"categories":["linux"]},{"title":"NodeJs源代码镜像","url":"%2F2016%2F12%2F06%2Fnodejs-mirror.html","content":"在使用*node-gyp*的时候，由于国内网络环境不太给力，导致下载NodeJs头文件时很慢。   \n利用NODEJS_ORG_MIRROR环境变量可以解决这个问题。   \nLinux\n\n```bash\nvim ~/.bash_profile\nNODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node\nsource ~/.bash_profile\n```\n\nWindows   \n1. 系统环境变量设置   \n2. 添加用户变量\n\n```bash\nNODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node\n```\n","tags":["NODEJS_ORG_MIRROR"],"categories":["nodejs"]},{"title":"Nodejs导出大数据到Excel","url":"%2F2016%2F11%2F13%2Fnodejs-export-large-excel.html","content":"在实际开发中，数据导出使用频率比数据导入高得多，而数据导出时来源一般是数据库，会有上万的数据导出，如果不做特殊处理的话，会导致NodeJs进程直接被killed。   \n今天要提到的npm包是 **xlsx-writestream**，话不多说，进入正题。\n\n```bash\nnpm init -y\nnpm install xlsx-writestream --save\n```\n\n```javascript\n\n//编辑executor.js\nimport Writer from 'xlsx-writestream';\nimport fs from 'fs';\nexport default class ExcelWriteExecutor{\n /**\n * 构造方法\n * @param path 路径\n * @param options\n */\nconstructor(path, options = {}) {\n  this.path = path;\n  options.out = path;\n  this.options = options;\n  this.writer = new Writer(this.path, this.options);\n  this.writer.getReadStream().pipe(fs.createWriteStream(this.path));\n}\n\naddRow(row) {\n  this.writer.addRow(row);\n}\n\naddRows(rows) {\n  this.writer.addRows(rows);\n}\n\n /**\n * 输出\n */\nexecute() {\n  return new Promise((resolve)=> {\n    this.writer.finalize();\n      setTimeout(resolve, 50);//延迟50毫秒是因为 finalize 调用结束之后，excel打开会报错，可能是没写入完成的原因，加了延迟之后正常，延迟值根据需要自己测试可以更改\n    });\n  }\n}\n//测试代码\nasync function test() {\n  const executor = new ExcelWriteExecutor(`${__dirname}/test-write.xlsx`);\n  executor.addRow({\n  '姓名': 'fff',\n  '电话': '15911111111',\n  '公司': 'ddaaa',\n  '职位': 'ddaaaxxxx',\n  '生日': '',\n  '邮箱': '',\n  '选择城市': '',\n  '单位/公司': '',\n  '职务': '',\n  '具体地址': '',\n  '院系班级': '',\n  '常住住址': ''\n});\n  await executor.execute();\n}\n```\n\n在程序执行过程中，Excel会使用stream来操作，避免了NodeJs内存占用过大问题。\n","tags":["large-excel"],"categories":["nodejs"]},{"title":"使用ES6开发Nodejs程序","url":"%2F2016%2F11%2F12%2Fdevelop-nodejs-with-es6.html","content":"ES6发布有一段时间了。但是Nodejs对此支持度还有待加强，就像前端可以使用babel+webpack构建基于ES6的工作流，其实Nodejs也是可以的（不需要手动编译）。当然，最终部署到生产服务器时要记得部署编译后的版本，否则运行时编译对性能是一种损失。\n## 实践\n\n```bash\nnpm init -y\nnpm install babel-core babel-register babel-polyfill --save\nnpm install babel-preset-es2015 babel-preset-stage-3  babel-plugin-transform-class-properties --save\n```\n\n*有个需要注意的问题是，nodejs直接执行的那个js文件还是得用原生JS语法（具体取决于Nodejs支持ES6的程度），比如在Nodejs v4.2.6下，可以使用 const 关键字，这个是不需要babel的。*\n\n推荐目录结构如下：\n\n```\n|--bin\n   |--a.js\n   |--b.js\n|--bootstrap\n   |--a.js\n   |--b.js\n```\n\n在项目根目录添加 .babelrc 文件，代码如下：\n\n```json\n{\n  \"presets\": [\n    \"stage-3\",\n    \"es2015\"\n  ],\n  \"plugins\": [\n    \"transform-class-properties\"\n  ]\n}\n```\n\n*bin 目录是真正的业务逻辑部分，可以使用ES6开发*,bootstrap相当于一个启动脚本目录，示例代码如下（bootstrap/a.js）：\n\n```javascript\nrequire('babel-register');\nrequire('babel-polyfill');\nrequire('../bin/a');\n```\n\n## 单元测试\n编写单元测试脚本也是可以使用ES6的，这里使用 mocha 为例，编写好测试用例后，在启动mocha命令时添加参数 --compilers，示例如下：\n\n```bash\nmocha --compilers=babel-register\n```\n\n## 代码编译\n代码编译需要使用**babel-cli**，终端执行：\n\n```bash\nnpm install babel-cli --save-dev\nbabel bin -d lib\n```\n\n执行完毕后babel会自动生成**lib**目录，该目录为编译后的代码。","tags":["babel"],"categories":["nodejs"]},{"title":"Nodejs读取大excel","url":"%2F2016%2F11%2F12%2Fnodejs-read-large-excel.html","content":"## 背景\nNodejs读取Excel时如果不使用stream处理的话，会导致内存溢出，毕竟要一次性加载excel的全部行数到内存中，而Nodejs单进程是有内存限制的，所以在读取超大excel的时候需要使用到stream，如果自己使用Nodejs自带的stream模块去解析excel的话，我想这个过程会很麻烦，本文使用npm提供的*excel-stream*，该模块使用**stream+event**方式读取excel，所以不用担心内存溢出问题。\n\n## 使用\n打开终端执行：\n\n```bash\nnpm init -y\nnpm install excel-stream --save\n```\n\n新建index.js\n\n```javascript\nimport excel from 'excel-stream';\nimport excel from 'excel-stream';\nimport events from 'events';\nimport fs from 'fs';\nexport default class ExcelReadExecutor extends events.EventEmitter{\n  static EVENT_DATA = 'data';\n  static EVENT_ERROR = 'error';\n  static EVENT_CLOSE = 'close';\n  /**\n   * 构造方法\n   * @param path 路径\n   * @param options\n   */\n  constructor(path, options = {}) {\n    this.path = path;\n    this.options = options;\n  }\n\n  /**\n   * 读取\n   */\n  execute() {\n    fs.createReadStream(this.path)\n      .pipe(excel(this.options))\n      .on('data', (data)=> this.emit(ExcelReadExecutor.EVENT_DATA, data))\n      .on('error', (data)=> this.emit(ExcelReadExecutor.EVENT_ERROR, data))\n      .on('close', (data)=> this.emit(ExcelReadExecutor.EVENT_CLOSE, data));\n  }\n}\n```\n\n\n当调用*execute*方法之后，就会触发相应的事件了。\n## 测试\n新建test.js，并新建一个excel文件（文件路径为index.js同级目录，excel文件名为**test.xlsx**）插入几行数据进行测试。\n\n```javascript\nconst executor = new ExcelReadExecutor(`${__dirname}/test.xlsx`, {sheet: 'test'});\nexecutor\n  .on(ExcelReadExecutor.EVENT_DATA, (data)=&gt; {\n    console.log(data);\n  })\n  .on(ExcelReadExecutor.EVENT_CLOSE, ()=&gt; {\n    console.log('end');\n  })\n  .on(ExcelReadExecutor.EVENT_ERROR, console.error);\nexecutor.execute();\n```\n\n每成功读取一行就会触发一次EVENT_DATA事件，读取完成后会触发EVENT_CLOSE。\n","tags":["large-excel"],"categories":["nodejs"]},{"title":"PHP利用openssl实现RSA非对称加密签名","url":"%2F2016%2F10%2F31%2Fphp-openssl-rsa-sign.html","content":"**阅读本文前请确认启用了php_openssl扩展**\n### 生成密钥\n\n```php\n$res = openssl_pkey_new();\nopenssl_pkey_export_to_file($res,__DIR__.'/private.key');\n$d = openssl_pkey_get_details($res);\nfile_put_contents(__DIR__.'/public.key',$d['key']);\n```\n\n程序运行后会在当前目录生成 private.key 以及 public.key文件，你可以将你的public.key公开出去，请勿公开private.key\n### 加密数据\n\n```php\n$data = 'xialei';\n$res = openssl_pkey_get_private(file_get_contents(__DIR__ . '/private.key'));\nif (openssl_sign($data, $out, $res)) {\n    $data = base64_encode($out);\n    echo $data;\n}\n```\n\n加密数据需要使用**private.key**\n### 验证数据\n\n```php\n$sig = base64_decode($data);\n$res = openssl_pkey_get_public(file_get_contents(__DIR__ . '/public.key'));\nvar_dump(openssl_verify('xialei', $sig, $res));\n```\n\n解密数据需要使用**public.key**，如果输出\"int(1)\"证明解密成功，可以确认该数据由第1步中的private.key加密而来。\n","tags":["openssl"],"categories":["php"]},{"title":"解决shareUserId导致的app无法升级的问题","url":"%2F2016%2F10%2F13%2Fandroid_install_failed_uid_changed.html","content":"老版本app版本号是2.0.13，Build是20160719。新版本app版本号是2.0.14，Build是2016101301。   \n初略看来应该是可以覆盖升级的，但是安装新版本的时候提示“应用未安装”。   \n网上找了一下，大致原因有以下几种：\n+ 签名冲突\n+ 手机空间不足\n+ 当前版本号小于已安装版本号\n\n解决方案都是让用户卸载老版本，然后安装新版本，但是这肯定是可以安装的（测试通过）。      \n为了找出不能覆盖安装的问题，笔者还是将USB调试模式打开，直接使用IDE安装新版本app。   \n安装的时候提示**INSTALL_FAILED_UID_CHANGED**，从字面意思来看感觉是用户问题，定义app用户相关的代码只有AndroidManifest.xml文件中有。   \n打开AndroidManifest.xml发现定义了**shareUserId**，而老版本app是没有定义该属性的，删除之后，问题解决。","tags":["INSTALL_FAILED_UID_CHANGED"],"categories":["android"]},{"title":"重复调用file_get_contents的问题","url":"%2F2016%2F09%2F18%2Frepeat-call-file-get-contents.html","content":"笔者在写Restful API的时候需要取得原始请求体，读了若干次输入流（将读取操作封装成了函数），发现就第一个参数有值，以后的读取都没有值。\n\n起初以为是参数名写错导致读取失败，检查发现不是这个问题。\n\n单步调试发现php://input只有第一次读取有值，以后的调用都是空。遇到这种问题往往需要查PHP的官方文档。\n\n在文档中找到以下说明：\n\n*php://input 是个可以访问请求的原始数据的只读流。 POST 请求的情况下，最好使用 php://input 来代替 $HTTP_RAW_POST_DATA，因为它不依赖于特定的 php.ini 指令。 而且，这样的情况下 $HTTP_RAW_POST_DATA 默认没有填充， 比激活 always_populate_raw_post_data 潜在需要更少的内存。 enctype=\"multipart/form-data\" 的时候 php://input 是无效的。*\n\n还有一个特别说明:\n\n*在 PHP 5.6 之前 php://input 打开的数据流只能读取一次； 数据流不支持 seek 操作。 不过，依赖于 SAPI 的实现，请求体数据被保存的时候， 它可以打开另一个 php://input 数据流并重新读取。 通常情况下，这种情况只是针对 POST 请求，而不是其他请求方式，比如 PUT 或者 PROPFIND。*\n\n而笔者本地的PHP是5.5.25版本的，所以只能读第一次。","tags":["file__get_contents"],"categories":["php"]},{"title":"微信公众平台开发NodeJs SDK","url":"%2F2016%2F08%2F09%2Fwechat-media-platform-nodejs-sdk.html","content":"*本SDK要求NodeJs >= 4.x，欢迎大家在issues提问。*\n\n## 项目地址\n[wechat-nodejs](https://github.com/xialeistudio/wechat-nodejs/)\n## 安装\n\n```bash\nnpm install wechat-nodejs ---save\n```\n\n## 说明\n使用所有sdk功能前需要初始化wechat句柄，初始化代码如下：\n\n```javascript\nconst Wechat = require('wechat-nodejs').Wechat;\nconst wechat = new Wechat(appId,appSecret);\n```\n\nSDK扩展了JS原始错误类，包含message,code属性，SDK中Promise抛出的错误code为微信返回的errcode，抛出一个自定义错误代码如下：\n\n```javascript\nconst AppError = require('wechat-nodejs').AppError;\nthrow new AppError('参数错误',1);\n```\n\n## 功能列表\n### 分组\n+ 初始化Group\n\n```javascript\nconst Group = require('wechat-nodejs').Group;\nconst group = new Group(wechat.getInstance());\n```\n\n+ 创建分组\n\n```javascript\ngroup.create('测试分组').then((data)=>{\n  console.log(data);\n}).catch((e)=>{\n  console.error(e.message,e.code);\n});\n```\n\n+ 获取所有分组\n\n```javascript\ngroup.getAll().then((data)=>{\n  console.log(data);\n}).catch((e)=>{\n  console.error(e.message,e.code);\n});\n```\n\n+ 获取用户所在分组\n\n```javascript\ngroup.getIdByOpenid(openid).then((groupId)=>{\n  console.log(groupId);\n}).catch((e)=>{\n  console.error(e.message,e.code);\n});\n```\n\n+ 修改分组名称\n\n```javascript\ngroup.update(100,'测试分组01').then((data)=>{\n  console.log(data);\n}).catch((e)=>{\n  console.error(e.message,e.code);\n});\n```\n\n+ 移动用户分组\n\n```javascript\ngroup.moveUserToGroup('oA-yljrYgywqN3SCXS_3jZnIP6Yw',100).then((data)=>{\n  console.log(data);\n}).catch((e)=>{\n  console.error(e.message,e.code);\n});\n```\n\n+ 批量移动用户分组\n\n```javascript\ngroup.moveUsersToGroup(['oA-yljrYgywqN3SCXS_3jZnIP6Yw'],100).then((data)=>{\n  console.log(data);\n}).catch((e)=>{\n  console.error(e.message,e.code);\n});\n```\n\n+ 删除分组\n\n```javascript\ngroup.remove(100).then((data)=>{\n  console.log(data);\n}).catch((e)=>{\n  console.error(e.message,e.code);\n});\n```\n\n### JSSDK\n+ 初始化JSSDK\n\n```javascript\nconst JSSDK = require('wechat-nodejs').JSSDK;\nconst jssdk = new JSSDK(wechat.getInstance());\n```\n\n+ 获取jsticket\n\n```javascript\njssdk.getTicket().then((ticket)=>{\n  console.log(ticket);\n}).catch((e)=>{\n  console.error(e.message,e.code);\n});\n```\n\n+ 获取jssdk配置参数\n\n```javascript\njssdk.getConfig('http://www.baidu.com',['onMenuShareTimeline'],false).then((config)=>{\n  console.log(config);\n}).catch((e)=>{\n  console.error(e.message,e.code);\n});\n```\n### 自定义菜单\n+ 初始化Menu\n\n```javascript\nconst Menu = require('wechat-nodejs').Menu;\nconst menu = new Menu(wechat.getInstance());\n```\n\n+ 创建自定义菜单\n\n```javascript\nconst button = [\n{\n  \"type\": \"click\",\n  \"name\": \"今日歌曲\",\n  \"key\": \"V1001_TODAY_MUSIC\"\n},\n{\n  \"name\": \"菜单\",\n  \"sub_button\": \n  [\n    {\n    \"type\": \"view\",\n    \"name\": \"搜索\",\n    \"url\": \"http://www.soso.com/\"\n    },\n    {\n    \"type\": \"view\",\n    \"name\": \"视频\",\n    \"url\": \"http://v.qq.com/\"\n    },\n    {\n    \"type\": \"click\",\n    \"name\": \"赞一下我们\",\n    \"key\": \"V1001_GOOD\"\n    }\n  ]\n}];\nmenu.create(button).then((data)=>{\n  console.log(data);\n}).catch((e)=>{\n  console.error(e.message,e.code);\n});\n```\n+ 查询自定义菜单\n\n```javascript\nmenu.get().then((data)=>{\n  console.log(data);\n}).catch((e)=>{\n  console.error(e.message,e.code);\n});\n```\n\n+ 删除自定义菜单\n\n```javascript\nmenu.remove().then((data)=>{\n  console.log(data);\n}).catch((e)=>{\n  console.error(e.message,e.code);\n});\n```\n\n+ 获取公众平台后台设置的自定义菜单\n\n```javascript\nmenu.getByWeb().then((data)=>{\n  console.log(data);\n}).catch((e)=>{\n  console.error(e.message,e.code);\n});\n```\n\n### 消息\n+ 初始化Message\n\n```javascript\nconst Message = require('wechat-nodejs').Message;\nconst message = new Message(wechat.getInstance());\n```\n\n+ 发送模板消息\n\n```javascript\nconst data = {\n  orderId: {\n    value: '20160101'\n  },\n  status: {\n    value: '已发货'\n  }\n};\nconst openid = 'oA-yljj5cBGSvnwFodHT1iqis7X8';\nconst templateId = 'G4C9rNCejbhyYzh7xsOh46pieLelrmj_bLQtRhdOqkY';\nconst url = 'https://github.com';\nmessage.sendTemplate(openid,templateId,url,data).then((data)=> {\n  data.should.have.property('errcode', 0);\n}).catch((e)=>{\n  console.error(e.message,e.code);\n});\n```\n\n### 用户\n+ 初始化User\n\n```javascript\nconst User = require('wechat-nodejs').User;\nconst user = new User(wechat.getInstance());\n```\n\n+ 设置用户备注名\n\n```javascript\nuser.setRemark('oA-yljj5cBGSvnwFodHT1iqis7X8','重要客户').then((data)=>{\n  console.log(data);\n}).catch((e)=>{\n  console.error(e.message,e.code);\n});\n```\n\n+ 获取用户信息\n\n```javascript\nuser.getInfo('oA-yljj5cBGSvnwFodHT1iqis7X8').then((data)=>{\n  console.log(data);\n}).catch((e)=>{\n  console.error(e.message,e.code);\n});\n```\n\n+ 批量获取用户信息\n\n```javascript\nuser.batchGetInfo(['oA-yljj5cBGSvnwFodHT1iqis7X8']).then((data)=>{\n  console.log(data);\n}).catch((e)=>{\n  console.error(e.message,e.code);\n});\n```\n\n+ 检测关注\n\n```javascript\nuser.isSubscribe('oA-yljj5cBGSvnwFodHT1iqis7X8').then((isSubscribe)=>{\n  console.log(isSubscribe);\n}).catch((e)=>{\n  console.error(e.message,e.code);\n});\n```\n\n+ 获取关注用户openid列表\n\n```javascript\nuser.getList('oA-yljj5cBGSvnwFodHT1iqis7X8').then((data)=>{\n  console.log(data);\n}).catch((e)=>{\n  console.error(e.message,e.code);\n});\n```\n\n## 单元测试\n终端执行：\n\n```bash\nnpm install mocha --save-dev\n```\n\n在本sdk根目录新建**config.json**，内容如下：\n\n```json\n{\n  \"wechat\": {\n    \"appId\": \"微信公众号appId\",\n    \"appSecret\": \"微信公众号appSecret\"\n  }\n}\n```\n\n终端执行：\n\n```bash\nnpm run test\n```\n\n## 授权协议\nMIT License","tags":["wechat-platform"],"categories":["open-source-projects"]},{"title":"node-sass安装镜像","url":"%2F2016%2F07%2F27%2Fnode-sass-install-mirror.html","content":"## 安装\nnpm安装node-sass模块的时候，会卡在 node scripts/install.js这里，因为要去github.com上下载源码，众所周知的原因，国内的网络上github.com速度太不稳定了，所以安装很慢。\n\n这里推荐一种极速安装的方法，当然还是使用万能的淘宝镜像源。\n\n打开~/.npmrc（windows用户打开 c:\\Users\\当前用户名\\.npmrc）增加一行\n\n```bash\nSASS_BINARY_SITE=https://npm.taobao.org/mirrors/node-sass/\n```\n\n终端执行:\n\n```bash\nnpm install node-sass\n```\n\n## 注意\n如果使用了较高版本的nodejs或者node-sass，此时镜像可能还未同步完成，所以请大家前往此链接查看受支持的node-sass:\n\n```\nhttps://npm.taobao.org/mirrors/node-sass/\n```\n\n该网页列出来的即为当前受支持的node-sass版本，开发的时候一般使用最新版本，本文写作时**node-sass**最新版本为**v4.0.0**，点击**v4.0.0**链接：\n\n```\nhttps://npm.taobao.org/mirrors/node-sass/v4.0.0/\n```\n\n可以看到新网页中有一个文件列表，后缀为**.node**的文件即位编译好的，文件名格式如下:\n\n```\n[platform]-[architecture]-[nodejs version]_binding.node\n```\n\n+ platform 操作系统平台 **darwin**为**Mac OS X**，**linux**为**linux**，**win32**为**windows**\n+ architecture 系统架构 目前有**x64**,**ia32**\n+ nodejs version nodejs版本号，取全版本号的前两位，比如**4.6.x**为**46**，**5.1.x**为**51**\n\n所以大家如果发现本网页没有出现你平台所需要的二进制文件，镜像也需要从github拉取数据，此时安装node-sass是不会加速的。","tags":["mirror"],"categories":["nodejs"]},{"title":"mybatis-generator-gui工具","url":"%2F2016%2F06%2F26%2Fmybatis-generator-gui-tool.html","content":"官方的mybatis-generator是个jar包只能写好xml配置后命令行生成，感觉略麻烦，这里用swing写了一个gui的开源版本，有需要的话可以去看看。   \n[项目地址](https://github.com/xialeistudio/mybatis-generator-gui)","tags":["mybatis-generator"],"categories":["open-source-projects"]},{"title":"android AsyncTask示例","url":"%2F2016%2F06%2F23%2Fandroid-asynctask-demo.html","content":"\nandroid实现异步的方法有很多种，本文只介绍用的比较多的AsyncTask。从类名就可以看出来该类是专为异步而生，API也很简单。\n\n## AsyncTask接口原型\n\n```java\npublic abstract class AsyncTask<Params, Progress, Result> {\n...\n}\n```\n\n该类是个抽象类，有三个泛型参数，说明如下：\n+ Params\t任务参数类型，比如加载网络图片时，这里传入String\n+ Progress\t更新进度时参数类型，一般传入Integer\n+ Result\t执行结果类型，比如加载网络图片时，结果为Bitmap\n\n该类的主要方法如下：\n+ doInBackground(Params... params)\t非主线程\t执行异步任务，params为声明类时的泛型\n+ onPreExecute\t主线程\t准备执行异步任务时调用\n+ onPostExecute(Result result)\t主线程\t异步任务执行完毕时调用，result为声明类时的泛型\n+ onProgressUpdate(Progress... values)\t主线程\t任务进度有更新时调用，values为声明类时的泛型\n+ publishProgress(Progress... values)\t非主线程\t更新异步任务进度，此方法一般在doInBackground中调用\n\n## 示例\n本文将使用一个图片批量下载程序作为示例   \n根据需求可以确定，任务参数是String类型，进度是Integer类型，执行结果是List<Bitmap>类型，项目代码如下：\n\n### 布局文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<ScrollView xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <LinearLayout\n        android:id=\"@+id/contentView\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:orientation=\"vertical\">\n\n        <Button\n            android:id=\"@+id/btnStart\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\"\n            android:layout_gravity=\"center_horizontal\"\n            android:onClick=\"loadImage\"\n            android:text=\"@string/start\" />\n\n        <ProgressBar\n            android:id=\"@+id/progressBar\"\n            style=\"?android:attr/progressBarStyleHorizontal\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\"\n            android:layout_marginTop=\"16dp\"\n            android:progress=\"0\"\n            android:visibility=\"gone\" />\n    </LinearLayout>\n\n</ScrollView>\n```\n\n### MainActivity.java\n\n```java\npackage com.ddhigh.asynctaskdemo;\n\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport android.os.AsyncTask;\nimport android.os.Bundle;\nimport android.support.v7.app.AppCompatActivity;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.ImageView;\nimport android.widget.LinearLayout;\nimport android.widget.ProgressBar;\n\nimport java.io.BufferedInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class MainActivity extends AppCompatActivity {\n\n    private ProgressBar mProgressBar;\n    private LinearLayout mLinearLayout;\n    private final String[] urls = {\n            \"http://n.sinaimg.cn/news/crawl/20160623/rGdP-fxtmwep2657001.jpg\",\n            \"http://n.sinaimg.cn/news/crawl/20160623/6mXQ-fxtmweh2331418.jpg\",\n            \"http://n.sinaimg.cn/news/crawl/20160623/z6Io-fxtmwep2657003.jpg\",\n            \"http://n.sinaimg.cn/news/crawl/20160623/U9QQ-fxtmweh2331421.jpg\",\n            \"http://n.sinaimg.cn/news/crawl/20160623/BIdM-fxtmweh2331423.jpg\"\n    };\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        mProgressBar = (ProgressBar) findViewById(R.id.progressBar);\n        mLinearLayout = (LinearLayout) findViewById(R.id.contentView);\n\n    }\n\n    public void loadImage(View view) {\n        ImageTask imageTask = new ImageTask();\n        imageTask.execute(urls);\n    }\n\n    private class ImageTask extends AsyncTask<String, Integer, List<Bitmap>> {\n        @Override\n        protected void onPreExecute() {\n            mProgressBar.setVisibility(View.VISIBLE);\n            mProgressBar.setMax(urls.length);\n        }\n\n        @Override\n        protected List<Bitmap> doInBackground(String... params) {\n            List<Bitmap> list = new ArrayList<>();\n            int i = 0;\n            for (String url : params) {\n                URLConnection connection;\n                Bitmap bitmap;\n                InputStream inputStream;\n                try {\n                    connection = new URL(url).openConnection();\n                    inputStream = connection.getInputStream();\n                    BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream);\n                    bitmap = BitmapFactory.decodeStream(bufferedInputStream);\n                    inputStream.close();\n                    bufferedInputStream.close();\n                    list.add(bitmap);\n                    publishProgress(++i);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return list;\n        }\n\n        @Override\n        protected void onPostExecute(List<Bitmap> bitmaps) {\n            for (Bitmap bitmap : bitmaps) {\n                ImageView imageView = new ImageView(MainActivity.this);\n                ViewGroup.LayoutParams layoutParams = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);\n                imageView.setLayoutParams(layoutParams);\n                imageView.setImageBitmap(bitmap);\n                mLinearLayout.addView(imageView);\n            }\n        }\n\n        @Override\n        protected void onProgressUpdate(Integer... values) {\n            mProgressBar.setProgress(values[0]);\n        }\n    }\n}\n```\n\n使用AsyncTask的核心在于重写相应方法实现自己的逻辑即可。\n\n### 源码\n[Android-AsyncTaskDemo](https://github.com/xialeistudio/Android-AsyncTaskDemo)","tags":["AsyncTask"],"categories":["android"]},{"title":"C++ RTTI 示例","url":"%2F2016%2F06%2F20%2Fcpp-rtti-demo.html","content":"```cpp\n#include <iostream>\n#include <stdlib.h>\n#include <string>\n#include <typeinfo>\nusing namespace std;\n\n/**\n* 定义移动类：Movable\n* 纯虚函数：move\n*/\nclass Movable\n{\n  public:\n    virtual void move() = 0;\n};\n\n/**\n* 定义公交车类：Bus\n* 公有继承移动类\n* 特有方法carry\n*/\nclass Bus : public Movable\n{\n  public:\n    void move()\n    {\n      cout << \"Bus -- move\" << endl;\n    }\n  \n    void carry()\n    {\n      cout << \"Bus -- carry\" << endl;\n    }\n};\n\n/**\n* 定义坦克类：Tank\n* 公有继承移动类\n* 特有方法fire\n*/\nclass Tank :public Movable\n{\n  public:\n    void move()\n    {\n      cout << \"Tank -- move\" << endl;\n    }\n\n    void fire()\n    {\n      cout << \"Tank -- fire\" << endl;\n    }\n};\n\n/**\n* 定义函数doSomething含参数\n* 使用dynamic_cast转换类型\n*/\nvoid doSomething(Movable *obj)\n{\n  obj->move();\n\n  if (typeid(*obj) == typeid(Bus))\n  {\n   Bus *bus = dynamic_cast<Bus *>(obj);\n   bus->carry();\n  }\n\n  if (typeid(*obj) == typeid(Tank))\n  {\n   Tank *tank = dynamic_cast<Tank *>(obj);\n   tank->fire();\n  }\n}\n\nint main(void)\n{\n  Bus *b = new Bus;\n  Tank *t = new Tank;\n  doSomething(b);\n  doSomething(t);\n  delete b;\n  delete t;\n  return 0;\n}\n```","tags":["dynamic_cast"],"categories":["cpp"]},{"title":"js在线调试工具","url":"%2F2016%2F06%2F12%2Fjs-live-console.html","content":"在进行微信开发的时候，由于JS SDK提供的api需要在真机调试，而手机端的console方法虽然存在，但是调用结果却看不到。所以笔者使用socket.io重写了一个在线版本的调试工具。\n\n[工具地址](http://jsconsole.org/)\n\n## 使用方法\n+ 打开 http://jsconsole.duapp.com?token=【您的标识符】 请确保标识符全局唯一，否则其他人可能会看到你的调试信息哟！   \n+ 在需要调试的页面引入以下js:   \n\n```html\n<script src=\"http://jsconsole.duapp.com/dist/chat.bundle.js\"></script>\n<script src=\"http://jsconsole.duapp.com/dist/client.js?token=【您的标识符】\"></script>\n```\n\n+ 开始调试！","tags":["socket"],"categories":["front-end"]},{"title":"phpstorm+xdebug远程调试服务器PHP代码","url":"%2F2016%2F06%2F08%2Fphpstorm-xdebug-remote-debug.html","content":"phpstorm+xdebug如何调试本地代码应该都熟悉了。本文说的是如何调试线上服务器的代码。本文写作时服务器的PHP环境是lnmp1.2。\n\n## 服务器配置\n### 安装debug\n\n```bash\npecl install xdebug\n```\n\n### 编辑php.ini\n编辑 **/usr/local/php/etc/php.ini**，在末尾加上以下代码：\n\n```\n[Xdebug]\nzend_extension=\"xdebug.so\"\nxdebug.remote_enable=1\nxdebug.remote_handler=dbgp\nxdebug.remote_host=【调试终端所在的公网IP】\nxdebug.remote_port=9000\nxdebug.remote_autostart=1\nxdebug.idekey=\"PHPSTORM\"\n```\n\n本文中调试终端为**PHPSTORM**，所以本地公网IP为**remote_host**的值   \n[查看本地公网IP](http://www.ip138.com)   \n更改配置完毕后终端执行:\n\n```bash\nlnmp php-fpm reload\n```\n\n## IDE配置\n### 配置server\nSetting => Languages & Frameworks=>PHP=>Servers，\n![Server配置](https://og5r5kasb.qnssl.com/wp-content/uploads/2016/06/QQ%E5%9B%BE%E7%89%8720160608121441.png)   \n### 配置DBGp Proxy\nSettings => Languages & Frameworks => PHP => Debug => DBGp Proxy\n![DBGp Proxy](https://og5r5kasb.qnssl.com/wp-content/uploads/2016/06/QQ%E5%9B%BE%E7%89%8720160608121659.png)   \n其中红框处需要和服务器的xdebug配置文件一致。\n## 路由端口映射\n由于大部分朋友公司都有路由器的，所以本机IP是局域网IP，这里需要将路由器的端口映射到本地。具体规则如下：\n\n```\n服务器Xdebug端口（路由器公网端口） => 本地端口，笔者这里把路由器的9000端口映射到本地的9000端口。\n```\n\n## 开始调试\n+ 打开项目的运行配置，选择“PHP Web Application”   \n![开始调试](https://og5r5kasb.qnssl.com/wp-content/uploads/2016/06/QQ%E5%9B%BE%E7%89%8720160608122018.png)   \n笔者服务器这里是https的，所以加了https，各位读者请根据实际情况填写网址。\n+ 点击IDE的“电话”图标开启远程监听。   \n![监听](https://og5r5kasb.qnssl.com/wp-content/uploads/2016/06/QQ%E6%88%AA%E5%9B%BE20160608122148.png)   \n+ 代码断点   \n![代码断点](https://og5r5kasb.qnssl.com/wp-content/uploads/2016/06/QQ%E6%88%AA%E5%9B%BE20160608122222.png)   \n+ 开始调试   \n![开始调试](https://og5r5kasb.qnssl.com/wp-content/uploads/2016/06/QQ%E6%88%AA%E5%9B%BE20160608122259.png)   \n+ IDE自动弹出调试窗口   \n![IDE自动弹出调试窗口](https://og5r5kasb.qnssl.com/wp-content/uploads/2016/06/QQ%E6%88%AA%E5%9B%BE20160608122347.png)   ","tags":["remote debug"],"categories":["php"]},{"title":"ios ScrollView AutoLayout","url":"%2F2016%2F06%2F02%2Fios-scrollview-autolayout.html","content":"XCode的Interface Builder解决了开发者使用代码进行布局的问题，但是在使用 **ScrollView** 时，如果没有方法，IB中的layout是会乱掉的，在网上查找资料加上自己的实际操作之后，总结了以下步骤：\n1. 在根view中添加好子控件，排好版\n2. 选中所有子控件，选择菜单 *Editor In* => *View*，命名为 **contentView**，此时编辑器会报警，暂时不理会\n3. 给contentView添加上下左右4个约束，值全部为**0**\n4. 选择contentView，选择菜单 *Editor In* => *ScrollView*\n5. 设置ScrollView的上下左右4个约束，值全部为**0**\n6. 给contentView加上height约束，并在Interface Builder中设置合适的约束值。\n\n","tags":["scrollview"],"categories":["ios"]},{"title":"nginx使用goddy ssl证书","url":"%2F2016%2F05%2F23%2Fnginx-goddy-ssl.html","content":"随着人们对网络安全要求的提高，越来越多的http站点已经转换为了https站点，保证网站在传输过程中不被监听、恶意篡改，本文将使用goddy提供的ssl证书来升级HTTPS网站。\n\n## 生成私钥和证书请求文件\n终端执行\n\n```bash\nopenssl req -new -newkey rsa:2048 -nodes -keyout domain.key -out domain.csr\n```\n\n生成过程会询问几个常见问题，比如City、Country等等。   \n最后会询问challenge password，输入的时候记住就可以了。   \n执行完以上命令后，当前目录会多出**domain.key**和**domain.csr**文件，前者为服务器私钥，后者为证书请求文件\n\n## Goddy证书\n购买完SSL证书之后会有一个初始化过程，将第1步中的**domain.csr**文件所有内容填写到**CSR**输入框中，Goddy会检测配置等操作，操作完成之后会签发证书，点击下载即可，下载时服务器类型选择“其他”。\n\n## Nginx配置\n下载证书的时候压缩包内容类似如下图   \n![压缩包](https://og5r5kasb.qnssl.com/wp-content/uploads/2016/05/QQ%E5%9B%BE%E7%89%8720160523195944.png)   \n\n正常情况下nginx配置SSL需要key和crt文件即可。   \n这里有两个crt所以需要进行证书合并操作。   \n打开终端，执行以下命令：\n\n```bash\ncat 53f58e3ac2172cd5.crt gd_bundle-g2-g1.crt > domain.crt\n```\n\n证书合并完成，接下来打开Nginx的配置文件，笔者这里**证书目录**位于**/root/crt**\n\n```\nserver\n{\n  listen 443;\n  server_name domain;\n  index index.html index.htm default.html default.htm;\n  root /home/wwwroot/domain;\n  \n  location = /favicon.ico {\n    log_not_found off;\n    access_log off;\n  }\n  ssl on;\n  ssl_certificate /root/crt/domain.crt;\n  ssl_certificate_key /root/crt/domain.key;\n  access_log off;\n}\n```\n\n保存之后，终端执行\n\n```bash\nnginx -s reload\n```\n","tags":["goddy"],"categories":["nginx"]},{"title":"NodeJs进程守护工具forever使用","url":"%2F2016%2F05%2F23%2Fprocess-daemon-forever.html","content":"nodejs是单进程的，如果应用中发生未捕获的异常，进程就会退出，一个比较笨的办法在系统中使用计划任务检查进程是否存在，如果不存在启动该程序，但是该方式会造成系统资源的浪费，而且不是及时的。\n\n好在NodeJs活跃的社区给开发者提供了一个选择**forever**，该包就是用来解决以上状况的。\n\n## 安装\n\n```bash\nnpm install forever -g\n```\n\n## 启动脚本\n\n```bash\nforever start app.js\n```\n\n## 查看目前监控任务\n\n```bash\nforever list\n```","tags":["forevet"],"categories":["nginx"]},{"title":"ReactRouter不在组件中进行导航","url":"%2F2016%2F05%2F17%2Freact-router-navigation-outside-of-components.html","content":"项目使用了**Flux+React Router**架构，有一些需要操作路由的地方是放在Action层的，比如登录之类，但是Action层不是React组件，需要操作路由的话有点麻烦。   \n\n当然最终还是有一个办法的，利用**window.location.href=**，但是既然用了react，再用这种导航模式未免不妥。   \n\n查看react router源码发现,**hashHistory,browseHistory**中有**push**方法，经过测试之后可行。\n\n```javascript\nimport {hashHistory} from 'react-router';\nhashHistory.push('/login');\n```","tags":["react router"],"categories":["react"]},{"title":"安装nodejs的shell脚本","url":"%2F2016%2F05%2F14%2Fshell-install-nodejs.html","content":"## 脚本定义\n\n```bash\n#!/bin/bash\nexport NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node\ngit clone https://github.com/creationix/nvm.git ~/.nvm\nsource ~/.nvm/nvm.sh\nnvm install 4.4.2\n```\n\n## 脚本执行\n\n```bash\nchmod +x ./install.sh\n./install.sh\n```\n\nnodejs版本大家可以 根据实际需要进行选择","tags":["bash"],"categories":["bash"]},{"title":"wordpress WPImageEditorImagick 漏洞临时修复方案","url":"%2F2016%2F05%2F12%2Ffix-wordpress-wpimageeditorimagick-bug.html","content":"4.5.1存在该漏洞，但是更新到4.5.2发现漏洞依旧存在。   \n临时修复方案如下：   \n文件路径：\n\n```\n/wp-includes/media.php的_wp_image_editor_choose\n```\n\n将\n\n```php\n$implementations = apply_filters( 'wp_image_editors', array( 'WP_Image_Editor_Imagick' ,'WP_Image_Editor_GD' ) );\n```\n\n改为\n\n```php\n$implementations = apply_filters( 'wp_image_editors', array(  'WP_Image_Editor_GD', 'WP_Image_Editor_Imagick' ) );\n```\n\n*此方法为临时解决方案，请大家及时更新最新版本的wordpress*","tags":["imagick"],"categories":["php"]},{"title":"JS提取字符串中文英文数字","url":"%2F2016%2F05%2F10%2Fjs-extract-chinese-words-number-of-string.html","content":"最近在做导出excel的时候，发现导出成功，文件大小也正常，但是Office 2013打不开，检查数据库发现，导出数据中有非中文字符导致Excel异常。   \n\n我们知道JS是支持unicode字符集的，符合导出规则的字符应该是\"中文\"、\"英文\"、\"数字\"。\n\n## 正则表达式\n\n```javascript\n/([\\u4e00-\\u9fa5\\w]*)/ig\n```\n\n## 提取字符串\n\n```javascript\n/**\n* 获得可打印字符\n* @param str 需要提取的字符串\n*/\nfunction getPrintableChars(str) {\n  const matches = str.match(/([\\u4e00-\\u9fa5\\w]*)/ig);\n  let a = '';\n  matches.forEach(item=> item && (a += item));\n  return a;\n}\n```","tags":["js"],"categories":["javascript"]},{"title":"angularjs显示html文本","url":"%2F2016%2F03%2F29%2Fangularjs-display-html.html","content":"Angularjs中输出变量使用**花括号**或者**ng-bind**，但是如果变量中有html代码的话，angularjs为了xss安全，默认是不解析html，直接原样显示html代码。   \n如果需要显示解析后的html代码，需要使用**angular-sanitize**模块。\n\nangular-sanitize一般会附带在angularjs中，如果没有附带，请前往官网下载对应版本的angular-sanitize模块。\n## 模块代码\n\n```javascript\nvar demo = angular.module('demo',['ng-sanitize']);\n```\n\n## 控制器代码\n\n```javascript\ndemo.controller('Demo13Controller', [\n  '$scope', function($scope) {\n    $scope.html = '<span style=\"color: red\">这是格式化的HTML文本</span>';\n  }\n]);\n```\n\n## 视图代码\n\n```html\n<article class=\"demo13\" ng-controller=\"Demo13Controller\">\n<h2><a name=\"demo13\">13.显示HTML文本</a></h2>\n<div class=\"demo13-content\">\n<p>需要显示的文本：</p>\n<p>Html格式化文本： <span ng-bind-html=\"html|htmlContent\"></span></p>\n</div>\n</article>\n```\n\n## 过滤器代码\n\n```javascript\ndemo.filter('htmlContent',['$sce', function($sce) {\n  return function(input) {\n    return $sce.trustAsHtml(input);\n  }\n}]);\n```\n\n## 总结\n$sce过滤器+ng-bind-html就可以显示html文本了。","tags":["sanitize"],"categories":["angularjs"]},{"title":"React Flux ES6记事本应用","url":"%2F2016%2F03%2F24%2Freact-flux-es6-note-app.html","content":"\n## 项目地址\n\n[react-notepad-es6](https://github.com/xialeistudio/react-notepad-es6.git)\n\nReact出来有很久了，与angularjs最大的不同在于React只是一个处理UI层面的库，可以认为是“V”，而angularjs则是一整套解决方案。   \n\n随着前端开发的组件化思想越来越浓烈，angularjs很多场合已经显得力不从心了。而这时候，核心为“模块化、组件化”的React可以派上永用场。真正用来开发项目的话，React肯定是不足的，缺少C和M模块。   \n\nFacebook官方推荐的Flux可以认为是一个简单的解决方案，Flux没什么特别含义，就是一个facebook随便找的一个词而已。至于什么是Flux，本文不做解释，本文以Flux来开发一个记事本应用。\n\n## 项目目录\n\n```\n|----action    Action Creator\n\n    |---- NoteAction.js    记事本应用需要的动作\n\n|----css    样式文件目录\n\n    |---- style.scss    样式文件\n\n|----dispatcher    分发器目录\n\n    |---- AppDispatcher.js    分发器\n\n|----store    Store目录\n\n    |---- NoteStore.js     存储日记数据以及处理AppDispatcher派发事件\n\n|----view    视图&组件目录\n\n    |---- Note.jsx    单条日记\n\n    |---- NoteBox.jsx    整个日记组件的父容器\n\n    |---- NoteForm.jsx    日记创建/编辑表单\n\n    |----NoteList.jsx    日记列表组件\n\n|----entry.js    webpack入口文件\n\n|----index.html    项目页面\n\n|----webpack.config.js    webpack配置文件\n```\n\n## 项目思路\n1. NoteList.jsx组件包含多个Note.jsx，NoteList.jsx的数据来源于NoteStore.js。\n2. 创建日记时，NoteForm.jsx需要调用NoteAction的add方法最终触发AppDispatcher.dispatch方法\n3. NoteStore注册AppDispatcher的监听器实现对dispatch事件的监听\n4. 编辑日记时，Note.jsx调用NoteAction的setNote方法设置需要编辑的日记，通过AppDispatcher的调度之后最终将日记数据显示在NoteForm.jsx组件中。\n\n## 项目实现\n### 安装依赖\n本文采用ES6语法进行开发， 所以需要安装babel编译器，打开终端执行以下命令：\n\n```bash\nnpm init -y\nnpm install webpack webpack-dev-server -g\nnpm install flux microevent react react-dom --save\nnpm install babel-loader css-loader jsx-loader sass-loader style-loader --save-dev\nnpm instlal babel-preset-es2015 babel-preset-react --save-dev\nnpm install microevent --save\n```\n\n### webpack.config.js\n\n```javascript\n/**\n * Created by xialei on 2016/3/23 0023.\n */\nmodule.exports = {\n  entry: './entry.jsx',\n  output: {\n    publicPath: 'http://localhost:8000/assets',\n    filename: 'bundle.js',\n    path: './assets'\n  },\n  module: {\n    loaders: [\n    {test: /\\.js$/, loader: 'babel'},\n    {\n      test: /.jsx?$/,\n      loader: 'babel-loader',\n      exclude: /node_modules/,\n      query: {\n        presets: ['es2015', 'react']\n      }\n    },\n    {test: /\\.css$/, loader: 'style!css'},\n    {test: /\\.scss$/, loader: 'style!css!sass'}\n    ]\n  },\n  resolve: {\n    extensions: ['', '.js', '.jsx']\n  }\n};\n```\n\n### dispatcher/AppDispatcher.js\n\n```javascript\nimport Flux from 'flux';\nlet AppDispatcher = new Flux.Dispatcher();\nexport default AppDispatcher;\n```\n\n### action/NoteAction.js\nActionCreator主要是为了简化代码量，不然每次需要触发动作的时候都需要调用AppDispatcher.dispatch方法。   \n根据项目实际情况，可以总结出需要以下动作：\n+ 创建日记\n+ 更新日记\n+ 删除日记\n+ 编辑日记\n\n由于ActionCreator是为了简化AppDispatcher.dispatch的方法调用，所以需要引入该模块。   \n\n```javascript\n/**\n * Created by xialei on 2016/3/23 0023.\n */\nimport AppDispatcher from '../dispatcher/AppDispatcher';\nexport default class NoteAction {\n  static create(item) {\n    AppDispatcher.dispatch({\n      eventName: 'create-note',\n      item: item\n    });\n  }\n\n  static update(item) {\n    AppDispatcher.dispatch({\n      eventName: 'update-note',\n      item: item\n    });\n  }\n\n  static remove(item) {\n    AppDispatcher.dispatch({\n      eventName: 'remove-note',\n      item: item\n    });\n  }\n\n  static setNote(item) {\n    AppDispatcher.dispatch({\n      eventName: 'set-note',\n      item: item\n    });\n  }\n}\n```\n\n### store/NoteScore.js\n有了分发，就要有接收，所以接下来编辑 store/NoteScore.js文件，这里需要注意的是由于V中不要直接调用AppDispatcher.dispatch，但是V是肯定需要监听事件的，所以这里使用**MicroEvent**库来进行事件处理。\n\n```javascript\n/**\n * Created by xialei on 2016/3/23 0023.\n */\nimport AppDispatcher from '../dispatcher/AppDispatcher';\nimport MicroEvent from 'microevent';\nclass NoteStore {\n  constructor() {\n    this.items = [];\n  }\n}\n\nMicroEvent.mixin(NoteStore);\nlet store = new NoteStore();\n\nAppDispatcher.register((payload)=> {\n  switch (payload.eventName) {\n    case 'create-note':\n      store.items.push(payload.item);\n      store.trigger('change');\n      break;\n    case 'update-note':\n      store.items.forEach(function(i, index2) {\n        if (i.id == payload.item.id) {\n          store.items[index2] = payload.item;\n          store.trigger('change');\n        }\n      });\n      break;\n    case 'remove-note':\n      store.items.forEach(function(i, index2) {\n        if (i.id == payload.item.id) {\n          store.items.splice(index2, 1);\n          store.trigger('change');\n        }\n      });\n      break;\n    case 'set-note':\n      store.trigger('set', payload.item);\n      break;\n  }\n  return true;\n});\nexport default store;\n```\n\n### view/Note.jsx\n该组件主要负责单条日记的显示和操作，所以该组件需要有一个初始属性以及编辑/删除方法，由于编辑日记最终会放在NoteForm.jsx组件进行，所以此处使用props而不是state。\n\n```javascript\n/**\n * Created by xialei on 2016/3/23 0023.\n */\nimport React from 'react';\nimport NoteAction from '../action/NoteAction';\nexport default class Note extends React.Component {\n  constructor() {\n    super();\n    this.handleDelete = this.handleDelete.bind(this);\n    this.handleUpdate = this.handleUpdate.bind(this);\n  }\n\n  handleUpdate() {\n    NoteAction.setNote(this.props.note);\n  }\n\n  handleDelete() {\n    if (confirm('确定删除吗?')) {\n      NoteAction.remove(this.props.note);\n    }\n  }\n\n  render() {\n    return (\n      <div className=\"note-item\">\n        <div className=\"id\">{this.props.note.id}</div>\n        <div className=\"text\">{this.props.note.text}</div>\n        <div className=\"operation\">\n          <button type=\"button\" onClick={this.handleUpdate}>编辑</button>\n          <button type=\"button\" onClick={this.handleDelete}>删除</button>\n        </div>\n      </div>\n    );\n  }\n}\n```\n\n由于采用了ES6语法，所以此处需要对this做特殊处理，否则会提示props undefined之类的错误。\n\n### view/NoteBox.jsx\n该组件的作用是将日记列表和日记表单显示出来，所以该组件只有一个构造方法和render方法。\n\n```javascript\n/**\n * Created by xialei on 2016/3/23 0023.\n */\nimport NoteList from './NoteList';\nimport NoteForm from './NoteForm';\nimport React from 'react';\nexport default class NoteBox extends React.Component {\n  render() {\n    return (\n      <div className=\"note-box\">\n        <NoteList/>\n        <NoteForm/>\n      </div>\n    );\n  }\n}\n```\n\n### view/NoteForm.jsx\n该组件需要完成的事情比较多：\n1. 需要对编辑和创建进行分别处理\n2. 需要监听Note.jsx组件触发的编辑事件\n3. 可编辑的文本域\n\n根据以上要求，可以得出以下结论：\n\n1. 需要使用state，以及设置一个初始的state\n2. 在textarea的onChange事件中，将值设置到state中去\n3. 需要监听NoteStore触发的“set”事件，将需要编辑的日记显示在textarea中\n\n```javascript\n/**\n * Created by xialei on 2016/3/23 0023.\n */\nimport React from 'react';\nimport NoteAction from '../action/NoteAction';\nimport NoteStore from '../store/NoteStore';\nexport default class NoteForm extends React.Component {\n  constructor() {\n    super();\n    this.handleClick = this.handleClick.bind(this);\n    this.handleSetNote = this.handleSetNote.bind(this);\n    this.handleChange = this.handleChange.bind(this);\n    this.resetForm = this.resetForm.bind(this);\n    this.state = {\n      note: {\n        id: 0,\n        text: ''\n      }\n    };\n  }\n\n  componentDidMount() {\n    NoteStore.bind('set', this.handleSetNote);\n  }\n\n  componentWillUnmount() {\n    NoteStore.unbind('set', this.handleSetNote);\n  }\n\n  isCreate() {\n    return this.state.note.id == 0;\n  }\n\n  handleClick() {\n  let text = this.refs.input.value;\n  if (text.length == 0) {\n    alert('请输入日记内容');\n    this.refs.input.focus();\n    return;\n  }\n  if (this.isCreate()) {\n    let id = 1;\n    if (NoteStore.items.length > 0) {\n      id = NoteStore.items[NoteStore.items.length - 1].id + 1;\n    }\n    NoteAction.create({\n      id: id,\n      text: text\n    });\n   }\n  else {\n    let note = this.state.note;\n    note.text = text;\n    NoteAction.update(note);\n  }\n    this.resetForm();\n  }\n\n  render() {\n  let note = this.state.note.text;\n  let btnText = this.isCreate() ? '创建' : '编辑';\n  let tips = this.isCreate() ? '' : '当前编辑 [' + this.state.note.id + '] 号日记';\n  return (\n    <div className=\"note-form\">\n    <div>{tips}</div>\n    <textarea ref=\"input\" rows=\"8\" placeholder=\"日记内容\" value={note} onChange={this.handleChange}/>\n      <button type=\"button\" onClick={this.handleClick}>{btnText}</button>\n      <button type=\"button\" onClick={this.resetForm}>重置</button>\n    </div>\n  );\n }\n\n  handleChange(e) {\n  let id = this.state.note.id || 0;\n  this.setState({\n    note: {\n      id: id,\n      text: e.target.value\n    }\n  });\n }\n\n  handleSetNote(note) {\n    this.setState({note: note});\n    console.log('set ', this.state.note);\n  }\n\n  resetForm() {\n    this.setState({\n      note: {\n        id: 0,\n        text: ''\n      }\n    });\n  }\n}\n```\n\n### view/NoteList.jsx\n该组件负责渲染NoteStore中的日记列表以及对NoteStore触发的change事件作出相应，实时显示最新数据。\n\n```javascript\n/**\n * Created by xialei on 2016/3/23 0023.\n */\nimport React from 'react';\nimport NoteStore from '../store/NoteStore';\nimport Note from './Note';\nexport default class NoteList extends React.Component {\n  constructor() {\n    super();\n    this.handleChanged = this.handleChanged.bind(this);\n  }\n\n  componentDidMount() {\n    NoteStore.bind('change', this.handleChanged);\n  }\n\n  componentWillUnmount() {\n    NoteStore.unbind('change', this.handleChanged);\n  }\n\n  handleChanged() {\n    this.forceUpdate();\n  }\n\n  render() {\n    const notes = NoteStore.items.map((item)=> {\n      return <Note note={item} key={item.id}/>;\n    });\n    return (\n      <div className=\"note-list\">{notes}</div>\n    );\n  }\n}\n```\n\n## entry.jsx\n该文件主要将NoteBox.jsx组件渲染到html容器中。\n\n```javascript\n/**\n * Created by xialei on 2016/3/23 0023.\n */\nimport ReactDOM from 'react-dom';\nimport NoteBox from './view/NoteBox';\nimport './css/style.scss';\nReactDOM.render(<NoteBox/>, document.querySelector('#content'));\n```\n\n## index.html\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>Title</title>\n  <script src=\"./node_modules/react/dist/react-with-addons.js\"></script>\n</head>\n<body>\n  <div id=\"content\"></div>\n  <script src=\"http://localhost:8000/webpack-dev-server.js\"></script>\n  <script src=\"http://localhost:8000/assets/bundle.js\"></script>\n</body>\n</html>\n```\n\n## 项目运行\n\n```bash\nwebpack-dev-server --progress --colors --port 8000\n```\n\n[demo](http://ngdemo.sinaapp.com/react-notepad)","tags":["flux"],"categories":["react"]},{"title":"android选择图片返回统一图片地址","url":"%2F2016%2F03%2F02%2Fandroid-pick-image-return-image-path.html","content":"android从选择图片有两种方法，但是返回值确不同，本文将指导大家如何统一这两种方式的返回值。\n\n```java\n//关键代码\n@Event(R.id.btnPhoto)\n   private void onBtnPhotoClicked(View view) {\n       Intent intent = new Intent(Intent.ACTION_PICK, MediaStore.Images.Media.EXTERNAL_CONTENT_URI);\n       startActivityForResult(intent, Config.Constants.CODE_PICK_IMAGE_FROM_PHOTO);\n   }\n\n   @Event(R.id.btnCamera)\n   private void onBtnCameraClicked(View view) {\n       Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);\n       startActivityForResult(intent, Config.Constants.CODE_PICK_IMAGE_FROM_CAMERA);\n   }\n   \n   @Override\n   protected void onActivityResult(int requestCode, int resultCode, Intent data) {\n       switch (requestCode) {\n           case Config.Constants.CODE_PICK_IMAGE_FROM_CAMERA:\n               if (data != null && data.hasExtra(\"data\")) {\n                   Bitmap bitmap = data.getParcelableExtra(\"data\");\n                   bitmap = BitmapUtil.scale(bitmap, 640.0f / bitmap.getWidth());\n                   try {\n                       File path = new File(((MyApplication) getApplication()).appPath, DateUtil.format(new Date(), \"yyyyMMddHHmmss\") + \".jpg\");\n                       FileOutputStream outputStream = new FileOutputStream(path);\n                       bitmap.compress(Bitmap.CompressFormat.JPEG, 100, outputStream);\n                       outputStream.close();\n                       Intent intent = new Intent();\n                       intent.putExtra(\"path\", path.getAbsolutePath());\n                       setResult(RESULT_OK, intent);\n                   } catch (IOException e) {\n                        e.printStackTrace();\n                   }\n               }\n               finish();\n               break;\n           case Config.Constants.CODE_PICK_IMAGE_FROM_PHOTO:\n               if(data != null){\n                   Uri uri = data.getData();\n                   Bitmap bitmap;\n                   ContentResolver contentResolver = getContentResolver();\n                   try {\n                       bitmap = MediaStore.Images.Media.getBitmap(contentResolver, uri);\n                       bitmap = BitmapUtil.scale(bitmap, 640.0f / bitmap.getWidth());\n                       File path = new File(((MyApplication) getApplication()).appPath, DateUtil.format(new Date(), \"yyyyMMddHHmmss\") + \".jpg\");\n                       FileOutputStream outputStream = new FileOutputStream(path);\n                       bitmap.compress(Bitmap.CompressFormat.JPEG, 100, outputStream);\n                       outputStream.close();\n                       Intent intent = new Intent();\n                       intent.putExtra(\"path\", path.getAbsolutePath());\n                       setResult(RESULT_OK, intent);\n                   } catch (IOException e) {\n                       e.printStackTrace();\n                   }\n               }\n               finish();\n               break;\n           default:\n               super.onActivityResult(requestCode, resultCode, data);\n       }\n   }\n//BitmapUtil.java\npublic static Bitmap scale(Bitmap bitmap, float scale) {\n    Matrix matrix = new Matrix();\n    matrix.postScale(scale, scale);\n    return Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(), bitmap.getHeight(), matrix, true);\n}\n\n//MyApplication\npublic File appPath;\n\n@Override\npublic void onCreate() {\n    super.onCreate();\n    //创建目录\n    appPath = new File(Environment.getExternalStorageDirectory(), getPackageName());\n    if (!appPath.isDirectory()) {\n        appPath.mkdir();\n    }\n}\n```\n\n经过统一处理之后，返回值均为图片的绝对路径地址。","tags":["android"],"categories":["android"]},{"title":"百度推送收到消息时带参数启动activity","url":"%2F2016%2F02%2F19%2Fbaidu-push-launch-app-with-params.html","content":"一般来说，在BPushReceiver的onNotificationClicked或者onMessage方法收到推送消息后会去启动一个activity。此时整个应用有以下几种状态：\n+ 应用进程不存在\n+ 应用进程存在，但是不在前台\n+ 应用进程存在，在前台\n\n在BPushReceiver的onNotificationClicked或者onMessage方法中使用Intent来启动activity：\n\n```java\nIntent intent = new Intent();\nintent.setClass(context.getApplicationContext(), MainActivity.class);\nintent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_SINGLE_TOP);\nif (url != null && !url.isEmpty()) {\n    Bundle bundle = new Bundle();\n    bundle.putString(\"url\", url);\n    intent.putExtras(bundle);\n}\n\nLog.d(TAG, \"start app\");\ncontext.getApplicationContext().startActivity(intent);\n```\n\n需要注意的是，针对不同的应用状态，MainActivity中触发的方法也不同：\n+ 应用进程不存在时,onCreate被调用\n+ 应用进程存在，不管是不是在前台，onNewIntent被调用\n\n针对以上状态，合理的使用onCreate和onNewIntent就可以在任何时候呆参数启动APP了。","tags":["百度推送"],"categories":["android"]},{"title":"MAMP下使用pecl安装PHP扩展","url":"%2F2016%2F02%2F16%2Fmamp-install-php-extension.html","content":"之前写过一篇在Mac下搭建PHP开发环境的文章，[Mac搭建PHP开发环境]({% post_url 2016-02-16-mac-php-env %})，但是此种方式搭建的PHP有弊端，由于默认不带PHP源码，所以在使用pecl安装扩展时会报错。\n\n## 测试安装扩展\n\n```bash\nsudo pecl install mongo\n```\n\n运行起来后会报形如“php.h not found”的错误，因为MAMP默认是不带PHP源码包的。   \n## 配置扩展安装环境\n按照如下步骤将源码包集成以便于安装扩展：\n1.在web目录下添加index.php文件，内容如下：\n\n```php\n<?php\nphpinfo();\n```\n\n2.打开浏览器访问该php文件，记录PHP版本，本文暂定**PHP版本A**。   \n3.打开终端，输入以下命令：\n\n```php\nphp -v\n```\n\n记录PHP版本，本文暂定**PHP版本B**。   \n4.如果PHP版本A不等于PHP版本B，在终端执行以下命令：\n\n```bash\nsudo rm -rf /usr/bin/php\nsudo rm -rf /usr/bin/phpize\nsudo rm -rf /usr/bin/php-config\nsudo rm -rf /usr/bin/pecl\n \nln -s /Application/MAMP/bin/php/php[PHP版本A]/bin/php /usr/bin/php\nln -s /Application/MAMP/bin/php/php[PHP版本A]/bin/php-config /usr/bin/php-config\nln -s /Application/MAMP/bin/php/php[PHP版本A]/bin/phpize /usr/bin/phpize\nln -s /Application/MAMP/bin/php/php[PHP版本A]/bin/pecl /usr/bin/pecl\n```\n\n请替换**[PHP版本A]**为步骤2中的版本，如**5.5.18**   \n执行完以上命令之后，命令行模式和浏览器模式的PHP都是一致的了。   \n5.下载PHP源码包，打开浏览器访问如下网址 http://cn2.php.net/get/php-**[PHP版本A]**.tar.gz/from/this/mirror。   \n6.将下载的压缩包解压到 /Application/MAMP/bin/php/php**[PHP版本A]**/include/php 中。   \n7.在终端执行以下命令：\n\n```bash\ncd /Application/MAMP/bin/php/php[PHP版本A]/include/php\n./configure\n```\n\n此时PHP源码包已经配置正常了，头文件也可以正常调用了。   \n8.在终端执行：\n\n```bash\nsudo pecl install mongo\n```\n\n扩展安装成功后，编辑*/Application/MAMP/bin/php/php*[PHP版本A]*/conf/php.ini* 在最后添加：\n\n```\nextension=mongo.so\n```\n\n9.由于命令行模式和浏览器模式中加载的php.ini并不是同一个文件，所以需要用软连接的方式处理下。终端执行：\n\n```bash\nphp -i|grep ini\n```\n\n查看**Loaded ini file**路径，本文假设为**PHP配置文件A**。   \n10.备份**PHP配置文件A**，终端执行：\n\n```bash\nln -s /Application/MAMP/bin/php/php[PHP版本A]/conf/php.ini PHP配置文件A\n```\n\n11.终端执行：\n\n```bash\nphp -i|grep ini\n```\n\n此时该路径应该和浏览器中看到的是一致的了。\n\n## 安装扩展\n1. sudo pecl install **[扩展名]**\n2. 编辑 /Application/MAMP/bin/php/php**[PHP版本A]**/conf/php.ini 加载扩展\n3. 重启Web服务器","tags":["mamp"],"categories":["php"]},{"title":"Mac搭建PHP开发环境","url":"%2F2016%2F02%2F16%2Fmac-php-env.html","content":"本文教大家在Mac环境中搭建PHP开发环境。   \n1. 下载软件包 [下载地址](http://pan.baidu.com/s/1dEmIwY9)\n2. 安装软件\n3. 使用MAMP_PRO_3.0.7.3_SN.txt中的序列号激活\n\n关于MAMP具体的使用，比如添加虚拟主机等，请自己摸索。","tags":["mamp"],"categories":["php"]},{"title":"mongodb更新指定条件的子文档","url":"%2F2016%2F01%2F04%2Fmongodb-findandmodify.html","content":"## 文档内容\n\n```json\n{\n    \"_id\": ObjectId(\"5689db252d162c9881532986\"),\n    \"openid\": \"xialei\",\n    \"channels\": [\n        {\n            \"channel_id\": \"c1\"\n        },\n        {\n            \"channel_id\": \"c2\"\n        },\n        {\n            \"channel_id\": \"c2\"\n        },\n        {\n            \"channel_id\": \"c2\"\n        }\n    ]\n}\n```\n\n## 需求\n把该文档的channels中channel_id为c2的删除，但是主记录要保留。\n这时候就不能用remove方法了，该方法会删除整条文档，查询[官方文档](https://docs.mongodb.org/manual/reference/method/db.collection.findAndModify/#db.collection.findAndModify)发现有个findAndModify方法。\n## 函数原型\n\n```javascript\ndb.collection.findAndModify({\n    query: <document>,\n    sort: <document>,\n    remove: <boolean>,\n    update: <document>,\n    new: <boolean>,\n    fields: <document>,\n    upsert: <boolean>\n    bypassDocumentValidation: <boolean>\n});\n```\n\n## 调用代码\n\n```bash\ndb.collection.findAndModify({\n    query: {\"openid\":\"xialei\"},\n    update: {\"$pull\":{\"channels\":{\"channel_id\":\"c2\"}}},\n    new: true\n});\n```\n\n## 执行结果\n\n```json\n{\n    \"_id\" : ObjectId(\"5689db252d162c9881532986\"),\n    \"openid\" : \"xialei\",\n    \"channels\" : [ \n        {\n            \"channel_id\" : \"c1\"\n        }\n    ]\n}\n```\n\n**$pull**是数组操作符，明白update中的操作之后，相信大家可以举一反三，比如要插入一个文档就肯定会想到用**$push**了。","tags":["mongodb"],"categories":["mongodb"]},{"title":"百度云推送nodejs sdk","url":"%2F2015%2F12%2F29%2Fbaidu-push-nodejs-sdk.html","content":"## 项目地址\n[bpush-nodejs](https://github.com/xialeistudio/bpush-nodejs)\n## 开发背景\n百度官方只有php和java的sdk，但是百度提供了rest api,好处就是开发者可以使用任何语言开发一套服务端SDK，本人开源一套基于nodejs的sdk。\n## 使用\n\n```bash\nnpm install bpush-nodejs --save\n```\n\n```javascript\nvar bpush = require('bpush-nodejs');\n```\n\n## 说明   \nSDK采用Promise方式进行回调,demo代码如下(以推送单个设备为例),catch代码块中 **只捕获HTTP请求错误,如果HTTP请求成功,但是百度服务端报错,请自行在then中处理**   \n\n```javascript\nvar data = {\n    channel_id: '5247517738736986629',\n    msg: JSON.stringify({\n        aps: {\n            alert: '你是呵呵SINGLE'\n        }\n    }),\n    msg_type: bpush.constant.MSG_TYPE.NOTIFICATION,\n    deploy_status: bpush.constant.DEPLOY_STATUS.DEVELOPMENT,\n    device_type: bpush.constant.DEVICE_TYPE.IOS\n};\nbpush.sendRequest(bpush.apis.pushMsgToSingleDevice, data).then(function (data) {\n            data = JSON.parse(data);\n            console.log(data);\n        }).catch(function(e){\n            console.error(e);\n        });\n```\n\n所有api调用方法均为 **bpush.sendRequest(bpush.apis.[api名称], [api需要的数据])**   \n## api列表   \n[百度官方文档](http://push.baidu.com/doc/restapi/restapi)   \n**特别说明:** 本文档写作时,百度api返回的数据以本文档为准,与官方文档有出入的地方可能是百度升级了api忘记更新文档所致.   \n+ pushSingleDevice   \n功能:推送单一终端   \n请求参数:\n\n```javascript\nvar data = {\n    channel_id: '5247517738736986629',//设备channelID\n    msg: JSON.stringify({\n        aps: {\n        alert: '你是呵呵SINGLE'\n        }\n    }),\n    msg_type: bpush.constant.MSG_TYPE.NOTIFICATION,\n    deploy_status: bpush.constant.DEPLOY_STATUS.DEVELOPMENT,\n    device_type: bpush.constant.DEVICE_TYPE.IOS\n};\n```\n\n返回参数:\n\n```javascript\n{\n    request_id: 900279880,\n    response_params: {\n        msg_id: '7960733379606623036',\n        send_time: 1451380442\n    }\n}\n```\n\n+ pushMsgToAll   \n功能:推送所有终端   \n请求参数:\n\n```javascript\nvar data = {\n    msg: JSON.stringify({\n        aps: {\n            alert: '你是呵呵ALL'\n        }\n    }),\n    msg_type: bpush.constant.MSG_TYPE.NOTIFICATION,\n    deploy_status: bpush.constant.DEPLOY_STATUS.DEVELOPMENT,\n    device_type: bpush.constant.DEVICE_TYPE.IOS\n};\n```\n\n返回参数:\n\n```javascript\n{\n    request_id: 900279880,\n    response_params: {\n        msg_id: '7960733379606623036',\n        send_time: 1451380442\n    }\n}\n```\n\n+ pushMsgToTag   \n功能:组播推送   \n请求参数:\n\n```javascript\nvar data = {\n    msg: JSON.stringify({\n    aps: {\n            alert: '你是呵呵TAG'\n        }\n    }),\n    type: 1,//固定为1\n    tag: 'test',//标签名称\n    msg_type: bpush.constant.MSG_TYPE.NOTIFICATION,\n    deploy_status: bpush.constant.DEPLOY_STATUS.DEVELOPMENT,\n    device_type: bpush.constant.DEVICE_TYPE.IOS\n};\n```\n\n返回参数:\n\n```javascript\n{\n    request_id: 900279880,\n    response_params: {\n        msg_id: '7960733379606623036',\n        send_time: 1451380442\n    }\n}\n```\n\n+ queryMsgStatus   \n功能:查询消息推送情况   \n请求参数:\n\n```javascript\nvar data = {\n    msg_id: '3129074535657443828'\n};\n```\n\n返回结果:\n\n```json\n{\n    \"request_id\": 1221365722,\n    \"response_params\": {\n        \"total_num\": 1,\n        \"result\": [\n            {\n                \"send_time\": 1451381279,\n                \"success\": -1,\n                \"total_num\": 4,\n                \"status\": 0,\n                \"msg_id\": \"3129074535657443828\"\n            }\n        ]\n    }\n}\n```\n\n+ queryTags   \n功能:查询标签组列表   \n请求参数:\n\n```javascript\nvar data = {\n};\n```\n\n返回参数:\n\n```json\n{\n    \"request_id\": 896177143,\n    \"response_params\": {\n        \"total_num\": 4,\n        \"result\": [\n            {\n                \"tid\": \"1933949969962682514\",\n                \"tag\": \"default\",\n                \"info\": \"default\",\n                \"type\": 0,\n                \"create_time\": 1447315802\n            },\n            {\n                \"tid\": \"73579040\",\n                \"tag\": \"test20151112\",\n                \"info\": \"test201511127237210\",\n                \"type\": 2,\n                \"create_time\": 1447321138\n            },\n            {\n                \"tid\": \"77983912\",\n                \"tag\": \"test\",\n                \"info\": \"test7237210\",\n                \"type\": 2,\n                \"create_time\": 1451376995\n            },\n            {\n                \"tid\": \"77986112\",\n                \"tag\": \"testtag\",\n                \"info\": \"testtag7237210\",\n                \"type\": 2,\n                \"create_time\": 1451379084\n            }\n        ]\n    }\n}\n```\n\n+ createTag   \n功能:创建标签组   \n请求参数:\n\n```javascript\nvar data = {\n    tag: 'testtag'\n};\n```\n\n返回参数:\n\n```json\n{\n    \"request_id\": 1221802330,\n    \"response_params\": {\n        \"tag\": \"testtag\",\n        \"result\": 0\n    }\n}\n```\n\n+ deleteTag   \n功能:删除标签组   \n请求参数:\n\n```javascript\nvar data = {\n    tag: 'testtag'\n};\n```\n\n返回参数:\n\n```json\n{\n    \"request_id\": 897517834,\n    \"response_params\": {\n        \"tag\": \"testtag\",\n        \"result\": 0\n    }\n}\n```\n\n+ addDevicesToTag   \n功能:添加设备到标签组   \n请求参数:\n\n```javascript\nvar data = {\n    tag: 'testtag',\n    channel_ids: JSON.stringify([5247517738736986629])\n};\n```\n\n返回参数:\n\n```json\n{\n    \"request_id\": 881162061,\n    \"response_params\": {\n        \"result\": [\n            {\n                \"channel_id\": \"5247517738736987000\",\n                \"result\": 1\n            }\n        ]\n    }\n}\n```\n\n+ removeDevicesFromTag   \n功能:将设备从标签组中移除   \n请求参数:\n\n```javascript\nvar data = {\n    tag: 'testtag',\n    channel_ids: JSON.stringify([5247517738736986629])\n};\n```\n\n返回参数:\n\n```json\n{\n    \"request_id\": 881521481,\n    \"response_params\": {\n        \"result\": [\n            {\n                \"channel_id\": \"5247517738736987000\",\n                \"result\": 1\n            }\n        ]\n    }\n}\n```\n\n+ deviceNumInTag   \n功能:查询标签组设备数量   \n请求参数:\n\n```javascript\nvar data = {\n    tag: 'testtag'\n};\n```\n\n返回参数:\n\n```json\n{\n    \"request_id\": 882409689,\n    \"response_params\": {\n        \"device_num\": -1\n    }\n}\n```\n\n+ reportStaticDevice   \n功能:当前应用的设备统计信息   \n请求参数:\n\n```javascript\nvar data = {\n};\n```\n\n返回参数:\n\n```json\n{\n    \"request_id\": 883742690,\n    \"response_params\": {\n        \"result\": {\n            \"1450713600\": {\n                \"total_term\": 2,\n                \"total_term_detail\": {\n                    \"1450774800\": 2\n                },\n                \"new_term\": 1,\n                \"new_term_detail\": {\n                    \"1450774800\": 1\n                },\n                \"del_term\": 0,\n                \"del_term_detail\": []\n            },\n            \"1450800000\": {\n                \"total_term\": 3,\n                \"total_term_detail\": {\n                    \"1450868400\": 3\n                },\n                \"new_term\": 1,\n                \"new_term_detail\": {\n                    \"1450868400\": 1\n                },\n                \"del_term\": 0,\n                \"del_term_detail\": []\n            },\n            \"1451232000\": {\n                \"total_term\": 4,\n                \"total_term_detail\": {\n                    \"1451293200\": 4\n                },\n                \"new_term\": 1,\n                \"new_term_detail\": {\n                    \"1451293200\": 1\n                },\n                \"del_term\": 0,\n                \"del_term_detail\": []\n            }\n        },\n        \"total_num\": 3\n    }\n}\n```\n","tags":["百度云推送"],"categories":["open-source-projects"]},{"title":"ios仿微信右上角弹出菜单","url":"%2F2015%2F12%2F17%2Fios-wechat-like-menu.html","content":"\n## 项目地址\n[ios仿微信右上角弹出菜单](https://github.com/xialeistudio/wechat-like-menu)\n## 效果图\n![效果图](https://og5r5kasb.qnssl.com/wp-content/uploads/2015/12/2.gif)\n## 实现过程\n本人倾向于使用storyboard来做布局，所以实现起来也是不难的   \n1.新建 Single View Application。\n\n2.打开Main.storyboard。\n\n3.选择默认的View Controller，点击菜单\"Editor\"=>\"Embed In\"=>\"Navigation Controller\",确认Navigation Controller是Initial View Controller。\n\n4.拖两个viewController到Interface builder，并做好连接，效果如图1所示。\n![图1](https://og5r5kasb.qnssl.com/wp-content/uploads/2015/12/2.pic_.jpg)\n\n5.选择第二个 Segue，属性设置如图2所示。   \n![图2](https://og5r5kasb.qnssl.com/wp-content/uploads/2015/12/4.pic_.jpg)\n\n6.打开ViewController.m，覆盖 prepareForSegue方法\n\n```object-c\n- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender {\n    if ([segue.identifier isEqualToString:@\"showMenu\"]) {\n        UIViewController *viewController = segue.destinationViewController;\n        if ([[[UIDevice currentDevice] systemVersion] floatValue] >= 8.0) {\n            viewController.modalPresentationStyle = UIModalPresentationOverCurrentContext;\n        } else {\n            self.modalPresentationStyle = UIModalPresentationCurrentContext;\n        }\n    }\n}\n```\n\n由于IOS8更换了Enum的名称，所以这里需要做下判断\n7.新建Cocao Touch Class=>View2Controller\n\n8.在Interface Builder中把第二个viewController的Class设置为View2Controller，并把“取消”按钮绑定到View2Controller.m\n\n9.打开View2Controller.m\n\n```object-c\n//\n//  View2Controller.m\n//  viewtransition\n//\n//  Created by xialeistudio on 15/12/17.\n//  Copyright © 2015年 Group Friend Information. All rights reserved.\n//\n\n#import \"View2Controller.h\"\n\n@interface View2Controller ()\n- (IBAction)cancelClicked:(id)sender;\n\n@property(weak, nonatomic) IBOutlet UIView *menuView;\n\n@end\n\n@implementation View2Controller {\n    UITapGestureRecognizer *_tap;\n}\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    // Do any additional setup after loading the view.\n    _tap = [[UITapGestureRecognizer alloc] init];\n    [_tap addTarget:self action:@selector(closeView)];\n    [self.view addGestureRecognizer:_tap];\n}\n\n- (void)closeView {\n    _menuView.frame = CGRectMake(_menuView.frame.origin.x, self.view.frame.size.height - _menuView.frame.size.height, _menuView.frame.size.width, _menuView.frame.size.height);\n    [UIView animateWithDuration:.3 delay:0 options:UIViewAnimationOptionCurveEaseInOut\n                     animations:^{\n                         _menuView.frame = CGRectMake(_menuView.frame.origin.x, self.view.frame.size.height, _menuView.frame.size.width, _menuView.frame.size.height);\n                     }\n                     completion:^(BOOL isFinished) {\n                         if (isFinished) {\n                             [self dismissViewControllerAnimated:NO completion:nil];\n                         }\n                     }];\n}\n\n- (void)didReceiveMemoryWarning {\n    [super didReceiveMemoryWarning];\n    // Dispose of any resources that can be recreated.\n}\n\n- (void)viewWillAppear:(BOOL)animated {\n    _menuView.frame = CGRectMake(_menuView.frame.origin.x, self.view.frame.size.height, _menuView.frame.size.width, _menuView.frame.size.height);\n    [UIView animateWithDuration:.3 animations:^{\n        _menuView.frame = CGRectMake(_menuView.frame.origin.x, self.view.frame.size.height - _menuView.frame.size.height, _menuView.frame.size.width, _menuView.frame.size.height);\n    }];\n}\n\n/*\n#pragma mark - Navigation\n\n// In a storyboard-based application, you will often want to do a little preparation before navigation\n- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender {\n    // Get the new view controller using [segue destinationViewController].\n    // Pass the selected object to the new view controller.\n}\n*/\n\n- (IBAction)cancelClicked:(id)sender {\n    [self closeView];\n}\n@end\n```\n\n关键是 viewWillAppear 和 closeView 中的动画处理。","tags":["modal"],"categories":["ios"]},{"title":"mac 10.11安装php-mongo扩展踩过的坑","url":"%2F2015%2F12%2F15%2Fmac-10-11-install-php-mongo.html","content":"## pecl的安装\n本文采用的是 pecl 的方式安装。   \n如果系统执行 pecl 命令报错的话，请打开终端，执行以下命令\n\n```bash\ncurl -o go-pear.phar http://pear.php.net/go-pear.phar\nphp go-pear.phar\n```\n\n接下来的询问过程直接回车即可，成功之后执行以下命令\n\n```bash\nsudo ln -s /Users/[用户名]/pear/bin/pear /usr/bin/pear\nsudo ln -s /Users/[用户名]/pear/bin/pecl /usr/bin/pecl\n```\n\n## mongo扩展的安装\n\n```bash\nsudo pecl install mongo\n```\n\n接下来会询问是不是启用 sasl 认证，输入**[no]**回车，接下来是编译了，不出意外的话会编译出错，大致错误是\n\n```bash\n<openssl/evp.h> file not found\n```\n\n简而言之就是 openssl/evp.h 头文件查找失败，由于用 尖括号括起来的头文件，编译器会去系统路径查找，而 mac 下默认的路径是 /usr/include，使用终端ls查看之后发现确实没有openssl文件夹。\n\n## openssl的安装\n\n```bash\nsudo brew install openssl\n```\n\n如果提示**brew**命令不存在，可以通过以下代码安装**Homebrew**，终端执行\n\n```bash\nruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n```\n\n安装完成后重新安装**openssl**即可。\n\n## link头文件\n通过brew命令安装完openssl之后会自动link一次，但是重新执行mongo的安装命令时依旧出错。猜想应该是头文件没有复制过去，这时候需要手动ln一下，终端执行\n\n```bash\nln -s /usr/local/Cellar/openssl/1.0.2d_1/include/openssl /usr/include/openssl\n```\n\n如果你的openssl版本不一致，请自行替换，执行完该命令之后再安装mongo就不会有问题了。\n\n## 启用扩展\nMAMP的php很有意思，web版本的配置文件在\n\n```bash\n/Library/Application Support/appsolute/MAMP PRO/conf/php.ini\n```\n\ncli版本的配置文件在（请通过终端执行 php -v 获取PHP版本）\n\n```bash\n/Applications/MAMP/bin/php/php5.5.10/conf/php.ini \n```\n\n在这两个文件都加上\n\n```bash\nextesion=mongo.so \n```\n\n重启MAMP即可","tags":["mongo"],"categories":["mamp"]},{"title":"ios9 导航栏全透明","url":"%2F2015%2F12%2F12%2Fios9-navigation-bar-transparent.html","content":"\n## 效果图\n![效果图](https://og5r5kasb.qnssl.com/wp-content/uploads/2015/12/1.pic_.jpg)   \n导航栏是全透明的，但是导航栏的 item 还是正常的。\n\n```\n[self.navigationBar setBackgroundImage:[UIImage new] forBarMetrics:UIBarMetricsDefault];\nself.navigationBar.shadowImage = [UIImage new];\nself.navigationBar.translucent = YES;\n```\n如果你的当前**viewController**不是**navigationController**navigationController，请把**self.navigationBar**改为**self.navigationController.navigationBar**。","tags":["ios"],"categories":["ios"]},{"title":"2011CCJOY群雄逐鹿","url":"%2F2015%2F12%2F01%2F2011-ccjoy-2011.html","content":"<iframe src=\"http://www.tudou.com/programs/view/html5embed.action?type=0&code=jJRVqxQWuqM&lcode=&resourceId=48069092_06_05_99\" allowtransparency=\"true\" allowfullscreen=\"true\" allowfullscreeninteractive=\"true\" scrolling=\"no\" border=\"0\" frameborder=\"0\" style=\"width:100%;height:500px;\"></iframe>","categories":["AfterEffects"]},{"title":"2015群友茶吧万圣节","url":"%2F2015%2F12%2F01%2F2015-group-of-friends-of-tea-halloween.html","content":"<p><iframe height=\"498\" width=\"100%\" src=\"http://player.youku.com/embed/XMTM3NTM2OTg2OA==\" frameborder=\"0\" allowfullscreen></iframe></p>\n","categories":["AfterEffects"]},{"title":"2014网络102班毕业剪影","url":"%2F2015%2F12%2F01%2F2014-network-102-class-graduation-silhouette.html","content":"<iframe src=\"http://player.youku.com/embed/XNzIxMjc5NDQ4\" width=\"100%\" height=\"498\" frameborder=\"0\" allowfullscreen=\"allowfullscreen\"></iframe>","categories":["AfterEffects"]},{"title":"2012-9-15班级活动剪影","url":"%2F2015%2F12%2F01%2F2012-9-15-class-activities-silhouette.html","content":"<iframe height=\"498\" width=\"100%\" src=\"http://player.youku.com/embed/XNDU1NjU3NjY0\" frameborder=\"0\" allowfullscreen></iframe>","categories":["AfterEffects"]},{"title":"2012计算机与通信学院辩论赛","url":"%2F2015%2F12%2F01%2F2012-computer-and-communication-college-debate.html","content":"<iframe src=\"http://player.youku.com/embed/XMzc3MDk1Njgw\" width=\"100%\" height=\"498\" frameborder=\"0\" allowfullscreen=\"allowfullscreen\"></iframe>","categories":["AfterEffects"]},{"title":"2011圣诞节小作","url":"%2F2015%2F12%2F01%2F2011-christmas.html","content":"<iframe height=\"498\" width=\"100%\" src=\"http://player.youku.com/embed/XMzM2MDg4NDQ0\" frameborder=\"0\" allowfullscreen></iframe>","categories":["AfterEffects"]},{"title":"2011湖南工业大学计算机与通信学院迎新晚会","url":"%2F2015%2F12%2F01%2F2011-hunan-university-of-technology-school-of-computer-and-communications-welcome-party.html","content":"<iframe src=\"http://player.youku.com/embed/XMzE2MTY5ODI4\" width=\"100%\" height=\"500\" frameborder=\"0\" allowfullscreen=\"allowfullscreen\"></iframe>","categories":["AfterEffects"]},{"title":"object-c委托实例","url":"%2F2015%2F12%2F01%2Fobject-c-delegate.html","content":"## 定义\n+ delegate是一种设计模式，不是object-c特有\n+ object-c通过protocol实现delegat\n\n## 作用\n+ 业务逻辑解耦\n+ 加强程序可读性\n\n## 使用\n1. 声明protocol\n2. 实现protocol\n3. 指定delegate\n4. 调用delegate方法\n\n## 实例\n本文以UIImagePickerController举例。   \nUIImagePickerController本身需要实现<UIImagePickerControllerDelegate,UINavigationControllerDelegate>两个protocol，本文为了解释delegate的工作过程，在此之上封装一层。   \n1.新建cocoa touch class 继承NSObject，命名UITool   \n\n### UITool.h\n```object-c\nUITool.h\n\n#import <Foundation/Foundation.h>\n#import <UIKit/UIKit.h>\n\nenum{\n    ImageErrorUnSupportedSourceType = -1//不支持的来源类型\n}ImageError;\n@protocol ToolImageDelegate <NSObject>\n/**\n *  选择图片回调\n *\n *  @param info 图片数据\n */\n-(void)didSelectImage:(NSDictionary *)info;\n\n@end\n\n@interface UITool : NSObject\n<UIImagePickerControllerDelegate,UINavigationControllerDelegate>\n{\n    id<ToolImageDelegate>imageDelegate;\n}\n/**\n *  单例\n *\n *  @return 单例\n */\n+(instancetype)sharedManager;\n/**\n *  选择图片\n *\n *  @param sourceType     来源类型\n *  @param viewController 视图\n *  @param error          错误\n *\n *  @return 是否出错\n */\n-(BOOL)selectPicture\n                :(UIImagePickerControllerSourceType)sourceType\n                :(UIViewController<ToolImageDelegate> *)viewController\n                :(NSError **)error;\n@end\n```\n\n## UITool.m\n\n```object-c\nUITool.m\n#import \"UITool.h\"\n/**\n *  单例\n *\n *  @return 单例\n */\n+(instancetype)sharedManager{\n    static UITool *instance         = nil;\n    static dispatch_once_t predicate;\n    dispatch_once(&predicate,^{\n    instance                        = [[self alloc]init];\n    });\n    return instance;\n}\n/**\n *  选择图片\n *\n *  @param sourceType     来源地址\n *  @param viewController 视图\n *  @param error          错误\n *\n *  @return 是否成功\n */\n-(BOOL)selectPicture:(UIImagePickerControllerSourceType)sourceType :(UIViewController<ToolImageDelegate> *)viewController :(NSError **)error{\n    if (![UIImagePickerController isSourceTypeAvailable:sourceType]) {\n        NSDictionary *info  = [NSDictionary dictionaryWithObject:@\"UnSupported source type\" forKey:NSLocalizedDescriptionKey];\n        *error = [NSError errorWithDomain:@\"com.xialeistudio.core.UITool\" code:ImageErrorUnSupportedSourceType userInfo:info];\n        return NO;\n    }\n    \n    //委托处理\n    imageDelegate = viewController;\n    \n    UIImagePickerController *picker = [[UIImagePickerController alloc] init];\n    picker.sourceType = sourceType;\n    picker.allowsEditing= YES;\n    picker.delegate = self;\n    [viewController presentViewController:picker animated:YES completion:nil];\n    return YES;\n}\n\n/**\n *  取消图片选择回调\n *\n *  @param picker 图片选择器\n */\n-(void)imagePickerControllerDidCancel:(UIImagePickerController *)picker{\n    [picker dismissViewControllerAnimated:YES completion:^{\n        [imageDelegate didSelectImage:nil];\n    }];\n}\n/**\n *  图片成功回调\n *\n *  @param picker 图片选择器\n *  @param info   回调数据\n */\n-(void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary<NSString *,id> *)info{\n    [picker dismissViewControllerAnimated:YES completion:^{\n        [imageDelegate didSelectImage:info];\n    }];\n}\n@end\n```\n\n按照**委托的使用4步**来说，我们自定义的委托已经实现了两步。   \n**imageDelegate**就是我们的delegate，只要实现了该委托的子类，我们调用**didSelectImage**方法就不会出错。\n\n### 视图\n打开Interface Builder，放入一个button和一个ImageView，并做好输出口连接。\n\n### ViewController.h\n\n```object-c\nViewController.h\n#import <UIKit/UIKit.h>\n#import \"UITool.h\"\n\n@interface ImagePickerViewController : UIViewController\n<ToolImageDelegate>\n- (IBAction)fromCamera:(id)sender;\n@property (weak, nonatomic) IBOutlet UIImageView *cameraImage;\n\n@end\n```\n\n### ViewController.m\n\n```object-c\nViewController.m\n\n#import \"ImagePickerViewController.h\"\n\n@interface ImagePickerViewController ()\n\n@end\n\n@implementation ImagePickerViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n}\n\n- (void)didReceiveMemoryWarning {\n    [super didReceiveMemoryWarning];\n}\n\n\n- (IBAction)fromCamera:(id)sender {\n    NSError *error = nil;\n    if (![[UITool sharedManager] selectPicture:UIImagePickerControllerSourceTypeCamera :self :&error]) {\n        NSLog(@\"error:%@\",[error localizedDescription]);\n    }\n}\n\n-(void)didSelectImage:(NSDictionary *)info{\n    if (info ==nil) {\n        NSLog(@\"未选择图片\");\n    }else{\n        UIImage *originImage = [info objectForKey:UIImagePickerControllerOriginalImage];\n        [self.cameraImage setImage:originImage];\n    }\n}\n@end\n```\n\n### 总结\n 在调用UITool的selectPicture方法时第二个参数(UIViewController<ToolImageDelegate> *)，强制要求传入的viewController实现ToolImageDelegate协议，在UIImagePickerController回调成功之后就会执行imagePickerControllerDidCancel和didFinishPickingMediaWithInfo方法，由于我们在该方法中进行了委托方法的调用，所以最终会执行ViewController的didSelectImage方法。","tags":["object-c"],"categories":["ios"]},{"title":"使用QQ企业邮箱发信时501错误解决方案","url":"%2F2015%2F11%2F23%2Fexmail-501.html","content":"此现象只出现在新增或者编辑邮箱密码的时候出现，发送邮箱时服务端会返回501，此时是由于QQ企业邮箱强制要求第一次登录必须修改密码。\n解决方案是：\n1. 登录QQ企业邮箱\n2. 修改密码\n3. 使用新密码调用接口","tags":["企业邮箱"],"categories":["php"]},{"title":"css3实现三角形","url":"%2F2015%2F11%2F23%2Fcss3-triangle.html","content":"\n```css\ndiv{\n    border: 1px solid #dddddd;\n    padding: 4px 40px 4px 8px;\n    position: relative;\n}\ndiv:after{\n    content: ' ';\n    margin-top: -5px;\n    display: block;\n    position: absolute;\n    right: 8px;\n    top: 50%;\n    width: 0;\n    height: 0;\n    border-left: 12px transparent solid;\n    border-right: 12px transparent solid;\n    border-top: 12px #000000 solid;\n}\n```\n\n[demo](http://ngdemo.sinaapp.com/#demo12)\n","tags":["三角形"],"categories":["css"]},{"title":"angularjs icheck","url":"%2F2015%2F11%2F23%2Fangularjs-icheck.html","content":"## 项目地址\n[https://github.com/xialeistudio/angular-icheck](https://github.com/xialeistudio/angular-icheck)\n## 项目说明\n[icheck](http://plugins.jquery.com/icheck/)的angularjs版本","tags":["icheck"],"categories":["open-source-projects"]},{"title":"angularjs上传指令","url":"%2F2015%2F11%2F23%2Fangularjs-upload.html","content":"## 项目地址\n[https://github.com/xialeistudio/angular-upload](https://github.com/xialeistudio/angular-upload)\n## 项目说明\nangularjs上传指令","tags":["bower"],"categories":["open-source-projects"]},{"title":"nodejs mongodb 缓存模块","url":"%2F2015%2F11%2F23%2Fnodejs-mongodb-cache.html","content":"## 项目地址\n[https://github.com/xialeistudio/mongodb-cache](https://github.com/xialeistudio/mongodb-cache)\n## 项目说明\n基于mongodb的nodejs缓存模块\n## 使用\n\n```bash\nnpm install xl-cache --save\n```\n\n```javascript\nvar cache = require('xl-mongodb-cache');\n```\n+ 连接服务器\n\n```javascript\ncache.connect('mongodb://localhost:27017/app');\n```\n\n+ 写入缓存\n\n```javascript\ncache.set(key, value, duration).then(function(data) {\n  console.log(data);\n}).catch(console.error);\n```\n\n+ 读取缓存\n\n```javascript\ncache.get(key).then(function(data) {\n  console.log(data);\n}).catch(console.error);\n```\n\n+ 删除缓存\n\n```javascript\ncache.remove(key).then(function(data) {\n  console.log(data);\n}).catch(console.error);\n```","tags":["npm"],"categories":["open-source-projects"]},{"title":"chrome hosts插件","url":"%2F2015%2F11%2F23%2Fchrome-hostsmanager-plugin.html","content":"## 项目地址\n[https://github.com/xialeistudio/hostManager](https://github.com/xialeistudio/hostManager)\n## 特别说明\n*Chrome 44*版本以后不支持，不过开发过程大家可以了解下。","tags":["chrome plugin"],"categories":["open-source-projects"]},{"title":"svn更新时403的解决","url":"%2F2015%2F11%2F14%2Fsvn-update-403.html","content":"今天在服务器上svn up的时候出现这么一段\n\n*svn: Server sent unexpected return value (403 Forbidden) in response to OPTIONS request*\n\n403一般是权限问题，但是昨天还好好更新的，应该不是，然后更新的时候昨天是需要输入账号密码的，但是今天不需要，想着是不是账号密码被保存下来了，而这个账号密码可能有误，经过google发现在 ~/.subversion/auth/svn.simple 有一个md5加密后的文件，应该就是那个所谓的账号密码保存文件了，删掉之后重新SVN要求输入密码了。","tags":["subversion"],"categories":["linux"]},{"title":"MAMP PRO 3.0.5 在 OS X EI Capitan下无法启动的问题","url":"%2F2015%2F11%2F13%2Fmamp-pro-can-not-launch.html","content":"网上找了很多文章，什么关闭自带的apache服务，查看系统日志等等，全没用。真佩服 baidu。   \n还是google到了一篇文章，解决方法很简单:   \n1.打开终端   \n2.执行\n\n```bash\ncd /Applications/MAMP/Library/bin/\nmv envvars _envvars\n```\n\n3.enjoy","tags":["mamp"],"categories":["mamp"]},{"title":"移动端滚动加载问题","url":"%2F2015%2F10%2F23%2Fmobile-scroll-load.html","content":"去年写过一篇[摆脱jquery!angularjs利用指令简单实现滚动翻页]({% post_url 2014-09-06-angularjs-lazy-load%})，但是用了一段时间之后发现很多浏览器有问题，移动端下滚动事件只有**body**才会触发，其他元素是不会触发的，经过改进后的指令代码如下（仅限移动端）:\n\n```javascript\napp.directive('whenScrolled', function() { \nreturn function (scope, ele, attr) {\n        angular.element(window).on('scroll', function (e) {\n            var a = window.screen.availHeight;\n            var b = document.documentElement.scrollTop == 0 ? document.body.scrollTop : document.documentElement.scrollTop;\n            var c = document.documentElement.scrollTop == 0 ? document.body.scrollHeight : document.documentElement.scrollHeight;\n            if (a + b >= c) {\n                scope.$apply(attr.scrollLoad);\n            }\n        });\n    };\n});\n```","tags":["scroll"],"categories":["angularjs"]},{"title":"php实现扫描二维码登录网站","url":"%2F2015%2F09%2F17%2Fphp-qrcode-login.html","content":"扫描二维码登录对于现在的web应用来说，确实是个很炫酷的功能，安全性也可以保障，不少朋友可能觉得这是个很复杂的工作，其实不然，真正说来只有几个步骤而已。\n## 原理\n1. PC浏览器展示一张二维码图片，该图片二维码值为一段绝对地址的url，大致如下：http://www.example.com/oauth/qrcode?key=key\n2. PC浏览器定期轮询 http://www.example.com/oauth/query，可能有的同学会问，怎么不用带上key？这里我们用session来保存key，所以链接中不用带上key，将这个key作为服务端的缓存key且值为空，如果该缓存值为空，证明没被扫描，继续轮询，如果已经被扫描，展示扫描结果。\n3. 手机微信扫描之后会直接访问http://www.example.com/oauth/qrcode?key=key，这里我们先把这个key保存的session中（这个session和2中的不同，一个是PC，一个是手机）。然后检测用户在手机端是否登录，如果已登录，则把用户信息存到2中的key缓存中，这时候前端查询的时候就会有值了。如果用户在手机未登录，则直接跳转微信登录，登陆成功之后再将用户信息设置到2中的key缓存\n\n## demo\n[http://www.lizhiclub.com/](http://www.lizhiclub.com/)","tags":["login"],"categories":["php"]},{"title":"angularjs ng-options第一个选项为空的解决方案","url":"%2F2015%2F09%2F02%2Fangularjs-ng-options-first-option-empty.html","content":"angularjs的ng-options渲染到页面上的时候结构大致是这样的。\n\n```html\n<select>\n  <option value=\"\"></option>\n    <option value=\"1\">北京</option>\n</select>\n```\n\n这样会导致select第一行为空，用户体验很差。所以改造后的代码如下\n\n```html\n<select>\n  <option value=\"\" selected hidden></option>\n  <option value=\"1\">北京</option>\n</select>\n```\n\n这样就可以避免第一行的空行了。配合绝对定位以及加个div，可以做个很好看的下拉列表样式。","tags":["ng-options"],"categories":["angularjs"]},{"title":"JS函数不同执行环境下的this指向","url":"%2F2015%2F08%2F20%2Fjs-function-this-scope.html","content":"先来看一段代码\n\n```javascript\nvar length = 10;\nfunction fn() {\n  console.log(this.length);\n}\n\nvar obj = {\n  length: 5,\n  method: function(fn) {\n    fn();\n    arguments[0]();\n  }\n};\n\nobj.method(fn,1);\n```\n\n猜猜输出结果？\n\n## 浏览器环境\n\n```bash\n10\n2\n```\n\n### 为什么输出10？\n执行过程大致如下：   \n\nobj.method这是个obj对象的方法，而传入的fn是个函数，fn()属于调用模式的\"函数调用\"，非严格模式下，this为global对象（浏览器中就是window）。   \n而在这段代码的最上方使用var定义了length，由于var是直接写在global作用域中的，所以此处的 var length 与 window.length是同一个东西。输出10也就不奇怪了。\n### 为什么输出2？\narguments这个是在函数内部才有的参数，很像array，而且typeof得到的也是object值，我们知道，js访问对象有 . 操作符 和 中括号操作符，此处使用的是第二种方法获取到obj.method的第一个参数，也就是fn.   \n由于arguments[0]()是输入调用方式中的“方法调用模式”,this指向对象本身，也就是arguments，所以会输出2。\n## NodeJs环境\n\n```bash\nundefined\n2\n```\n### 为什么输出undefined？\n\n*nodejs的global处理机制不同*\n\nglobal贯穿与nodejs整合生命周期，而每个js文件是单独的模块，就算使用var定义在顶层，也只是这个module的全局变量。所以会输出undefined。\n\n### 为什么输出2？\n同浏览器。","tags":["javascript"],"categories":["javascript"]},{"title":"php-fpm sock文件权限问题导致502","url":"%2F2015%2F08%2F14%2Fphp-fpm-permission-502-bad-gateway.html","content":"今天升级完PHP出现了502 Bad Gateway错误，根据经验是php-fpm的问题，但是看到网上那些什么访问量，子进程设置什么的，但是我这太服务器压根没啥流量。所以只能从配置文件下手看看。\n\n## php-fpm.conf\n\n```bash\n[global]\npid = /usr/local/php/var/run/php-fpm.pid\nerror_log = /usr/local/php/var/log/php-fpm.log\nlog_level = notice\n\n[www]\nlisten = /tmp/php-cgi.sock\nuser = www\ngroup = www\npm = dynamic\npm.max_children = 20\npm.start_servers = 2\npm.min_spare_servers = 1\npm.max_spare_servers = 6\nrequest_terminate_timeout = 100\n```\n看到 /tmp/php-cgi.sock 直觉发现应该是个文件，所以前往该目录查看权限，发现文件属主是**root:root**，而我的nginx和php-fpm进程是以www用户运行的。所以应该是权限问题。   \n而配置文件中的user = www,group = www也设置了一个权限，通过 ps -aux|grep php 发现，这是php-fpm进程的属主。   \n知道问题的源头后便开始查php-fpm的配置，查到了 listen.ower listen.group 设置。   \n这是改进之后的文件：\n\n```bash\n[global]\npid = /usr/local/php/var/run/php-fpm.pid\nerror_log = /usr/local/php/var/log/php-fpm.log\nlog_level = notice\n\n[www]\nlisten = /tmp/php-cgi.sock\nlisten.owner = www\nlisten.group = www\nuser = www\ngroup = www\npm = dynamic\npm.max_children = 20\npm.start_servers = 2\npm.min_spare_servers = 1\npm.max_spare_servers = 6\nrequest_terminate_timeout = 100\n```","tags":["php-fpm"],"categories":["php"]},{"title":"angularjs 用户认证解决方案","url":"%2F2015%2F07%2F29%2Fangularjs-authorization-solution.html","content":"作为一个全栈ajax的mvvm框架，angularjs可谓如火如荼，可真正做到全栈ajax，首要面对的问题就是用户身份验证。   \n本文的身份验证不采用cookie,而采用基于http Authorize 请求头的方式验证用户，此方式能做到永远只有一个用户同时在线（服务端同一时间只会接受一个合法的token请求，其他的请求返回401）。   \n\n## Service\n\n```javascript\napp.factory('Authorize', function() {\n  return {\n    uid: '',\n    token: '',\n    logout: function() {\n      this.uid = '';\n      this.token = '';\n      localStorage.removeItem('authorize.uid');\n      localStorage.removeItem('authorize.token');\n    }\n  }\n});\n```\n\n由于service是单例的。保存在service很合适，再看登录检测。\n\n## 验证流程\n1. app运行时主动读取localStorage中的authorize.uid和authorize.token字段，将这两个字段发送至后端接口验证，如果验证成功返回用户信息，验证失败返回http 401错误（未授权）。   \n\n2. 如果localStorage没有上述两个字段，则检测url中是否有，如果有则写入本地localStorage之后发送至后端验证，如果没有，跳转至后端服务器的oauth接口进行授权拿之后，将openid和token写入queryString并回调到app页面，代码如下：\n\n```javascript\nAuthorize.uid = $location.search().uid || localStorage.getItem('authorize.uid');\nAuthorize.token = $location.search().token || localStorage.getItem('authorize.token');\nif (!Authorize.uid || !Authorize.token) {\n  if (!Platform.isWechat) {\n    Authorize.uid = 1001;\n    Authorize.token = '2ddha3nry8';\n  }\n  else {\n    location.href = CONFIG.api + '/auth/oauth?callback=' + encodeURIComponent($location.protocol() + \"://\" + $location.host() + \":\" + $location.port() + \"/#\" + $location.path());\n    return;\n  }\n}\n//写入本地\nlocalStorage.setItem('authorize.uid', Authorize.uid);\nlocalStorage.setItem('authorize.token', Authorize.token);\n//读取用户数据\nvar user = User.get({uid: Authorize.uid}, function() {\n  $rootScope.user = user;\n});\n```\n\n读取用户数据这边，采用的$resource服务封装，这里就不说了。\n\n## 请求过程中的授权处理\n接下来是比较重要的一点，如何在登陆后在每次请求头中注入Authorize信息，方法是**采用拦截器**。   \n有一个问题，如果由于刷新过快，检测用户回调还没执行完，这时候访问所有接口都是401，这里就需要在$httpProvider上注入拦截器进行请求恢复了。代码如下：\n\n```javascript\napp.factory('AuthInjector', function($q, Authorize, $injector, CONFIG) {\n  return {\n    request: function(config) {\n      if (Authorize.token) {\n        config.headers.Authorization = 'Bearer ' + Authorize.token;\n      }\n      return config;\n    },\n    response: function(response) {\n      var defer = $q.defer();\n      defer.resolve(response);\n      return defer.promise;\n    },\n    responseError: function(error) {\n      //如果401且本地存在uid，则刷新accessToken\n      if (error.status == 401) {\n        //刷新请求\n        var $http = $injector.get(\"$http\");\n        $http({\n          method: 'GET',\n          url: CONFIG.api + '/auth/token',\n          params: {\n            uid: Authorize.uid\n          }\n        }).success(function(data) {\n          Authorize.token = data.token;\n          //写入本地\n          localStorage.setItem('authorize.token', data.token);\n          return $http(error.config);\n        });\n      }\n      else if (error.status == 422) {\n        var resp;\n        angular.forEach(error.data, function(item) {\n          if (resp == undefined) {\n            resp = item;\n          }\n        });\n        return $q.reject(resp);\n      }\n      return $q.reject({\n      message: '请求失败'\n      });\n    }\n  }\n});\n```\n\n原理就是所有的http请求一旦返回401就进行重新登录请求，最后一句\n\n```javascript\nreturn $http(error.config);\n```\n\n会将之前报401错误的请求恢复并重新执行一遍。\n\n大体就是这么多，总结一下就是：\n1. app.run中检测登录。\n2. Authorize服务保存用户信息。\n3. httpProvider中注入拦截器实现Authorize头的自动添加和401结果的请求恢复。","tags":["authorize"],"categories":["angularjs"]},{"title":"angularjs集成requirejs","url":"%2F2015%2F07%2F22%2Fdevelopment-angularjs-app-with-requirejs.html","content":"angularjs自带的模块话机制对于业务逻辑的组织确实起到了规范化的作用，但是对于大型web项目，弊端也出来了，一次性加载所有的资源会导致进入应用的时间变长，而实际上，首页需要加载的并不多，所以，本文将介绍如何使用requireJs与angularJs集成。\n## 依赖\n+ jquery(非必须)\n+ angularjs\n+ ui-router\n+ requirejs\n\n## 入口文件\n我们知道，使用requireJs之后，在首页只需使用script标签加载requirejs即可，剩下的文件加载需要配置下入口文件。\n\n```javascript\n/**\n * @author xialei <xialeistudio@gmail.com>\n */\nrequire.config({\n    baseUrl: 'app',\n    paths: {\n        \"angular\": \"/vendor/angular/angular\",\n        \"ui-router\": \"/vendor/ui-router/release/angular-ui-router\",\n        \"jquery\": \"/vendor/jquery/dist/jquery\"\n    },\n    shim: {\n        \"angular\": {\n            exports: \"angular\",\n            deps: [\"jquery\"]\n        },\n        \"ui-router\": {\n            exports: \"ui-router\",\n            deps: [\"angular\"]\n        },\n        \"jquery\": {\n            exports: \"jquery\"\n        }\n    }\n});\n\nrequire([\"jquery\", \"angular\", \"app\",\"router\",\"controllers\"], function($, angular) {\n    $(function() {\n        angular.bootstrap(document, [\"app\"]);\n    });\n});\n```\n\nvendor是依赖的库，路径可以根据实际情况进行修改。   \nangularjs的代码组织方式不是amd规范的，所以需要使用shim将其暴露出来供其他模块使用。   \n由于采用了requireJs，所以不能直接写 angular.module('xx',[])这种代码了。因为依赖的库有可能没下载完成。\n## app.js\n\n```javascript\nvar app = angular.module(\"app\", [\"ui.router\"]);\n```\n\n使用requireJs之后，这种就行不通了，因为amd开发方式下，一切皆模块。   \n而app作为“根模块”是需要给其他模块（controller,directive,etc...）使用的，所以模块定义的最后需要return。\n\n```javascript\nvar app = angular.module(\"app\", [\"ui.router\"]);\ndefine([\"angular\",\"ui-router\"], function(angular) {\n    var app = angular.module(\"app\", [\"ui.router\"]);\n    return app;\n});\n```\n\n这样，其他需要依赖app模块的模块就可以使用该“根模块了”。\n## controllers.js\n\n```javascript\ndefine([\"app\"], function(app) {\n    app.controller(\"HomeCtrl\", [\"$scope\", function($scope) {\n        $scope.run = function() {\n            console.log('run');\n        };\n    }]);\n});\n```\n\ncontrollers是依赖app模块的，所以这里引入app依赖，其他代码与之前一样。\n\n## router.js\n之前一直使用angular-router,但是永久之后发现还是ui-router好用，这里使用ui-router作为路由管理库。\n\n```javascript\ndefine([\"app\"], function(app) {\n    app.config(['$stateProvider', '$urlRouterProvider', function($stateProvider, $urlRouterProvider) {\n        $stateProvider.state('index', {\n            url:\"/\",\n            views: {\n                \"main\": {\n                    templateUrl: \"app/templates/home.html\",\n                    controller: \"HomeCtrl\"\n                }\n            }\n        });\n        $urlRouterProvider.otherwise('/');\n    }]);\n});\n```\n\n## index.html\n\n```html\n<!DOCTYPE html>\n<html>\n<head lang=\"en\">\n    <meta charset=\"UTF-8\">\n    <title>Angularjs+RequireJs</title>\n</head>\n<body>\n\n<div ui-view=\"main\"></div>\n<script src=\"/vendor/requirejs/require.js\" data-main=\"main\"></script>\n</body>\n</html>\n```\n\n相比于之前写很多script标签，这里只需要写一个，是不是“清爽”了很多呢？\n\n## demo\n[demo](http://ngdemo.sinaapp.com/ng-requirejs/#/)，打开之后只有一个\"run\"的按钮，请大家打开控制台之后点击按钮即可。","tags":["requirejs"],"categories":["angularjs"]},{"title":"移动端input和textarea宽度不一致的问题","url":"%2F2015%2F07%2F05%2Finput-textarea-width-not-same-on-mobile-phone.html","content":"今天在做写一个IOS端的表单时，尽管input,textarea设置了宽度，结果发现真机浏览的时候发现宽度不一致，有图为证   \n![图片](https://og5r5kasb.qnssl.com/wp-content/uploads/2015/07/IMG_0839.png)\n\n## css\n\n```css\ninput,\ntextarea {\n  border-radius: 4px;\n  border: 1px solid #4f4f4f;\n  font-size: 24px;\n  background: none;\n  outline: 0;\n  width: 283px;\n  -webkit-box-shadow: 0 0 4px rgba(0, 0, 0, .4);\n}\n```\n\n在PC版的chrome发现textarea有默认的padding属性，估计是这个问题，加上padding:0;之后，宽度一致了。   \n![图片](https://og5r5kasb.qnssl.com/wp-content/uploads/2015/07/IMG_0840.png)\n","tags":["front-end"],"categories":["front-end"]},{"title":"angularjs指令实现radioGroup","url":"%2F2015%2F06%2F30%2Fangularjs-radio-group-directive.html","content":"angularjs的指令系统其实也是很强大的东西，扩展了HTML的表现力。本文讲的是如何用angularjs指令实现radioGroup，自带的radio只能控制ngModel的两种状态: true/false。\n## 指令代码\n\n```javascript\nmodule.directive('radio', [function() {\n    return {\n        transclude: true,\n        replace: true,\n        template: '<div class=\"ui ui-radio\"><span class=\"radio-item\"></span><span ng-transclude=\"\" class=\"common-color\"></span></div>',\n        require: 'ngModel',\n        link: function(scope, ele, attrs, ctrl) {\n            ctrl.$render = function() {\n                if(ctrl.$viewValue == attrs.value) {\n                    //jqLite不支持siblings方法，如果此段代码无效，请使用zepto实现\n                    ele.parent().children().removeClass(\"active\");\n                    ele.addClass(\"active\");\n                }\n            };\n            ele.bind(\"click\", function() {\n                ctrl.$setViewValue(attrs.value);\n                ele.addClass(\"active\");\n                var childrens = ele[0].parentNode.children;\n                for(var i = 0; i < childrens.length; i++) {\n                    if(childrens[i] != ele[0]) {\n                        angular.element(childrens[i]).removeClass(\"active\");\n                    }\n                }\n            });\n        }\n    };\n}]);\n```\n\n```less\n.ui {\n  &-radio {\n    &.active {\n      .radio-item:after {\n        display: block;\n        width: 19px;\n        height: 19px;\n        content: ' ';\n        position: absolute;\n        border-radius: 50%;\n        left: (35px-19)/2;\n        top: (35px-19)/2;\n        background: #d14db7;\n      }\n    }\n    .radio-item {\n      width: 35px;\n      height: 35px;\n      border-radius: 50%;\n      position: relative;\n      background: white;\n      display: inline-block;\n      vertical-align: middle;\n      margin: 0;\n    }\n    span {\n      margin-left: 12px;\n    }\n  }\n}\n```\n\n## HTML\n\n```html\n<div ng-init=\"answer='A'\" class=\"options container-fluid wrapper\">\n  <div radio=\"\" ng-model=\"answer\" value=\"A\">A. </div>\n  <div radio=\"\" ng-model=\"answer\" value=\"B\">B. </div>\n  <div radio=\"\" ng-model=\"answer\" value=\"C\">C. </div>\n    <div ng-if=\"questions[index].option_d\" radio=\"\" ng-model=\"answer\" value=\"D\">D. </div>\n</div>\n```\n\n## 效果\n![效果](https://og5r5kasb.qnssl.com/wp-content/uploads/2015/07/B0723015-0ECD-403A-9207-78EFB316E358.jpg)","tags":["radio-group"],"categories":["angularjs"]},{"title":"lnmp一键安装memcached的shell脚本","url":"%2F2015%2F05%2F29%2Fshell-to-install-memached-on-lnmp.html","content":"通过LNMP安装脚本安装的PHP环境默认是不带Memcached支持的（是memcached不是memcache），百度一下memcached的安装方法，发现基本都是memcache的，其实这是两个不同的东西。\n\n而memcached是pecl的项目，所以需要到pecl网站上去下载最新的memcached安装包。\n\n为了方便多台服务器的安装，本人整理成了一个sh脚本进行安装，当然,php-config路径和phpize路径需要改下（如果使用LNMP脚本安装的话则不用改）\n\n```bash\n#!/bin/bash\nwget https://launchpad.net/libmemcached/1.0/0.53/+download/libmemcached-0.53.tar.gz\ntar xvfz libmemcached-0.53.tar.gz\ncd libmemcached-0.53\n./configure --prefix=/usr/local/libmemcached --enable-sasl\nmake && make install\nwget http://pecl.php.net/get/memcached-2.0.0.tgz\ntar zvxf memcached-2.0.0.tgz\ncd memcached-2.0.0/\nphpize\n./configure --enable-memcached --with-php-config=/usr/local/php/bin/php-config --with-libmemcached-dir=/usr/local/libmemcached --enable-memcached-sasl\nmake && make install\n```\n","tags":["memcached"],"categories":["linux"]},{"title":"linux运行dos格式脚本导致的bad interpreter","url":"%2F2015%2F05%2F21%2Fshell-bad-interpreter.html","content":"\n## 问题\n在使用php作为linux上shell脚本运行时出现了以下错误：\n\n```php\n#!/usr/bin/env php\n<?php\nphpinfo();\n```\n\n```bash\nchmod +x test.php\n./test.php\n/usr/local/php/bin/php^M: bad interpreter: No such file or directory\n```\n\n原因是你的文本以DOS文件形式保存，导致文件头有不可见字符，导致bash shell无法解析。\n\n## 解决办法\n\n```bash\nyum install dos2unix -y\ndos2unix test.php\n```\n\n再执行就没问题了","tags":["linux"],"categories":["linux"]},{"title":"svg制作loading","url":"%2F2015%2F05%2F17%2Fsvg-loading.html","content":"还在使用gif做loading效果吗？你确实out了，再不济也得用css3动画是不是--。无奈，css3旋转动画需要一张png图片来做，也没什么问题，现在，有更炫酷的方案了。   \n没错!就是SVG。svg其实不是什么新东西。SVG 于 2003 年 1 月 14 日成为 W3C 推荐标准。现在浏览器越来越强大，所以，尽情使用吧！   \n\n## 代码\n\n```xml\n<div style=\"width: 200px;height: 200px;background: #000000\">\n  <svg width=\"100%\" height=\"100%\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\">\n    <g>\n      <circle cx=\"100\" cy=\"100\" r=\"50\" fill=\"none\" stroke-width=\"2\" stroke=\"rgba(255,255,255,0.2)\"/>\n      <path d=\"M100 50 A50 50 0 0 1 150 100 \" style=\"stroke: rgba(255,255,255,.7);stroke-width: 2\"/>\n      <animateTransform \n        attributeName=\"transform\" \n        fill=\"freeze\" \n        attributeType=\"XML\" \n        type=\"rotate\" \n        from=\"0,100,100\" \n        to=\"360,100,100\" \n        dur=\"1s\" \n        repeatCount=\"indefinite\"\n      />\n    </g>\n  </svg>\n</div>\n```\n\n## 效果\n\n<div style=\"width: 200px;height: 200px;background: #000000\">\n  <svg width=\"100%\" height=\"100%\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\">\n    <g>\n      <circle cx=\"100\" cy=\"100\" r=\"50\" fill=\"none\" stroke-width=\"2\" stroke=\"rgba(255,255,255,0.2)\"/>\n      <path d=\"M100 50 A50 50 0 0 1 150 100 \" style=\"stroke: rgba(255,255,255,.7);stroke-width: 2\"/>\n      <animateTransform attributeName=\"transform\" fill=\"freeze\" attributeType=\"XML\" type=\"rotate\" from=\"0,100,100\" to=\"360,100,100\" dur=\"1s\" repeatCount=\"indefinite\"/>\n    </g>\n  </svg>\n</div>","tags":["svg"]},{"title":"php文件缓存类","url":"%2F2015%2F04%2F13%2Fphp-filecache.html","content":"缓存有很多方法，memcache,databse,file,redis等等，原理都差不多，简要介绍一下，写入缓存就不多说了，主要是读取缓存。\n1. 检测指定key是否存在，如不存在则返回false。\n2. 检测指定key是否过期，如过期则返回false。\n3. 指定key存在且未过期，返回缓存值。\n\n本文介绍文件缓存的实现，其他类型可以参照实现。\n\n```php\n<?php\n\n/**\n * @project wechatPublicPlatform\n * @date 2015-4-13\n * @author xialei <xialeistudio@gmail.com>\n */\nclass Cache\n{\n\n    function __construct()\n    {\n        throw new Exception('不可被实例化');\n    }\n\n    /**\n     * 设置缓存\n     * @param string $key\n     * @param string $value\n     * @param int $expires 0为不过期\n     * @return int\n     */\n    public static function set($key, $value, $expires = 0)\n    {\n        $cachePath = __DIR__ . '/cache';\n        if (!is_dir($cachePath)) {\n            mkdir($cachePath, 666);\n        }\n        $data = [\n            'key' => $key,\n            'value' => $value,\n            'expires' => $expires\n        ];\n        return file_put_contents($cachePath . '/' . md5($key), json_encode($data, JSON_UNESCAPED_UNICODE));\n    }\n\n    /**\n     * 获取缓存\n     * @param string $key\n     * @return bool\n     */\n    public static function get($key)\n    {\n        $cacheFile = __DIR__ . '/cache/' . md5($key);\n        //检测是否存在\n        if (!is_file($cacheFile)) {\n            return false;\n        }\n        //检测是否过期\n        $data = json_decode(file_get_contents($cacheFile), true);\n        //获取最近修改时间\n        $mtime = filemtime($cacheFile);\n        if (time() > $mtime + $data['expires']) {\n            unlink($cacheFile);\n            return false;\n        }\n        return $data['value'];\n    }\n\n    /**\n     * 删除缓存\n     * @param string $key\n     * @return bool\n     */\n    public static function delete($key)\n    {\n        $cacheFile = __DIR__ . '/cache/' . md5($key);\n        if (is_file($cacheFile)) {\n            return unlink($cacheFile);\n        }\n        return true;\n    }\n}\n```","tags":["cache"],"categories":["php"]},{"title":"带进度条的angularjs上传指令","url":"%2F2015%2F04%2F09%2Fangularjs-upload-directive-with-progress.html","content":"## 项目地址\n[https://git.coding.net/xialei/xl-angular-upload.git](https://git.coding.net/xialei/xl-angular-upload.git)\n## 效果图\n![图1](https://og5r5kasb.qnssl.com/wp-content/uploads/2015/04/QQ%E6%88%AA%E5%9B%BE20150409190032-300x144.png)\n![图2](https://og5r5kasb.qnssl.com/wp-content/uploads/2015/04/QQ%E6%88%AA%E5%9B%BE20150409190040-300x153.png)\n## 指令代码\n\n```javascript\nangular.module('xl-angular-upload', [])\n    .directive('angularUpload', [function () {\n        return {\n            restrict: 'E',\n            require: 'ngModel',\n            template: '<div class=\"xl-angular-upload\">\\n    <!--upload button-->\\n    <button class=\"xl-btn btn-primary\">上传\\n        <input type=\"file\"/>\\n    </button>\\n    <!--upload queue-->\\n    <div class=\"queue\">\\n        <div class=\"item\" ng-repeat=\"item in queue\">\\n            <div class=\"info\">\\n                <div class=\"no\">{{$index+1}}</div>\\n                <div class=\"name\">{{item.name}}</div>\\n                <div class=\"size\">{{(item.size/1024).toFixed(2)}}KB</div>\\n            </div>\\n            <div class=\"process-bar\">\\n                <div class=\"process\" style=\"width:{{item.process}}%\"></div>\\n            </div>\\n        </div>\\n    </div>\\n</div>',\n            replace: true,\n            link: function (scope, ele, attrs, ctrl) {\n                //必要属性检测\n                if (!attrs.action) {\n                    throw new Error('请设置上传action');\n                }\n                //初始化\n                scope.queue = [];\n                var file = angular.element(document.querySelector('.xl-angular-upload>.xl-btn>input[type=\"file\"]'));\n                var files = [];\n                attrs.accept && file.attr('accept', attrs.accept);\n                attrs.multiple && file.attr('multiple', attrs.multiple);\n                file.bind(\"change\", function (e) {\n                    scope.$apply(function () {\n                        scope.queue = [];\n                        for (var i in e.target.files) {\n                            if (/^\\d+$/.test(i)) {\n                                e.target.files[i].process = 0;\n                                scope.queue.push(e.target.files[i]);\n                            }\n                        }\n                    });\n                    //准备上传\n                    scope.queue.forEach(function (item) {\n                        var data = new FormData;\n                        data.append(attrs.name || 'file', item);\n                        var xhr = new XMLHttpRequest();\n                        xhr.open('POST', attrs.action, true);\n                        //事件监听\n                        xhr.onreadystatechange = function () {\n                            if (xhr.readyState == 4 && xhr.status == 200) {\n                                //上传完成了\n                                var resp = JSON.parse(xhr.responseText);\n                                if (resp.error) {\n                                    throw new Error(resp.error);\n                                } else {\n                                    files.push(resp);\n                                    ctrl.$setViewValue(files);\n                                }\n                            }\n                        };\n                        xhr.onerror = function (error) {\n                            throw new Error(error);\n                        };\n                        xhr.upload && (xhr.upload.onprogress = function (e) {\n                            if (e.lengthComputable) {\n                                scope.$apply(function () {\n                                    item.process = parseInt((e.loaded / e.total) * 100);\n                                });\n                            }\n                        });\n                        xhr.send(data);\n                    });\n                });\n            }\n        }\n    }]);\n```\n\n## HTML代码\n\n```html\n<!DOCTYPE html>\n<html ng-app=\"app\">\n<head lang=\"en\">\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n    <title>AngularToggle</title>\n    <link rel=\"stylesheet\" href=\"angular-upload.css\"/>\n    <style>\n        * {\n            font-family: Consolas, \"Microsoft Yahei\", arial, sans-serif;\n        }\n    </style>\n</head>\n<body ng-controller=\"MainCtrl\">\n<div style=\"width: 400px\">\n    <angular-upload action=\"upload.php\" name=\"file\" accept=\"image/*\" multiple=\"true\" ng-model=\"files\"/>\n</div>\n<script src=\"http://cdn.bootcss.com/angular.js/1.3.15/angular.min.js\"></script>\n<script src=\"angular-upload.js\"></script>\n<script>\n    (function () {\n        \"use strict\";\n        angular.module('app', [\n            'xl-angular-upload'\n        ]).controller('MainCtrl', ['$scope', function ($scope) {\n            $scope.$watch('files', function (n, o) {\n                console.log(n);\n            });\n        }]);\n    })();\n</script>\n</body>\n</html>\n```\n\n## CSS代码\n\n```css\n.xl-angular-upload .xl-btn {\n  color: #666;\n  background-color: #EEE;\n  border-color: #EEE;\n  font-weight: 300;\n  font-size: 16px;\n  font-family: \"Consolas\", \"Microsoft YaHei\", Arial, arial, sans-serif;\n  text-decoration: none;\n  text-align: center;\n  line-height: 40px;\n  height: 40px;\n  padding: 0 40px;\n  margin: 0;\n  display: inline-block;\n  appearance: none;\n  cursor: pointer;\n  border: none;\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n  -webkit-transition-property: all;\n  transition-property: all;\n  -webkit-transition-duration: .3s;\n  transition-duration: .3s;\n  border-radius: 4px;\n  -webkit-border-radius: 4px;\n  -moz-border-radius: 4px;\n  position: relative;\n}\n.xl-angular-upload .xl-btn.btn-primary {\n  background-color: #7B72E9;\n  border-color: #7B72E9;\n  color: #FFF;\n}\n.xl-angular-upload .xl-btn.btn-primary:hover {\n  background-color: #a49ef0;\n  border-color: #a49ef0;\n  color: #FFF;\n}\n.xl-angular-upload .xl-btn input[type=\"file\"] {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  left: 0;\n  top: 0;\n  opacity: 0;\n}\n.xl-angular-upload .queue {\n  width: 100%;\n}\n.xl-angular-upload .queue .item {\n  margin-top: 4px;\n}\n.xl-angular-upload .queue .item > .info .no {\n  float: left;\n  width: 10%;\n  text-align: center;\n}\n.xl-angular-upload .queue .item > .info .name {\n  float: left;\n  width: 70%;\n}\n.xl-angular-upload .queue .item > .info .size {\n  float: right;\n  width: 20%;\n}\n.xl-angular-upload .queue .item > .info:after {\n  content: ' ';\n  display: block;\n  clear: both;\n}\n.xl-angular-upload .queue .item > .process-bar {\n  width: 100%;\n  height: 4px;\n  margin-top: 4px;\n}\n.xl-angular-upload .queue .item > .process-bar .process {\n  transition: all .2s;\n  -webkit-transition: all .2s;\n  -moz-transition: all .2s;\n  height: 100%;\n  width: 0;\n  background: #7B72E9;\n}\n```\n\n本指令的难点在于进度条的更新及ngModel数据的双向绑定，其实，只要在指令中require”ngModel”之后，利用$setViewValue方法和$render方法就可以了。而进度条的处理是由于双向绑定中列表的每个元素都是一个单独的对象，更新该对象的值不会影响其他上传，即每个上传都是单独的进度条。","tags":["progress"],"categories":["angularjs"]},{"title":"在AngularJS中使用$q进行“同步”编程","url":"%2F2015%2F04%2F06%2Fangularjs-q.html","content":"今天群里有位朋友问到直接返回$http说读不到数据，原因在于$http是异步请求，而且是“不可期”的，你不知道什么时候这个请求完成了。\n\n而对于这种需要“同步”编程的方式，AngularJS提供了一个内置Service $q，它提供了一种承诺/延后（promise/deferred），可以保证我们的调用代码一定能够拿到数据。所以我们用起来可以像同步调用一样，话说回来，最终还是xhr异步请求。\n\n##　Factory\n\n```javascript\napp.factory('itemService', ['$http', '$q', function ($http, $q) {  \n  return {  \n    query : function() {  \n      var deferred = $q.defer();//声明承诺\n      $http({method: 'GET', url: '/item/list'}).  \n      success(function(data) {  \n        deferred.resolve(data);//请求成功\n      }).  \n      error(function(data) {  \n        deferred.reject(data); //请求失败\n      });  \n      return deferred.promise;   // 返回承诺，这里返回的不是数据，而是API\n    } \n  };  \n}]);  \n```\n\n## Controller\n\n```javascript\nangular.module('app')  \n  .controller('MainCtrl', ['itemService','$scope', function (itemService,$scope) { // 注入itemService\n    var promise = itemService.query(); //获得承诺接口  \n    promise.then(function(data) {  // 成功回调\n        $scope.user = data;  \n    }, function(data) {  // 错误回调\n        console.log('请求失败');\n    });  \n  }]);  \n```\n\n## 文档地址\n[http://docs.angularjs.org/api/ng.$q](http://docs.angularjs.org/api/ng.$q)","tags":["promise"],"categories":["angularjs"]},{"title":"angularjs Hello World","url":"%2F2015%2F04%2F06%2Fangularjs-hello-world.html","content":"几乎所有的编程入门都是以\"Hello World\"开始的，这里也不例外。\n## HTML代码\n\n```html\n<!DOCTYPE html>\n<!--使用ng-app指令“告诉”ng从哪里开始编译-->\n<html ng-app=\"app\">\n<head lang=\"en\">\n    <meta charset=\"UTF-8\">\n    <title>Hello World - Angularjs</title>\n    <script src=\"../vendor/angularjs/angular.js\"></script>\n    <script src=\"main.js\"></script>\n</head>\n<body>\n<p></p>\n<input type=\"text\" ng-model=\"message\" placeholder=\"说点什么\"/>\n</body>\n</html>\n```\n\n## JS代码\n\n```javascript\n/**\n * @author xialei <xialeistudio@gmail.com>\n */\nvar app = angular.module('app',[\n]);\n```\n\n双向绑定为ng内置，所以这里的js，实际上只有一个app定义罢了。   \n在输入框中输入任何字符都会及时在其之前的p元素显示出来。","tags":["hello world"],"categories":["angularjs"]},{"title":"Angularjs概念解释","url":"%2F2015%2F04%2F06%2Fangularjs-concept%20to%20explain.html","content":"+ 本文将根据项目进度不定期更新   \n+ 本文所有内容仅代表个人观点\n\n## ng\n*Angularjs的简称。*\n## 指令(Directive)\n*特殊的html标签或html属性，扩展了html的功能*。有以下几类：\n+ E    Element 元素 如 <dropdown /> 就是一个自定义指令（如何自定义指令，将在后面的文章中介绍），名称为\"dropdown\"。\n+ A    Attribute 属性 如 <html ng-app=\"app\"></html> 这是最常用的指令了，ng-app为指令名称，也是html元素的属性，app为该属性的值\n\n## 作用域(scope)\n*ng中变量、方法都是基于作用域的，作用类似于js作用域。*\n## ng-bind\n*html输出js变量，跟作用域绑定，message为作用域中的一个变量。*示例代码：\n\n```html\n<button ng-bind=\"message\"></button>\n```\n\n最终会显示同一scope下的message变量值。\n\n## ng-model\n*双向绑定指令*，示例代码：\n\n```html\n<input type=\"text\" ng-model=\"message\"/>\n```\n\n表明将input的值与作用域中的message变量进行绑定，当input值改变的时候，变量message跟着改变，html中输出的内容也会同步改变。\n","tags":["get-started"],"categories":["angularjs"]},{"title":"使用gulp来构建你的前端自动化工作流","url":"%2F2015%2F03%2F16%2Fgulp-workflow.html","content":"之前用的Grunt，不过有时候Grunt确实用起来不爽，进来找到一款叫gulp.js的前端构建工具，当然，也是基于node.js的。\n## 安装\n\n```bash\nnpm install gulp --save-dev\nnpm install del gulp-concat gulp-cssmin gulp-uglify --save-dev\n```\n\n## 配置\n配置gulpfile.js，如果工作目录下没有该文件，请新建gulpfile.js，以下为一个常用的参考代码:\n\n```javascript\n/**\n * @author xialei <xialeistudio@gmail.com>\n */\n(function () {\n    \"use strict\";\n    /**\n     * 加载插件\n     * @type {exports}\n     */\n    var gulp = require('gulp');\n    var del = require('del');\n    var cssmin = require('gulp-cssmin');\n    var concat = require('gulp-concat');\n    var uglify = require('gulp-uglify');\n\n    /**\n     * 清空目录的命令\n     */\n    gulp.task('clean', function () {\n        del(['build']);\n    });\n    gulp.task('css', function () {\n        /**\n         * 加载源代码\n         */\n        return gulp.src([\n            'bower_components/bootstrap/dist/css/bootstrap.min.css',\n            'bower_components/font-awesome/css/font-awesome.min.css',\n            'css/style.css'\n        ])\n        /**\n         * 压缩css\n         */\n            .pipe(cssmin())\n        /**\n         * 连接压缩后的css\n         */\n            .pipe(concat('style.css'))\n        /**\n         * 输出到目标目录\n         */\n            .pipe(gulp.dest('build/css'))\n    });\n    gulp.task('js', function () {\n        return gulp.src([\n        /**\n         * 加载源代码\n         */\n            'bower_components/angular/angular.min.js',\n            'bower_components/angular-sanitize/angular-sanitize.min.js',\n            'js/main.js'])\n        /**\n         * 压缩Js\n         */\n            .pipe(uglify())\n        /**\n         * 合并js\n         */\n            .pipe(concat('main.js'))\n        /**\n         * 输出到目标目录\n         */\n            .pipe(gulp.dest('build/js'))\n    });\n    gulp.task('img', function () {\n        /**\n         * 加载源文件\n         */\n        return gulp.src([\n            'img/*.*'\n        ])\n        /**\n         * 输出到目标目录\n         */\n            .pipe(gulp.dest('build/img'));\n    });\n\n    /**\n     * 定义默认任务，此任务依赖于 clean,img,css,js，所以在执行\n     * 本任务时会按顺序先执行依赖任务\n     */\n    gulp.task('default', ['clean', 'img', 'css', 'js']);\n})();\n```\n\n## 执行编译\n\n```bash\ngulp\n```","tags":["gulp"],"categories":["front-end"]},{"title":"PHPExcel导出时列过大的解决方案","url":"%2F2015%2F03%2F07%2Fphpexcel-a-lot-of-column.html","content":"今天导出Excel的时候，列不是固定的，而且有差不多几十个，横轴由'A'变为了'AA'，给导出时增加了难度，因为要去算列名称，不过换个方式想一下，发现是很有规律的26进制数。 发现秘诀后就好办了，发一个10进制转26进制的方法。\n## 代码\n\n```php\nprivate function numberToStr26($n)\n{\n    $s = '';\n    while ($n > 0) {\n        $m = $n % 26;\n        if ($m == 0) $m = 26;\n        $s = chr($m + 64) . $s;\n        $n = ($n - $m) / 26;\n    }\n    return $s;\n}\n```\n\n## 效果图\n![效果图](https://og5r5kasb.qnssl.com/wp-content/uploads/2015/03/QQ%E6%88%AA%E5%9B%BE20150307113935.png)","tags":["excel"],"categories":["php"]},{"title":"微信公众平台回复乱码问题","url":"%2F2015%2F03%2F06%2Fwechat-reply-messy-code.html","content":"很多微信公众平台的自动回复程序都是 ThinkWechat.class.php 这个类开发的，今天碰到一个莫名其妙的乱码问题，查问题发现是GB2312编码导致，所以要修改源码。\n\n先增加一个方法:\n\n```php\n/**\n * 检测是否UTF-8\n * @param $str\n * @return bool\n */\nprivate function is_utf8($str)\n{\n    return preg_match('//u', $str);\n}\n```\n\n找到\n\n```php\n$this->data ['Content'] = $content;\n```\n\n修改为\n\n```php\nif ($this->is_utf8($content)) {\n    $this->data ['Content'] = $content;\n} else {\n    $this->data ['Content'] = iconv('gb2312', 'UTF-8//IGNORE', $content);\n}\n```\n","tags":["wechat"],"categories":["php"]},{"title":"angularjs ueditor指令","url":"%2F2015%2F02%2F05%2Fangularjs-ueditor-directive.html","content":"一直以来，angularjs的富文本编辑器都比较难做，主要是第三方的编辑器很难集成进来，今天花时间研究了一下，发现ueditor主要加载两个js文件\n+ ueditor.config.js\n+ ueditor.all.js\n\n能不能把这两个文件异步加载呢？答案是肯定的。我们新建一个服务用来异步加载资源，并设置必要的回调方法。\n\n## Factory\n\n```javascript\nservices.factory('Common', ['$http', '$q',\nfunction($http, $q) {\n    return {\n        loadScript: function(url, callback) {\n            var head = document.getElementsByTagName(\"head\")[0];\n            var script = document.createElement(\"script\");\n            script.setAttribute(\"type\", \"text/javascript\");\n            script.setAttribute(\"src\", url);\n            script.setAttribute(\"async\", true);\n            script.setAttribute(\"defer\", true);\n            head.appendChild(script);\n            //fuck ie! duck type\n            if (document.all) {\n                script.onreadystatechange = function() {\n                    var state = this.readyState;\n                    if (state === 'loaded' || state === 'complete') {\n                        callback && callback();\n                    }\n                }\n            } else {\n                //firefox, chrome\n                script.onload = function() {\n                    callback && callback();\n                }\n            }\n        },\n        loadCss: function(url) {\n            var ele = document.createElement('link');\n            ele.href = url;\n            ele.rel = 'stylesheet';\n            if (ele.onload == null) {\n                ele.onload = function() {};\n            } else {\n                ele.onreadystatechange = function() {};\n            }\n            angular.element(document.querySelector('body')).prepend(ele);\n        }\n    }\n}]);\n```\n\n通过绑定callback到 onload 事件来实现回调。\n## 指令\n\n```javascript\ndirectives.directive('ueditor', ['Common', '$rootScope',\nfunction(Common, $rootScope) {\n    return {\n        restrict: 'EA',\n        require: 'ngModel',\n        link: function(scope, ele, attrs, ctrl) {\n            $rootScope.$emit('loading', '初始化编辑器...'); //广播loading事件，可以删除\n            var _self = this,\n            _initContent, editor, editorReady = false,\n            base = '/public/vendor/utf8_qiniu_ueditor-master',\n            //ueditor目录\n            _id = attrs.ueditor;\n            var editorHandler = {\n                init: function() {\n                    window.UEDITOR_HOME_URL = base + '/';\n                    var _self = this;\n                    if (typeof UE != 'undefined') {\n                        editor = UE.getEditor(_id, {\n                            toolbars: [['fontsize', '|', 'blockquote', 'horizontal', '|', 'removeformat', '|', 'insertimage', '|', 'bold', 'italic', 'underline', 'forecolor', 'backcolor', '|', 'justifyleft', 'justifycenter', 'justifyright', 'justifyjustify', 'rowspacingtop', 'rowspacingbottom', 'lineheight', '|', 'insertorderedlist', 'insertunorderedlist', '|', 'link', 'unlink', '|', 'emotion']]\n                        });\n                        editor.ready(function() {\n                            editor.setHeight(500);\n                            editorReady = true;\n                            $rootScope.$emit('loading', ''); //编辑器初始化完成\n                            editor.addListener('contentChange',\n                            function() { //双向绑定\n                                if (!scope.$$phase) {\n                                    scope.$apply(function() {\n                                        ctrl.$setViewValue(editor.getContent());\n                                    });\n                                }\n                            });\n                        });\n                    } else {\n                        Common.loadScript(base + '/ueditor.config.js', null);\n                        Common.loadScript(base + '/ueditor.all.min.js',\n                        function() {\n                            _self.init();\n                        });\n                    }\n                },\n                setContent: function(content) {\n                    if (editor && editorReady) {\n                        editor.setContent(content);\n                    }\n                }\n            };\n            ctrl.$render = function() {\n                _initContent = ctrl.$isEmpty(ctrl.$viewValue) ? '': ctrl.$viewValue;\n                editorHandler.setContent(_initContent); //双向绑定\n            };\n            editorHandler.init();\n            //事件\n            $rootScope.$on('$routeChangeStart',\n            function() {\n                editor && editor.destroy();\n            });\n        }\n    }\n}]);\n```\n\n由于angularjs无法自动获得编辑器内容，只能手动监听 contentChange事件来实现双向绑定。\n\n## 模板代码\n\n```html\n<div ueditor=\"editor\" ng-required=\"true\" ng-model=\"material.content.content\" id=\"editor\"></div> \n```\n\n## 效果图\n![效果图](https://og5r5kasb.qnssl.com/wp-content/uploads/2015/02/QQ%E6%88%AA%E5%9B%BE20150205191752.png)","tags":["rich text editor"],"categories":["angularjs"]},{"title":"基于angularjs的在线音乐播放器","url":"%2F2015%2F01%2F30%2Fangularjs-online-music-player.html","content":"\n## 项目地址\n[https://github.com/xialeistudio/angular-audio-player](https://github.com/xialeistudio/angular-audio-player)\n## 在线demo\n[http://ngdemo.sinaapp.com/audio/](http://ngdemo.sinaapp.com/audio/)\n## 效果图\n![效果图](https://og5r5kasb.qnssl.com/wp-content/uploads/2015/01/QQ%E6%88%AA%E5%9B%BE20150130194035.png)","tags":["music player"],"categories":["open-source-projects"]},{"title":"android直接挂断电话","url":"%2F2015%2F01%2F29%2Fandroid-hangup-call.html","content":"最近在写一个用来发短信的机器人（android),当然需要屏蔽所有来电了。多的话不说了，直接看步骤。（IDE为android studio）：\n1.在 src/main下新建 aidl 目录。\n\n2.在src/main/aidl下新建包 com.android.internal.telephony。\n\n3.在com.android.internal.telephony新建文件 ITelephony.aidl，内容如下:\n\n```java\n/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.internal.telephony;\n\nimport android.os.Bundle;\nimport java.util.List;\nimport android.telephony.NeighboringCellInfo;\n\n/**\n * Interface used to interact with the phone.  Mostly this is used by the\n * TelephonyManager class.  A few places are still using this directly.\n * Please clean them up if possible and use TelephonyManager insteadl.\n *\n * {@hide}\n */\ninterface ITelephony {\n\n    /**\n     * Dial a number. This doesn't place the call. It displays\n     * the Dialer screen.\n     * @param number the number to be dialed. If null, this\n     * would display the Dialer screen with no number pre-filled.\n     */\n    void dial(String number);\n\n    /**\n     * Place a call to the specified number.\n     * @param number the number to be called.\n     */\n    void call(String number);\n\n    /**\n     * If there is currently a call in progress, show the call screen.\n     * The DTMF dialpad may or may not be visible initially, depending on\n     * whether it was up when the user last exited the InCallScreen.\n     *\n     * @return true if the call screen was shown.\n     */\n    boolean showCallScreen();\n\n    /**\n     * Variation of showCallScreen() that also specifies whether the\n     * DTMF dialpad should be initially visible when the InCallScreen\n     * comes up.\n     *\n     * @param showDialpad if true, make the dialpad visible initially,\n     *                    otherwise hide the dialpad initially.\n     * @return true if the call screen was shown.\n     *\n     * @see showCallScreen\n     */\n    boolean showCallScreenWithDialpad(boolean showDialpad);\n\n    /**\n     * End call or go to the Home screen\n     *\n     * @return whether it hung up\n     */\n    boolean endCall();\n\n    /**\n     * Answer the currently-ringing call.\n     *\n     * If there's already a current active call, that call will be\n     * automatically put on hold.  If both lines are currently in use, the\n     * current active call will be ended.\n     *\n     * TODO: provide a flag to let the caller specify what policy to use\n     * if both lines are in use.  (The current behavior is hardwired to\n     * \"answer incoming, end ongoing\", which is how the CALL button\n     * is specced to behave.)\n     *\n     * TODO: this should be a oneway call (especially since it's called\n     * directly from the key queue thread).\n     */\n    void answerRingingCall();\n\n    /**\n     * Silence the ringer if an incoming call is currently ringing.\n     * (If vibrating, stop the vibrator also.)\n     *\n     * It's safe to call this if the ringer has already been silenced, or\n     * even if there's no incoming call.  (If so, this method will do nothing.)\n     *\n     * TODO: this should be a oneway call too (see above).\n     *       (Actually *all* the methods here that return void can\n     *       probably be oneway.)\n     */\n    void silenceRinger();\n\n    /**\n     * Check if we are in either an active or holding call\n     * @return true if the phone state is OFFHOOK.\n     */\n    boolean isOffhook();\n\n    /**\n     * Check if an incoming phone call is ringing or call waiting.\n     * @return true if the phone state is RINGING.\n     */\n    boolean isRinging();\n\n    /**\n     * Check if the phone is idle.\n     * @return true if the phone state is IDLE.\n     */\n    boolean isIdle();\n\n    /**\n     * Check to see if the radio is on or not.\n     * @return returns true if the radio is on.\n     */\n    boolean isRadioOn();\n\n    /**\n     * Check if the SIM pin lock is enabled.\n     * @return true if the SIM pin lock is enabled.\n     */\n    boolean isSimPinEnabled();\n\n    /**\n     * Cancels the missed calls notification.\n     */\n    void cancelMissedCallsNotification();\n\n    /**\n     * Supply a pin to unlock the SIM.  Blocks until a result is determined.\n     * @param pin The pin to check.\n     * @return whether the operation was a success.\n     */\n    boolean supplyPin(String pin);\n\n    /**\n     * Handles PIN MMI commands (PIN/PIN2/PUK/PUK2), which are initiated\n     * without SEND (so dial is not appropriate).\n     *\n     * @param dialString the MMI command to be executed.\n     * @return true if MMI command is executed.\n     */\n    boolean handlePinMmi(String dialString);\n\n    /**\n     * Toggles the radio on or off.\n     */\n    void toggleRadioOnOff();\n\n    /**\n     * Set the radio to on or off\n     */\n    boolean setRadio(boolean turnOn);\n\n    /**\n     * Request to update location information in service state\n     */\n    void updateServiceLocation();\n\n    /**\n     * Enable location update notifications.\n     */\n    void enableLocationUpdates();\n\n    /**\n     */\n    void disableLocationUpdates();\n\n    /**\n     * Enable a specific APN type.\n     */\n    int enableApnType(String type);\n\n    /**\n     * Disable a specific APN type.\n     */\n    int disableApnType(String type);\n\n    /**\n     * Allow mobile data connections.\n     */\n    boolean enableDataConnectivity();\n\n    /**\n     * Disallow mobile data connections.\n     */\n    boolean disableDataConnectivity();\n\n    /**\n     * Report whether data connectivity is possible.\n     */\n    boolean isDataConnectivityPossible();\n\n    Bundle getCellLocation();\n\n    /**\n     * Returns the neighboring cell information of the device.\n     */\n    List getNeighboringCellInfo();\n\n     int getCallState();\n     int getDataActivity();\n     int getDataState();\n}\n```\n\n4.android studio 菜单 Build->Rebuild project\n\n5.在Activity中注册监听（写在onCreate()）\n\n```java\nTelephonyManager mTelephonyManager = (TelephonyManager) this\n                .getSystemService(TELEPHONY_SERVICE);\n        mTelephonyManager.listen(phoneStateListener,\n                PhoneStateListener.LISTEN_CALL_STATE);\n```\n\n6.在Activity中新建以下方法以获得telephony的实例\n\n```java\n/**\n     * @param context\n     * @return\n     */\n    private static ITelephony getITelephony(Context context) {\n        TelephonyManager mTelephonyManager = (TelephonyManager) context\n                .getSystemService(TELEPHONY_SERVICE);\n        Class c = TelephonyManager.class;\n        Method getITelephonyMethod = null;\n        try {\n            getITelephonyMethod = c.getDeclaredMethod(\"getITelephony\",\n                    (Class[]) null); // 获取声明的方法\n            getITelephonyMethod.setAccessible(true);\n        } catch (SecurityException e) {\n            e.printStackTrace();\n        } catch (NoSuchMethodException e) {\n            e.printStackTrace();\n        }\n\n        try {\n            ITelephony iTelephony = (ITelephony) getITelephonyMethod.invoke(\n                    mTelephonyManager, (Object[]) null); // 获取实例\n            return iTelephony;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n```\n\n7.在activity类中建立内部类\n\n```java\nPhoneStateListener phoneStateListener = new PhoneStateListener() {\n\n        @Override\n        public void onCallStateChanged(int state, String incomingNumber) {\n\n            ITelephony iTelephony = getITelephony(MainActivity.this);\n            switch (state) {\n                case TelephonyManager.CALL_STATE_RINGING:\n                    iTelephony = getITelephony(getApplicationContext()); //获取电话接口\n                    if (iTelephony != null) {\n                        try {\n                            iTelephony.endCall(); // 挂断电话\n                            Message msg = new Message();\n                            msg.what = SYS_MSG;\n                            msg.obj =\"成功挂断[\"+incomingNumber+\"]的电话\";\n                            handler.sendMessage(msg);\n                        } catch (RemoteException e) {\n                            Message msg = new Message();\n                            msg.what = SYS_MSG;\n                            msg.obj =\"挂断[\"+incomingNumber+\"]的电话失败\";\n                            handler.sendMessage(msg);\n                        }\n                    }\n                    break;\n                default:\n                    break;\n            }\n        }\n\n    };\n```\n","tags":["hangup call"],"categories":["android"]},{"title":"七牛上传出现 invalid mutilpart format的解决方案","url":"%2F2015%2F01%2F27%2Fphp-qiniu-invalid-mutilpart-format.html","content":"今天用umeditor编辑文章上传图片的时候发现一直卡在\"loading...\"，打开控制台发现出现了500错误，进一步调试发现是七牛上传报错了。\n\n整个上传流程是\n\n浏览器=》业务服务器=》七牛服务器\n\n在上传方法断点调试发现$_FILES数组正常，所以排除了浏览器到业务服务器上传问题，继续调试\n\n通过查看七牛SDK源码发现在 http.php的第119行附近有这样的代码：\n\n```php\n$options = array(\n      CURLOPT_USERAGENT => $req->UA,\n      CURLOPT_RETURNTRANSFER => true,\n      CURLOPT_SSL_VERIFYPEER => false,\n      CURLOPT_SSL_VERIFYHOST => false,\n      CURLOPT_HEADER => true,\n      CURLOPT_NOBODY => false,\n      CURLOPT_CUSTOMREQUEST => 'POST',\n      CURLOPT_URL => $url['path'],\n      CURLOPT_SAFE_UPLOAD => false\n);\n```\n\n请注意最后那个\n\n```php\nCURLOPT_SAFE_UPLOAD => false\n```\n\n这里应该是跟上传有关的设置，很有可能是这里的问题，果然，GOOGLE发现PHP的CURL上传文件跟PHP版本的关系很大。\n\n传统上，PHP的cURL支持通过在数组数据中，使用“@+文件全路径”的语法附加文件，供cURL读取上传。这与命令行直接调用cURL程序的语法是一致的：\n\n```php\ncurl_setopt(ch, CURLOPT_POSTFIELDS, array(\n    'file' => '@'.realpath('image.png'), \n));\n```\n\n但PHP从5.5开始引入了新的CURLFile类用来指向文件。CURLFile类也可以详细定义MIME类型、文件名等可能出现在multipart/form-data数据中的附加信息。PHP推荐使用CURLFile替代旧的@语法：\n\n```php\ncurl_setopt(ch, CURLOPT_POSTFIELDS, [\n    'file' => new CURLFile(realpath('image.png')), \n]); \n```\n\nPHP 5.5另外引入了CURL_SAFE_UPLOAD选项，可以强制PHP的cURL模块拒绝旧的@语法，仅接受CURLFile式的文件。5.5的默认值为false，5.6的默认值为true。\n\n但是坑的一点在于：@语法在5.5就已经被打了deprecated，在5.6中就直接被删除了（会产生 ErorException: The usage of the @filename API for file uploading is deprecated. Please use the CURLFile class instead）。\n\n对于PHP 5.6+而言，手动设置CURL_SAFE_UPLOAD为false是毫无意义的。根本不是字面意义理解的“设置成false，就能开启旧的unsafe的方式”——旧的方式已经作为废弃语法彻底不存在了。PHP 5.6+ == CURLFile only，不要有任何的幻想。\n\n我的部署环境是5.4(仅@语法)与服务器不同，所以必须写出带有环境判断的代码。\n\n从可靠的角度，推荐指定CURL_SAFE_UPLOAD的值，明确告知php是容忍还是禁止旧的@语法。\n\n注意在低版本PHP中CURLOPT_SAFE_UPLOAD常量本身可能不存在，需要判断：\n\n```php\nif (class_exists('\\CURLFile')) {\n    curl_setopt($ch, CURLOPT_SAFE_UPLOAD, true);\n} else {\n    if (defined('CURLOPT_SAFE_UPLOAD')) {\n        curl_setopt($ch, CURLOPT_SAFE_UPLOAD, false);\n    }\n}\n```\n","tags":["curl"],"categories":["php"]},{"title":"console.log在线控制台","url":"%2F2015%2F01%2F26%2Fonline-js-console.html","content":"项目已升级，最新版地址如下:   \n[js在线调试工具]({% post_url 2016-06-12-js-live-console %})","tags":["websocket"],"categories":["open-source-projects"]},{"title":"百度地图添加自定义标注","url":"%2F2015%2F01%2F24%2Fbaidu-map-custom-overlay.html","content":"百度地图的默认标注是一个 红色 的地标，如果要做互动性强的地图应用，几乎没提供什么额外信息，本文教大家怎么添加自定义标注，如添加头像。\n## JS代码\n\n```javascript\nvar icon = new BMap.Icon('头像URL地址', new BMap.Size(33, 33), {\n    offset: new BMap.Size(10, 25),\n    imageOffset: new BMap.Size(0, 0)\n});\nmarkers[i] = new BMap.Marker(new BMap.Point([经度], [纬度]), {\n    icon: icon\n});\nmap.addOverlay(markers[i]);\n```\n\n由于百度地图的限制，我们不能获取标注的HTML，只能采取“特别”的方式对头像增加样式，比如圆角，边框等等。\n\n```javascript\nvar avatarRadiusCompleted = false;\nvar avatarRadius = setInterval(function() {\n    avatarRadius && clearInterval(avatarRadius);\n    $('#map').find('img').each(function() {\n        var src = $(this).attr('src');\n        if (src.indexOf('map') == -1) {\n            $(this).addClass('xl-map-avatar'); //.xl-map-avatar 为自定义的CSS\n        }\n    });\n    avatarRadiusCompleted = true;\n},\n100);\n```\n\n## CSS代码\n\n```css\n.xl-map-avatar {\n\twidth: 32px;\n\theight: 32px;\n\tborder: 1px solid white !important;\n\tborder-top-left-radius: 999px; /* 左上角 */\n\tborder-top-right-radius: 999px; /* 右上角 */\n\tborder-bottom-right-radius: 999px; /* 右下角 */\n\tborder-bottom-left-radius: 999px; /* 左下角 */\n\tborder-radius: 50%;\n\tbackground-color: #ccc;\n\tbackground-clip: padding-box;\n}\n```\n\n## 效果图\n![效果图](https://og5r5kasb.qnssl.com/wp-content/uploads/2015/01/QQ%E6%88%AA%E5%9B%BE20150124140833.png)","tags":["overlay"],"categories":["front-end"]},{"title":"css3打造炫酷loading","url":"%2F2015%2F01%2F20%2Fcss3-loading.html","content":"css3的优点就不多说了，一个很重要的，节约了带宽，以往需要使用图片的地方很多时候都可以使用CSS3来实现。 本文将带来一个利用CSS3制作loading的教程，这里直接上代码了。\n\n## CSS代码\n\n```css\n@keyframes spin {\n\t0% {\n\t\ttransform: rotate(0deg);\n\t\t-webkit-transform: rotate(0deg);\n\t}\n\n\t100% {\n\t\ttransform: rotate(360deg);\n\t\t-webkit-transform: rotate(360deg);\n\t}\n}\n\n@-webkit-keyframes spin {\n\t0% {\n\t\ttransform: rotate(0deg);\n\t\t-webkit-transform: rotate(0deg);\n\t}\n\n\t100% {\n\t\ttransform: rotate(360deg);\n\t\t-webkit-transform: rotate(360deg);\n\t}\n}\n\n@keyframes spinoff {\n\t0% {\n\t\ttransform: rotate(0deg);\n\t\t-webkit-transform: rotate(0deg);\n\t}\n\n\t100% {\n\t\ttransform: rotate(-360deg);\n\t\t-webkit-transform: rotate(-360deg);\n\t}\n}\n\n@-webkit-keyframes spinoff {\n\t0% {\n\t\ttransform: rotate(0deg);\n\t\t-webkit-transform: rotate(0deg);\n\t}\n\n\t100% {\n\t\ttransform: rotate(-360deg);\n\t\t-webkit-transform: rotate(-360deg);\n\t}\n}\n\nbody {\n\tmargin: 0;\n}\n\n.content {\n\twidth: 100px;\n\theight: 100px;\n\tposition: relative;\n\tmargin: 10% auto 0 auto;\n}\n\n.content .ball {\n\ttop: 25px;\n\tleft: 25px;\n\twidth: 50px;\n\theight: 50px;\n\tposition: absolute;\n\tborder-radius: 50px;\n\t-webkit-border-radius: 50px;\n\tborder: 5px solid rgba(40,40,200,0.5);\n\tborder-left: 5px solid rgba(255,255,255,0.7);\n\tborder-top: 5px solid rgba(255,255,255,0.7);\n\tbox-shadow: 2px 2px 4px 0 rgba(40,40,200,0.4);\n\tanimation: spin .5s linear infinite;\n\t-webkit-animation: spin .5s linear infinite;\n}\n\n.content .ball1 {\n\ttop: 35px;\n\tleft: 35px;\n\twidth: 30px;\n\theight: 30px;\n\tposition: absolute;\n\tborder-radius: 30px;\n\t-webkit-border-radius: 30px;\n\tborder: 5px solid rgba(40,40,200,0.8);\n\tborder-left: 5px solid rgba(255,255,255,1.0);\n\tborder-top: 5px solid rgba(255,255,255,1.0);\n\tbox-shadow: 2px 2px 4px 0 rgba(40,40,200,0.4);\n\tanimation: spinoff .5s linear infinite;\n\t-webkit-animation: spinoff .5s linear infinite;\n}\n```\n\n## HTML代码\n\n```html\n<div class=\"content\">\n    <div class=\"ball\"></div>\n    <div class=\"ball1\"></div>\n</div>\n```\n\n## 总结\n\n实现动画有几个关键点：\n+ css3 keyframes\n+ css position\n+ css border\n \n基本就以上问题，代码可以直接新建一个页面，复制打开即可运行","tags":["css3"],"categories":["css"]},{"title":"php利用百度地图API进行IP定位和GPS定位","url":"%2F2015%2F01%2F11%2Fphp-location-by-ipgps-with-baidu-mapapi.html","content":"最近在做一个手机端的webapp地图应用，而核心内容当然是定位了，但是定位的话有几种方式，IP定位,GPS定位，基站定位（这个貌似webapp用不了），\n\n那么剩下核心的gps定位和ip定位了，我们知道，html5有定位API，但是该API拿到的GPS数据是硬件坐标，无法直接显示在地图上。\n\n后来上百度LBS云看到有地图IP定位API和GPS坐标转换API，地址：http://developer.baidu.com/map/\n\n百度地图API的调用需要申请KEY，这里就不具体介绍了，直接贴上本人写了两个关键方法，为了方便前台调用，返回数据采用以下格式：\n\n```javascript\n{\n    address: \"北京市海淀区西二旗北路\",\n    province: \"北京市\",\n    city: \"北京市\",\n    street: \"西二旗北路\",\n    street_number: \"\",\n    city_code: 131,\n    lng: 116.3207676804,\n    lat: 40.064084055578\n}\n```\n\n## PHP代码\n\n```php\n<?php\n\n/**\n * @author xialei <xialeistudio@gmail.com>\n */\nclass map\n{\n private static $_instance;\n\n const REQ_GET = 1;\n const REQ_POST = 2;\n\n /**\n  * 单例模式\n  * @return map\n  */\n public static function instance()\n {\n  if (!self::$_instance instanceof self)\n  {\n   self::$_instance = new self;\n  }\n  return self::$_instance;\n }\n\n /**\n  * 执行CURL请求\n  */\n  protected function async($api,array $params)\n  {\n    $ch = curl_init($api.'?'.http_build_query($params));\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n    $resp = curl_exec($ch);\n    curl_close($ch);\n    return $resp;\n }\n\n /**\n  * ip定位\n  * @param string $ip\n  * @return array\n  * @throws Exception\n  */\n public function locationByIP($ip)\n {\n  //检查是否合法IP\n  if (!filter_var($ip, FILTER_VALIDATE_IP))\n  {\n   throw new Exception('ip地址不合法');\n  }\n  $params = array(\n    'ak' => '百度地图API KEY',\n    'ip' => $ip,\n    'coor' => 'bd09ll'//百度地图GPS坐标\n  );\n  $api = 'http://api.map.baidu.com/location/ip';\n  $resp = $this->async($api, $params);\n  $data = json_decode($resp, true);\n  //有错误\n  if ($data['status'] != 0)\n  {\n   throw new Exception($data['message']);\n  }\n  //返回地址信息\n  return array(\n    'address' => $data['content']['address'],\n    'province' => $data['content']['address_detail']['province'],\n    'city' => $data['content']['address_detail']['city'],\n    'district' => $data['content']['address_detail']['district'],\n    'street' => $data['content']['address_detail']['street'],\n    'street_number' => $data['content']['address_detail']['street_number'],\n    'city_code' => $data['content']['address_detail']['city_code'],\n    'lng' => $data['content']['point']['x'],\n    'lat' => $data['content']['point']['y']\n  );\n }\n\n\n /**\n  * GPS定位\n  * @param $lng\n  * @param $lat\n  * @return array\n  * @throws Exception\n  */\n public function locationByGPS($lng, $lat)\n {\n  $params = array(\n    'coordtype' => 'wgs84ll',\n    'location' => $lat . ',' . $lng,\n    'ak' => '百度地图API KEY',\n    'output' => 'json',\n    'pois' => 0\n  );\n  $resp = $this->async('http://api.map.baidu.com/geocoder/v2/', $params, false);\n  $data = json_decode($resp, true);\n  if ($data['status'] != 0)\n  {\n   throw new Exception($data['message']);\n  }\n  return array(\n    'address' => $data['result']['formatted_address'],\n    'province' => $data['result']['addressComponent']['province'],\n    'city' => $data['result']['addressComponent']['city'],\n    'street' => $data['result']['addressComponent']['street'],\n    'street_number' => $data['result']['addressComponent']['street_number'],\n    'city_code'=>$data['result']['cityCode'],\n    'lng'=>$data['result']['location']['lng'],\n    'lat'=>$data['result']['location']['lat']\n  );\n }\n}\n```","tags":["baidu map"],"categories":["php"]},{"title":"移动端滑动的实现","url":"%2F2015%2F01%2F08%2Fmobile-swipe.html","content":"## 重点\n移动端的touch事件有三个: touchstart、touchmove、touchend 分别代表 触摸开始，触摸移动，触摸结束\n\n```javascript\nvar _begin;\nvar _end;\ndocument.querySelector('#target').addEventListener('touchstart', function(e) {\n\t_begin = e.changedTouches[0].pageX;\n}, false);\ndocument.querySelector('#target').addEventListener('touchend', function(e) {\n\t_end = e.changedTouches[0].pageX;\n\tif (_end > _begin) {\n\t\tconsole.log('从左向右')\n\t}else{\n\t\tconsole.log('从右向左')\n\t}\n}, false);\n```","tags":["touch"],"categories":["javascript"]},{"title":"SVN命令行提交“--This line, and those below, will be ignored--”","url":"%2F2014%2F12%2F29%2Fsvn-commit-error.html","content":"今天phpstorm突然抽风，导致svn不能用，无奈只好用svn命令来提交。\n\n```bash\nsvn commit -m \"init\"\n```\n\n结果报错\n\n```bash\n--This line, and those below, will be ignored--\n\nM webroot/thatyear/js/main.js\n~ \n~ \n~ \n~ \n~ \n~ \n~ \n~ \n~ \n\"svn-commit.2.tmp\" 4L, 83C\n```\n\n直接保存发现会出现以下结果\n\n```bash\nLog message unchanged or not specified\n(a)bort, (c)ontinue, (e)dit:\n```\n\n输入**c**提交   \n*我这是设置了SVN提交默认编辑器的时候才会这样，默认是不会设置的。*按以下操作设置提交的编辑器   \n\n```bash\nvi ~/.subversion/config \n```\n\n找到[helpers]下的 editor-cmd 节，更改为vi即可   \n\n```bash\n[helpers]\neditor-cmd = /usr/bin/vi\n```","tags":["subversion"],"categories":["linux"]},{"title":"wordpress使用prettify插件实现代码高亮","url":"%2F2014%2F12%2F27%2Fwordpress-prettify.html","content":"最近百度感冒的太严重了，统计代码严重拖慢网页打开速度，不得已，只得暂时关闭JS统计代码。而另一个重灾区--ueditor也是太大了。我着实受不了。也关掉了。那么问题来了。之前用ueditor有配套的代码高亮插件，取消ueditor之后，代码不亮了。\n别急，wordpress的插件多着呢!\n\n## 步骤\n1.插件->安装插件，搜索 \"prettify\" ，排名第一的插件就是他了，直接启用吧\n\n2.wordpress这边就配置完了，以后写代码时，像这样\n\n```html\n<pre class=\"prettyprint linenums\">\n    <?php\n        echo 1;\n</pre>\n```\n\n刷新一下页面，是不是发现已经变了呢~，这款插件效果确实挺赞的！","tags":["highlight"],"categories":["wordpress"]},{"title":"angularjs开发ios风格的toggle","url":"%2F2014%2F12%2F20%2Fangularjs-ios-like-toggle.html","content":"## 效果图\n![效果图](https://og5r5kasb.qnssl.com/wp-content/uploads/2014/12/53441419037830.png)\n\n## HTML代码\n\n```html\n<div class=\"toggle-box\" ng-click=\"item.hide_remind = !item.hide_remind\"\n     ng-class=\"{'active':item.hide_remind,'':!item.hide_remind}\" ng-init=\"item.hide_remind=0\">\n    <div class=\"toggle-container\">\n        <div class=\"toggle-item\"></div>\n    </div>\n</div>\n```\n\n```css\n.site-create .page-bd .container form .form-group .toggle-box {\n  position: absolute;\n  right: 48px;\n  top: 15px;\n}\n.site-create .page-bd .container form .form-group .toggle-box .toggle-container {\n  position: relative;\n  width: 72px;\n  height: 40px;\n  background: #a8aeb3;\n  -webkit-border-radius: 24px;\n  -moz-border-radius: 24px;\n  border-radius: 24px;\n  padding: 2px;\n}\n.site-create .page-bd .container form .form-group .toggle-box .toggle-container .toggle-item {\n  width: 39px;\n  height: 39px;\n  background: white;\n  -webkit-border-radius: 39px;\n  -moz-border-radius: 39px;\n  border-radius: 39px;\n  cursor: pointer;\n  -webkit-transition: all linear 0.3s;\n  -moz-transition: all linear 0.3s;\n  -o-transition: all linear 0.3s;\n  transition: all linear 0.3s;\n}\n.site-create .page-bd .container form .form-group .toggle-box.active .toggle-container {\n  background: #79e575;\n}\n.site-create .page-bd .container form .form-group .toggle-box.active .toggle-container .toggle-item {\n  margin-left: 32px;\n}\n```\n\n记得自己去掉不存在的容器（我是在项目中用的，有CSS层级限制）\n## JS代码\n无\n\n所有的操作都在html中实现的。   \n如果需要获取值，请获取**item.hide_remind**即可","tags":["toggle"],"categories":["angularjs"]},{"title":"angularjs注入拦截器实现Loading效果","url":"%2F2014%2F12%2F19%2Fangularjs-loading.html","content":"angularjs作为一个全ajax的框架，对于请求，如果页面上不做任何操作的话，在结果烦回来之前，页面是没有任何响应的，不像普通的HTTP请求，会有进度条之类。\n\n本文通过对httpProvider注入拦截器实现loading。\n## HTML代码\n\n```html\n<div class=\"loading-modal modal\" ng-if=\"loading\">\n    <div class=\"loading\">\n        <img src=\"<?=$this->module->getAssetsUrl()?>/img/loading.gif\" alt=\"\"/><span ng-bind=\"loading_text\"></span>\n    </div>\n</div>\n```\n\n## LESS代码\n\n```css\n.modal {\n  position: fixed;\n  width: 100%;\n  height: 100%;\n  left: 0;\n  top: 0;\n  z-index: 99;\n  background: rgba(0, 0, 0, 0.3);\n  overflow: hidden;\n}\n\n.loading {\n  position: absolute;\n  top: 50%;\n  background: white;\n  #solution> .border-radius(8px);\n  width: 160px;\n  height: 72px;\n  left: 50%;\n  margin-top: -36px;\n  margin-left: -80px;\n  text-align: center;\n  img {\n    margin-top: 12px;\n    text-align: center;\n  }\n  span {\n    display: block;\n  }\n}\n```\n\n## JS代码\n\n```javascript\napp.config([\"$routeProvider\", \"$httpProvider\", function ($routeProvider, $httpProvider) {\n    $routeProvider.when('/', {\n        templateUrl: \"/views/reminder/index.html\",\n        controller: \"IndexController\"\n    });\n    $routeProvider.when('/create', {\n        templateUrl: \"/views/reminder/item/create.html\",\n        controller: \"ItemCreateController\"\n    });\n    $routeProvider.otherwise({redirectTo: '/'});\n    $httpProvider.interceptors.push('timestampMarker');\n}]);\n\n//loading\napp.factory('timestampMarker', [\"$rootScope\", function ($rootScope) {\n    var timestampMarker = {\n        request: function (config) {\n            $rootScope.loading = true;\n            config.requestTimestamp = new Date().getTime();\n            return config;\n        },\n        response: function (response) {\n           // $rootScope.loading = false;\n            response.config.responseTimestamp = new Date().getTime();\n            return response;\n        }\n    };\n    return timestampMarker;\n}]);\n```\n\n## 效果图\n![效果图](https://og5r5kasb.qnssl.com/wp-content/uploads/2014/12/C34B52AD-CEA0-4762-85A6-45B6869D757A.jpg)","tags":["interceptor"],"categories":["angularjs"]},{"title":"css水平居中和垂直居中","url":"%2F2014%2F12%2F16%2Fcss-center.html","content":"水平居中还是比较好弄的\n\n```css\n{\n    margin-left: auto;\n    margin-right: auto;\n}\n```\n\n但是垂直居中就比较麻烦，网上一大推文章都是什么display:table-cell,根本不管用。这里利用position属性可以达到这个目的。\n## 效果图\n![效果图](https://og5r5kasb.qnssl.com/wp-content/uploads/2014/12/16541418724107.png)\n## HTML代码\n\n```html\n<html>\n <head></head>\n <body> \n  <div class=\"container\"> \n   <div class=\"inner\"></div> \n  </div> \n </body>\n</html>\n```\n\n## CSS代码\n\n```css\nbody{\n background: #f1f1f1;\n}\n.container{\n width: 400px;\n height: 400px;\n position: relative;\n margin: 100px auto;\n background: white;\n}\n.container .inner{\n width: 100px;\n height: 100px;\n background: black;\n position: absolute;\n left: 50%;\n margin-left: -50px;\n top: 50%;\n margin-top: -50px;\n}\n```\n\n## 关键点\ntop属性和margin-top的组合，一般来说 top: 50%之后，加一个 margin-top: 容器的高度/2 就可以垂直居中了。","tags":["center"],"categories":["css"]},{"title":"MySQL行锁的使用","url":"%2F2014%2F12%2F12%2Fmysql-row-lock.html","content":"大家可能都有这样一种感觉，Web程序在本地调试的时候一切正常，放到线上也基本是正常，但是偶尔会有数据错误的情况，这种情况在订单系统中特别常见，因为大部分的订单状态更新都是有两个路径（浏览器跳转和支付服务器的异步推送消息），当然，最终数据要以异步结果为准，但是问题是，浏览器跳转也需要更新订单状态，当这两种方式在很短的时间内同时到达数据库时（一般在一秒内），如果数据库没有加锁，那这个订单会被处理两次。\n\n说到建立数据表时，涉及到支付的，都要用InnoDB引擎，该引擎支持行锁，支持事务，外键。\n\n文章开始的解决办法就是采用InnoDB对要操作的数据行进行锁定。\n\n## 数据表结构\n```\n订单ID(主键)  订单金额  订单状态\n```\n\n## 事务SQL\n\n```sql\nBEGIN;\nSELECT * FROM `orders` WHERE `order_id`=100 FOR UPDATE;\n\nCOMMIT;\n```\n\n## 释义\n1. BEGIN 手动开启事务（行锁只对开启事务的查询起作用）\n2. FOR UPDATE 独占写（成功获得锁后，只有当前进程能够更新该纪录，其他进程如果需要更新该记录，则需进行“锁等待”）\n3. COMMIT 提交处理\n\n","tags":["row lock"],"categories":["mysql"]},{"title":"android实现圆形带进度条的ProgressBar","url":"%2F2014%2F12%2F06%2Fandroid-circle-progressbar.html","content":"android加载图片免不了使用加载进度显示，而android自带的progressBar有局限.\n1. 圆型的progressBar不能显示进度条，只能无限制转圈圈\n2. 水平的progressBar可以显示进度条，但是貌似不好看\n\n解决办法是自己写一个view就可以了。\n\n```java\npackage com.ddhigh.library.widget;\n\nimport android.content.Context;\nimport android.graphics.Canvas;\nimport android.graphics.Color;\nimport android.graphics.Paint;\nimport android.graphics.RectF;\nimport android.util.AttributeSet;\nimport android.view.View;\n\npublic class CircleProgressBar extends View {\n    private int maxProgress = 100;\n    private int progress = 0;\n    //画圆所在的距形区域\n    RectF oval;\n    Paint paint;\n    public CircleProgressBar(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        oval = new RectF();\n        paint = new Paint();\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n        int width = this.getWidth();\n        int height = this.getHeight();\n\n        if(width!=height)\n        {\n            int min=Math.min(width, height);\n            width=min;\n            height=min;\n        }\n\n        paint.setAntiAlias(true); // 设置画笔为抗锯齿\n        paint.setColor(Color.WHITE); // 设置画笔颜色\n        canvas.drawColor(Color.TRANSPARENT); // 白色背景\n        int progressStrokeWidth = 4;\n        paint.setStrokeWidth(progressStrokeWidth); //线宽\n        paint.setStyle(Paint.Style.STROKE);\n\n        oval.left = progressStrokeWidth / 2; // 左上角x\n        oval.top = progressStrokeWidth / 2; // 左上角y\n        oval.right = width - progressStrokeWidth / 2; // 左下角x\n        oval.bottom = height - progressStrokeWidth / 2; // 右下角y\n\n        canvas.drawArc(oval, -90, 360, false, paint); // 绘制白色圆圈，即进度条背景\n        paint.setColor(Color.rgb(0x57, 0x87, 0xb6));\n        canvas.drawArc(oval, -90, ((float) progress / maxProgress) * 360, false, paint); // 绘制进度圆弧，这里是蓝色\n\n        paint.setStrokeWidth(1);\n        String text = progress + \"%\";\n        int textHeight = height / 4;\n        paint.setTextSize(textHeight);\n        int textWidth = (int) paint.measureText(text, 0, text.length());\n        paint.setStyle(Paint.Style.FILL);\n        canvas.drawText(text, width / 2 - textWidth / 2, height / 2 +textHeight/2, paint);\n\n    }\n\n\n\n    public int getMaxProgress() {\n        return maxProgress;\n    }\n\n    public void setMaxProgress(int maxProgress) {\n        this.maxProgress = maxProgress;\n    }\n\n    public void setProgress(int progress) {\n        this.progress = progress;\n        this.invalidate();\n    }\n\n    /**\n     * 非ＵＩ线程调用\n     */\n    public void setProgressNotInUiThread(int progress) {\n        this.progress = progress;\n        this.postInvalidate();\n    }\n}\n```\n\n## 效果图\n![效果图](https://og5r5kasb.qnssl.com/wp-content/uploads/2014/12/1.gif)","tags":["progressbar"],"categories":["android"]},{"title":"在coding上部署Yii1.x应用","url":"%2F2014%2F12%2F05%2Fcoding-yii1.html","content":"总的来说，由于没有成熟的资料可以参考，部署过程话费了将近一个小时才成功，现在来分享一下经验。\n## 目录配置\n由于Paas禁止了本地写功能，所以，如果不加任何处理的话，Yii会尝试在 protected/runtime 目录下写私有文件，结果是肯定没权限的。\n\n经过查找官方文档发现CApplication有个方法叫**setRuntimePath**，可以设置运行时目录，那么最重要的一点，这个目录的配置肯定要在入口文件中配置，更改之后的入口文件代码如下：\n\n```php\ndefined('YII_DEBUG') or define('YII_DEBUG',false);\nif(isset($_GET['_d']))\n    setcookie('_d',1,7*25*3600);\n// change the following paths if necessary\n$yii=dirname(__FILE__).'/framework/yii.php';\n$config=dirname(__FILE__).'/protected/config/main.php';\n\n\n// remove the following lines when in production mode\n// specify how many levels of call stack should be shown in each log message\ndefined('YII_TRACE_LEVEL') or define('YII_TRACE_LEVEL',3);\n\nrequire_once($yii);\n$app = Yii::createWebApplication($config);\n$app->setRuntimePath('/home/vcap/fs/*****');\n$app->run();\n```\n\n可以看到，倒数一二行，重新设置了 runtimepath，所以，第一个问题解决。\n\n## 数据库配置\n数据库这边没什么好说的，自己更改下连接信息就可以了。\n## 缓存配置\n本地开发采用的缓存，默认是File的，如果你解决了上一个问题之后，在线上，缓存是没有问题了，这里探讨下服务器缓存的设置（Coding.NET提供的缓存为Redis的，PHP操作Redis需要扩展，这里先不探讨），本站现在的缓存驱动为DB方法，配置方法为:\n\n```php\n'cache' => array(\n  'class' => 'system.caching.CDbCache',\n  'connectionID' => 'db',\n  'cacheTableName'=>'t_cache'\n),\n```\n\n## 日志配置\n默认情况下，日志是写入runtime path的，不过在Paas上，我们一般是没有本地文件权限的，就算写入了，查看起来比较麻烦，这里也采用数据库方法记录：\n\n```php\n'log' => array('class' => 'CLogRouter',\n'routes' => array(\n    array('class'=>'CDbLogRoute',\n    'connectionID'=>'db',\n    'logTableName'=>'t_log')\n))\n```\n\n## 总结\n经过以上处理，大家应该发现很多任务都交给数据库了，连缓存也是，缓存不就是为了减少直接从数据库读取数据吗，为什么还要用数据库缓存呢？\n\n这里本人简单分析下（仅代表本人观点）\n\n*WEB应用程序的瓶颈在于数据库，比如InnoDB方法进行事务操作时，会锁行，或者锁表，这样下一个请求对同一条记录进行事务操作时会有“锁等待”，会浪费大部分的时间。还有一种是复杂的大数据查询，就算做了很多优化，查询速度依旧不快，毕竟连表的开销很大。*\n\n而数据库缓存的核心就是，数据只需要一次单表查询即可，没有连表，没有加锁，这个速度还是很快的。所以数据库缓存的存在性就是在此。","tags":["php"],"categories":["php"]},{"title":"android datepicker和timepicker显示在一行","url":"%2F2014%2F11%2F19%2Fandroid-datepickertimepicker-display-inline.html","content":"android默认的datepicker和默认的timepicker可以放在一行（Linelayout），但是timepicker右边会“挤出”屏幕，尝试设置layout_weight和layout_height对于布局有效，但是控件显示就不完整了。到这一步发现xml不局文件已经处理不了，所以自然想到应该利用java来处理了。\n\n## 效果图\n![效果图](https://og5r5kasb.qnssl.com/wp-content/uploads/2014/11/98281416412408.jpg)\n## 布局代码\n\n```xml\n<LinearLayout\n    android:orientation=\"horizontal\"\n    android:layout_width=\"fill_parent\"\n    android:layout_height=\"fill_parent\"\n    android:paddingLeft=\"10dp\">\n\n    <DatePicker\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:id=\"@+id/datePicker\"\n    android:calendarViewShown=\"false\" />\n\n    <TimePicker\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:id=\"@+id/timePicker\" />\n</LinearLayout>\n```\n\n## JAVA代码\n### UI.java\n\n```java\npublic static void resizePicker(FrameLayout tp) {\n        List<NumberPicker> npList = findNumberPicker(tp);\n        for (NumberPicker np : npList) {\n            resizeNumberPicker(np);\n        }\n}\n\nprivate static List<NumberPicker> findNumberPicker(ViewGroup viewGroup) {\n        List<NumberPicker> npList = new ArrayList<NumberPicker>();\n        View child = null;\n        if (null != viewGroup) {\n            for (int i = 0; i < viewGroup.getChildCount(); i++) {\n                child = viewGroup.getChildAt(i);\n                if (child instanceof NumberPicker) {\n                    npList.add((NumberPicker) child);\n                } else if (child instanceof LinearLayout) {\n                    List<NumberPicker> result = findNumberPicker((ViewGroup) child);\n                    if (result.size() > 0) {\n                        return result;\n                    }\n                }\n            }\n        }\n        return npList;\n}\n\nprivate static void resizeNumberPicker(NumberPicker np) {\n   LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(100, RadioGroup.LayoutParams.WRAP_CONTENT);\n   params.setMargins(10, 0, 10, 0);\n   np.setLayoutParams(params);\n}\n```\n\n## Main.java\nView的查找自己应该知道写了。\n\n```java\nUI.resizePicker(datePicker);\nUI.resizePicker(timePicker);\n\ndatePicker.setMinDate(System.currentTimeMillis() - 1000);\ndatePicker.init(year, monthOfYear, dayOfMonth, new DatePicker.OnDateChangedListener() {\n\npublic void onDateChanged(DatePicker view, int year,\n                          int monthOfYear, int dayOfMonth) {\n                //得到时间\n                String time = timePicker.getCurrentHour() + \":\" + timePicker.getCurrentMinute();\n                datetime = year + \"-\" + (monthOfYear + 1) + \"-\" + dayOfMonth + \" \" + time;\n            }\n\n        });\n\n        timePicker.setIs24HourView(true);\n        timePicker.setOnTimeChangedListener(new TimePicker.OnTimeChangedListener() {\n            public void onTimeChanged(TimePicker view, int hourOfDay, int minute) {\n                String date = datePicker.getYear() + \"-\" + \n                (datePicker.getMonth() + 1) + \n                \"-\" + datePicker.getDayOfMonth();\n                datetime = date + \" \" + \n                timePicker.getCurrentHour() + \":\" + \n                timePicker.getCurrentMinute();\n            }\n        });\n```\n\n## 原理\ndatepicker和timepicker都是继承FrameLayout，内部为很多NumberPicker，所以，查找到所有NumberPicker的List，然后设置样式即可。","tags":["timepicker"],"categories":["android"]},{"title":"Angularjs处理后端空数据","url":"%2F2014%2F11%2F15%2Fangularjs-empty-array.html","content":"Yii1.x DAO中的queryAll方法查询，如果有结果，会返回一个数组，如果没有结果，会返回null。现在分两种情况：\n## 返回空数组\n\n```php\n$array = array(\n);\necho json_encode($array);\n```\n\n输出为\n\n```json\n[]\n```\n\n## 返回null\n\n```php\n$array = null;\necho json_encode($array);\n```\n\n输出为\n\n```json\nnull\n```\n\n那么问题来了，JS接收这两个的结果是不同的。   \n如果使用以下代码判断数据:\n```javascript\nif(data.length == 0){\n    //当前评论为空\n}else{\n    //当前评论不为空\n}\n```\n\n如果返回   []  ，这段代码是生效的。但是如果返回 null ,这个就有问题了。\n\n后来，使用\n\n```javascript\nif(data == null){\n    //评论为空\n}else{\n    //评论不为空\n}\n```\n\n这个判断老是出问题，后端明明返回null了，判断还是错误的，这时候想到JS也是若类型语言，会不会是类型的问题。\n\n```javascript\nconsole.log(typeof data)\n```\n\n返回的是**\"string\"**   \n那么问题就解决了，用以下代码就可以了\n\n```javascript\nif(data.length == 0 || data == \"null\"){\n    //评论为空\n}else{\n    //评论不为空\n}\n```","categories":["angularjs"]},{"title":"angularjs遍历空数组&索引数组","url":"%2F2014%2F11%2F14%2Fangularjs-traverse-empty-array.html","content":"今天做开发时发现控制老是报错，虽然不影响使用，但是作为有那么一点“强迫症”的我来说，无法忍受。通过调试发现是ng-repeat对一个空数组遍历出错，另外，['ab','cd','ad']这样只有值没有键的数组也会遍历出错。\n\n## 解决办法\n```html\n<li class=\"media\" ng-repeat=\"item in comments track by $index\">\n    <div class=\"media-body\">\n        <strong></strong>\n<p> <br />\n<time></time>\n<br />\n<span ng-if=\"item.comment_author_url.length>0\">\n            <i class=\"fa fa-globe\"></i> \n            <a href=\"\" target=\"_blank\"></a>\n            </span>\n        </p>\n    </div>\n</li>\n```\n\n特别注意**track by $index**","tags":["ng-repeat"],"categories":["angularjs"]},{"title":"IllegalStateException： Can not perform this action after onSaveInstanceState","url":"%2F2014%2F11%2F13%2Fillegalstateexception-can-not-perform-this-action-after-onsaveinstancestate.html","content":"今天使用Fragment的时候，出现了这个错误 IllegalStateException: Can not perform this action after onSaveInstanceState。查看一下控制台，发现是FragmentManager的commit()方法报错的，看字面意思应该是\n\n*onSaveInstanceState这个方法之后不能处理这个操作（指commit()）。*\n\n因为onSaveInstanceState\n方法是在该Activity即将被销毁前调用，来保存Activity数据的，如果在保存玩状态后再给它添加Fragment就会出错。解决办法就是把commit（）方法替换成 commitAllowingStateLoss()就行了，其效果是一样的。","tags":["java"],"categories":["android"]},{"title":"android使用ImageLoader缓存图片","url":"%2F2014%2F11%2F11%2Fandroid-cache-image-with-imageloader.html","content":"缓存和异步是两个极大提升用户体验的好东西，android加载图片时的开销还是挺大的，要是不做缓存同步加载，网速不给力的情况下，等个十几秒是有可能的。\n\n今天要说的是一个叫做ImageLoader的库\n\nGITHUB:[https://github.com/nostra13/Android-Universal-Image-Loader](https://github.com/nostra13/Android-Universal-Image-Loader)\n\n使用这个库有以下几步：\n+ 导入libs目录\n+ 声明自己的MyApplication类（继承Application）\n+ 在onCreate()方法中\n\n```java\npublic void onCreate() {\n        super.onCreate();\n        DisplayImageOptions options = new DisplayImageOptions.Builder()  \n        .cacheInMemory()  //缓存在内存中\n        .cacheOnDisc()  //磁盘缓存\n        .build();  \n        ImageLoaderConfiguration config2 = new ImageLoaderConfiguration.Builder(this)\n        .defaultDisplayImageOptions(options)\n          .threadPriority(Thread.NORM_PRIORITY - 2)\n          .denyCacheImageMultipleSizesInMemory()\n          .discCacheFileNameGenerator(new Md5FileNameGenerator())\n          .tasksProcessingOrder(QueueProcessingType.LIFO)\n          .build();\n        ImageLoader.getInstance().init(config2);\n}\n```\n\n+ 在要加载图片的地方使用\n\n```java\nDisplayImageOptions options = new DisplayImageOptions.Builder()\n\t\t\t\t.cacheInMemory() // 缓存用\n\t\t\t\t.cacheOnDisc()\n\t\t\t\t.bitmapConfig(Bitmap.Config.RGB_565)//防止溢出\n\t\t\t\t.displayer(new RoundedBitmapDisplayer(139)) // 图片圆角显示，值为整数\n\t\t\t\t.build();\nImageLoader.getInstance().displayImage(url, avatar, options);\n```\n\n其中 url 是图片URL地址，avatar为ImageView,options为动态配置，这里加了一个防止溢出的参数。\n\n好了，使用起来是不是很简单呢~我们压根不用操心异步和缓存的问题了","tags":["Android-Universal-Image-Loader"],"categories":["android"]},{"title":"async http client socket超时问题","url":"%2F2014%2F11%2F10%2Fasync-http-client-socket-timeout.html","content":"最近做的一个项目的HTTP模块使用了loopj的asynchttpclient ([https://github.com/loopj/android-async-http](https://github.com/loopj/android-async-http)）。\n\n自动更新模块总是出现sockettimeout的exception,查来查去也不知道什么问题，为此还换了asynchttpclient的库版本。但是问题也没解决。\n\n仔细看了一下，提示的是timeout，应该从这方面去看看，后面看到自己的HTTP工具类设置了全局超时时间为5000ms,普通请求当然没这么久，但是自动更新是下载，肯定不止5秒的，删掉超时设置就可以了。","tags":["android"],"categories":["android"]},{"title":"android 替换斜杠","url":"%2F2014%2F11%2F07%2Fandroid-replace-slash.html","content":"## 问题\n最近写安卓的时候服务端返回的数据会带上“\\n”，但是在android这边不能换行，初次想到的解决方法是利用\n\n```java\nString.replace(\"\\n\",\"\\n\")\n```\n\n给替换掉，结果是不行的。之前记得java的反斜杠是需要转义的，就用\n\n```java\nString.replaceAll(\"\\n\",\"\\\\n\")\n```\n\n试了一下，结果依旧不行。后来去查了谷歌--，发现要 \\\\\\\\n 才可以 匹配到 \\n,这么多斜杠，头都晕了，一个个来解释：\n+ 第一个和第二个反斜杠是一组，由于java的转义，实际为 \"\\\"\n+ 第三个和第四个同理，\n\n经过以上两步之后，\\\\\\\\n 实际上是 \\\\n ，由于是正则的关系，\\\\n 可以匹配到字符串的\\n了。\n\n## 解决方法\n```java\nString.replaceAll(\"\\\\n\",\"\\\\n\")\n```\n\n第一个参数是正则，第二个是普通字符串。不得不吐槽下Java的正则表达式。。","tags":["java"],"categories":["android"]},{"title":"mac os x 使用eclipse调试android","url":"%2F2014%2F11%2F01%2Fmac-os-x-debug-android-with-eclipse.html","content":"这两天心血来潮装了个mac os x 10.10系统，折腾的过程就不说了。   \nMac OS X 10.10的环境下，Eclipse+ADT，进行真机调试时，会出现一个问题。   \n终端下输入 adb devices可以看到小米2S，但是Device Chooser对话框里不显示真机设备，只有重新插拔数据线才可以。   \n仔细看了下android run configure发现一个问题，默认显示的**compatible devices**（意思差不多是适配的设备）。   \n简单说下方法   \n右键项目>run as>run configurations>target>选中间那个>Active Devices\n![示意图](https://og5r5kasb.qnssl.com/wp-content/uploads/2014/11/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7-2014-11-01-%E4%B8%8B%E5%8D%889.05.42.jpg)   \n再次点击run就可以了。","tags":["mac"],"categories":["android"]},{"title":"解决wordpress d8主题使用七牛镜像插件后无法评论的问题","url":"%2F2014%2F11%2F01%2Fwordpress-d8-theme-qiniu-cannot-comment.html","content":"上午有热心的网友给我反映说评论功能出bug了，初步查看是七牛出了问题，利用chrome的开发者工具可以查看请求。\n![示意图](https://og5r5kasb.qnssl.com/wp-content/uploads/2014/11/blob3.png)   \nPS：这张图是今天截的，所以域名是正常的，昨天实际上请求的是 static.ddhigh.com (本站的CDN域名)。   \n查看HTTP请求发现整站就请求了一个jquery文件，但是这个文件比较大有140K，查看源代码发现评论的代码已经合并在里面了。   \n![示意图](https://og5r5kasb.qnssl.com/wp-content/uploads/2014/11/blob4.png)   \n按照以上步骤可以查看到评论时执行的脚本，当然这里的域名已经修复了。\n\n278行，昨天的是 \n\n```\nurl:window._deel.url+\"/ajax/comment.php\"\n```\n\n在控制台输入\n\n```javascript\nconsole.log(_deel);\n```\n\n![示意图](https://og5r5kasb.qnssl.com/wp-content/uploads/2014/11/blob5.png)\n\n域名是CDN域名，所以ajax请求实际上被提交到**七牛**去了。\n## 修正方法\n利用ssh工具连接你的服务器（不是七牛），找到对应的jquery文件278行，改成你的站点域名（如本站的www.ddhigh.com）,更新下缓存即可。","tags":["comment"],"categories":["wordpress"]},{"title":"UCenter 后台应用通知列表空白","url":"%2F2014%2F10%2F31%2Fucenter-empty.html","content":"今天遇到了一个奇葩的问题UCenter后台通知列表空白并且500，通过xdebug调试发现是**uc_server/control/admin/note.php 第68行代码有问题!**IDE都报错了\n\n## 原代码\n\n```php\n$this->_format_notlist(&$notelist);\n```\n\n## 修正代码\n\n```php\n$this->_format_notlist($notelist);\n```\n\n可能是由于PHP版本升级导致的问题。","tags":["ucenter"],"categories":["php"]},{"title":"解决 angularjs html5Mode 404的问题","url":"%2F2014%2F10%2F30%2Fangularjs-html5mode-404.html","content":"采用location的html5Mode之后，链接是正常的，但是刷新的时候会404，此时就需要后端服务器配置URL重写了。\n\n本文以apache为例\n\n```\nRewriteEngine on\nRewriteCond %{REQUEST_FILENAME} !-d\nRewriteCond %{REQUEST_FILENAME} !-f\nRewriteRule . index.html\n```\n\n这样子就可以将所有不是文件夹且不是文件的请求转发到index.html。","tags":["location"],"categories":["angularjs"]},{"title":"让IE7,IE8支持html5属性","url":"%2F2014%2F10%2F28%2Fie7ie8-support-html5-attribute.html","content":"HTML5确实很好用，但是国内IE7和IE8的用户还是挺多的（或许是XP的缘故）。这些浏览器不识别HTML5的新属性以及<!doctype html>，导致页面渲染进入“怪异”模式，简直就是“不堪入目”。   \n不过，还好，开源的力量是强大的，有热心的开发者写了一套JS库来兼容IE7,IE8。本文就简单教大家用下这款JS库。\n\n1.[下载](https://og5r5kasb.qnssl.com/wp-content/uploads/2014/10/data.zip)   \n2.解压之后得到html5shiv.js   \n3.开发模板\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n    <title>Template</title>\n    <!--[if lt IE 9]>\n    <script src=\"http://cdn.bootcss.com/html5shiv/3.7.2/html5shiv.min.js\"></script>\n    <script src=\"http://cdn.bootcss.com/respond.js/1.4.2/respond.min.js\"></script>\n    <![endif]-->\n</head>\n<body>\n<h1>你好，世界！</h1>\n<script src=\"http://cdn.bootcss.com/jquery/1.11.1/jquery.min.js\"></script>\n</body>\n</html>\n```\n使用这个库之后就可以正常开发啦。   \n题外话：IE系列好像是不太好兼容的。","tags":["ie8"],"categories":["front-end"]},{"title":"PHPExcel导出时为空的解决方法","url":"%2F2014%2F10%2F24%2Fphpexcel-export-empty.html","content":"今天在做数据导出的时候遇到个麻烦事情，SQL查询是有数据的，但是写入excel的时候为空的。\n\n输出异常是有一行遇到错误了。将那一行数据打印出来发现字段中有个 = 号，excel中有 = 会将后面的当作表达式计算，所以导致错误。\n\n解决方式是在 = 前面加上单引号 '= 就可以了","tags":["phpexcel"],"categories":["php"]},{"title":"移动端textarea自适应高度","url":"%2F2014%2F10%2F21%2Fmobile-textarea-auto-fit.html","content":"PC端网页的textarea内容多了会出现滚动条，这个没什么，鼠标么，滚动方便。但是移动端是没鼠标的，出现滚动条是很不友好的行为。\n\n利用js的事件绑定及动态改变CSS就可以做到这个了。\n\n```javascript\nonpropertychange=\"this.style.height=this.scrollHeight + 'px'\" oninput=\"this.style.height=this.scrollHeight + 'px'\"\n```","tags":["mobile"],"categories":["javascript"]},{"title":"linux检查端口占用","url":"%2F2014%2F10%2F15%2Flinux-check-port.html","content":"```bash\nnetstat -lnp | grep 80\n```","tags":["netstat"],"categories":["linux"]},{"title":"移动端实时检测输入框","url":"%2F2014%2F10%2F14%2Fmobile-realtime-check.html","content":"PC浏览器的话由于有blur和focus事件，可以在失去焦点时进行一次验证，但是移动端有点麻烦，点击其他地方才可以，这种的话体验不是很好。\n利用input事件可以解决这个问题。\n\n```javascript\n$(document).on('input','#username',function(){\n    //验证逻辑\n});\n```\n\n测试之后问题确实来了，每输入一个字符就会触发，浪费很多网络请求，接下来使用一个定时器的技术来进行处理。\n\n```javascript\nvar timer;\n$(document).on('input','#username',function(){\n    timer && clearTimeout(timer);\n    timer = setTimeout(function(){\n   \n    //验证逻辑\n    },500);//延时0.5s触发\n});\n```\n\n采用这种定时器技术可以在请求次数和用户体验之间取得平衡，很多地方都可以使用这种技术来实现。","tags":["mobile"],"categories":["javascript"]},{"title":"nginx服务器启用SSL访问","url":"%2F2014%2F10%2F11%2Fnginx-enable-ssl.html","content":"## HTTP和HTTPS的区别\n1. https协议需要到ca申请证书，一般免费证书很少，需要交费。 　\n2. http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。 　　\n3. http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 　　\n4. http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。\n\n所以在涉及到账户、金钱等敏感信息交互的时候使用HTTPS是个不错的选择。   \n## 申请证书\n1. 申请SSL证书过程就不多说了。挺简单的，本文主要是在nginx上配置ssl证书实现https访问。   \n2. 将key和证书上传到服务器。\n\n## nginx配置\n\n```\nserver {\n                listen 443;\n                #listen [::]:80;\n                server_name passport.ddhigh.com;\n                index index.html index.htm index.php default.html default.htm default.php;\n                root  /home/wwwroot/passport.ddhigh.com;\n                include other.conf;\n                #error_page   404   /404.html;\n                location ~ [^/]\\.php(/|$)\n                        {\n                                # comment try_files $uri =404; to enable pathinfo\n                                try_files $uri =404;\n                                fastcgi_pass  unix:/tmp/php-cgi.sock;\n                                fastcgi_index index.php;\n                                include fastcgi.conf;\n                                #include pathinfo.conf;\n                        }\n                location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$\n                        {\n                                expires      30d;\n                        }\n                location ~ .*\\.(js|css)?$\n                        {\n                                expires      12h;\n                        }\n                ssl on;\n                ssl_certificate /root/crt/server.crt;\n                ssl_certificate_key /root/crt/server.key;\n                access_log  /home/wwwlogs/passport.ddhigh.com.log  access;\n}\n```\n\n**/root/crt**是我的证书目录，各位读者可以根据实际情况更改。","tags":["ssl"],"categories":["nginx"]},{"title":"ng-repeat获取父级INDEX","url":"%2F2014%2F10%2F11%2Fng-repeat-get-parent-index.html","content":"angularjs的循环嵌套我就不多说了，无非是ng-repeat的嵌套而已，如果需要获取索引请使用$index。\n\n那么问题来了，$index只能获取当前循环的索引，如果需要获取父级的索引怎么办？\n\n原理其实也不难，在父级ng-repeat时利用ng-init写入一个变量即可，子循环是可以访问到的。\n\n```html\n<div ng-controller=\"MainCtrl\">\n    <dl ng-repeat=\"user in users\">\n       <dt ng-init=\"p_index=$index\">Name:</dt>\n        <dd ng-repeat=\"p in user.posts\">父级INDEX: - \n        自己的INDEX:\n        </dd>\n    </dl>\n</div>\n```\n\n```javascript\nvar site = angular.module('application.site', []);\nsite.controller('MainCtrl', ['$scope', '$http', function ($scope, $http) {\n    $scope.users = [\n        {name:\"xialei\",posts:[\"文章一\",\"文章二\",\"文章三\"]},\n        {name:\"zhangsan\",posts:[\"文章四\",\"文章五\"]}\n    ];\n}]);\n```\n\n这里只是关键代码，用过angularjs的小伙伴们相信一眼就可以看懂了。","tags":["ng-repeat"],"categories":["angularjs"]},{"title":"html5新属性data api","url":"%2F2014%2F10%2F08%2Fhtml5-data-api.html","content":"以往在做列表程序的时候，需要做类似“删除”功能的时候，往往是组装一个URL，类似于这个\n\nindex.php?m=news&a=delete&id=10\n\n这是最普通的url方式来进行删除。\n\n但是随着用户体验要求的增加，很多时候都需要使用ajax来实现相应效果。\n\n记得很早以前在写一个CURD项目的时候，我是用ID来做的，类似于 id=\"news_id_10\",id=\"news_id_11\" 这样，然后通过分割字符串来获取ID，简直就是要多麻烦有多麻烦，当时就在想有没有一个能自己定义所需数据的字段呢？\n\n现在好了。HTML5的data-* API可以帮到我们\n\n## html代码\n\n```html\n<a href=\"javascript:void(0)\" data-action=\"delete\" data-id=\"10\">删除</a>\n```\n\n是不是看到了data-action和data-id属性呢？data-*只要更改*就可以了，需要满足标识符约束。\n## js代码\n\n```javascript\n$(document).on('click', '[data-action=\"delete\"]',\nfunction() {\n    var $id = $(this).data(\"id\");\n    var $this = $(this);\n    ajax && ajax.abort();\n    ajax = $.get('index.php', {\n        id: $id,\n        m: 'news',\n        a: 'delete'\n    },\n    function(data) {\n        if (data.status == 1) {\n            //操作成功\n        } else {\n            alert(data.info);\n        }\n    },\n    'json');\n});\n```\n\nJQ提供的$.data方法确实挺方便的，但是请注意，本人发现$.data方法是只读的（就是不能改变data-id=\"10\"中的10），如果需要改变，请用底层的$.attr('data-id',9)这种操作。","tags":["html5"],"categories":["front-end"]},{"title":"PHP二进制方法存储图片","url":"%2F2014%2F10%2F02%2Fphp-save-image-to-database.html","content":"大部分人的图片上传都是保存一个路径到数据库，这样在插入时确实快，也符合web的特点，但是在删除时就很麻烦，需要找到文件并删除，该代码能够把代码直接存入数据库，删除时一并删除。   \n请注意：这样的话数据库大小会激增，请酌情使用,且RDBMS对于二进制数据的处理并不是很理想。\n## 表结构（只做简单演示，故字段有限）\n\n```sql\nCREATE TABLE `upload` (\n  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,\n  `type` varchar(20) NOT NULL,\n  `data` mediumblob NOT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;\n```\n\n## 上传表单\n\n```html\n<!doctype html>\n    <html>\n<head>\n    <title>\n        Post-Image\n    </title>\n</head>\n<body>\n<form action=\"post.php\" method=\"post\" enctype=\"multipart/form-data\">\n    <input type=\"file\" name=\"file\" id=\"file\"/>\n    <input type=\"submit\" value=\"OK\"/>\n</form>\n</body>\n</html>\n```\n\n## 处理程序\n\n```php\n<?php\nif ($_FILES[\"file\"][\"error\"] > 0)\n{\n    echo \"Error: \" . $_FILES[\"file\"][\"error\"] . \"<br />\";\n}\nelse\n{\n    $type = $_FILES[\"file\"][\"type\"];\n    $size = $_FILES['file']['size'];\n    $tmp=$_FILES[\"file\"][\"tmp_name\"];\n    $fp = fopen($tmp,'rb');\n    $data = bin2hex(fread($fp,$size));\n    $dsn='mysql:host=localhost;dbname=test';\n    echo '<pre>';\n    try{\n        $pdo = new PDO($dsn,'root','root');\n        $pdo->exec(\"INSERT INTO `upload`(`type`,`data`) values ('$type',0x$data)\");\n        $id = $pdo->lastInsertId();\n        echo 'upload success!<a href=\"view.php?id='.$id.'\">View</a>';\n        $pdo = null;\n    }catch (PDOException $e){\n        echo $e->getMessage();\n    }\n    echo '</pre>';\n    fclose($fp);\n}\n```\n\n## 显示页面\n\n```php\n<?php\n$id = $_GET['id'];\nif(is_numeric($id)){\n    $dsn='mysql:host=localhost;dbname=test';\n    try{\n        $pdo = new PDO($dsn,'root','root');\n        $rs = $pdo->query('select * from `upload`  where `id`='.$id);\n        $row = $rs->fetchAll();\n        $data = $row[0];\n        header(\"Content-Type:${data['type']}\");\n        echo $data['data'];\n        $pdo = null;\n    }catch (PDOException $e){\n        echo $e->getMessage();\n    }\n}else{\n    exit();\n}\n```\n\n经过测试可行，请大家在必要的时候才使用~","tags":["image"],"categories":["php"]},{"title":"Angularjs动态表单项","url":"%2F2014%2F09%2F29%2Fangularjs-dymanic-form-item.html","content":"后台业务系统中有很多CURD操作，一个很简单的例子是OA系统中为员工添加帐号信息，传统的做法是添加完一个就跳转并提示“成功”,后来高级一点的做法是利用jquery来做。\n\n但是一个比较麻烦的问题是需要手动拼接HTML并且插入文档树。\n\n然而，现在有了跨时代神器--angularjs,就是这么炫，强大的双向绑定功能可以帮到我们。\n\n整体思想是利用 ng-repeat 指令来遍历一个临时数组（元素个数为表单个数）生成表单\n\n## HTML代码\n\n```html\n<!DOCTYPE html>\n<html ng-app=\"application.site\">\n<head>\n    <meta charset=\"UTF-8\"/>\n    <title>Login</title>\n</head>\n<body>\n\n<div ng-controller=\"ListCtrl\">\n    <button type=\"button\" ng-click=\"add()\">添加表单</button>\n    <form action=\"\" method=\"post\" class=\"form\" ng-repeat=\"form in forms\" novalidate=\"novalidate\">\n        <p> 号表单</p>\n        <label for=\"username\">帐号</label>\n        <input type=\"text\" ng-model=\"username\" id=\"username\" ng-required=\"true\"/>\n        <button type=\"submit\" ng-click=\"post($index,username)\">提交</button>\n        <button type=\"button\" ng-click=\"remove($index)\">移除</button>\n    </form>\n</div>\n<script src=\"js/angularjs-1.2.19.js\"></script>\n```\n\n## JS代码\n\n```javascript\nvar site = angular.module('application.site', []);\nsite.controller('ListCtrl', ['$scope', '$http',\nfunction($scope, $http) {\n    $scope.forms = [\"1\"];\n\n    $scope.index = 1;\n    $scope.post = function(index, username) {\n        console.log(index + ' 号表单提交 [' + username + '] 成功');\n    }\n    $scope.remove = function(index) {\n        console.log('删除 [' + index + '] 号表单成功');\n        $scope.forms.splice(index, 1);\n    }\n    $scope.add = function() {\n        console.log('添加表单');\n        $scope.forms.push((++$scope.index).toString());\n    }\n}]);\n```\n\n由于小编只是为了实现功能而写的这么一个demo，样式至上难免有些欠缺--。但是，麻雀虽小，五脏俱全，大家可以根据这个思路去开发更为强大的应用系统。","tags":["form"],"categories":["angularjs"]},{"title":"Yii1.x单点登录","url":"%2F2014%2F09%2F27%2Fyii1-sso.html","content":"## 背景\nWeb迅速发展的今天，往往一个产品拥有很多个子站点，SSO技术显得很重要。Yii作为我常用的框架，发现Yii的SSO配置其实是非常简单的。\n## 代码\n在所有站点中直接打开 **protected/config/main.php** 在 components 中加入以下代码，并且把**protected/runtime/state.bin**文件复制到各个具体的子站点中就可以实现SSO了！\n\n```php\n'user' => array(\n            'identityCookie' => array(\n                'domain' => '.ddhigh.com',\n                'path' => '/'\n            ),\n            // enable cookie-based authentication\n            'allowAutoLogin' => true,\n            'stateKeyPrefix' => 'ddhigh',\n            'loginUrl' => array('user/login')\n        ),\n        'session' => array(\n            'cookieParams' => array(\n                'domain' => '.ddhigh.com',\n                'lifetime' => 0,\n                'timeout' => 3600\n            ),\n        ),\n        'statePersister' => array(\n            'class' => 'CStatePersister',\n            'stateFile' => './protected/runtime/state.bin'\n        ),\n```\n\n推荐所有的站点全部放在一个域名中进行操作~","tags":["sso"],"categories":["php"]},{"title":"PHP遍历文件","url":"%2F2014%2F09%2F27%2Fphp-traverse-file.html","content":"遍历文件夹主要用到 opendir readdir closedir 三个函数，有两个要注意的地方\n\n要排除 '.' 和 '..' 两个目录\n\n需要用到递归\n\n```php\n<?php\n/**\n * 遍历文件夹\n * @param string $path\n * @return array\n */\nfunction listFiles($path)\n{\n    $files = array();\n    $handler = opendir($path);//打开目录\n    while (($file = readdir($handler)) !== false) {\n        if($file != '.' && $file != '..'){ //当前目录和上级目录\n            if(is_dir($path.DIRECTORY_SEPARATOR.$file)){\n                $files[$file] = listFiles($path.DIRECTORY_SEPARATOR.$file);\n            }else{\n                $files[] = $file;\n            }\n        }\n    }\n    closedir($handler);\n    return $files;\n}\n\n$array = listFiles(__DIR__);\nprint_r($array);\n```","tags":["file"],"categories":["php"]},{"title":"highchats曲线不显示","url":"%2F2014%2F09%2F24%2Fhighchats-not-display.html","content":"highchats是什么就不介绍了。一个JS绘图工具库，基于JQ，使用简单方便，但是不注意的话会坑人。\n\n今天兴致满满的去绘图，后端数据也返回了。可是一个纠结的问题困扰了我一下午！\n\n后端数据返回的JSON是\n\n```json\n[\"0\",\"0\",\"0\"]\n```\n\n这种形式，JSON.parse解析之后返回的是一个字符数组，而不是数字数组，解决方案是利用JS做一次类型转换\n\n```javascript\nfor(var i in data){\n    data[i]=parseInt(data[i]);\n}\n```\nfor(var i in data){\n    data[i]=parseInt(data[i]);\n}\n图形就可以正常显示了。","tags":["highcharts"],"categories":["javascript"]},{"title":"angularjs鼠标悬浮效果","url":"%2F2014%2F09%2F22%2Fangularjs-mouse-move-effect.html","content":"用JQ来做的话很简单的，(通过toggleClass函数就可以了),但是既然提到了angularjs，当然要用angularjs的解决方案来做啦!\n\nangularjs集成了一个jqlite模块（可以理解为阉割版的jquery）,提供有限并且常用的功能。\n\n主要用到指令系统中的Link函数，代码就不贴了。\n\n直接上dome吧！\n[下载地址](https://og5r5kasb.qnssl.com/demo2014092201.zip)\n","tags":["hover"],"categories":["angularjs"]},{"title":"PHP自动更新网站","url":"%2F2014%2F09%2F20%2Fphp-website-auto-update.html","content":"目前软件开发主流越来越倾向于B/S模式，不同于C/S模式的软件，B/S模式下的WEB程序自动更新是个麻烦问题。\n\n本人利用PHP下载远程文件和ZIP类，写了一个简单的自动更新DEMO，供大家参考。\n\n## 服务端\n### 目录结构\n\n```\n|data\n\n    |--20140918.zip\n\n|--index.php\n```\n\n其中 data 文件夹用来存放补丁包,index.php 文件用来响应版本数据给客户端。\n\n### index.php\n\n```php\n<?php\nsleep(3);\nheader('Content-Type:application/json;utf-8');\necho json_encode(array(\n    '20140918' => array(\n        'version' => 20140920,\n        'desc' => 'BUG修正，缓存系统',\n        'url' => 'http://' . $_SERVER['HTTP_HOST'] . $_SERVER['REQUEST_URI'] . '/data/20140918.zip'\n    )\n));\nexit();\n```\n\n20140918 对应的是客户端版本号，20140920 对应的是服务端版本号，desc 是本次补丁的描述，url 则是补丁包下载地址\n## 客户端\n### 目录结构\n\n```\n|tmp\n\n|--config.php\n\n|--Zip.php\n\n|--index.php\n```\n\nconfig.php 为配置文件，保存本地版本信息，Zip.php 为ZIP操作类（从服务端下载的补丁包均为zip格式）,index.php 为自动更新程序（只是为了方便，实际中可以写个方法出来）\n### index.php\n\n```php\n<?php\nob_implicit_flush(true);\n$begin = microtime(true);\n//检查更新,加载本地版本号\n$config = require(__DIR__ . '/config.php');\n$server = 'http://localhost/version';\necho '连接更新服务器...<br/>';\nob_flush();\n$versions = json_decode(file_get_contents($server), true);\n\nif (!isset($versions[$config['version']])) {\n    echo '当前已是最新版本!';\n} else {\n    echo '当前版本：<b>', $config['version'], '</b> 服务器版本：<b>', \n    $versions[$config['version']]['version'], '</b><br/>';\n    ob_flush();\n    //开始下载\n    $remote_fp = fopen($versions[$config['version']]['url'], 'rb');\n    if(!is_dir(__DIR__.'/tmp')) mkdir(__DIR__.'/tmp');\n    $tmp = __DIR__ . '/tmp/' . date('YmdHis') . '.zip';\n    $local_fp = fopen($tmp, 'wb');\n    echo '开始下载...<br/>';\n    ob_flush();\n    while (!feof($remote_fp)) {\n        fwrite($local_fp, fread($remote_fp, 128));\n    }\n    fclose($remote_fp);\n    fclose($local_fp);\n    echo '下载完成,准备解压<br/>';\n    ob_flush();\n    require(__DIR__ . '/Zip.php');\n    $zip = new Zip();\n    $zip->extra($tmp, __DIR__);\n    echo '解压完成,准备删除临时文件<br/>';\n    ob_flush();\n    //删除补丁包\n    unlink($tmp);\n    echo '临时文件删除完毕<br/>';\n    ob_flush();\n    //更新本地版本号\n    $content = file_get_contents(__DIR__.'/config.php');\n    $content = str_replace($config['version'],$versions[$config['version']]['version'],$content);\n    file_put_contents(__DIR__.'/config.php',$content);\n    echo '更新完成!耗时',microtime(true) - $begin,'秒<br/>';\n    ob_flush();\n    ob_end_clean();\n    exit();\n}\n```\n\n## config.php\n\n```php\n<?php\nreturn array(\n    'version' => '20140918'\n);\n```\n\n### Zip.php\n\n```php\n<?php\n\n/**\n * @version 1.0\n * @date 2014-08-11\n * @author 十七号 <xialeistudio@gmail.com>\n * @license MIT\n * 压缩、解压缩类\n */\nclass Zip\n{\n    /**\n     * 打包\n     * @param $path\n     * @param $save\n     */\n    public static function archive($path, $save)\n    {\n        $zip = new ZipArchive();\n        if ($zip->open($save, ZipArchive::OVERWRITE) === true) {\n            self::addZip($path, $zip);\n            $zip->close();\n        }\n    }\n\n    /**\n     * 添加文件或文件夹到zip对象\n     * @param string $path\n     * @param ZipArchive $zip\n     */\n    private static function addZip($path, $zip)\n    {\n        $handler = opendir($path);\n        while (($file = readdir($handler)) !== false) {\n            if ($file != '.' && $file != '..') {\n                if (is_dir($path . DIRECTORY_SEPARATOR . $file)) {\n                    self::addZip($path . DIRECTORY_SEPARATOR . $file, $zip);\n                } else {\n                    $zip->addFile($path . DIRECTORY_SEPARATOR . $file);\n                }\n            }\n        }\n        closedir($handler);\n    }\n\n    /**\n     * 解压文件\n     * @param string $file 压缩文件路径\n     * @param string $path 解压路径，为空则以文件名为路径\n     */\n    public static function extra($file, $path = null)\n    {\n        if (!isset($path)) {\n            $array = explode('.', $file);\n            $path = reset($array);\n        }\n\n        $zip = new ZipArchive();\n        if ($zip->open($file) === true) {\n            $zip->extractTo($path);\n            $zip->close();\n        }\n    }\n}\n```\n\n本文只写了一个很简单的自动更新程序，只是为了说明更新程序的基本思路。还有很多细节方面可以定制的。","tags":["auto updator"],"categories":["php"]},{"title":"PHP下载远程文件","url":"%2F2014%2F09%2F20%2Fphp-download-remote-file.html","content":"在做小偷程序的时候，文章的图片往往是有防盗链措施的，一个比较好的解决办法是通过PHP下载图片到本地并且替换URL实现。\n\n由于图片这种东西不能直接像下载HTML那样直接下载，所以需要指定fopen的打开模式为b(二进制模式)。\n\n```php\n<?php\n$url = 'http://picturescdn.qiniudn.com/93aa93787ae02be68192b3533d3e76b0';\n$remote_fp = fopen($url,'rb');\n$local_fp = fopen(date('YmdHis'),'wb');\nwhile(!feof($remote_fp)){\n    fwrite($local_fp,fread($remote_fp,128));\n}\nfclose($remote_fp);\nfclose($local_fp);\n```\n\n这样就在本地目录生成了一张图片。","categories":["php"]},{"title":"bootstrap3禁用响应式布局","url":"%2F2014%2F09%2F18%2Fbootstrap3-disable-responsive-layout.html","content":"IE8及以下版本的浏览器确实是心中的痛,不支持媒体查询和CSS3，导致bootstrap样式怪怪的。没办法，只能采取折中的办法--禁用响应式布局\n1. 移除 viewport 标签\n2. 引入该CSS文件以重置bootstrap的响应式布局\n\n这种情况下会导致一些高级浏览器不能得到最好的效果，所以，进阶的办法是:\n\n*利用PHP判断是否是IE8及以下版本的浏览器，如果不是，则进行正常的响应式布局。如果是，则禁用响应式布局*","tags":["bootstrap"],"categories":["front-end"]},{"title":"Grunt快速上手","url":"%2F2014%2F09%2F18%2Fgrunt-get-started.html","content":"## 为什么要使用Grunt?\n一句话：自动化。对于需要反复重复的任务，例如压缩（minification）、编译、单元测试、linting等，自动化工具可以减轻你的劳动，简化你的工作。当你正确配置好了任务，任务运行器就会自动帮你或你的小组完成大部分无聊的工作。\n## 怎么使用Grunt?\n1.grunt是基于nodejs的，所以请先安装nodejs和npm安装grunt   \n2.新版本的grunt安装需要两步，终端执行   \n\n```bash\nnpm install grunt-cli -g\n```\n\n3.进入项目目录，终端执行   \n\n```bash\nnpm install grunt --save-dev\n```\n\n4.安装常用插件\n\n```bash\nnpm install grunt-contrib-cssmin grunt-contrib-uglify grunt-contrib-watch --save-dev\n```\n\n5.项目目录\n\n```\n--dev\n    |--js\n        |-- jquery.js\n        |-- main.js\n    |--css\n        |-- library.css\n        |-- main.css\n```\n\n一个很简单的JS,CSS目录，很关键的任务在于如何定义Gruntfile.js文件（请在项目根目录下创建Gruntfile.js,大小写不能错）   \n6.Gruntfile.js\n\n```javascript\nmodule.exports = function(grunt) {\n    grunt.initConfig({\n        cssmin: {\n            site: {\n                files: {\n                    'build/css/site.css': ['dev/css/library.css', 'dev/css/main.css']\n                }\n            },\n        },\n        uglify: {\n            site: {\n                src: ['dev/js/jquery.js', 'dev/js/main.js'],\n                dest: 'build/js/site.js'\n            },\n\n        },\n        watch: {\n            site: {\n                files: ['dev/js/**.*', 'dev/css/**.*'],\n                tasks: ['uglify:site', 'cssmin:site']\n            }\n        }\n    });\n    grunt.loadNpmTasks('grunt-contrib-cssmin');\n    grunt.loadNpmTasks('grunt-contrib-uglify');\n    grunt.loadNpmTasks('grunt-contrib-watch');\n    grunt.registerTask('site', ['watch:site']);\n};\n```\n\ncssmin:\n\nsite为一个子任务\n\nbuild/css/site.css 为合并压缩之后的css存放路径,该参数后面的数组为原始的css文件路径\n\nuglify:\n\nsite为一个子任务\n\nsrc数组为源JS文件\n\ndest为合并压缩之后的js文件存放路径\n\nwatch\n\nsite为一个子任务\n\nfiles数组为监听哪些文件的变化\n\ntasks数组为如果文件变化则执行什么任务\n\ngrunt.loadNpmTasks 加载模块\n\ngrunt.registerTask 注册新任务\n\n在项目目录下打开CMD工具，输入\n\n```bash\ngrunt site\n```\n\n即开始执行监听，此时修改dev/js/main.js或者dev/css/main.css都会触发相应的事件。\n\n## 结语\n从此以后再也不用进行重复的压缩合并...etc等一些重复而乏味的工作了，交给grunt吧！","tags":["workflow"],"categories":["javascript"]},{"title":"七牛云存储定义自定义变量返回数据","url":"%2F2014%2F09%2F18%2Fqiniu-custom-data.html","content":"## 背景\n七牛云存储也使用了这么久了。一直一来都只用了它的图片上传和处理功能。用的是客户端直传API，七牛给我返回一个key（一串随机的hash值，对人类无可读性）。\n\n最近做的一个文件共享的项目，因为文件是客户端直传七牛的，那么我在后台PHP这边是拿不到原始文件名的，但是文件列表必须显示原始文件名，不能显示那个hash值。后来查找文件发现，七牛可以自定义返回的变量。\n\n## 关键代码\n\n```php\n<?php\nQiniu_SetKeys($this->accessKey, $this->secretKey);\n$putPolicy = new Qiniu_RS_PutPolicy($this->bucket);\n$putPolicy->Expires = $expires;\n$putPolicy->SaveKey = $filename;\n$putPolicy->FsizeLimit = 20*1024*1024;\nif($returnUrl != '')\n\tputPolicy->ReturnUrl = $returnUrl;\n$upToken = $putPolicy->Token(null);\nreturn $upToken;\n```\n\n通过对 $filename参数进行定制\n\n```php\n$filename = '$(fsize)/$(fname)'\n```\n\n这样子七牛返回的hash应该是\n\n```\na3466b7fa159ab4f671bdc4ae45dae08/103/稿件共享.txt\n```\n\n通过 explode 函数就可以拿到文件名了。\n\n## 题外话\n七牛还有很多自定义参数有待各位挖掘，这里只做个抛砖引玉的作用。","tags":["qiniu"],"categories":["php"]},{"title":"linux利用ssh公钥部署git代码","url":"%2F2014%2F09%2F15%2Flinux-public-key-git.html","content":"## 背景\n阿里云的使用门槛降低，直接导致了很多人优先使用VPS而不是以前的虚拟主机，毕竟虚拟主机存在诸多限制。阿里云犹如一台全新的服务器，所有软件都要自己安装。作为一个写PHP的，代码部署就略麻烦了，以前使用FTP的时候很方便部署，但是不适合长期开发（因为没有版本控制），所以使用GIT会很方便。\n## 问题\n在windows开发机上使用https方式进行git操作是没问题的，但是在linux上进行git操作的时候就会出错误，会让你输入帐号密码，就算是对的帐号密码也不行。这种情况下需要使用 ssh 方式进行GIT。\n## 解决方法\n1. 生成密钥 在终端下输入 `ssh-keygen -t rsa`\n2. 接下来的询问全部直接按回车\n3. 最后得到了两个文件：id_rsa和id_rsa.pub\n4. cat ~/.ssh/id_rsa.pub\n5. 将显示的内容全部复制下来\n6. 进入你的git网站，比如oschina的git\n7. 添加ssh公钥\n8. 保存\n9. enjoy!","tags":["git"],"categories":["linux"]},{"title":"Linux删除乱码文件","url":"%2F2014%2F09%2F13%2Flinux-delete-messy-code-file.html","content":"shell终端中有时候中文文件名会出现乱码，导致很多操作都不能进行，一个最简单的就是删除了。\n\nlinux中每个文件有类似于ID的东西，使用以下命令查看\n\n```bash\nll -i\n```\n\n显示出来的第一个数字就是文件的inum\n\n可以利用以下命令进行删除操作,假设inum为111111\n\n```bash\nfind . -inum 11111 -exec rm -f {} \\\n```\n\nrm -f {}可以自行替换为自己需要操作的命令。\n这样的话，不管什么文件都可以操作，只要有inum!","tags":["messy code"],"categories":["linux"]},{"title":"MySQL联合主键","url":"%2F2014%2F09%2F13%2Fmysql-combined-primary-key.html","content":"## 单字段主键\nMySQL单字段主键相信大家都熟悉了。就是以一个字段主要数据行的主键，比如下面这个表\n\n```sql\ncreate table `user`(\nuser_id int(11) auto_increment,\nusername varchar(24),\npassword char(32),\nprimary key(user_id)\n);\n```\n\nuser_id作为单字段主键,说明任何用户的user_id都不能相同，一个user_id即标识一个用户。\n## 多字段联合主键\n再看这个表\n\n```sql\ncreate table `user`(\nusername varchar(24),\npassword char(32),\nemail varchar(40),\nprimary key(username,email)\n);\n```\n这里使用username,email作为联合主键，为了标识一个用户，只有在username和email共同存在，且不同时才能标识。\n## 例子\n\n```\nusername\tpassword\temail\nzhangsan\t111111\tzhangsan@qq.com\nzhangsan\t111111\tlisi@qq.com\nlisi\t111111\tzhangsan@qq.com\n```\n\n这三条记录均为合法记录，多字段联合主键的核心就是（所有字段才能唯一确定一条记录，就像上面的username,email）。","tags":["combine primary key"],"categories":["mysql"]},{"title":"PHP正则表达式匹配中文","url":"%2F2014%2F09%2F13%2Fphp-regex-chinese.html","content":"正常的正则表达式匹配英文和数字以及一些常用字符还是很简单的，如\n\n```php\n/^\\w$/\n/^[0-9]$/\n/^[\\-\\_]$/\n```\n\n等等，但是匹配中文的话就有些麻烦了。UTF-8的中文根据unicode编码，所以我们需要手动构造UTF-8字符串\n\n```php\n/^[\\x{4e00}-\\x{9fa5}]$/u\n```\n\n请注意大括号，因为没有大括号PHP会报错\n\n```bash\nWarning: preg_match() [function.preg-match]: Compilation failed: PCRE does not support \\L, \\l, \\N, \\U, or \\u at offset 3 in test.php on line 3\n```\n\n因为\\x是表示十六进制数的，所以需要用大括号括起来\n\n另外，需要增加 u 修饰符。\n\n此修正符启用了一个 PCRE 中与 Perl 不兼容的额外功能。模式字符串被当成 UTF-8。\n\n本修正符在 Unix 下自 PHP 4.1.0 起可用，在 win32 下自 PHP 4.2.3 起可用。\n\n很多时候google的作用确实比 X度 大，学会google吧！","tags":["chinese"],"categories":["php"]},{"title":"nginx url重写和pathinfo配置","url":"%2F2014%2F09%2F10%2Fnginx-urlrewritepathinfo.html","content":"nginx近年来的上涨趋势确实挺快的，但是apache作为老牌HTTP服务器，拥有的生态圈是nginx比不上的。一个最简单的例子，URL重写，apache的话利用无所不能的.htaccess文件就可以了。nginx还要改主配置文件。\n\n## URL重写配置\n### 主配置文件\n\n```\nlocation /\n{\n  if (!-e $request_filename) {\n    rewrite ^/(.*)$ /index.php?$1 last;\n  }\n}\n```\n\n*if和(中间要有括号*,url重写这里就配置完了。\n## pathinfo配置\nnginx原生是不支持pathinfo的，但是通过配置fastcgi参数可以达到效果\n### 主配置文件\n\n```\nlocation ~ [^/]\\.php(/|$)\n{\n  # comment try_files $uri =404; to enable pathinfo\n  #try_files $uri =404;\n  fastcgi_pass  unix:/tmp/php-cgi.sock;\n  fastcgi_index index.php;\n  include fastcgi.conf;\n  include pathinfo.conf;\n}\n```\n\n### fastcgi.conf\n\n```\nfastcgi_param  SCRIPT_FILENAME    $document_root$fastcgi_script_name;\nfastcgi_param  QUERY_STRING       $query_string;\nfastcgi_param  REQUEST_METHOD     $request_method;\nfastcgi_param  CONTENT_TYPE       $content_type;\nfastcgi_param  CONTENT_LENGTH     $content_length;\nfastcgi_param  SCRIPT_NAME        $fastcgi_script_name;\nfastcgi_param  REQUEST_URI        $request_uri;\nfastcgi_param  DOCUMENT_URI       $document_uri;\nfastcgi_param  DOCUMENT_ROOT      $document_root;\nfastcgi_param  SERVER_PROTOCOL    $server_protocol;\nfastcgi_param  HTTPS              $https if_not_empty;\nfastcgi_param  GATEWAY_INTERFACE  CGI/1.1;\nfastcgi_param  SERVER_SOFTWARE    nginx/$nginx_version;\nfastcgi_param  REMOTE_ADDR        $remote_addr;\nfastcgi_param  REMOTE_PORT        $remote_port;\nfastcgi_param  SERVER_ADDR        $server_addr;\nfastcgi_param  SERVER_PORT        $server_port;\nfastcgi_param  SERVER_NAME        $server_name;\n# PHP only, required if PHP was built with --enable-force-cgi-redirect\nfastcgi_param  REDIRECT_STATUS    200;\n```\n\n### pathinfo.conf\n\n```\nfastcgi_split_path_info ^(.+?\\.php)(/.*)$;\nset $path_info $fastcgi_path_info;\nfastcgi_param PATH_INFO       $path_info;\ntry_files $fastcgi_script_name =404;\n```\n\n## 结语\n从这些配置可以看出来，nginx的可定制性还是很强的，同样的，apache下的.htaccess文件，经过一些改写也能在nginx上成功运行~","tags":["rewrite"],"categories":["nginx"]},{"title":"php OOP中的__get和__set方法","url":"%2F2014%2F09%2F07%2Fphp-oop-getter-setter.html","content":"__get,__set光看前面两个下划线就知道是魔术方法了，而且还是PHP OOP中比较重要的方法。\n\n先看一段代码\n\n```php\n<?php\nclass Account{\n    private $user = 1;\n    private $pwd = 2;\n}\n$a = new Account();\necho $a->user;\n$a->name = 5;\necho $a->name;\necho $a->big;\n```\n运行这段代码结果是肯定会报错的！\n\n原因在于，不能访问私有属性user。利用__get和__set改进下这个类\n\n```php\n<?php\nclass Account{\n    private $user = 1;\n    private $pwd = 2;\n    \n    public function __set($name,$value){\n        $this->name = $value;\n    }\n    \n    public function __get($name){\n        if(!isset($this->name)){\n            $this->name = '这是默认值';\n        }\n        return $this->name;\n    }\n}\n$a = new Account();\necho $a->user;\n$a->name = 5;\necho $a->name;\necho $a->big;\n```\n\n运行之后就不会报错了。\n\n现在有了这两个魔术方法就可以随时扩展类里面的属性了，是不是很方便呢？","tags":["setter"],"categories":["php"]},{"title":"摆脱jquery!angularjs利用指令简单实现滚动翻页","url":"%2F2014%2F09%2F06%2Fangularjs-lazy-load.html","content":"移动开发一个很重要的问题是翻页操作，而现在的主流都是滚动翻页，以往都是用jquery的插件进行实现。用了angularjs之后，要逐步减轻对jquery的依赖。   \n\n*滚动翻页基本原理就是判断scrollTop和offsetHeight之和 大于等于 scrollHeight*   \n## 代码\n### 指令\n```javascript\napp.directive('whenScrolled', function() { \n  return function(scope, elm, attr) { \n    var raw = elm[0]; \n    elm.bind('scroll', function() { \n      if (raw.scrollTop+raw.offsetHeight &gt;= raw.scrollHeight) { \n        scope.$apply(attr.whenScrolled); \n      } \n    }); \n  }; \n});\n```\n### 控制器\n\n```javascript\n$scope.loadMore = function() { \n    if ($scope.currentPage &lt; $scope.pages) { \n      $scope.currentPage++; \n      if ($scope.busy) { \n        return false; \n      } \n      $scope.busy = true; \n      $http.get('/api.php?r=site/list/page/'+$scope.currentPage+'/limit/'+$scope.limit).success(function(data) { \n        $scope.busy = false; \n        for (var i in data.data) { \n          $scope.newses.push(data.data[i]); \n        } \n        $scope.pages = Math.ceil(data.total/$scope.limit); \n        $rootScope.title = '首页 - 微文章'; \n      }); \n    } \n  };\n```\n\n### 视图\n\n```html\n<div when-scrolled=\"loadMore()\">\n//内容处理逻辑\n</div>\n```","tags":["angularjs"],"categories":["angularjs"]},{"title":"PHP将日期转换为星座","url":"%2F2014%2F09%2F06%2Fphp-convert-date-to-constellation.html","content":"这几日在做的一个项目发现一个很有意思的东西，就是PHP将指定日期输出为星座\n\n```php\n<?php\nfunction constellation($month, $day) \n{ \n    if ($month < 1 || $month > 12 || $day < 1 || $day > 31) return false; \n    $constellations = array( \n      array(\"20\" => '水瓶座'), \n      array(\"19\" => '双鱼座'), \n      array(\"21\" => '白羊座'), \n      array(\"20\" => '金牛座'), \n      array(\"21\" => '双子座'), \n      array(\"22\" => '巨蟹座'), \n      array(\"23\" => '狮子座'), \n      array(\"23\" => '处女座'), \n      array(\"23\" => '天秤座'), \n      array(\"24\" => '天蝎座'), \n      array(\"22\" => '射手座'), \n      array(\"22\" => '摩羯座') \n    ); \n    list($constellation_start, $constellation_name) = each($constellations[(int)$month - 1]); \n    if ($day < $constellation_start) list($constellation_start, $constellation_name) = each($constellations[($month - 2 < 0) ? $month = 11 : $month -= 2]); \n    return $constellation_name;\n}\n```","tags":["constellation"],"categories":["php"]},{"title":"ngResource快速上手","url":"%2F2014%2F09%2F06%2Fng-resource-get-started.html","content":"废话不多说，本文的目的就是看过之后就会使用ngResource了。\n1. 引入angular-resource.min.js\n2. 定义模块时加载ngResource\n3. 定义service\n\n完整代码如下\n\n```javascript\nvar app = angular.module('app', [\"ngResource\"]);\napp.factory('Phone', ['$resource',\nfunction($resource) {\n    return $resource('user/:uid', {\n        uid: '@uid'\n    },\n    {\n        update: {\n            method: 'PUT'\n        }\n    });\n}]);\napp.controller('MainCtrl', ['$scope', 'Phone',\nfunction($scope, Phone) {\n    $scope.phones = Phone.query();\n    Phone.update({\n        uid: 1\n    },\n    {\n        name: \"zhangsan\",\n        age: \"10\"\n    });\n}]);\n```","tags":["restful"],"categories":["angularjs"]},{"title":"PHP heredoc 字符串定界符使用","url":"%2F2014%2F09%2F06%2Fphp-heredoc.html","content":"PHP定义字符串有三种形式\n+ 双引号\n+ 单引号\n+ heredoc定界符\n\n前面两种大家都很熟悉了，第三种大家用的少。一般在输出大段HTML的时候很方便，不多说，上代码！\n\n```php\n<?php\n$link = 'https://www.google.com.hk';\nprint <<<DOGS \n<a href=\"{$link}\"}Google</a>\nDOGS;\n```\nDOGS可以自己定义。","tags":["heredoc"],"categories":["php"]},{"title":"jquery插件写法","url":"%2F2014%2F09%2F06%2Fjquery-write-a-plugin.html","content":"## 项目地址\n[http://xialeistudio.github.io/search/](http://xialeistudio.github.io/search/)\n\njquery插件确实是数不胜数，只要你用心找，肯定能找得到!\n\n但是一些小功能想自己写，找的话估计时间还长些，本文简单开发一个 基于jquery的获取url查询字符串的 小插件。\n\n插件的模版（$.extend扩展jquery内置方法)\n\n```javascript\n(function($) {\n  $.x_search = function(_name,target) { //x_search是插件名字,_name、target是参数\n  };\n})(jQuery);\n```\n\n```javascript\n\n/** \n * $.x_search \n * @extends jquery 2.1.1(基于该版本开发，其他版本自测) \n * @fileOverview 获取url queryString \n * @author xialeistudio \n * @email 1065890063@qq.com \n * @site www.ddhigh.com \n * @version 0.0.1 \n * @date 2014-08-12 \n * @license MIT \n * @example \n * 获取当个Key \n * $.x_search('name'); \n * 获取所有 \n * $.x_search(); \n */ (function($) { \n  $.x_search = function(_name,target) { \n    if(typeof target == 'undefined'){ \n      target =  window.location.search; \n    } \n    if (typeof _name == 'undefined') { \n      //所有 \n      var query =target.substr(1, window.location.search.length-1).split('&'); \n      var data = []; \n      for (var i = 0; i < query.length; i++) { \n        var tmp = query[i].split('='); \n        data.push({ \n          key: tmp[0], \n          data: decodeURIComponent(tmp[1]) \n        }); \n      } \n      return data; \n    } \n    else { \n      //指定Key \n      try { \n        var regex = new RegExp(_name+'=([^&]+)?'); \n        return decodeURIComponent(target.match(regex)[1]); \n      } \n      catch (e) { \n        return null; \n      } \n    } \n  }; })(jQuery);\n```\n","tags":["jquery plugin"],"categories":["javascript"]},{"title":"bower快速入门","url":"%2F2014%2F09%2F06%2Fbower-get-started.html","content":"## 简介\nbower是twitter的又一个开源项目，使用nodejs开发，用于web包管理。如果越来越多得开源项目都托管在github上，bower只需要将github上项目加上一个配置文件既可以使用bower方式使用安装包。作为包管理，bower能提供添加新web包，更新web包，删除web包，发布web包功能，管理包依赖。web包通常认为由html+css+javascript构成。\n## 安装bower\n\n```bash\nnpm install bower -g\n```\n\n请确保你有Nodejs环境  \n\n在项目目录中运行\n\n```bash\nbower install jquery\n```\n\n运行成功之后项目中会多出components文件夹，文件夹中jquery文件夹，jquery文件夹里面就有最新的jquery文件。\n\n这还不能说明他NB的地方，试想下面的场景，jQuery升级了，是不是再down一次jQuery呢？bower可以这样做：\n\n```bash\nbower update jquery\n```\n\n就可以自动升级到最新版的jquery了。\n\n再假设我们需要使用bootstrap，bootstrap可不是一个文件，有css,js还有图片。js还依赖于jQuery，如果使用bower：\n\n```bash\nbower install bootstrap\n```\n\nbower会自动从github上down最新的代码，而且，会自动将依赖包jquery也down一次。\n\n如果你发布程序的时候不想把一些依赖的库发布上去（主要原因是太大了 - - ），可以在项目根目录下生成一个 bower.json 文件用来管理依赖。\n\n在项目目录下执行\n\n```bash\nbower init\n```\n\n按照提示操作就好，这样子会生成一个bower文件\n\n安装 jquery\n\n```bash\nbower install jquery --save\n```\n\n这样子 bower.json 文件就会写入一个 Jquery的依赖项\n\n别人只要在项目目录下输入\n\n```bash\nbower install\n```\n\n就会自动安装了","tags":["bower"],"categories":["front-end"]},{"title":"php使用CORS实现跨域请求","url":"%2F2014%2F09%2F06%2Fphp-cors-crossdomain.html","content":"js跨域的解决方法，一百度一大堆，不过都是jsonp为主，这种解决方法只适用于GET请求。POST跨域的话需要在HTTP协议上下功夫。\n## 基础知识\n主要会用到以下几个响应头\n+ Access-Control-Allow-Origin：允许哪些url可以跨域请求到本域\n+ Access-Control-Allow-Methods:允许的请求方法，一般是GET,POST,PUT,DELETE,OPTIONS\n+ Access-Control-Max-Age：表明在该时间段内不再“预检”允许的请求方法（相当于缓存），即不以OPTIONS方法进行请求\n+ Access-Control-Allow-Headers：允许哪些请求头可以跨域\n\n## php代码\n\n```php\n<?php\nheader('Access-Control-Allow-Origin:*');\nheader('Access-Control-Allow-Methods:POST');\nheader('Access-Control-Max-Age:60');\nheader('Access-Control-Allow-Headers:x-requested-with,content-type');\nheader('Content-Type:application/json;charset=utf-8');\nprint_r(file_get_contents('php://input'));\n```","tags":["crossdomain"],"categories":["php"]},{"title":"阿里云ECS服务器phpmailer发信失败解决方法","url":"%2F2014%2F09%2F06%2Faliyun-phpmailer.html","content":"phpmailer之前一直在用，一般都是采用smtp登录服务器的方式进行发信，今天在本地windows主机测试也能发信成功，但是到线上去就不行了，提示“连接smtp服务器失败”。\n首先可以排除的是代码方面的错误，那么剩下就知道服务器的问题了。\n\n根据这个错误，可以想到有几种问题:\n1. 服务器ping不通，做Ping测试的时候是通的   \n2. 服务器端口没开，用telnet测试的时候也是这样的\n\n后来在服务器上用php代码测试163邮箱发现可以发信，但是腾讯的就不行，看了下邮箱配置发现是SSL的问题，然后在服务器上输出phpinfo()发现没有openssl扩展。   \n接下来就是安装扩展了。   \n1. 首先进到php的源码包，前往**ext/openssl**目录\n2. 执行 phpize 这个会自动配置\n3. 然后执行 \n\n```bash\n./configure --with-openssl -with-php-config=/usr/local/php/bin/php-config\nmake\nmake install\n```\n\n这里模块安装就完成了，但是需要编辑 **/etc/php.ini**加上\n\n```\nextension=openssl.so\n```\n\n重启 web 服务器就可以了。经过测试，服务器上SSL发信也能成功进行","tags":["aliyun"],"categories":["php"]},{"title":"nginx虚拟主机配置","url":"%2F2014%2F09%2F06%2Fnginx-virtual-host.html","content":"\n最近服务器上用的环境是lnmp，之前一直在用apache，配置虚拟主机也是很方便的。今天查资料发现Nginx的虚拟主机配置更加简单。\n\n\n```\nserver {\n\n    listen       80;\n\n    server_name  domain1;\n\n    location / {\n\n        root   html/domain1;\n\n        index  index.html index.htm index.php;\n\n    }\n\n    location ~ \\.php$ {\n\n    root    html/domain1;\n\n    fastcgi_pass   127.0.0.1:9000;\n\n    fastcgi_index  index.php;\n\n    fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;\n\n    include    fastcgi_params;\n\n        }\n\n}\n\nserver {\n\n    listen    80;\n\n    server_name  domain2;\n\n    location / {\n\n        root   html/domain2;\n\n        index  index.html index.htm index.php;\n\n        }\n\n    location ~ \\.php$ {\n\n        root    html/domain2;\n\n        fastcgi_pass   127.0.0.1:9000;\n\n        fastcgi_index  index.php;\n\n        fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;\n\n        include    fastcgi_params;\n\n    }\n\n}\n```\n\n保存之后，执行 \n\n```bash\nnginx -s reload\n```","tags":["virtual hosts"],"categories":["nginx"]},{"title":"Yii同一站点配置多个用户角色","url":"%2F2014%2F09%2F06%2Fyii-multi-user.html","content":"Yii是基于组件的PHP MVC框架，yii的用户组件调用很方便，但是如果有遇到一个站点有多种用户的时候，如前台用户，后台用户，就需要增加User组件了。\n\n简单来说，就是新建一个用户类去继承 CWebUser类，比如\n\nWebUser继承CWebUser，配置文件在components中增加\n\n```php\n'user'=>array(\n    'class'=>'WebUser'\n)\n```\n\n以上就创建了一个前台用户,调用方式 Yii::app()->user\n\n后台用户可以这么写\n\nAdminUser继承CWebUser,配置文件在components中增加\n\n```php\n'admin'=>array(\n    'class'=>'AdminUser'\n)\n```\n\n这样就创建了一个后台用户，调用方式 Yii::app()->admin\n\n这种方法是本人所知最科学的，比用session来区分好多了。毕竟很多时候，能用框架现有的方法就用框架的方法。","tags":["multi user"],"categories":["php"]},{"title":"Angularjs指令数据远程请求的处理","url":"%2F2014%2F09%2F06%2Fangularjs-load-remote-data-on-directive.html","content":"假设有一个指令用来根据IP地址进行地位，获取实际地址。\n\n首先，我们的IP地址是由后台PHP程序返回的，这里需要一个Http请求，使用了Http请求就会有类似回调的问题，之前想了各种办法，死活拿不到数据，后来去ng官网看了下，需要使用ngModel，这个是双向绑定。\n\n## 指令代码\n\n```javascript\napp.directive('location', ['ApiService', function (ApiService) {\n    return {\n        restrict: 'A',\n        require:'ngModel',\n        link: function (scope, ele, attrs,ngModel) {\n            ele.addClass('opt');\n            ele.bind('click', function () {\n                ele.text('定位中...');\n                ApiService.location(ngModel.$viewValue).success(function (data) {\n                    ele.text(data.country + ' ' + data.region + ' ' + data.city + ' ' + data.isp);\n                });\n            });\n        }\n    };\n}]);\n```\n\n## HTML部分\n\n```html\n<span location ng-model=\"user.login_ip\">定位</span>\n```\n\nJS中的ngModel 会去搜索该指令的元素上的ng-model指令，这里会搜索到一个user.login_ip 的model,然后JS中使用ngModel.$viewValue 就可以拿到值了。\n\n","tags":["directive"],"categories":["angularjs"]},{"title":"Angularjs自动保存指令","url":"%2F2014%2F09%2F06%2Fangularjs-autosave-directive.html","content":"angularjs的指令真是好东西，也是精髓。刚才群里面有朋友在问如何在用户离开编辑区域时提醒保存，其实用指令实现很简单的。\n\n请注意，这里使用的指令标签为**ajax-submit**\n\n```javascript\napp.directive('ajaxSubmit', [\n\t'$http', function($http) {\n\t\treturn {\n\t\t\tlink: function(scope, ele, attrs) {\n\t\t\t\tvar old = ele.val();\n\t\t\t\tele.bind('blur', function() {\n\t\t\t\t\tvar url = ele.data('url');\n\t\t\t\t\tvar val = ele.val();\n\n\t\t\t\t\tele.prop('disabled', true);\n\t\t\t\t\t//发送http\n\t\t\t\t\t$http.post(url, {\n\t\t\t\t\t\tdata: val\n\t\t\t\t\t}).success(function(data) {\n\t\t\t\t\t\tele.prop('disabled', false);\n\t\t\t\t\t\tif (data.msg != undefined) {\n\t\t\t\t\t\t\told = val;\n\t\t\t\t\t\t\tele.after('操作成功');\n\t\t\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\t\t\tele.next().remove();\n\t\t\t\t\t\t\t}, 1000);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\talert(data.error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n]);\n```\n\n关键是利用指令的link函数获取包装后的jq元素，然后给该元素进行事件绑定，其实很多的事件绑定都是这样做的。事件处理函数中的业务逻辑各位看官可以自行修改~。","tags":["timer"],"categories":["angularjs"]},{"title":"PDO简明教程，是时候抛弃mysql_*函数了","url":"%2F2014%2F09%2F06%2Fpdo-get-started.html","content":"mysql_*系列函数我一之前一直在用，基于性能、安全性等原因，再加上PHP面向对象的增强，是时候使用PDO来处理数据了。PDO一个很重要的特点是该类与数据库无关，不同的数据库只是在实例化时传入的参数不同，但是操作方法是一样的。\n\n```php\n<?php\ntry {\n    $pdo = new PDO('mysql:host=localhost;dbname=test','root','root');\n    //查询数据\n    $stmt = $pdo->prepare('SELECT * FROM user WHERE sex=?');\n    $sex = 'male';\n    $stmt->bindParam(1,$sex);\n    $stmt->setFetchMode(PDO::FETCH_ASSOC);\n    $list = $stmt->fetchAll();\n    //查询完毕\n    //写入数据\n    $stmt = $pdo->prepare('INSERT INTO user VALUES (?,?,?)');\n    $username = 'admin';\n    $password = md5('111111');\n    $sex = 'male';\n    $stmt->bindParam(1,$username);\n    $stmt->bindParam(2,$password);\n    $stmt->bindParam(3,$sex);\n    $stmt->execute();\n    //写入完毕\n} catch (Exception $e) {\n    echo $e->getMessage();\n}\n```\n\n编辑、更新、删除统称为写入操作，大家可以举一反三~\n\nexecute会返回受影响的函数，有可能为0行!请大家在判断时用 === 而不是 == , 0 == false 而 0 !== false","tags":["pdo"],"categories":["php"]},{"title":"php中文字符串反转","url":"%2F2014%2F09%2F06%2Fphp-chinese-reverse.html","content":"\nphp **strrev()** 函数能实现字符串反转，但是不支持中文，利用mb_系列函数可以进行中文字符串反转。\n\n```php\n/**\n * 中文字符串反转\n * @param $str\n * @param string $charset\n * @return string\n */\nfunction reverse($str, $charset = 'UTF-8')\n{\n    $ret = '';\n    $len = mb_strlen($str, $charset);\n    for ($i = 0; $i < $len; $i++) {\n        $ret[] = mb_substr($str, $i, 1, $charset);\n    }\n\n    return implode('', array_reverse($ret));\n}\n```","tags":["reverse words"],"categories":["php"]},{"title":"Redis初探","url":"%2F2014%2F09%2F06%2Fredis-get-started.html","content":"Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。\n我本地的PHP是 5.4.25 ts版本，这里是php_redis扩展（只限于5.4.x TS版本）。\n\n[ext.zip](https://og5r5kasb.qnssl.com/ext.zip)\n\n打开php.ini\n\n添加以下两行\n\n```\nextension=php_igbinary.dll\nextension=php_redis.dll\n```\n\n请注意顺序！\n\n重启web服务器就可以了。\n\n示例代码\n```php\n<?php\n$redis = new Redis();\n$redis->connect('127.0.0.1');\n//存储一个值\n$redis->set('name', 'zhangsan', 5);\n//存储多个值\n$array = array(\n    'name' => '张三',\n    'sex' => 'male',\n    'age' => 10\n);\n$array_get=array(\n    'name','sex','age'\n);\n$redis->mset($array);\nprint_r($redis->mget($array_get));\n```\n\n本文只起到抛砖引玉的作用，详细的使用有待大家挖掘~","tags":["redis"],"categories":["php"]}]