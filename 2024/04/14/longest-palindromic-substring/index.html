<!doctype html><html lang=zh><head><meta name=viewport content="width=device-width,initial-scale=1"><title>leetcode热题100(5) - 最长回文子串</title>
<meta charset=utf-8><meta name=google-adsense-account content="ca-pub-2871082647721658"><meta content="Web开发 ,Java ,Go ,Node.js ,PHP ,Koa ,MySQL ,Redis ,前端 ,后端 ,数据库" name=keywords><meta name=description content="Question https://leetcode.cn/problems/longest-palindromic-substring/description/
给你一个字符串 s，找到 s 中最长的回文子串。"><meta name=author content="Lei Xia"><link rel=canonical href=https://www.ddhigh.com/2024/04/14/longest-palindromic-substring/><link rel=alternate type=application/rss+xml href=https://www.ddhigh.com//index.xml title=每天进步一点点><script async defer data-website-id=52f8f0f9-d93d-466b-8ef5-508aae8c4ed4 src=https://analysis.ddhigh.com/script.js></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-EC3XLVSGKV"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-EC3XLVSGKV")</script><meta property="og:url" content="https://www.ddhigh.com/2024/04/14/longest-palindromic-substring/"><meta property="og:site_name" content="每天进步一点点"><meta property="og:title" content="leetcode热题100(5) - 最长回文子串"><meta property="og:description" content="Question https://leetcode.cn/problems/longest-palindromic-substring/description/
给你一个字符串 s，找到 s 中最长的回文子串。"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-04-14T15:15:26+08:00"><meta property="article:modified_time" content="2024-04-14T15:15:26+08:00"><meta property="article:tag" content="Leetcode"><meta name=twitter:card content="summary"><meta name=twitter:title content="leetcode热题100(5) - 最长回文子串"><meta name=twitter:description content="Question https://leetcode.cn/problems/longest-palindromic-substring/description/
给你一个字符串 s，找到 s 中最长的回文子串。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.ddhigh.com/posts/"},{"@type":"ListItem","position":2,"name":"leetcode热题100(5) - 最长回文子串","item":"https://www.ddhigh.com/2024/04/14/longest-palindromic-substring/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"leetcode热题100(5) - 最长回文子串","name":"leetcode热题100(5) - 最长回文子串","description":"Question https://leetcode.cn/problems/longest-palindromic-substring/description/\n给你一个字符串 s，找到 s 中最长的回文子串。","keywords":["leetcode"],"articleBody":"Question https://leetcode.cn/problems/longest-palindromic-substring/description/\n给你一个字符串 s，找到 s 中最长的回文子串。\n示例 1：\n示例 2：\n提示：\n1 \u003c= s.length \u003c= 1000 s 仅由数字和英文字母组成 Solution 暴力法 此解法提交Leetcode会超时\n暴力法主要有两个步骤：穷举所有子串和判断子串是否问回文串。\n子串的长度从1...N ,所有需要一重循环 针对每个长度的子串，我们需要遍历子串起点 lass Solution1 { public String longestPalindrome(String s) { if (s.length() \u003c= 1) { return s; } int maxLength = 0; String maxString = \"\"; // 子串长度 for (int length = 2; length \u003c= s.length(); length++) { // 子串起点 for (int start = 0; start \u003c= s.length() - length; start++) { var end = start + length; var substring = s.substring(start, end); // 如果是回文串且长度大于当前最大的子串长度则更新 if (isPalindrome(substring) \u0026\u0026 substring.length() \u003e maxLength) { maxLength = substring.length(); maxString = substring; } } } return maxString; } boolean isPalindrome(String s) { var length = s.length(); for (int i = 0; i \u003c length / 2; i++) { if (s.charAt(i) != s.charAt(length - 1 - i)) { return false; } } return true; } } 时间复杂度\nO(n^3), n是字符串长度，我们有两重循环穷举子串，有一重循环检测是否为回文串。\n空间复杂度\nO(1),需要使用几个固定数量的变量。\n动态规划(Dynamic Programing) 对于此类题目，动态规划一般可以用来降维。\n根据回文字符串的定义，可以知道字符串的子串是对称的，根据该条件我们可以优化isPalindrome 函数的调用。\n假设我们使用二维数组dp[start][end]来存储子串s[start,end]是否为回文串，那么需要讨论以下几种情况：\n当s[start] = s[end] 时，考虑如下情况：\n如果start = end, 则s[start] 和 s[end] 是同一个字符，满足回文串条件； 如果 |start-end|=1 ，则s[start] 和s[end] 相邻，满足回文串条件； 如果|start-end|=2 ，则s[start] 和s[end] 中间隔了一个字符，满足回文串条件； 如果|start-end|\u003e2 ，则需要根据上一个子串s[start-1][end+1] 是否为回文串来确定。 因此状态转移方程如下:\nDP(start,end)=\\begin{cases} s[start]=s[end], \u0026\\text{if } (end-start) \\leqslant 2 \\ DP(start-1, end+1) \\land s[start]=s[end], \u0026\\text{if } (end-start) \\gt 2 \\end{cases}\nclass Solution2 { public String longestPalindrome(String s) { if (s.length() \u003c= 1) { return s; } var maxLength = 1; var maxBegin = 0; var dp = new boolean[s.length()][s.length()]; // 初始化DP for (int i = 0; i \u003c s.length(); i++) { dp[i][i] = true; } // 遍历子串长度 for (int length = 2; length \u003c= s.length(); length++) { // 遍历起点 for (int start = 0; start \u003c= s.length() - length; start++) { // 计算结束下标 var end = start + length - 1; if (s.charAt(start) != s.charAt(end)) { dp[start][end] = false; } else { // 可以直接得出结论 if (end - start \u003c= 2) { dp[start][end] = true; } else { // 需要状态转移 dp[start][end] = dp[start + 1][end - 1]; } } // 当前子串是回文串而且长度比当前最大长度大，则更新最大长度 if (dp[start][end] \u0026\u0026 (end - start + 1) \u003e maxLength) { maxLength = end - start + 1; maxBegin = start; } } } return s.substring(maxBegin, maxBegin + maxLength); } } 时间复杂度\nO(n^2)​, n​是字符串长度。\n空间复杂度\nO(n^2), n是字符串长度，需要二维数组存储动态规划状态。\n中心扩展法 本题还可以使用中心扩展法解答。\n对于字符串s 的每个字符s[i] 我们考察s[i-1] 和s[i+1] 是否相等，如果相等，则继续考察前1个和后一个是否匹配，这就是中心扩展法的核心思想。需要注意的是，回文中心有单个字符和两个相同的相邻字符，如a 和aa 都是有效的回文中心，因此在编码时需要考虑这两种情况并取长度更长的作为当前位置i 的最优解。\nclass Solution3 { public String longestPalindrome(String s) { if (s.length() \u003c= 1) { return s; } int start = 0; int end = 0; for (int i = 0; i \u003c s.length(); i++) { int len1 = extendCenter(s, i, i); // 中点是同一个字符 int len2 = extendCenter(s, i, i + 1); // 中点是两个字符 int len = Math.max(len1, len2); if (len \u003e end - start) { start = i - (len - 1) / 2; // 闭区间，所以len-1 end = i + len / 2; // 开区间 } } return s.substring(start, end + 1); } private int extendCenter(String s, int start, int end) { while (start \u003e= 0 \u0026\u0026 end \u003c s.length() \u0026\u0026 s.charAt(start) == s.charAt(end)) { start--; end++; } // 此时的start和end满足回文条件，因此需要回退一位才是回文串 // 起点(start+1), 终点(end-1) // 距离公式 (end-1)-(start+1)+1 // 化简得 end-start-1 return end - start - 1; } } 需要注意的是在方法extendCenter 中，while 循环结束后start 和end 构成的子串一定不是回文串（如果是的话循环还会继续），因此在计算当前start~end 的最大回文串长度时需要将start 和end 进行回退(回退过程见代码注释)。\n时间复杂度\nO(n^2),n字符串长度，外侧需要遍历字符串，内侧有两个while循环调用，总的时间复杂度为O(n*2n)=O(2n^2) ，化简得O(n^2) .\n空间复杂度\nO(1), 需要使用常数项的变量。\n","wordCount":"515","inLanguage":"zh","datePublished":"2024-04-14T15:15:26+08:00","dateModified":"2024-04-14T15:15:26+08:00","author":{"@type":"Person","name":"Lei Xia"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.ddhigh.com/2024/04/14/longest-palindromic-substring/"},"publisher":{"@type":"Organization","name":"每天进步一点点","logo":{"@type":"ImageObject","url":"https://www.ddhigh.com/favicon.ico"}}}</script><link rel=icon href=/img/favicon.ico sizes=16x16><link rel=apple-touch-icon href=/img/favicon.ico><link rel=manifest href=/img/favicon.ico><link href=https://fonts.cdnfonts.com/css/titillium-web rel=stylesheet><link rel=stylesheet href=/css/main.min.0eb4160ba4a2d63122fe8ae83f1560951a87ab510d5dab0615973b5206555759.css integrity="sha256-DrQWC6Si1jEi/oroPxVglRqHq1ENXasGFZc7UgZVV1k=" crossorigin=anonymous media=screen><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css integrity="sha512-ygEyjMC6rqnzJqWGjRTJUPYMEs9JUOm3i7OWUS9CgQ4XkBUvMsgCS1I8JqavidQ2ClHcREB7IbA2mN08+r9Elg==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=/scss/highlight/github-dark.min.min.66034289ee9a113219a2c4aae0a8bd2095ab255c832a42efcf5863f10814e7a1.css><script src=/js/highlight.min.min.c607d6febd16934a82eb61d3a896ed9d869f54373cc63ce95864ed5488fe3128.js></script><script>hljs.highlightAll()</script><script>$darkModeInit.Content|safeJS</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2871082647721658" crossorigin=anonymous></script></head><body><main class=wrapper><nav class=navigation><section class=container><a class=navigation-brand href=/>每天进步一点点
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><span></span><span></span><span></span></label><ul class=navigation-list id=navigation-list><li class="navigation-item navigation-menu"><a class=navigation-link href=/>首页</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/archives>归档</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/books>出版物</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/guestbook>留言板</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class="navigation-item navigation-social"><a class=navigation-link href=https://github.com/xialeistudio><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li class="navigation-item navigation-dark"><button id=mode type=button aria-label="toggle user light or dark theme">
<span class=toggle-dark><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span>
<span class=toggle-light><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></li><li class="navigation-item navigation-language"><a href=https://www.ddhigh.com/en/>EN</a></li></ul></section></nav><div id=content><article class=blog-single><header class=blog-title><h1>leetcode热题100(5) - 最长回文子串</h1></header><p><small>2024年4月14日&nbsp;· 515 字&nbsp;· 3 分钟</small><p><div class=blog-toc><nav id=TableOfContents><ul><li><ul><li><a href=#question>Question</a></li><li><a href=#solution>Solution</a></li></ul></li></ul></nav></div><section class=blog-content><h3 id=question>Question</h3><p><a href=https://leetcode.cn/problems/longest-palindromic-substring/description/ target=_blank rel=noopener>https://leetcode.cn/problems/longest-palindromic-substring/description/</a></p><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p><p></p><p><strong>示例 1：</strong></p><p><strong>示例 2：</strong></p><p></p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 仅由数字和英文字母组成</li></ul><h3 id=solution>Solution</h3><h4 id=暴力法>暴力法</h4><blockquote><p>此解法提交Leetcode会超时</p></blockquote><p>暴力法主要有两个步骤：穷举所有子串和判断子串是否问回文串。</p><ol><li>子串的长度从<code>1...N</code> ,所有需要一重循环</li><li>针对每个长度的子串，我们需要遍历子串起点</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>lass Solution1 {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>longestPalindrome</span>(String s) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (s.<span style=color:#a6e22e>length</span>() <span style=color:#f92672>&lt;=</span> 1) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> s;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> maxLength <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>            String maxString <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;&#34;</span>;
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 子串长度</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> length <span style=color:#f92672>=</span> 2; length <span style=color:#f92672>&lt;=</span> s.<span style=color:#a6e22e>length</span>(); length<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 子串起点</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> start <span style=color:#f92672>=</span> 0; start <span style=color:#f92672>&lt;=</span> s.<span style=color:#a6e22e>length</span>() <span style=color:#f92672>-</span> length; start<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>var</span> end <span style=color:#f92672>=</span> start <span style=color:#f92672>+</span> length;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>var</span> substring <span style=color:#f92672>=</span> s.<span style=color:#a6e22e>substring</span>(start, end);
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 如果是回文串且长度大于当前最大的子串长度则更新</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (isPalindrome(substring) <span style=color:#f92672>&amp;&amp;</span> substring.<span style=color:#a6e22e>length</span>() <span style=color:#f92672>&gt;</span> maxLength) {
</span></span><span style=display:flex><span>                        maxLength <span style=color:#f92672>=</span> substring.<span style=color:#a6e22e>length</span>();
</span></span><span style=display:flex><span>                        maxString <span style=color:#f92672>=</span> substring;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> maxString;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>isPalindrome</span>(String s) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> length <span style=color:#f92672>=</span> s.<span style=color:#a6e22e>length</span>();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> length <span style=color:#f92672>/</span> 2; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (s.<span style=color:#a6e22e>charAt</span>(i) <span style=color:#f92672>!=</span> s.<span style=color:#a6e22e>charAt</span>(length <span style=color:#f92672>-</span> 1 <span style=color:#f92672>-</span> i)) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p><strong>时间复杂度</strong></p><p>O(n^3), n是字符串长度，我们有两重循环穷举子串，有一重循环检测是否为回文串。</p><p><strong>空间复杂度</strong></p><p>O(1),需要使用几个固定数量的变量。</p><h4 id=动态规划dynamic-programing>动态规划(Dynamic Programing)</h4><p>对于此类题目，动态规划一般可以用来降维。</p><p>根据回文字符串的定义，可以知道字符串的子串是对称的，根据该条件我们可以优化<code>isPalindrome</code> 函数的调用。</p><p>假设我们使用二维数组dp[start][end]来存储子串s[start,end]是否为回文串，那么需要讨论以下几种情况：</p><p>当s[start] = s[end] 时，考虑如下情况：</p><ol><li>如果start = end, 则s[start] 和 s[end] 是同一个字符，满足回文串条件；</li><li>如果 |start-end|=1 ，则s[start] 和s[end] 相邻，满足回文串条件；</li><li>如果|start-end|=2 ，则s[start] 和s[end] 中间隔了一个字符，满足回文串条件；</li><li>如果|start-end|>2 ，则需要根据上一个子串s[start-1][end+1] 是否为回文串来确定。</li></ol><p>因此状态转移方程如下:</p><p>DP(start,end)=\begin{cases} s[start]=s[end], &\text{if } (end-start) \leqslant 2 \ DP(start-1, end+1) \land s[start]=s[end], &\text{if } (end-start) \gt 2 \end{cases}</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution2</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>longestPalindrome</span>(String s) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (s.<span style=color:#a6e22e>length</span>() <span style=color:#f92672>&lt;=</span> 1) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> s;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> maxLength <span style=color:#f92672>=</span> 1;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> maxBegin <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> dp <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>boolean</span><span style=color:#f92672>[</span>s.<span style=color:#a6e22e>length</span>()<span style=color:#f92672>][</span>s.<span style=color:#a6e22e>length</span>()<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 初始化DP</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> s.<span style=color:#a6e22e>length</span>(); i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>                dp<span style=color:#f92672>[</span>i<span style=color:#f92672>][</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 遍历子串长度</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> length <span style=color:#f92672>=</span> 2; length <span style=color:#f92672>&lt;=</span> s.<span style=color:#a6e22e>length</span>(); length<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 遍历起点</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> start <span style=color:#f92672>=</span> 0; start <span style=color:#f92672>&lt;=</span> s.<span style=color:#a6e22e>length</span>() <span style=color:#f92672>-</span> length; start<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 计算结束下标</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>var</span> end <span style=color:#f92672>=</span> start <span style=color:#f92672>+</span> length <span style=color:#f92672>-</span> 1;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (s.<span style=color:#a6e22e>charAt</span>(start) <span style=color:#f92672>!=</span> s.<span style=color:#a6e22e>charAt</span>(end)) {
</span></span><span style=display:flex><span>                        dp<span style=color:#f92672>[</span>start<span style=color:#f92672>][</span>end<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                        <span style=color:#75715e>// 可以直接得出结论</span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> (end <span style=color:#f92672>-</span> start <span style=color:#f92672>&lt;=</span> 2) {
</span></span><span style=display:flex><span>                            dp<span style=color:#f92672>[</span>start<span style=color:#f92672>][</span>end<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                        } <span style=color:#66d9ef>else</span> { <span style=color:#75715e>// 需要状态转移</span>
</span></span><span style=display:flex><span>                            dp<span style=color:#f92672>[</span>start<span style=color:#f92672>][</span>end<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> dp<span style=color:#f92672>[</span>start <span style=color:#f92672>+</span> 1<span style=color:#f92672>][</span>end <span style=color:#f92672>-</span> 1<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 当前子串是回文串而且长度比当前最大长度大，则更新最大长度</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (dp<span style=color:#f92672>[</span>start<span style=color:#f92672>][</span>end<span style=color:#f92672>]</span> <span style=color:#f92672>&amp;&amp;</span> (end <span style=color:#f92672>-</span> start <span style=color:#f92672>+</span> 1) <span style=color:#f92672>&gt;</span> maxLength) {
</span></span><span style=display:flex><span>                        maxLength <span style=color:#f92672>=</span> end <span style=color:#f92672>-</span> start <span style=color:#f92672>+</span> 1;
</span></span><span style=display:flex><span>                        maxBegin <span style=color:#f92672>=</span> start;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> s.<span style=color:#a6e22e>substring</span>(maxBegin, maxBegin <span style=color:#f92672>+</span> maxLength);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p><strong>时间复杂度</strong></p><p>O(n^2)​, n​是字符串长度。</p><p><strong>空间复杂度</strong></p><p>O(n^2), n是字符串长度，需要二维数组存储动态规划状态。</p><h4 id=中心扩展法>中心扩展法</h4><p>本题还可以使用中心扩展法解答。</p><p>对于字符串<code>s</code> 的每个字符<code>s[i]</code> 我们考察<code>s[i-1]</code> 和<code>s[i+1]</code> 是否相等，如果相等，则继续考察前1个和后一个是否匹配，这就是中心扩展法的核心思想。需要注意的是，回文中心有单个字符和两个相同的相邻字符，如<code>a</code> 和<code>aa</code> 都是有效的回文中心，因此在编码时需要考虑这两种情况并取长度更长的作为当前位置<code>i</code> 的最优解。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution3</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>longestPalindrome</span>(String s) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (s.<span style=color:#a6e22e>length</span>() <span style=color:#f92672>&lt;=</span> 1) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> s;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> start <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> end <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> s.<span style=color:#a6e22e>length</span>(); i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>int</span> len1 <span style=color:#f92672>=</span> extendCenter(s, i, i); <span style=color:#75715e>// 中点是同一个字符</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>int</span> len2 <span style=color:#f92672>=</span> extendCenter(s, i, i <span style=color:#f92672>+</span> 1); <span style=color:#75715e>// 中点是两个字符</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>int</span> len <span style=color:#f92672>=</span> Math.<span style=color:#a6e22e>max</span>(len1, len2);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (len <span style=color:#f92672>&gt;</span> end <span style=color:#f92672>-</span> start) {
</span></span><span style=display:flex><span>                    start <span style=color:#f92672>=</span> i <span style=color:#f92672>-</span> (len <span style=color:#f92672>-</span> 1) <span style=color:#f92672>/</span> 2; <span style=color:#75715e>// 闭区间，所以len-1</span>
</span></span><span style=display:flex><span>                    end <span style=color:#f92672>=</span> i <span style=color:#f92672>+</span> len <span style=color:#f92672>/</span> 2; <span style=color:#75715e>// 开区间</span>
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> s.<span style=color:#a6e22e>substring</span>(start, end <span style=color:#f92672>+</span> 1);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>extendCenter</span>(String s, <span style=color:#66d9ef>int</span> start, <span style=color:#66d9ef>int</span> end) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (start <span style=color:#f92672>&gt;=</span> 0 <span style=color:#f92672>&amp;&amp;</span> end <span style=color:#f92672>&lt;</span> s.<span style=color:#a6e22e>length</span>() <span style=color:#f92672>&amp;&amp;</span> s.<span style=color:#a6e22e>charAt</span>(start) <span style=color:#f92672>==</span> s.<span style=color:#a6e22e>charAt</span>(end)) {
</span></span><span style=display:flex><span>                start<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>                end<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 此时的start和end满足回文条件，因此需要回退一位才是回文串</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 起点(start+1), 终点(end-1)</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 距离公式 (end-1)-(start+1)+1</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 化简得 end-start-1</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> end <span style=color:#f92672>-</span> start <span style=color:#f92672>-</span> 1;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>需要注意的是在方法<code>extendCenter</code> 中，<code>while</code> 循环结束后<code>start</code> 和<code>end</code> 构成的子串一定不是回文串（如果是的话循环还会继续），因此在计算当前<code>start~end</code> 的最大回文串长度时需要将<code>start</code> 和<code>end</code> 进行回退(回退过程见代码注释)。</p><p><strong>时间复杂度</strong></p><p>O(n^2),n字符串长度，外侧需要遍历字符串，内侧有两个while循环调用，总的时间复杂度为O(n*2n)=O(2n^2) ，化简得O(n^2) .</p><p><strong>空间复杂度</strong></p><p>O(1), 需要使用常数项的变量。</p><div class=blog-footer><div class=social-share></div><div class=copyright><ul><li style=margin-bottom:.5em>本文作者: <a href=https://ddhigh.com/ target=_blank style=color:#000;text-decoration:none>xialeistudio</a></li><li style=margin-bottom:.5em>本文链接: <a href=https://www.ddhigh.com/2024/04/14/longest-palindromic-substring/ target=_blank style=color:#000;text-decoration:none>leetcode热题100(5) - 最长回文子串</a></li><li>版权声明: <a href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank style=color:#000;text-decoration:none>「署名-非商业性使用-相同方式共享 4.0 国际」</a></li></ul></div><div style=margin-top:2rem><img src=/img/mp.png alt=qrcode></div></div></section><div class=paginator><a class=prev href=https://www.ddhigh.com/2024/04/15/container-with-most-water/><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M9.94496 9C9.28897 9.61644 7.63215 10.997 6.04814 11.7966 5.98257 11.8297 5.98456 11.9753 6.05061 12.0063c1.00435.4716 2.8788 1.9201 3.89435 2.9937M6.44444 11.9667C8.86549 12.0608 14 12 16 11" stroke="currentcolor" stroke-linecap="round"/></svg>
<span>leetcode热题100(11) - 盛最多水的容器</span></a>
<a class=next href=https://www.ddhigh.com/2024/03/20/understand-rbac/><span>理解RBAC授权</span><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M12.055 9C12.711 9.61644 14.3679 10.997 15.9519 11.7966 16.0174 11.8297 16.0154 11.9753 15.9494 12.0063 14.945 12.4779 13.0706 13.9264 12.055 15m3.5006-3.0333C13.1345 12.0608 8 12 6 11" stroke="currentcolor" stroke-linecap="round"/></svg></a></div><div class=comments><script>const getTheme=window.localStorage&&window.localStorage.getItem("theme");let theme=getTheme==="dark"?"dark":"light",s=document.createElement("script");s.src="https://giscus.app/client.js",s.setAttribute("data-repo","xialeistudio/discussion"),s.setAttribute("data-repo-id","R_kgDOKurTRA"),s.setAttribute("data-category","General"),s.setAttribute("data-category-id","DIC_kwDOKurTRM4CbCJt"),s.setAttribute("data-mapping","pathname"),s.setAttribute("data-strict","0"),s.setAttribute("data-reactions-enabled","1"),s.setAttribute("data-emit-metadata","0"),s.setAttribute("data-input-position","bottom"),s.setAttribute("data-theme",theme),s.setAttribute("data-lang","en"),s.setAttribute("data-loading","lazy"),s.setAttribute("crossorigin","anonymous"),s.setAttribute("async",""),document.querySelector("div.comments").innerHTML="",document.querySelector("div.comments").appendChild(s)</script></div></article></div><footer class=footer><p>&copy; 2014 - 2024 <a href=https://www.ddhigh.com/>每天进步一点点</a>
Powered by
<a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>
<a href=https://github.com/guangzhengli/hugo-theme-ladder rel=noopener target=_blank>Ladder</a>
️</p></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg width="24" height="24" viewBox="0 0 24 24" fill="none"><path d="M10.5376 22.7916C11.0152 22.7207 22.5795 21.1781 22.0978 10.4211 22.0536 9.43274 21.9303 8.53367 21.7387 7.71865M10.5376 22.7916C16.876 22.3728 20.0969 19.8899 21.5383 16.9142M10.5376 22.7916C9.7707 22.9055 8.97982 22.8964 8.19743 22.7725M21.7387 7.71865C21.4988 6.69828 21.1518 5.80967 20.7188 5.04257m1.0199 2.67608C22.6022 10.1105 23.0542 13.7848 21.5383 16.9142M20.7188 5.04257c-3.5504-6.28886-12.88753-4.410077-16.44303.0C2.88063 6.77451-.0433281 11.1668 1.38159 16.6571c.89322 3.4417 3.7911 5.6365 6.81584 6.1154M20.7188 5.04257c1.3509 1.89783 3.3111 6.34223 1.6353 10.37273M21.5383 16.9142C21.8737 16.4251 22.1428 15.9235 22.3541 15.4153M8.19743 22.7725C12.1971 23.4683 20.6281 22.971 22.3541 15.4153M14 10.945C13.3836 10.289 12.003 8.63215 11.2034 7.04814 11.1703 6.98257 11.0247 6.98456 10.9937 7.05061 10.5221 8.05496 9.07362 9.92941 8 10.945m3.0333-3.50056C10.9392 9.86549 11 15 12 17" stroke="currentcolor" stroke-linecap="round"/></svg>
</a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function n(){t.innerHTML="Copied",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)}),e.parentNode.appendChild(t)})</script><script src=https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js integrity="sha512-9DNXrSjk17bU9MUbRp3IjwcWe46V8FaGA062PFbryPUAEQVRbz4jiZP6FW0AdbqEGtMYBDWnul3eiGBMJOQajA==" crossorigin=anonymous referrerpolicy=no-referrer></script></main></body><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script><script>const images=Array.from(document.querySelectorAll(".blog-content img"));images.forEach(e=>{mediumZoom(e,{margin:10,scrollOffset:40,container:null,template:null,background:"rgba(0, 0, 0, 0.5)"})})</script><script src=/main.min.6bb26b69159420159c74dc9e097b06a578ed2b68c701466a91a44a9632d851bd0af167a1b30012387b4c512b48ad9ad4d3394e04d77ae38d57e1920fe4ed34fe.js integrity="sha512-a7JraRWUIBWcdNyeCXsGpXjtK2jHAUZqkaRKljLYUb0K8WehswASOHtMUStIrZrU0zlOBNd6441X4ZIP5O00/g==" crossorigin=anonymous defer></script></html>