<!doctype html><html lang=en><head><meta name=generator content="Hugo 0.123.8"><meta name=viewport content="width=device-width,initial-scale=1"><title>Lei Xia</title>
<meta charset=utf-8><meta name=description content="Ladder@Learning & Writing & Sharing"><meta name=author content="Lei Xia"><link rel=canonical href=https://www.ddhigh.com/><link rel=alternate type=application/rss+xml href=https://www.ddhigh.com//index.xml title="Lei Xia"><meta property="og:title" content="Lei Xia"><meta property="og:description" content="Learning & Writing & Sharing"><meta property="og:type" content="website"><meta property="og:url" content="https://www.ddhigh.com/"><meta name=twitter:card content="summary"><meta name=twitter:title content="Lei Xia"><meta name=twitter:description content="Learning & Writing & Sharing"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"Lei Xia","url":"https://www.ddhigh.com/","description":"Learning \u0026amp; Writing \u0026amp; Sharing","thumbnailUrl":"https://www.ddhigh.com/favicon.ico","sameAs":[]}</script><link rel=icon href=/img/favicon.ico sizes=16x16><link rel=apple-touch-icon href=/img/favicon.ico><link rel=manifest href=/img/favicon.ico><link rel=stylesheet href=https://cdn.staticfile.org/lxgw-wenkai-webfont/1.6.0/style.css><link rel=stylesheet href=/css/main.min.5dd042a107aa191c819948e5648b04844bec5bdd365fdcf2b880177ce3d89b79.css integrity="sha256-XdBCoQeqGRyBmUjlZIsEhEvsW902X9zyuIAXfOPYm3k=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/highlight/github-dark.min.min.66034289ee9a113219a2c4aae0a8bd2095ab255c832a42efcf5863f10814e7a1.css><script src=/js/highlight.min.min.c607d6febd16934a82eb61d3a896ed9d869f54373cc63ce95864ed5488fe3128.js></script><script>hljs.highlightAll()</script><script>$darkModeInit.Content|safeJS</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-EC3XLVSGKV"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-EC3XLVSGKV")</script></head><body><main class=wrapper><nav class=navigation><section class=container><a class=navigation-brand href=/>HOME
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><span></span><span></span><span></span></label><ul class=navigation-list id=navigation-list><li class="navigation-item navigation-menu"><a class=navigation-link href=/archives>Archive</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/books>Books</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/guestbook>Guestbook</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class="navigation-item navigation-social"><a class=navigation-link href=https://github.com/xialeistudio><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li class="navigation-item navigation-dark"><button id=mode type=button aria-label="toggle user light or dark theme">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span>
<span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></li></ul></section></nav><div id=content><div class=home><div class=info><div class=intro><h1>Lei Xia</h1><small>Sr. Software Engineer | Solution Architect</small><p><p>Writing code, Enjoying life, Building future</p><p><a href=/atom.xml target=_blank rel=noopener>RSS</a> ·
<a href=/sponsors target=_blank rel=noopener>Sponsor</a></p></p></div></div></div><div class=blog-wrapper><div><div class=blog-list><article><div class=blog-card><h3><a href=/2019/09/20/leetcode-median-of-two-sorted-arrays/>leetcode(4)——寻找两个有序数组的中位数</a></h3><p><small>September 20, 2019&nbsp;· 453 words&nbsp;· 3 min</small><p>本文是力扣算法的第四篇，讲解寻找两个有序数组的中位数。
Question 给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。
请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。
你可以假设 nums1 和 nums2 不会同时为空。
示例 1:
nums1 = [1, 3] nums2 = [2] 则中位数是 2.0 示例 2:
nums1 = [1, 2] nums2 = [3, 4] 则中位数是 (2 + 3)/2 = 2.5 中位数 中位数是按顺序排列的一组数据中居于中间位置的数，即在这组数据中，有一半的数据比他大，有一半的数据比他小。
暴力法 将两个有序数组合并成一个有序数组
如果长度是奇数则返回中间的值，如果是否则则返回中间两个数的平均值。
var findMedianSortedArrays = function (nums1, nums2) { const nums = []; let p1 = p2 = 0; while (p1 &lt; nums1.</div></article><article><div class=blog-card><h3><a href=/2019/09/17/javascript-var-scope/>搞懂JS变量提升</a></h3><p><small>September 17, 2019&nbsp;· 107 words&nbsp;· One minute</small><p>本文讲解Javascript变量提升引起的问题以及如何规避。
问题 今天看到一道有意思的面试题，考察的还真是JS的基本功，题目如下：
var name = "world"; (function(){ if(typeof name === "undefined") { var name = "Jack"; console.log("Hello " + name); } else { console.log("Hello " + name); } }()); 根据if条件可以得出可能的答案：
Hello world Hello Jack 正确答案 答案是Hello Jack，但是答案怎么来的，回答不好可能还是只能打50分，有以下两种理解：
理解1：
立即执行函数有独立的作用域，访问不到外部name，所以if判断成立，输出 Hello Jack
这个理解是不正确的。虽然函数隔离了作用域，但是由于作用域链的关系，JS会从当前作用域一直往上级查找，直到顶级作用域（浏览器环境为window）。
如下代码输出Hello world
var name = "world"; (function(){ console.log("Hello " + name); }()); 理解2：
var存在变量提升，所以if在判断的时候name确实为undefined，走了if分支，输出 Hello Jack
变量提升 MDN对变量提升的解释：
“变量提升”意味着变量和函数的声明会在物理层面移动到代码的最前面，但这么说并不准确。实际上变量和函数声明在代码里的位置是不会动的，而是在编译阶段被放入内存中。
JavaScript 仅提升声明，而不提升初始化 函数和变量相比，会被优先提升 根据变量提升理论我们可以“模拟”JS实际执行代码的过程：
var name = "world"; (function(){ var name; // 变量提升，仅提升声明，不提升初始化 if(typeof name === "undefined") { name = "Jack"; console.</div></article><article><div class=blog-card><h3><a href=/2019/09/16/leetcode-longest-substring-without-repeating-characters-copy/>leetcode(3)——无重复字符的最长子串</a></h3><p><small>September 16, 2019&nbsp;· 341 words&nbsp;· 2 min</small><p>本文是力扣算法的第三篇，讲解无重复字符的最长子串问题。
Question 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。
示例1：
输入: "abcabcbb" 输出: 3 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。 示例2：
输入: "bbbbb" 输出: 1 解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。 示例3：
输入: "pwwkew" 输出: 3 解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。 遍历法 最容易想到的一种算法，也是效率最低的一种算法
通过两次遍历得到所有可能的 子字符串 列表 将每个字符串传入一个函数检测是否包含重复字符，如果不包含则更新最长子串的长度 // 判断给定的子串是否包含重复字符 function isUnique(str, start, end) { const chars = []; for(let i = start; i &lt; end; i++) { const char = str[i]; if(chars.indexOf(char) !== -1) { // 字符已存在，本字符串不符合条件 return false; } chars.</div></article><article><div class=blog-card><h3><a href=/2019/09/12/leetcode-add-two-sum/>leetcode(2) —— 两数相加</a></h3><p><small>September 12, 2019&nbsp;· 189 words&nbsp;· One minute</small><p>本文是力扣算法的第二篇，讲解两数相加问题。
Question 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。
如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。
您可以假设除了数字 0 之外，这两个数都不会以 0 开头。
示例：
输入：(2 -> 4 -> 3) + (5 -> 6 -> 4) 输出：7 -> 0 -> 8 原因：342 + 465 = 807 分析 遍历两个链表把值加起来好之后插入链表，如果有进位的话需要把进位的值保存到后面的节点上，如果遍历完毕之后还剩下需要进位的值，那么需要插入末尾新节点。
边界情况 遇到链表相关的题目时一定要处理好边界情况，因为有些为空的链表或者只有1个节点的链表没有处理的必要，及时返回可以降低算法复杂度。
链表1和链表2同时为空，直接返回undefined即可 链表1为空，返回链表2 链表2为空，返回链表1 解题方法 // 链表节点定义 function ListNode(val) { this.val = val; this.next = null; } function addTwoNumbers(l1, l2) { if(!l1 && !l2) { // 链表1和链表2同时为空，无需任何处理 return; } if(!l1) { // 链表1为空，直接返回链表2 return l2; } if(!</div></article><article><div class=blog-card><h3><a href=/2019/09/12/leetcode-two-sum/>leetcode(1) —— 两数之和</a></h3><p><small>September 12, 2019&nbsp;· 199 words&nbsp;· One minute</small><p>本文是力扣算法的第一篇，讲解两数之和问题。
问题 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。
你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。
示例:
给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 嵌套循环解题法 通过第1遍循环可以拿到当前值和剩余值，然后嵌套循环一次，检查剩余值是不是在数组中。
function twoSum(nums, target) { for(let i = 0;i&lt;nums.length;i++) { const current = nums[i]; // 拿到当前值 const remain = target - current; // 拿到剩余值 for(let j = 1;j&lt;nums.length;j++) { if(nums[j] === remain) { return [i, j]; } } } } 时间复杂度是O(n^2)</div></article><article><div class=blog-card><h3><a href=/2019/09/10/nestjs-interceptor/>NestJs学习之旅(9)——拦截器</a></h3><p><small>September 10, 2019&nbsp;· 405 words&nbsp;· 2 min</small><p>本文是NestJs的第九篇，讲解拦截器。
拦截器是一个实现了NestInterceptor接口且被**@Injectable**装饰器修饰的类。
拦截器是基于AOP编程思想的一种应用，以下是常用的功能：
在方法执行之前或之后执行额外的逻辑，这些逻辑一般不属于业务的一部分 转换函数执行结果 转换函数执行时抛出的异常 扩展函数基本行为 特定场景下完全重写函数的行为（比如缓存拦截器，一旦有可用的缓存则直接返回，不执行真正的业务逻辑，即业务逻辑处理函数行为已经被重写） 拦截器接口 每个拦截器都需要实现NestInterceptor接口的**intercept()**方法，该方法接收两个参数。方法原型如下：
function intercept(context: ExecutionContext, next: CallHandler): Observable&lt;any> ExecutionContext 执行上下文，与NestJs学习之旅(7)——路由守卫中的执行上下文相同 CallHandler 路由处理函数 CallHandler 该接口是对路由处理函数的抽象，接口定义如下：
export interface CallHandler&lt;T = any> { handle(): Observable&lt;T>; } handle()函数的返回值也就是对应路由函数的返回值。
以获取用户列表为例：
// user.controller.ts @Controller('user') export class UserController { @Get() list() { return []; } } 当访问 /user/list 时，路由处理函数返回**[]**，如果在应用拦截器的情况下，调用CallHandler接口的handle()方法得到的也是Observable&lt;[]>(RxJs包装对象)。
所以，如果在拦截器中调用了next.handle()方法就会执行对应的路由处理函数，如果不调用的话就不会执行。
一个请求链路日志记录拦截器 随着微服务的兴起，原来的单一项目被拆分成多个比较小的子模块，这些子模块可以独立开发、独立部署、独立运行，大大提高了开发、执行效率，但是带来的问题也比较多，一个经常遇到的问题是接口调用出错不好查找日志。
如果在业务逻辑中硬编码这种链路调用日志是非常不可取的，严重违反了单一职责的原则，这在微服务开发中是相当不好的一种行为，会让微服务变得臃肿，这些逻辑完全可以通过拦截器来实现。
// app.interceptor.ts import { CallHandler, ExecutionContext, Injectable, Logger, NestInterceptor } from '@nestjs/common'; import { Observable } from 'rxjs'; import { tap } from 'rxjs/operators'; import { Request } from 'express'; import { format } from 'util'; @Injectable() export class AppInterceptor implements NestInterceptor { private readonly logger = new Logger(); // 实例化日志记录器 intercept(context: ExecutionContext, next: CallHandler): Observable&lt;any> { const start = Date.</div></article><article><div class=blog-card><h3><a href=/2019/08/28/nestjs-pipe/>NestJs学习之旅(8)——管道</a></h3><p><small>August 28, 2019&nbsp;· 387 words&nbsp;· 2 min</small><p>本文是NestJs学习之旅的第八篇，讲解管道。
管道 熟悉Linux命令的伙伴应该对“管道运算符”不陌生。
ls -la | grep demo &ldquo;|&rdquo; 就是管道运算符，它把左边命令的输出作为输入传递给右边的命令，支持级联，如此一来，便可以通过管道运算符进行复杂命令的交替运算。
NestJs中的管道有着类似的功能，也可以级联处理数据。NestJs管道通过**@Injectable()装饰器装饰，需要实现PipeTransform**接口。
NestJs中管道的主要职责如下：
数据转换 将输入数据转换为所需的输出 数据验证 接收客户端提交的参数，如果通过验证则继续传递，如果验证未通过则提示错误 执行顺序 在前面的文章中我们讨论了中间件、控制器、路由守卫，结合本问讨论的管道，可能有些读者会对这些组件的执行顺序提出疑问：这些东西执行的顺序到底是怎样的？
执行顺序也不用找资料，自己在这些组件执行时加上日志即可，我得出的结论如下：
客户端请求 -> 中间件 -> 路由守卫 -> 管道 -> 控制器方法
开发管道 数据转换类的管道就不详细解释了：
给你一个value和元数据，你的return值就是转换后的值。
NestJs内置了ValidationPipe、ParseIntPipe和ParseUUIDPipe。为了更好地理解它们的工作原理，我们以ValidationPipe（验证器管道）为例来演示管道的使用。
PipeTransform 这是管道必须实现的接口，该接口定义如下：
export interface PipeTransform&lt;T = any, R = any> { transform(value: T, metadata: ArgumentMetadata): R; } value 输入参数，T为输入参数类型 metadata  value的元数据，包括参数来源，参数类型等等 输出参数，R为输出参数类型 ArgumentMetadata 用来描述当前处理value的元数据接口，接口定义如下：
export interface ArgumentMetadata { readonly type: 'body' | 'query' | 'param' | 'custom'; readonly metatype?</div></article><article><div class=blog-card><h3><a href=/2019/08/27/nestjs-guard/>NestJs学习之旅(7)——路由守卫</a></h3><p><small>August 27, 2019&nbsp;· 457 words&nbsp;· 3 min</small><p>本文是NestJs的第七篇，讲解路由守卫。
传统的Web应用中去检测用户登录、权限判断等等都是在控制器层或者中间件层做的，而在目前比较推荐的模块化与组件化架构中，不同职责的功能建议拆分到不同的类文件中去。
通过前几篇的学习可以发现NestJs在这方面做的很好，传统的express/koa应用中，需要开发者去思考项目结构以及代码组织，而NestJs不需要你这样做，降低了开发成本，另外也统一了开发风格。
路由守卫 熟悉Vue,React的伙伴应该比较熟悉这个概念，通俗的说就是在访问指定的路由之前回调一个处理函数，如果该函数返回true或者**调用了next()**就会放行当前访问，否则阻断当前访问。
NestJs中路由守卫也是如此，通过继承CanActive接口即可定义一个路由守卫。
import { CanActivate, ExecutionContext, Injectable } from '@nestjs/common'; import { Observable } from 'rxjs'; @Injectable() class AppGuard implements CanActivate { canActivate(context: ExecutionContext): boolean | Promise&lt;boolean> | Observable&lt;boolean> { return true; } } 路由守卫与中间件 区别 路由守卫本质上也是中间件的一种，koa或者express开发中接口鉴权就是基于中间件开发的，如果当前请求是不被允许的，当前中间件将不会调用后续中间件，达到阻断请求的目的。
但是中间件的职责是不明确的，中间件可以干任何事（数据校验，格式转化，响应体压缩等等），这导致只能通过名称来识别中间件，项目迭代比较久以后，有比较高的维护成本。
联系 由于单一职责的关系，路由守卫只能返回true和false来决定放行/阻断当前请求，不可以修改request/response对象，因为一旦破坏单一职责的原则，排查问题比较麻烦。
如果需要修改request对象，可以结合中间件一起使用。
路由守卫在所有中间件执行完毕之后开始执行。
以下是一个结合路由守卫和中间件的例子。
// auth.middleware.ts // 中间件职责：读取请求头Authorization，如果存在且有效的话，设置user对象到request中 import { Injectable, NestMiddleware } from '@nestjs/common'; import { Request, Response } from 'express'; @Injectable() export class AuthMiddleware implements NestMiddleware&lt;Request|any, Response> { constructor(private readonly userService: UserService) {} async use(req: Request|any, res: Response, next: Function) { const token = req.</div></article><article><div class=blog-card><h3><a href=/2019/08/26/nestjs-exception-filter/>NestJs学习之旅(6)——异常处理</a></h3><p><small>August 26, 2019&nbsp;· 405 words&nbsp;· 2 min</small><p>本文是NestJs的第六篇，讲解异常处理。
传统的异常处理 在前面的内容中我们介绍了NestJs的几大常用组件，但是有一点没有做出说明，当我们的应用需要中断此次请求且输出错误信息时，我们需要怎么做？
这个问题有两种解决办法：
services层直接返回中断请求的响应对象，controller直接输出该对象即可
if(!this.allowLogin()) { return {errcode: 403, errmsg: '不允许登录'}; } services层抛出异常，controller捕获该异常，然后输出响应对象
以上两种方法都有一定的缺点：
controller调用多个services时，需要依据services层的返回值来进行错误判断，要是漏了判断的话会导致原本需要中断的请求处理继续运行，导致不可预料的后果 如果每个controller都需要try/catch掉services层抛出的异常的话，会多了很多“重复”代码 那有没有一个像SpringBoot的ExceptionHandler相似的解决办法呢?
NestJs的异常处理 NestJs提供了统一的异常处理器，来集中处理运行过程中未捕获的异常，可以自定义响应参数，非常灵活。
默认响应 NestJs内置了默认的全局异常过滤器，该过滤器处理HttpException(及其子类)的异常。如果抛出的异常不是上述异常，则会响应以下默认JSON：
{ "statusCode": 500, "message": "Interval server error" } 内置异常过滤器 由于NestJs内置了默认的异常过滤器，如果在应用内抛出HttpException，是可以被NestJs自动捕获的。
比如在services层抛出一个HttpException：
@Injectable() export class UserService { login(username: string, password: string) { if(!this.allowLogin()) { throw new HttpException('您无权登录', HttpStatus.FORBIDDEN); } return {user_id:1, token: 'fake token'} } } controller正常调用该services即可:
@Controller('users') export class UserController { constructor(private readonly userService: UserService) {} @Post('login') login(@Body('username') username: string, @Body('password') password: string) { return this.</div></article><article><div class=blog-card><h3><a href=/2019/08/24/socks5-protocol/>socks5协议详解</a></h3><p><small>August 24, 2019&nbsp;· 355 words&nbsp;· 2 min</small><p>Socks5代理协议 或许你没听说过socks5，但你一定听说过SS，SS内部使用的正是socks5协议。
socks5是一种网络传输协议，主要用于客户端与目标服务器之间通讯的透明传递。
该协议设计之初是为了让有权限的用户可以穿过防火墙的限制，访问外部资源。
1. RFC地址 socks5协议规范rfc1928 socks5账号密码鉴权规范rfc1929 2. 协议过程 客户端连接上代理服务器之后需要发送请求告知服务器目前的socks协议版本以及支持的认证方式 代理服务器收到请求后根据其设定的认证方式返回给客户端 如果代理服务器不需要认证，客户端将直接向代理服务器发起真实请求 代理服务器收到该请求之后连接客户端请求的目标服务器 代理服务器开始转发客户端与目标服务器之间的流量 3. 认证过程 3.1 客户端发出请求 客户端连接服务器之后将直接发出该数据包给代理服务器
VERSION METHODS_COUNT METHODS&mldr; 1字节 1字节 1到255字节，长度由METHODS_COUNT值决定 0x05 0x03 0x00 0x01 0x02 VERSION SOCKS协议版本，目前固定0x05 METHODS_COUNT 客户端支持的认证方法数量 METHODS&mldr; 客户端支持的认证方法，每个方法占用1个字节 METHOD定义
0x00 不需要认证（常用） 0x01 GSSAPI认证 0x02 账号密码认证（常用） 0x03 - 0x7F IANA分配 0x80 - 0xFE 私有方法保留 0xFF 无支持的认证方法 3.2 服务端返回选择的认证方法 接收完客户端支持的认证方法列表后，代理服务器从中选择一个受支持的方法返回给客户端
3.2.1 无需认证 VERSION METHOD 1字节 1字节 0x05 0x00 VERSION SOCKS协议版本，目前固定0x05 METHOD 本次连接所用的认证方法，上例中为无需认证 3.2.2 账号密码认证 VERSION METHOD 1字节 1字节 0x05 0x02 3.</div></article></div><div class=paginator><a class=prev href=/page/8/>&larr;&nbsp;&nbsp;Pre Page</a>
<a class=next href=/page/10/>Next Page&nbsp;&nbsp;&rarr;</a></div></div></div></div><footer class=footer><p>&copy; 2014 - 2024 <a href=https://www.ddhigh.com/>Lei Xia</a>
Powered by
<a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>
<a href=https://github.com/guangzhengli/hugo-theme-ladder rel=noopener target=_blank>Ladder</a>
️</p></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.5376 22.7916C11.0152 22.7207 22.5795 21.1781 22.0978 10.4211 22.0536 9.43274 21.9303 8.53367 21.7387 7.71865M10.5376 22.7916C16.876 22.3728 20.0969 19.8899 21.5383 16.9142M10.5376 22.7916C9.7707 22.9055 8.97982 22.8964 8.19743 22.7725M21.7387 7.71865C21.4988 6.69828 21.1518 5.80967 20.7188 5.04257m1.0199 2.67608C22.6022 10.1105 23.0542 13.7848 21.5383 16.9142M20.7188 5.04257c-3.5504-6.28886-12.88753-4.410077-16.44303.0C2.88063 6.77451-.0433281 11.1668 1.38159 16.6571c.89322 3.4417 3.7911 5.6365 6.81584 6.1154M20.7188 5.04257c1.3509 1.89783 3.3111 6.34223 1.6353 10.37273M21.5383 16.9142C21.8737 16.4251 22.1428 15.9235 22.3541 15.4153M8.19743 22.7725C12.1971 23.4683 20.6281 22.971 22.3541 15.4153M14 10.945C13.3836 10.289 12.003 8.63215 11.2034 7.04814 11.1703 6.98257 11.0247 6.98456 10.9937 7.05061 10.5221 8.05496 9.07362 9.92941 8 10.945m3.0333-3.50056C10.9392 9.86549 11 15 12 17" stroke="currentcolor" stroke-linecap="round"/></svg>
</a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function n(){t.innerHTML="Copied",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)}),e.parentNode.appendChild(t)})</script></main></body><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script><script>const images=Array.from(document.querySelectorAll(".blog-content img"));images.forEach(e=>{mediumZoom(e,{margin:10,scrollOffset:40,container:null,template:null,background:"rgba(0, 0, 0, 0.5)"})})</script><script src=/main.min.6bb26b69159420159c74dc9e097b06a578ed2b68c701466a91a44a9632d851bd0af167a1b30012387b4c512b48ad9ad4d3394e04d77ae38d57e1920fe4ed34fe.js integrity="sha512-a7JraRWUIBWcdNyeCXsGpXjtK2jHAUZqkaRKljLYUb0K8WehswASOHtMUStIrZrU0zlOBNd6441X4ZIP5O00/g==" crossorigin=anonymous defer></script></html>