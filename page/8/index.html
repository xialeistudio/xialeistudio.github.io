<!doctype html><html lang=en><head><meta name=generator content="Hugo 0.123.8"><meta name=viewport content="width=device-width,initial-scale=1"><title>Lei Xia</title>
<meta charset=utf-8><meta name=description content="Ladder@Learning & Writing & Sharing"><meta name=author content="Lei Xia"><link rel=canonical href=https://www.ddhigh.com/><link rel=alternate type=application/rss+xml href=https://www.ddhigh.com//index.xml title="Lei Xia"><meta property="og:title" content="Lei Xia"><meta property="og:description" content="Learning & Writing & Sharing"><meta property="og:type" content="website"><meta property="og:url" content="https://www.ddhigh.com/"><meta name=twitter:card content="summary"><meta name=twitter:title content="Lei Xia"><meta name=twitter:description content="Learning & Writing & Sharing"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"Lei Xia","url":"https://www.ddhigh.com/","description":"Learning \u0026amp; Writing \u0026amp; Sharing","thumbnailUrl":"https://www.ddhigh.com/favicon.ico","sameAs":[]}</script><link rel=icon href=/img/favicon.ico sizes=16x16><link rel=apple-touch-icon href=/img/favicon.ico><link rel=manifest href=/img/favicon.ico><link rel=stylesheet href=https://cdn.staticfile.org/lxgw-wenkai-webfont/1.6.0/style.css><link rel=stylesheet href=/css/main.min.5dd042a107aa191c819948e5648b04844bec5bdd365fdcf2b880177ce3d89b79.css integrity="sha256-XdBCoQeqGRyBmUjlZIsEhEvsW902X9zyuIAXfOPYm3k=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/highlight/github-dark.min.min.66034289ee9a113219a2c4aae0a8bd2095ab255c832a42efcf5863f10814e7a1.css><script src=/js/highlight.min.min.c607d6febd16934a82eb61d3a896ed9d869f54373cc63ce95864ed5488fe3128.js></script><script>hljs.highlightAll()</script><script>(()=>{var t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,e=localStorage.getItem("theme");t&&e===null&&(localStorage.setItem("theme","dark"),document.documentElement.setAttribute("data-dark-mode","")),t&&e==="dark"&&document.documentElement.setAttribute("data-dark-mode",""),e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script></head><body><main class=wrapper><nav class=navigation><section class=container><a class=navigation-brand href=/>HOME
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><span></span><span></span><span></span></label><ul class=navigation-list id=navigation-list><li class="navigation-item navigation-menu"><a class=navigation-link href=/archives>Archive</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/books>Books</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/guestbook>Guestbook</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class="navigation-item navigation-social"><a class=navigation-link href=https://github.com/xialeistudio><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li class="navigation-item navigation-dark"><button id=mode type=button aria-label="toggle user light or dark theme">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span>
<span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></li></ul></section></nav><div id=content><div class=home><div class=info><div class=intro><h1>Lei Xia</h1><small>Sr. Software Engineer | Solution Architect</small><p><p>Writing code, Enjoying life, Building future</p><p><a href=/atom.xml target=_blank rel=noopener>RSS</a> ·
<a href=/sponsors target=_blank rel=noopener>Sponsor</a></p></p></div></div></div><div class=blog-wrapper><div><div class=blog-list><article><div class=blog-card><h3><a href=/2019/10/30/es6-map/>ES6的Map类型</a></h3><p><small>October 30, 2019&nbsp;· 550 words&nbsp;· 3 min</small><p>本文内容
Map的基本使用 Map支持的数据类型 Map的迭代 Map与其他对象的转化 在Map出现之前，要实现类似需求，只能使用Object，但是Object还是存在一些问题的。
如果使用Object作为key存储在{}中，key最终是当做[object Object]来使用的 Object的keys是无序的 无法安全遍历Object 无法直接获取Object大小 Map 对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。
基本操作 new Map([iterator]) iterator 可以是一个数组或者其他iterator对象，其元素为键值对(如['key', 'value'])。 null或undefined不会生效，返回一个空的Map 非iterator会抛出错误 TypeError: object is not iterable const map = new Map(); // Create map.set('name','xialei'); map.set('site', 'https://www.ddhigh.com'); // Update map.set('name', 'xialeistudio'); // Read map.get('name'); // Delete map.delete('name'); // 清空 map.clear(); // map大小 console.log(map.size); 数据类型测试 JS中基本数据类型有string、number、boolean、null、undefined、symbol，复杂数据类型有object(包括object,array,function等)，还有个特殊的NaN(typeof结果是number)，分别对这些类型进行测试
const map = new Map(); const sKey = 'key', nKey = 1, bKey = true, nullKey = null, uKey = undefined, symbolKey = Symbol("key"), oKey = {}, ooKey = oKey, aKey = [], fKey = function () { }, nanKey = NaN; map.</div></article><article><div class=blog-card><h3><a href=/2019/10/30/twblog/>我是如何发现我的文章被侵权以及如何得到侵权网站的联系方式的?</a></h3><p><small>October 30, 2019&nbsp;· 261 words&nbsp;· 2 min</small><p>本文内容
如何发现自己的文章被侵权 如何结合whois信息查询侵权网站的联系方式 声明：本文只做技术研究，请勿用于非法目的，如果恶意使用造成任何法律责任本人概不负责！
发现侵权 我的文章除了发布在博客之外，还会同步到思否平台。自己没事的时候会去看看百度统计，比较关注来源网站(也就是referer)，一般来说通过搜索引擎过来的流量我不太关注，私人网站过来的就比较关注了，昨天查看来源的时候看到了一个新网站。
可以看到这个 www.twblogs.net是一个普通网站，点进去发现这样一篇文章。
可以看到这篇文章的作者是xialeistudio(也就是我常用的网络用户名)，可我压根就没听说过这个网站，我意识到可能被爬虫爬取了。
点击作者进入到作者的文章页，发现我昨天下午刚发布没多久的文章就被爬了。
然后我去查看nginx的访问日志，没有发现异常访问，有个IP虽然是美国的，但是是Google的爬虫。这意味着文章不是直接爬取我的博客来的。
nginx的访问日志过滤使用shell命令即可做到，不过这不是本文的重点，此处略过
那就只剩下思否和掘金，通过文章中的公众号图片二维码，我发现了爬取的文章来源。
可以看到是通过思否爬取到的。
侵权结论 伪造用户名爬取了思否大量的文章，截止发文时大概爬了三四十篇文章 思否应该并不知道这件事，应该早期的文章都爬过来了（包括我在思否已经删除的文章） 获取侵权网站联系方式 目前手头只有一个域名https://www.twblogs.net，先去站长工具的whois查询工具http://whois.chinaz.com/查询一下。
whois：用来查询域名注册信息的一种技术
通过查询并没有得到什么有效的信息。看来是whois做了保护处理。
不过没关系，目前得到了twblogs.net的域名提供商是Goddy，我们可以到域名提供商的网站看一下Whois信息
浏览器打开 whois.godaddy.com 输入 www.twblogs.net 就可以了，查询到的Whois信息如下：
WHOIS 搜索结果 Domain Name: twblogs.net Registry Domain ID: 2330628228_DOMAIN_NET-VRSN Registrar WHOIS Server: whois.godaddy.com Registrar URL: http://www.godaddy.com Updated Date: 2019-10-09T11:09:43Z Creation Date: 2018-11-08T16:30:46Z Registrar Registration Expiration Date: 2021-11-08T16:30:46Z Registrar: GoDaddy.com, LLC Registrar IANA ID: 146 Registrar Abuse Contact Email: abuse@godaddy.com Registrar Abuse Contact Phone: +1.</div></article><article><div class=blog-card><h3><a href=/2019/10/29/redis-high-concurrent/>Redis优化高并发下的秒杀性能</a></h3><p><small>October 29, 2019&nbsp;· 470 words&nbsp;· 3 min</small><p>本文内容
使用Redis优化高并发场景下的接口性能 数据库乐观锁 随着双11的临近，各种促销活动开始变得热门起来，比较主流的有秒杀、抢优惠券、拼团等等。
涉及到高并发争抢同一个资源的主要场景有秒杀和抢优惠券。
前提 活动规则
奖品数量有限，比如100个 不限制参与用户数 每个用户只能参与1次秒杀 活动要求
不能多发，也不能少发，100个奖品要全部发出去 1个用户最多抢1个奖品 遵循先到先得原则，先来的用户有奖品 数据库实现 悲观锁性能太差，本文不予讨论，讨论一下使用乐观锁解决高并发问题的优缺点。
数据库结构 ID Code UserId CreatedAt RewardAt 奖品ID 奖品码 用户ID 创建时间 中奖时间 未中奖时UserId为0，RewardAt为NULL 中奖时UserId为中奖用户ID，RewardAt为中奖时间 乐观锁实现 乐观锁实际上并不存在真正的锁，乐观锁是利用数据的某个字段来做的，比如本文的例子就是以UserId来实现的。
实现流程如下：
查询UserId为0的奖品，如果未找到则提示无奖品
SELECT * FROM envelope WHERE user_id=0 LIMIT 1 更新奖品的用户ID和中奖时间(假设奖品ID为1，中奖用户ID为100，当前时间为2019-10-29 12:00:00)，这里的user_id=0就是我们的乐观锁了。
UPDATE envelope SET user_id=100, reward_at='2019-10-29 12:00:00' WHERE user_id=0 AND id=1 检测UPDATE语句的执行返回值，如果返回1证明中奖成功，否则证明该奖品被其他人抢了
为什么要添加乐观锁 正常情况下获取奖品、然后把奖品更新给指定用户是没问题的。如果不添加user_id=0时，高并发场景下会出现下面的问题：
两个用户同时查询到了1个未中奖的奖品(发生并发问题) 将奖品的中奖用户更新为用户1，更新条件只有ID=奖品ID 上述SQL执行是成功的，影响行数也是1，此时接口会返回用户1中奖 接下来将中奖用户更新为用户2，更新条件也只有ID=奖品ID 由于是同一个奖品，已经发给用户1的奖品会重新发放给用户2，此时影响行数为1，接口返回用户2也中奖 所以该奖品的最终结果是发放给用户2 用户1就会过来投诉活动方了，因为抽奖接口返回用户1中奖，但他的奖品被抢了，此时活动方只能赔钱了 添加乐观锁之后的抽奖流程 更新用户1时的条件为id=红包ID AND user_id=0 ,由于此时红包未分配给任何人，用户1更新成功，接口返回用户1中奖 当更新用户2时更新条件为id=红包ID AND user_id=0，由于此时该红包已经分配给用户1了，所以该条件不会更新任何记录，接口返回用户2中奖 乐观锁优缺点 优点</div></article><article><div class=blog-card><h3><a href=/2019/10/28/symbol/>深入浅出ES6的Symbol类型</a></h3><p><small>October 28, 2019&nbsp;· 252 words&nbsp;· 2 min</small><p>本文内容 JS基本数据类型种类 Symbol的主要用法, 全局Symbol的使用与检测 Symbol与其他基本类型转换时的规则 ES6引入了一种新的原始数据类型，表示独一无二的值，最大的用处是作为对象属性的唯一标识符。
至此，Javascript拥有6种基本数据类型和一种复杂数据类型。
数据类型 基本类型
string number boolean undefined null symbol 复杂类型
object 用法 基本语法 Symbol([description]) description 可选的描述，一般用在调试的时候作为区分，但是 不能用来访问Symbol。 该方法返回一个symbol值 let s = Symbol('test'); let s2 = Symbol('test'); let s3 = new Symbol('test'); // TypeError console.log(s === s2); // false console.log(typeof s); // symbol console.log(s.description); // test 每次调用Symbol()返回的值都是独一无二的，不管描述是否一致。 Symbol不支持new调用 通过description属性可以获取到传入Symbol的描述性字符串 全局单例的Symbol 使用Symbol.for()可以创建全局单例的symbol值，语法如下：
Symbol.for([name]) name 可选的描述，建议传入，否则name会作为undefined传入 类似于单例模式，执行环境(一般是浏览器)内部维护了一个全局Symbol注册表，记录name和Symbol(name)关系 尝试通过name在该注册表查找对应symbol值，如果找到，则返回这个symbol值 如果没找到，则使用Symbol(name)创建一个symbol值，并记录该symbol值与name的关联关系，之后返回该symbol const name = Symbol('name'); const name2 = Symbol.for('name'); const name3 = Symbol.</div></article><article><div class=blog-card><h3><a href=/2019/10/22/let-and-const/>不只是块级作用域，你不知道的let和const</a></h3><p><small>October 22, 2019&nbsp;· 171 words&nbsp;· One minute</small><p>ES6新增了两个重要的关键字let和const，相信大家都不陌生，但是包括我在内，在系统学习ES6之前也只使用到了【不存在变量提升】这个特性。
let声明一个块级作用域的本地变量 const语句声明一个块级作用域的本地常量，不可以重新赋值 支持块级作用域 var定义的变量会提升到整个函数作用域内，let/const则支持块级作用域。
块级作用域: 由{}包裹的作用域（函数那种{}不算）
来看一个var的例子:
{ var a = 1; } console.log(a); 此时输出1，因为var没有块级作用域。
来看一个let的例子(const效果一样):
{ let a = 1; } console.log(a); 此时会报错ReferenceError，因为let/const支持块级作用域，所以let定义的a只在{}可以访问
不存在变量提升 与var不同的是，let/const声明的变量不存在变量提升，也就是说{}对于let/const是有效的。
来看一个var的例子:
console.log(a); var a = 1; 此时会输出undefined，因为var声明的变量会提升到作用域顶部（只提升声明，不提升赋值）
来看一个let的例子(const效果也一样):
console.log(a); let a = 1; 此时会报错ReferenceError，因为let不存在变量提升
同一作用域内不可以重复声明 同一作用域内let/const不可以重复声明,var可以。
来看一个var的例子:
var a = 1; var a = 2; console.log(a); 此时会输出2，var是支持重复声明的，后面声明的值会覆盖前面声明的值。
来看一个let的例子(const效果也一样):
let a = 1; let a = 2; console.log(a); 此时会报错SyntaxError，因为同一作用域内let/const不可以重复声明。
再来看一个不同作用域的例子：
let a = 1; { let a = 2; } console.</div></article><article><div class=blog-card><h3><a href=/2019/10/15/valueof-and-tostring/>聊一聊valueOf和toString</a></h3><p><small>October 15, 2019&nbsp;· 407 words&nbsp;· 2 min</small><p>valueOf和toString是Object.prototype的方法。一般很少直接调用，但是在使用对象参与运算的时候就会调用这两个方法了。我想大部分人都存在以下疑问：
valueOf和toString哪个优先级较高? 是不是所有场景都会调用valueOf和toString 概念解释 valueOf: 返回对象的原始值表示 toString: 返回对象的字符串表示 在介绍下面的内容之前先了解一下转换规则，下面的内容解释都是基于这个规则表来的：
valueOf转换规则 valueOf是Object.prototype的方法，由Object来的对象都会有该方法，但是很多内置对象会重写这个方法，以适合实际需要。
说到原始值就必须说到原始类型，JS规范中 原始类型 如下：
Boolean Null Undefined Number String 非原始值(也就是对象)重写规则如下：
对象 valueOf返回值 Array 数组本身 Boolean 布尔值 Date 返回毫秒形式的时间戳 Function 函数本身 Number 数字值 Object 对象本身 String 字符串值 以下规则是经过验证的，如果对验证过程不关心，可以只看转换规则。
建议看一下验证过程，这样可以加深理解
对象转换为布尔值 直接转换为true（包装类型也一样），不调用valueOf和toString 对象转换为数字 在预期会将对象用作数字使用时，比如参与算术运算等等操作，对象转换为数字会依次调用valueOf和toString方法，具体规则如下：
如果对象具有valueOf方法且返回原始值(string、number、boolean、undefined、null)，则将该原始值转换为数字(转换失败会返回NaN)，并返回这个数字 如果对象具有toString方法且返回原始值(string、number、boolean、undefined、null)，则将该原始值转换为数字(转换失败会返回NaN)，并返回这个数字 转换失败，抛出TypeError 对象转换为字符串 如果对象具有toString方法且返回原始值(string、number、boolean、undefined、null)，则将该原始值转换为字符串，并返回该字符串 如果对象具有valueOf方法且返回原始值(string、number、boolean、undefined、null)，则将该原始值转换为字符串，并返回该字符串 转换失败，抛出TypeError toString转换规则 对象 toString返回值 Array 以逗号分割的字符串，如[1,2]的toString返回值为"1,2" Boolean &ldquo;True&rdquo; Date 可读的时间字符串，如"Tue Oct 15 2019 12:20:56 GMT+0800 (中国标准时间)" Function 声明函数的JS源代码字符串 Number &ldquo;数字值&rdquo; Object &ldquo;[object Object]&rdquo; String &ldquo;字符串&rdquo; 验证对象到原始值的转换 光看valueOf和toString没啥东西可说，日常开发中也很少直接调用，但是当我们将对象当做原始值来使用时会发生转换，而且转换过程还略微有点迷糊。</div></article><article><div class=blog-card><h3><a href=/2019/10/14/js-closure/>搞懂JS闭包</a></h3><p><small>October 14, 2019&nbsp;· 198 words&nbsp;· One minute</small><p>闭包(Closure)是JS比较难懂的一个东西，或者说别人说的难以理解， 本文将以简洁的语言+面试题来深入浅出地介绍一下。
作用域和作用域链 在将闭包之前，需要先讲一下作用域。
JS中有全局作用域和局部作用域两种。
全局作用域任何地方都能访问，而局部作用于只有内部能访问。
function a() { var num = 1; } console.log(num); 在上面的例子中会报错，num不存在。
总结：函数外部无法访问函数内部的值
当代码在一个作用域中执行时，JS引擎会默认创建一个作用域链(从当前作用域一直链接到全局作用域)。
在访问变量或者函数时，如果当前作用域查找不到，则向上级作用域查找，找到就返回，如果查找到全局作用域还没找到的话就报错。
function a() { var num = 1; function b() { console.log(num); } } 在上面的例子中，num是在a函数作用域下的局部变量，我们在b函数访问num时会有以下过程：
在b的作用域查找num，发现找不到 往上一级作用域查找，发现num在a作用域，查找成功 总结：函数可以访问同级或上级作用域的值
闭包 当我们需要在函数外部访问函数内部的值时，闭包就产生了。
function a() { var num = 1; function b () { console.log(num); } return b; } var bb = a(); bb(); // 1 在函数a的内部声明一个函数b，然后把return b，这个时候的b()函数就可以在外部访问，最终能够访问到num。
简单来说：
闭包就是函数内部的函数，上面的那个b就是闭包，可以在外面访问到内部的num
面试题 // 每隔1秒输出0-10的数字 for(var i = 0;i&lt;10;i++) { setTimeout(function() { console.</div></article><article><div class=blog-card><h3><a href=/2019/10/11/https-protocol/>HTTPS协议是如何保证安全的?</a></h3><p><small>October 11, 2019&nbsp;· 89 words&nbsp;· One minute</small><p>相信大家对于HTTPS协议都不陌生，但是应该存在以下疑问：
HTTPS协议到底是如何运作的?
HTTPS是如何解决HTTP协议的不安全特性的?
HTTPS网站抓包为什么要信任证书?
HTTP协议 HTTP协议是一个应用层协议，通常运行在TCP协议之上。它是一个明文协议，客户端发起请求，服务端给出响应的响应。
由于网络并不是可信任的，HTTP协议的明文特性会存在以下风险：
通信数据有被窃听和被篡改的风险 目标网站有被冒充的风险 一般的网站可能没什么影响，但是如果是银行这种网站呢?
好在国内的银行在HTTP协议时代针对IE开发了ActiveX插件来保证安全性，这一点算是值得点赞了。
解决方案 既然HTTP协议是明文协议，如果对数据进行加密之后是否就能保证安全性了呢?
在回答这个问题之前，我们先看看比较常见的两种加密算法。
加密算法 常见的有对称加密算法和非对称加密算法。
对称加密
加密和解密使用同一个密钥。加解密效率比非对称加密高。但是密钥一旦泄露，通信就不安全了
非对称加密
存在密钥对，公钥加密私钥解密或者私钥加密公钥解密，无法通过公钥反推私钥，也无法通过私钥反推公钥。
一般情况下，使用非对称加密来传输通信所用的密钥，通信过程中采用对称加密，可以解决对称加密的安全问题以及非对称加密的性能问题。
HTTP加密通信过程 浏览器生成随机串A作为通信密钥 浏览器使用公钥将随机串A加密后得到密文B发送给服务器，这一步是安全的，因为黑客没有服务端私钥无法解密 服务端利用私钥解密出随机串A得到通信密钥 服务端和客户端用随机串A以及对称加密算法进行通信 这么一看似乎没有问题，毕竟黑客无法破解非对称加密的的内容，但是浏览器是如何得到公钥的?
有以下两种办法：
浏览器内置(不太可能，网站域名这么多，浏览器内置这么多公钥不现实) 服务器给浏览器下发(由于是明文下发，存在被窃听和篡改风险，也就是著名的中间人攻击) 中间人攻击 浏览器请求服务器获取公钥 中间人劫持了服务器的公钥，保存在自己手里 中间人生成一对密钥对，把伪造的公钥下发给浏览器 浏览器使用伪造的公钥和中间人通信 中间人和服务器进行通信 由于浏览器使用了伪造的公钥进行通信，所以通信过程是不可靠的
需要解决的问题 只要保证浏览器得到的公钥是目标网站的公钥即可保证通信安全，那么问题来了，如何在不可靠的网络上安全的传输公钥呢?
这就是HTTPS协议需要解决的问题
HTTPS协议 HTTPS协议涉及到的知识很多，本文只关注密钥安全交换部分，这也是HTTPS协议的精华。
HTTPS协议引入了CA和数字证书的概念。
数字证书 包含签发机构、有效期、申请人公钥、证书所有者、证书签名算法、证书指纹以及指纹算法等信息。
CA 数字证书签发机构，权威CA是受操作系统信任的，安装操作系统就会内置。
数字签名 用Hash算法对数据进行计算得到Hash值，利用私钥对该Hash加密得到签名。
只有匹配的公钥才能解密出签名，来保证签名是本人私钥签发的
证书签发过程 网站生成密钥对，将私钥自己保存，公钥和网站域名等信息提交给CA CA把证书签发机构(也就是自己)、证书有效期、网站的公钥、网站域名等信息以明文形式写入到一个文本文件 CA选择一个指纹算法(一般为hash算法)计算文本文件的内容得到指纹，用CA的私钥对指纹和指纹算法进行加密得到数字签名，签名算法包含在证书的明文部分 CA把明文证书、指纹、指纹算法、数字签名等信息打包在一起得到证书下发给服务器 此时服务器拥有了权威CA颁发的数字证书以及自己的私钥 证书验证过程 浏览器是如何验证网站的有效性的呢?
浏览器以HTTPS协议请求服务器的443端口 服务器下发自己的数字证书给浏览器(明文) 浏览器先校验CA、有效期、域名是否有效，如果无效，则终止连接(服务器此时不可信任) 如果有效，则从操作系统取出证书颁发机构的公钥，根据签名算法对数字签名解密得到证书指纹和指纹算法 浏览器用解密得到的指纹算法计算证书的指纹，与解密得到的指纹进行比对，如果一致，证书有效，公钥也安全拿到了 浏览器此时已经和真实的服务器进行通信了，中间人无法得知通信内容，因为中间人没有网站私钥 问题是如何解决的 黑客冒充CA给了一个假证书给浏览器
浏览器通过CA名称从操作系统取出CA公钥时对数字签名进行解密，发现解密失败，证明这个CA签名用的私钥和操作系统内置的不是一对，就发现了伪造
黑客篡改了证书中的网站公钥
证书中的网站公钥可以被篡改，但是数字签名是CA私钥计算出来的，黑客无法计算数字签名，浏览器用内置的CA公钥对数字签名解密时就会发现指纹不匹配了，这也发现了伪造
黑客也能正常获取网站公钥</div></article><article><div class=blog-card><h3><a href=/2019/09/27/javascript-this/>Javavscript基础——this指向</a></h3><p><small>September 27, 2019&nbsp;· 374 words&nbsp;· 2 min</small><p>本文研究一下Javascript的this指向。
Javascript的this指向问题，有些人可能觉得很简单，有些人却觉得扑朔迷离，看完本文之后相应会对this的掌握有一个直观的判断，而不是"开局全靠猜"。
敲黑板 function函数this指向由调用方式确定，跟定义环境无关。
箭头函数this指向由定义环境决定，与调用方式无关，也不可以bind(this)。
严格模式 非严格模式下，全局作用域下的this指向window
严格模式下，全局作用域下的this指向undefined
以下讨论均为非严格模式，这个不影响今天的讨论。
实践 说结论往往是让人难以理解的，下面通过不同的调用场景对this做一个说明。
1. 直接调用 function test() { console.log(this); } test(); // 输出undefined 直接调用是最简单的， 大部分人在这里都能回答的很好。
总结 直接调用时this指向全局作用域。
非严格模式this指向window 严格模式this指向undefined 2. 对象调用 'use strict' var n = 1; var a = { n: 2, b: function() { console.log(this.n); } }; a.b(); // 输出2 var b = a.b; b(); // 输出1 面试题：请问上述例子输出什么? 非严格模式下，输出2和1，严格模式下输出2和一个报错(this指向undefined，访问undefined的n属性肯定报错)
那如果你这么回答，满分!
分析 知其然还要知其所以然，我们分析一下：
为什么输出2?
因为a.b()是对象调用方式，所以b()中的this指向a
为什么输出1?
这个非常有意思，而且也很有迷惑性，面试的时候经常问到，也经常有人被问倒。
var b = a.b 把a.</div></article><article><div class=blog-card><h3><a href=/2019/09/23/javascript-prototype/>Javavscript基础——原型和原型链</a></h3><p><small>September 23, 2019&nbsp;· 289 words&nbsp;· 2 min</small><p>本文研究一下Javascript的核心基础——原型链和继承。
对于使用过基于类的语言(如Java或C#)的人来说，Javascript的继承有点难以搞懂，因为它本身没有class这种东西。(ES6中引入了class关键字，看上去也像传统的OOP语言，但是那只是语法糖，底层还是基于原型)。
原型链 MDN上对于原型链的解释：
当谈到继承时，JavaScript 只有一种结构：对象。每个实例对象（ object ）都有一个私有属性（称之为 __proto__ ）指向它的构造函数的原型对象（prototype ）。该原型对象也有一个自己的原型对象( __proto__ ) ，层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节。
几乎所有 JavaScript 中的对象都是位于原型链顶端的 Object 的实例。
这段话可能难以理解，我们来举个例子：
const list = []; // 定义数组 list.__proto__ === Array.prototype; // true list.__proto__.__proto__ === Object.prototype; // true list.__proto__.__proto__.__proto__===null; // true // 继承关系为 // list -> Array.prototype -> Object.prototype -> null 结合MDN的解释，我们来解释一下上述例子：
list是Array的实例对象，使用了字面量的方式创建了对象实例。
每个实例对象（ object ）都有一个私有属性（称之为 __proto__ ）指向它的构造函数的原型对象（prototype ）。
// list的构造函数是Array，所以list.__proto__指向构造函数Array的原型对象。 list.__proto__ === Array.prototype; // true 该原型对象也有一个自己的原型对象( __proto__ )
// Array.</div></article></div><div class=paginator><a class=prev href=/page/7/>&larr;&nbsp;&nbsp;Pre Page</a>
<a class=next href=/page/9/>Next Page&nbsp;&nbsp;&rarr;</a></div></div></div></div><footer class=footer><p>&copy; 2014 - 2024 <a href=https://www.ddhigh.com/>Lei Xia</a>
Powered by
<a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>
<a href=https://github.com/guangzhengli/hugo-theme-ladder rel=noopener target=_blank>Ladder</a>
️</p></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.5376 22.7916C11.0152 22.7207 22.5795 21.1781 22.0978 10.4211 22.0536 9.43274 21.9303 8.53367 21.7387 7.71865M10.5376 22.7916C16.876 22.3728 20.0969 19.8899 21.5383 16.9142M10.5376 22.7916C9.7707 22.9055 8.97982 22.8964 8.19743 22.7725M21.7387 7.71865C21.4988 6.69828 21.1518 5.80967 20.7188 5.04257m1.0199 2.67608C22.6022 10.1105 23.0542 13.7848 21.5383 16.9142M20.7188 5.04257c-3.5504-6.28886-12.88753-4.410077-16.44303.0C2.88063 6.77451-.0433281 11.1668 1.38159 16.6571c.89322 3.4417 3.7911 5.6365 6.81584 6.1154M20.7188 5.04257c1.3509 1.89783 3.3111 6.34223 1.6353 10.37273M21.5383 16.9142C21.8737 16.4251 22.1428 15.9235 22.3541 15.4153M8.19743 22.7725C12.1971 23.4683 20.6281 22.971 22.3541 15.4153M14 10.945C13.3836 10.289 12.003 8.63215 11.2034 7.04814 11.1703 6.98257 11.0247 6.98456 10.9937 7.05061 10.5221 8.05496 9.07362 9.92941 8 10.945m3.0333-3.50056C10.9392 9.86549 11 15 12 17" stroke="currentcolor" stroke-linecap="round"/></svg>
</a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function n(){t.innerHTML="Copied",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)}),e.parentNode.appendChild(t)})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-EC3XLVSGKV"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-EC3XLVSGKV")</script></main></body><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script><script>const images=Array.from(document.querySelectorAll(".blog-content img"));images.forEach(e=>{mediumZoom(e,{margin:10,scrollOffset:40,container:null,template:null,background:"rgba(0, 0, 0, 0.5)"})})</script><script src=/main.min.6bb26b69159420159c74dc9e097b06a578ed2b68c701466a91a44a9632d851bd0af167a1b30012387b4c512b48ad9ad4d3394e04d77ae38d57e1920fe4ed34fe.js integrity="sha512-a7JraRWUIBWcdNyeCXsGpXjtK2jHAUZqkaRKljLYUb0K8WehswASOHtMUStIrZrU0zlOBNd6441X4ZIP5O00/g==" crossorigin=anonymous defer></script></html>