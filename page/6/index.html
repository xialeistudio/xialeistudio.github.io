<!doctype html><html lang=zh><head><meta name=generator content="Hugo 0.124.0"><meta name=viewport content="width=device-width,initial-scale=1"><title>Lei Xia</title>
<meta charset=utf-8><meta name=description content="Ladder@Learning & Writing & Sharing"><meta name=author content="Lei Xia"><link rel=canonical href=https://www.ddhigh.com/><link rel=alternate type=application/rss+xml href=https://www.ddhigh.com//index.xml title="Lei Xia"><meta property="og:title" content="Lei Xia"><meta property="og:description" content="Learning & Writing & Sharing"><meta property="og:type" content="website"><meta property="og:url" content="https://www.ddhigh.com/"><meta name=twitter:card content="summary"><meta name=twitter:title content="Lei Xia"><meta name=twitter:description content="Learning & Writing & Sharing"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"Lei Xia","url":"https://www.ddhigh.com/","description":"Learning \u0026amp; Writing \u0026amp; Sharing","thumbnailUrl":"https://www.ddhigh.com/favicon.ico","sameAs":[]}</script><link rel=icon href=/img/favicon.ico sizes=16x16><link rel=apple-touch-icon href=/img/favicon.ico><link rel=manifest href=/img/favicon.ico><link rel=stylesheet href=https://cdn.staticfile.org/lxgw-wenkai-webfont/1.6.0/style.css><link rel=stylesheet href=/css/main.min.bdcd9f7232970786bae2a6f540d0af8c6bb155414954e87f05e933eccd48f434.css integrity="sha256-vc2fcjKXB4a64qb1QNCvjGuxVUFJVOh/Bekz7M1I9DQ=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/highlight/github-dark.min.min.66034289ee9a113219a2c4aae0a8bd2095ab255c832a42efcf5863f10814e7a1.css><script src=/js/highlight.min.min.c607d6febd16934a82eb61d3a896ed9d869f54373cc63ce95864ed5488fe3128.js></script><script>hljs.highlightAll()</script><script>$darkModeInit.Content|safeJS</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-EC3XLVSGKV"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-EC3XLVSGKV")</script></head><body><main class=wrapper><nav class=navigation><section class=container><a class=navigation-brand href=/>HOME
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><span></span><span></span><span></span></label><ul class=navigation-list id=navigation-list><li class="navigation-item navigation-menu"><a class=navigation-link href=/archives>归档</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/books>出版物</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/guestbook>留言板</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class="navigation-item navigation-social"><a class=navigation-link href=https://github.com/xialeistudio><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li class="navigation-item navigation-dark"><button id=mode type=button aria-label="toggle user light or dark theme">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span>
<span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></li><li class="navigation-item navigation-language"><a href=https://www.ddhigh.com/en/>EN</a></li></ul></section></nav><div id=content><div class=home><div class=info><div class=intro><h1>Lei Xia</h1><small>Sr. Software Engineer | Solution Architect</small><p><p>抒写代码，尽享生活，筑就未来。</p><p><a href=/atom.xml target=_blank rel=noopener>订阅</a> ·
<a href=/sponsors target=_blank rel=noopener>赞赏</a></p></p></div></div></div><div class=blog-wrapper><div><div class=blog-list><article><div class=blog-card><h3><a href=/2020/01/17/php-binary-io/>kafka二进制协议简要分析</a></h3><p><small>2020年1月17日&nbsp;· 671 字&nbsp;· 4 分钟</small><p>最近分享了《应用层私有协议的设计和实战》，对应用层私有协议设计做了一些介绍，同时也对协议设计中常用的数据类型做了比较形象的讲解，今天我们来研究一下kafka的二进制协议。
数据类型 kafka二进制协议定义了许多的数据类型，包含常用的数字、字符串，也包含了数组等类型。
本文主要讨论不可变长数据类型，可变长度（如Google Protocol Buffers）不在讨论范围内。
数据类型 字节长度 说明 BOOLEAN 1 布尔值 INT8 1 单字节整型，-2^7 ~ 2^7-1 INT16 2 双字节整型，大端序，范围 -2^15 ~ 2^15 - 1 INT32 4 四字节整型、大端序，范围 -2^31 ~ 2^31 - 1 INT64 8 八字节整型、大端序，范围 -2^63 ~ 2^63 -1 UINT32 4 十字街 UUID 16 16字节，Java UUID类型 STRING 2+N 头部由2字节标识字符串长度N，后续N字节为字符串内容 NULLABLE_STRING 2+N 头部由2字节标识字符串长度N，后续N字节为字符串内容，N为-1时无后续内容 BYTES 4+N 头部4字节标识字节数组长度，后续N字节为字节数组内容 NULLABLE_BYTES 4+N 头部4字节标识字节数组长度，后续N字节为字节数组内容，N为-1时无后续内容 ARRAY 4+N*M 头部4字节标识数组长度N，M为单个数组元素的长度，N为-1时为空数组 错误码 -1 未知错误 0 未出错 大于0， 具体错误 kafka内置的操作类型有点多，有兴趣的可以参阅kafka错误码</div></article><article><div class=blog-card><h3><a href=/2019/12/30/javascript-event/>Javascript事件系统</a></h3><p><small>2019年12月30日&nbsp;· 450 字&nbsp;· 3 分钟</small><p>本文内容
事件基础 事件监听方式 事件默认行为 事件冒泡与事件捕获 事件绑定与事件委托 事件基础 注意：本文不会深入探究Javascript的事件循环。
提到事件，相信每位Javascript开发者都不会陌生，由于Javascript是先有实现，后有规范，因此，对于大部分人来说，事件模块可以说是比较模糊的，本文将从不同角度帮助你理清楚事件模块。
事件的本质可以说是一个回调函数，当事件触发时会调用你的监听函数。
事件是一定会触发的，如果没有对应的监听函数，就不会执行回调。
比如下面就是用户点击指定元素打印日志的例子：
document.querySelector('#button').onclick = function() { console.log('clicked'); }; 事件基础相信大家都没什么问题，重点在后面的内容。
事件监听方式 由于历史原因，Javascript目前存在三种事件监听方式：
HTML代码中监听 DOM0级监听 DOM2级监听 Q: 为啥从DOM0级开始？
1998年，W3C综合各浏览器厂商的现有API，指定了DOM1标准。在DOM1标准出现之前浏览器已有的事件监听方式叫做DOM0级。
Q：DOM1级监听到哪里去了？
由于DOM1标准只是对DOM0标准的整理+规范化，并没有增加新的内容，因此DOM0级可以看做DOM1级。
HTML代码监听 &lt;button onclick="alert('Hello World!')">点我&lt;/button> 直接将事件处理函数或事件处理代码写到HTML元素对应的属性上的方式就是HTML代码监听方式。
该方式有一个明显的缺点，如果事件逻辑比较复杂时，将大段代码直接写在HTML元素上不利于维护。因此一般会提取到一个专一的函数进行处理。
&lt;button onclick="callback()">点我&lt;/button> 该方式也有一个问题，那就是如果callback()函数还未加载好时点击按钮将报错。而且直接将事件耦合到HTML元素上也不符合单一职责，HTML元素应该只负责展示，不负责事件。
不建议在开发中使用该方式处理事件。
DOM0级事件监听 在DOM1级规范出来之前，各浏览器厂商已经提供了一套事件API，也就是DOM0级API，它的写法如下：
&lt;button id="click">点我&lt;/button> &lt;script> document.querySelector('#click').onclick = function() { console.log('clicked'); }; &lt;/script> 这个相信大家在刚开始入行时写的比较多，比如我们的ajax相关API就是DOM0级的。
var xhr = new XMLHttpRequest(); xhr.onload = function() {}; xhr.onerror = function() {}; DOM0级事件基本上都是以"on"开头的
DOM0级事件也存在一个问题，那就是不支持添加多个事件处理函数，因此只有在不支持DOM2级事件的情况下才会使用DOM0级来绑定事件。
DOM2级事件监听 DOM2级事件是最新的事件处理程序规范（有许多年未更新了）。DOM2级事件通过addEventListener方式给元素添加事件处理程序。
&lt;button id="click">点我&lt;/button> &lt;script> document.</div></article><article><div class=blog-card><h3><a href=/2019/12/19/webpack-get-started/>Webpack4不求人系列(1)</a></h3><p><small>2019年12月19日&nbsp;· 817 字&nbsp;· 4 分钟</small><p>Webpack是一个现在Javascript应用程序的模块化打包器，在Webpack中JS/CSS/图片等资源都被视为JS模块，简化了编程。当Webpack构建时，会递归形成一个模块依赖关系图，然后将所有的模块打包为一个或多个bundle。
本文内容
简介 常用loader && plugin 传统网站的webpack配置 简介 要系统地学习Webpack，需要先了解Webpack的四个核心概念:
入口(entry) 输出(output) loader plugin webpack使用Node.js运行，因此所有的Node.js模块都可以使用，比如文件系统、路径等模块。
对Node.js基础不太了解的读者，可以参考我的Node.js系列
配置文件webpack.config.js的一般格式为:
const path = require('path'); // 导入Node.js的path模块 module.exports = { mode: 'development', // 工作模式 entry: './src/index', // 入口点 output: { // 输出配置 path: path.resolve(__dirname, 'dist'), // 输出文件的目录 filename: 'scripts/[name].[hash:8].js', // 输出JS模块的配置 chunkFilename:'scripts/[name].[chunkhash:8].js', // 公共JS配置 publicPath:'/' // 资源路径前缀，一般会使用CDN地址，这样图片和CSS就会使用CDN的绝对URL }, module:{ rules: [ { test:/\.(png|gif|jpg)$/, // 图片文件 use:[ { loader:'file-loader', // 使用file-loader加载 options:{ // file-loader使用的加载选项 name:'images/[name].[hash:8].[ext]' // 图片文件打包后的输出路径配置 } } ] } ] }, plugins:[ // 插件配置 new CleanWebpackPlugin() ] }; Webpack自己只管JS模块的输出，也就是output.</div></article><article><div class=blog-card><h3><a href=/2019/11/14/mysql-char-varchar-max-length/>MySQL中的CHAR和VARCHAR到底支持多长?</a></h3><p><small>2019年11月14日&nbsp;· 185 字&nbsp;· 1 分钟</small><p>最近在研究MySQL的数据类型，我们知道，选择合适的数据类型和数据长度对MySQL的性能影响是不可忽视的，小字段意味着可以MySQL可以读取更多的记录，从而加快查询速度。
网上该问题的答案有很多版本，还是通过实践得出的结论比较靠谱。
先说结论(MySQL版本5.7.27)
CHAR最大255字符，字符集对CHAR没有影响，CHAR()括号内填写最大字符数255 VARCHAR最大65535字节，字符集对VARCHAR有影响 UTF8字符集，每个字符大小3字节，所以65535/3 = 21845，最大支持21845字符，因此VARCHAR()括号中最大填写21845字符 GBK字符集，每个字符大小2字节，所以65535/2 = 32767.5，最大支持32767字符，因此VARCHAR()括号中最大填写32767字符 验证过程 CHAR UTF8字符集(1个字符占用3个字节)
CREATE TABLE `test`.`demo` ( `id` int(0) UNSIGNED NULL AUTO_INCREMENT, `title` char(256) NULL, PRIMARY KEY (`id`) ) CHARACTER SET = utf8 COLLATE = utf8_general_ci; MySQL提示错误
1074 - Column length too big for column 'title' (max = 255); use BLOB or TEXT instead GBK字符集(1个字符占用2个字节)
CREATE TABLE `test`.`demo` ( `id` int(0) UNSIGNED NULL AUTO_INCREMENT, `title` char(256) NULL, PRIMARY KEY (`id`) ) CHARACTER SET = gbk COLLATE = gbk_chinese_ci; MySQL提示错误</div></article><article><div class=blog-card><h3><a href=/2019/11/14/es6-iterator/>深入浅出ES6的迭代器</a></h3><p><small>2019年11月14日&nbsp;· 175 字&nbsp;· 1 分钟</small><p>迭代器是ES2015中新增的规范，与之相关的for&mldr;of也是ES2015新增的。
本文来深入研究一下迭代器是什么，以及迭代器能够干什么？
或许你对for &mldr; of的执行还不了解，比如什么情况下可以使用for &mldr; of去遍历对象，什么情况下会报错等等，这篇文章应该能帮到你。
迭代器协议 for &mldr; of只能迭代满足【迭代器协议】的对象
可迭代对象的必须存在[Symbol.iterator]方法，该方法一个无参函数，返回迭代器协议的对象。
迭代器对象包含一个next()函数，该函数返回值有两种:
如果迭代未结束，返回如下
return { value: 'item', // item是本次迭代值，可以为任意对象 done: false } 如果迭代已结束，返回如下
return { done: true } 下面是未提供迭代器的示例。
const obj = { name: 'xialei', id: 1 }; for(let item of obj) { // TypeError: obj is not iterable } 下面是提供迭代器的示例。
const obj = { name: 'xialei', id: 1, [Symbol.iterator]: function () { // 迭代器属性 const keys = Object.keys(this); // 读取对象键列表 let keyIndex = 0; // 遍历未知 const self = this; // 保存this，next中的function会有自己的this return { // 返回带有next()的对象 next: function () { if (keyIndex &lt; keys.</div></article><article><div class=blog-card><h3><a href=/2019/11/04/es6-proxy/>深入浅出ES6的标准内置对象Proxy</a></h3><p><small>2019年11月4日&nbsp;· 776 字&nbsp;· 4 分钟</small><p>Proxy是ES6规范定义的标准内置对象，可以对目标对象的读取、函数调用等操作进行拦截。一般来说，通过Proxy可以让目标对象“可控”，比如是否能调用对象的某个方法，能否往对象添加属性等等。
const originalObj = { name: 'xialei' }; const publicObj = new Proxy(originalObj, { set(target, prop, value) { // 将属性值转化为大写 target[prop] = value.toString().toUpperCase(); } }); publicObj.name = 'xialei'; console.log(publicObj.name); // XIALEI 从上例可以看出Proxy不需要更改目标对象(也就是originalObj)，就可以对originalObj的行为进行拦截。
语法 let obj = new Proxy(target, handler);
target Object 目标对象。可以是任何类型的对象，甚至包括原生对象（比如数组，函数，另一个Proxy对象） handler Object 代理行为对象。访问目标对象时会自动触发该handler的对应属性。 和大多数开发者一样，刚开始学习Proxy的时候，这个handler不知道是个什么东西，什么时候能触发。
先看一个简单的例子，看看handler到底是什么东西。假设我们开发一个游戏脚本，由于内存修改器的盛行，我们需要对内存中的数据进行安全处理，但是不能影响外部使用，我们使用Proxy完成这个功能。
const gameObj = { hp: 0 }; const publicGameObj = new Proxy(gameObj, { get(target, prop) { return target[prop]/2; }, set(target, prop, value) { target[prop] = value*2; } }); publicGameObj.</div></article><article><div class=blog-card><h3><a href=/2019/10/31/es6-set/>ES6的Set类型</a></h3><p><small>2019年10月31日&nbsp;· 213 字&nbsp;· 1 分钟</small><p>本文内容
Set的基本使用 常用用法 Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。
基本使用 new Set([iterator]) iterator 与Map类似，Set接收一个可选的Iterator对象，所有元素将按照顺序不重复地添加到Set中。传递null或者undefined将返回一个空Set const set = new Set(); // 添加元素 set.add(1); // 移除元素 set.delete(1); // 检测元素是否存在 set.has(1); // 清空Set set.clear(); 数据类型的唯一性判定 const set = new Set(undefined); set. add("string").add("string"). add(1).add(1). add(true).add(true). add(null).add(null). add(undefined).add(undefined) .add(NaN).add(NaN) .add({}).add({}) .add([]).add([]) .add(function () { }).add(function () { }); console.log(set); 输出如下：
Set { 'string', 1, true, null, undefined, NaN, {}, {}, [], [], [Function], [Function] } 结论 string/number/boolean/null/undefined/NaN是使用值判重 NaN!==NaN，但是Set也只会存一份，所以值判定应该不完全是用===做的 object/array/function等object类型使用引用判重 Set的迭代 for&mldr;of</div></article><article><div class=blog-card><h3><a href=/2019/10/30/es6-map/>ES6的Map类型</a></h3><p><small>2019年10月30日&nbsp;· 550 字&nbsp;· 3 分钟</small><p>本文内容
Map的基本使用 Map支持的数据类型 Map的迭代 Map与其他对象的转化 在Map出现之前，要实现类似需求，只能使用Object，但是Object还是存在一些问题的。
如果使用Object作为key存储在{}中，key最终是当做[object Object]来使用的 Object的keys是无序的 无法安全遍历Object 无法直接获取Object大小 Map 对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。
基本操作 new Map([iterator]) iterator 可以是一个数组或者其他iterator对象，其元素为键值对(如['key', 'value'])。 null或undefined不会生效，返回一个空的Map 非iterator会抛出错误 TypeError: object is not iterable const map = new Map(); // Create map.set('name','xialei'); map.set('site', 'https://www.ddhigh.com'); // Update map.set('name', 'xialeistudio'); // Read map.get('name'); // Delete map.delete('name'); // 清空 map.clear(); // map大小 console.log(map.size); 数据类型测试 JS中基本数据类型有string、number、boolean、null、undefined、symbol，复杂数据类型有object(包括object,array,function等)，还有个特殊的NaN(typeof结果是number)，分别对这些类型进行测试
const map = new Map(); const sKey = 'key', nKey = 1, bKey = true, nullKey = null, uKey = undefined, symbolKey = Symbol("key"), oKey = {}, ooKey = oKey, aKey = [], fKey = function () { }, nanKey = NaN; map.</div></article><article><div class=blog-card><h3><a href=/2019/10/30/twblog/>我是如何发现我的文章被侵权以及如何得到侵权网站的联系方式的?</a></h3><p><small>2019年10月30日&nbsp;· 261 字&nbsp;· 2 分钟</small><p>本文内容
如何发现自己的文章被侵权 如何结合whois信息查询侵权网站的联系方式 声明：本文只做技术研究，请勿用于非法目的，如果恶意使用造成任何法律责任本人概不负责！
发现侵权 我的文章除了发布在博客之外，还会同步到思否平台。自己没事的时候会去看看百度统计，比较关注来源网站(也就是referer)，一般来说通过搜索引擎过来的流量我不太关注，私人网站过来的就比较关注了，昨天查看来源的时候看到了一个新网站。
可以看到这个 www.twblogs.net是一个普通网站，点进去发现这样一篇文章。
可以看到这篇文章的作者是xialeistudio(也就是我常用的网络用户名)，可我压根就没听说过这个网站，我意识到可能被爬虫爬取了。
点击作者进入到作者的文章页，发现我昨天下午刚发布没多久的文章就被爬了。
然后我去查看nginx的访问日志，没有发现异常访问，有个IP虽然是美国的，但是是Google的爬虫。这意味着文章不是直接爬取我的博客来的。
nginx的访问日志过滤使用shell命令即可做到，不过这不是本文的重点，此处略过
那就只剩下思否和掘金，通过文章中的公众号图片二维码，我发现了爬取的文章来源。
可以看到是通过思否爬取到的。
侵权结论 伪造用户名爬取了思否大量的文章，截止发文时大概爬了三四十篇文章 思否应该并不知道这件事，应该早期的文章都爬过来了（包括我在思否已经删除的文章） 获取侵权网站联系方式 目前手头只有一个域名https://www.twblogs.net，先去站长工具的whois查询工具http://whois.chinaz.com/查询一下。
whois：用来查询域名注册信息的一种技术
通过查询并没有得到什么有效的信息。看来是whois做了保护处理。
不过没关系，目前得到了twblogs.net的域名提供商是Goddy，我们可以到域名提供商的网站看一下Whois信息
浏览器打开 whois.godaddy.com 输入 www.twblogs.net 就可以了，查询到的Whois信息如下：
WHOIS 搜索结果 Domain Name: twblogs.net Registry Domain ID: 2330628228_DOMAIN_NET-VRSN Registrar WHOIS Server: whois.godaddy.com Registrar URL: http://www.godaddy.com Updated Date: 2019-10-09T11:09:43Z Creation Date: 2018-11-08T16:30:46Z Registrar Registration Expiration Date: 2021-11-08T16:30:46Z Registrar: GoDaddy.com, LLC Registrar IANA ID: 146 Registrar Abuse Contact Email: abuse@godaddy.com Registrar Abuse Contact Phone: +1.</div></article><article><div class=blog-card><h3><a href=/2019/10/29/redis-high-concurrent/>Redis优化高并发下的秒杀性能</a></h3><p><small>2019年10月29日&nbsp;· 470 字&nbsp;· 3 分钟</small><p>本文内容
使用Redis优化高并发场景下的接口性能 数据库乐观锁 随着双11的临近，各种促销活动开始变得热门起来，比较主流的有秒杀、抢优惠券、拼团等等。
涉及到高并发争抢同一个资源的主要场景有秒杀和抢优惠券。
前提 活动规则
奖品数量有限，比如100个 不限制参与用户数 每个用户只能参与1次秒杀 活动要求
不能多发，也不能少发，100个奖品要全部发出去 1个用户最多抢1个奖品 遵循先到先得原则，先来的用户有奖品 数据库实现 悲观锁性能太差，本文不予讨论，讨论一下使用乐观锁解决高并发问题的优缺点。
数据库结构 ID Code UserId CreatedAt RewardAt 奖品ID 奖品码 用户ID 创建时间 中奖时间 未中奖时UserId为0，RewardAt为NULL 中奖时UserId为中奖用户ID，RewardAt为中奖时间 乐观锁实现 乐观锁实际上并不存在真正的锁，乐观锁是利用数据的某个字段来做的，比如本文的例子就是以UserId来实现的。
实现流程如下：
查询UserId为0的奖品，如果未找到则提示无奖品
SELECT * FROM envelope WHERE user_id=0 LIMIT 1 更新奖品的用户ID和中奖时间(假设奖品ID为1，中奖用户ID为100，当前时间为2019-10-29 12:00:00)，这里的user_id=0就是我们的乐观锁了。
UPDATE envelope SET user_id=100, reward_at='2019-10-29 12:00:00' WHERE user_id=0 AND id=1 检测UPDATE语句的执行返回值，如果返回1证明中奖成功，否则证明该奖品被其他人抢了
为什么要添加乐观锁 正常情况下获取奖品、然后把奖品更新给指定用户是没问题的。如果不添加user_id=0时，高并发场景下会出现下面的问题：
两个用户同时查询到了1个未中奖的奖品(发生并发问题) 将奖品的中奖用户更新为用户1，更新条件只有ID=奖品ID 上述SQL执行是成功的，影响行数也是1，此时接口会返回用户1中奖 接下来将中奖用户更新为用户2，更新条件也只有ID=奖品ID 由于是同一个奖品，已经发给用户1的奖品会重新发放给用户2，此时影响行数为1，接口返回用户2也中奖 所以该奖品的最终结果是发放给用户2 用户1就会过来投诉活动方了，因为抽奖接口返回用户1中奖，但他的奖品被抢了，此时活动方只能赔钱了 添加乐观锁之后的抽奖流程 更新用户1时的条件为id=红包ID AND user_id=0 ,由于此时红包未分配给任何人，用户1更新成功，接口返回用户1中奖 当更新用户2时更新条件为id=红包ID AND user_id=0，由于此时该红包已经分配给用户1了，所以该条件不会更新任何记录，接口返回用户2中奖 乐观锁优缺点 优点</div></article></div><div class=paginator><a class=prev href=/page/5/>&larr;&nbsp;&nbsp;Pre Page</a>
<a class=next href=/page/7/>Next Page&nbsp;&nbsp;&rarr;</a></div></div></div></div><footer class=footer><p>&copy; 2014 - 2024 <a href=https://www.ddhigh.com/>Lei Xia</a>
Powered by
<a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>
<a href=https://github.com/guangzhengli/hugo-theme-ladder rel=noopener target=_blank>Ladder</a>
️</p></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.5376 22.7916C11.0152 22.7207 22.5795 21.1781 22.0978 10.4211 22.0536 9.43274 21.9303 8.53367 21.7387 7.71865M10.5376 22.7916C16.876 22.3728 20.0969 19.8899 21.5383 16.9142M10.5376 22.7916C9.7707 22.9055 8.97982 22.8964 8.19743 22.7725M21.7387 7.71865C21.4988 6.69828 21.1518 5.80967 20.7188 5.04257m1.0199 2.67608C22.6022 10.1105 23.0542 13.7848 21.5383 16.9142M20.7188 5.04257c-3.5504-6.28886-12.88753-4.410077-16.44303.0C2.88063 6.77451-.0433281 11.1668 1.38159 16.6571c.89322 3.4417 3.7911 5.6365 6.81584 6.1154M20.7188 5.04257c1.3509 1.89783 3.3111 6.34223 1.6353 10.37273M21.5383 16.9142C21.8737 16.4251 22.1428 15.9235 22.3541 15.4153M8.19743 22.7725C12.1971 23.4683 20.6281 22.971 22.3541 15.4153M14 10.945C13.3836 10.289 12.003 8.63215 11.2034 7.04814 11.1703 6.98257 11.0247 6.98456 10.9937 7.05061 10.5221 8.05496 9.07362 9.92941 8 10.945m3.0333-3.50056C10.9392 9.86549 11 15 12 17" stroke="currentcolor" stroke-linecap="round"/></svg>
</a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function n(){t.innerHTML="Copied",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)}),e.parentNode.appendChild(t)})</script></main></body><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script><script>const images=Array.from(document.querySelectorAll(".blog-content img"));images.forEach(e=>{mediumZoom(e,{margin:10,scrollOffset:40,container:null,template:null,background:"rgba(0, 0, 0, 0.5)"})})</script><script src=/main.min.6bb26b69159420159c74dc9e097b06a578ed2b68c701466a91a44a9632d851bd0af167a1b30012387b4c512b48ad9ad4d3394e04d77ae38d57e1920fe4ed34fe.js integrity="sha512-a7JraRWUIBWcdNyeCXsGpXjtK2jHAUZqkaRKljLYUb0K8WehswASOHtMUStIrZrU0zlOBNd6441X4ZIP5O00/g==" crossorigin=anonymous defer></script></html>