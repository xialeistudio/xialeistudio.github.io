<!doctype html><html lang=en><head><meta name=generator content="Hugo 0.123.7"><meta name=viewport content="width=device-width,initial-scale=1"><title>Lei Xia</title>
<meta charset=utf-8><meta name=description content="Ladder@Learning & Writing & Sharing"><meta name=author content="Lei Xia"><link rel=canonical href=https://www.ddhigh.com/><link rel=alternate type=application/rss+xml href=https://www.ddhigh.com//index.xml title="Lei Xia"><script async defer data-website-id=865c8529-0729-4cf5-88a9-448616abbcbb src=https://umami-beta-peach.vercel.app/xialeistudio></script><meta property="og:title" content="Lei Xia"><meta property="og:description" content="Learning & Writing & Sharing"><meta property="og:type" content="website"><meta property="og:url" content="https://www.ddhigh.com/"><meta name=twitter:card content="summary"><meta name=twitter:title content="Lei Xia"><meta name=twitter:description content="Learning & Writing & Sharing"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"Lei Xia","url":"https://www.ddhigh.com/","description":"Learning \u0026amp; Writing \u0026amp; Sharing","thumbnailUrl":"https://www.ddhigh.com/favicon.ico","sameAs":[]}</script><link rel=icon href=/img/favicon.ico sizes=16x16><link rel=apple-touch-icon href=/img/favicon.ico><link rel=manifest href=/img/favicon.ico><link rel=stylesheet href=https://cdn.staticfile.org/lxgw-wenkai-webfont/1.6.0/style.css><link rel=stylesheet href=/css/main.min.ff1bc260fafbfb440e10194d7d06d57eb5e85eed11d12d06255581262664204e.css integrity="sha256-/xvCYPr7+0QOEBlNfQbVfrXoXu0R0S0GJVWBJiZkIE4=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/highlight/github-dark.min.min.66034289ee9a113219a2c4aae0a8bd2095ab255c832a42efcf5863f10814e7a1.css><script src=/js/highlight.min.min.c607d6febd16934a82eb61d3a896ed9d869f54373cc63ce95864ed5488fe3128.js></script><script>hljs.highlightAll()</script><script>(()=>{var t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,e=localStorage.getItem("theme");t&&e===null&&(localStorage.setItem("theme","dark"),document.documentElement.setAttribute("data-dark-mode","")),t&&e==="dark"&&document.documentElement.setAttribute("data-dark-mode",""),e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script></head><body><main class=wrapper><nav class=navigation><section class=container><a class=navigation-brand href=/>HOME
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><span></span><span></span><span></span></label><ul class=navigation-list id=navigation-list><li class="navigation-item navigation-menu"><a class=navigation-link href=/archives>Archive</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/tags>Tags</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/books>Books</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/guestbook>Guestbook</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class="navigation-item navigation-social"><a class=navigation-link href=https://github.com/xialeistudio><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li class="navigation-item navigation-dark"><button id=mode type=button aria-label="toggle user light or dark theme">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span>
<span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></li></ul></section></nav><div id=content><div class=home><div class=info><div class=intro><h1>Lei Xia</h1><small>Sr. Software Engineer | Solution Architect</small><p><p>Writing code, Enjoying life, Building future</p><p><a href=/atom.xml target=_blank rel=noopener>RSS</a> ·
<a href=/sponsors target=_blank rel=noopener>Sponsor</a></p></p></div></div></div><div class=blog-wrapper><div><div class=blog-list><article><div class=blog-card><h3><a href=/2022/02/08/convert-sorted-array-to-binary-search-tree/>LeetCode108——将有序数组转换为二叉搜索树</a></h3><p><small>February 8, 2022&nbsp;· 106 words&nbsp;· One minute</small><p>题目 给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。
高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。
示例 1：
输入：nums = [-10,-3,0,5,9] 输出：[0,-3,9,-10,null,5] 示例 2：
输入：nums = [1,3] 输出：[3,1] 解释：[1,3] 和 [3,1] 都是高度平衡二叉搜索树。 思路 二叉树的中序遍历是升序，节点顺序为[左，根，右]
对于给定的数组，根据升序的性质，可知，中间节点为根节点，左半部分为左子树，右半部分为右子树 左半部分也是一颗完整的树，复用1的逻辑，因此用递归即可 // 升序数组是树的中序遍历结果，中间Index就是根，可以递归的还原为一个树 func sortedArrayToBST(nums []int) *TreeNode { if len(nums) == 0 { return nil } if len(nums) == 1 { return &amp;TreeNode{Val: nums[0]} } return helper(nums, 0, len(nums)-1) } func helper(nums []int, start, end int) *TreeNode { if start > end { return nil } // 取得根 rootIndex := (start + end) / 2 rootValue := nums[rootIndex] root := &amp;TreeNode{Val: rootValue} root.</div></article><article><div class=blog-card><h3><a href=/2022/02/08/convert-sorted-list-to-binary-search-tree/>LeetCode109——有序链表转换二叉搜索树</a></h3><p><small>February 8, 2022&nbsp;· 292 words&nbsp;· 2 min</small><p>题目 给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。
本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。
示例:
给定的有序链表： [-10, -3, 0, 5, 9], 一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树： 0 / \ -3 9 / / -10 5 思路 转换为数组 转换为数组后解法跟前面一道题一样。
// 链表转换为数组，复用108解法 func sortedListToBST(head *ListNode) *TreeNode { if head == nil { return nil } list := listToArray(head) return helper(list, 0, len(list)-1) } func listToArray(head *ListNode) []int { result := []int{} for head != nil { result = append(result, head.</div></article><article><div class=blog-card><h3><a href=/2022/02/06/binary-tree-zigzag-level-order-traversal/>LeetCode103——二叉树的锯齿形层序遍历</a></h3><p><small>February 6, 2022&nbsp;· 149 words&nbsp;· One minute</small><p>题目 给你二叉树的根节点 root ，返回其节点值的 锯齿形层序遍历 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。
示例 1：
输入：root = [3,9,20,null,null,15,7] 输出：[[3],[20,9],[15,7]] 示例 2：
输入：root = [1] 输出：[[1]] 示例 3：
输入：root = [] 输出：[] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 用层序遍历的思路即可，不过偶数行需要将该行的值翻转。
// BFS处理，记录遍历层数，当层数是奇数，翻转下本层元素 func zigzagLevelOrder(root *TreeNode) [][]int { if root == nil { return [][]int{} } answers := [][]int{} queue := []*TreeNode{root} for level := 1; len(queue) > 0; level++ { size := len(queue) tmp := queue queue = []*TreeNode{} // 清空，存储下一层的节点 vals := []int{} for i := 0; i &lt; size; i++ { node := tmp[0] tmp = tmp[1:] vals = append(vals, node.</div></article><article><div class=blog-card><h3><a href=/2022/02/06/construct-binary-tree-from-preorder-and-inorder-traversal/>LeetCode105——从前序与中序遍历序列构造二叉树</a></h3><p><small>February 6, 2022&nbsp;· 116 words&nbsp;· One minute</small><p>题目 给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。
示例 1:
输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7] 输出: [3,9,20,null,null,15,7] 示例 2:
输入: preorder = [-1], inorder = [-1] 输出: [-1] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 利用前序遍历和中序遍历性质
前序遍历节点顺序如下[根，左，右] 中序遍历节点顺序如下[左，根，右] 前序遍历的左/右子树长度和中序遍历的左/右子树长度是相同的 由于这是同一颗树遍历来的，因此前序遍历的第0个元素和中序遍历的根节点是相同的。因此只要能定位中序遍历的根节点，将中序遍历数组拆分为左右两半后就可以了 查找中序遍历的数组中值为前序遍历第0个元素节点的下标，记为middle 此时中序遍历左子树节点列表为[:middle]，右子树节点列表为[middle+1:]，左子树长度为len([:middle])，记为leftTreeSize 根据第3点可知，前序遍历的左子树节点列表为[1:leftTreeSize+1],右子树节点为[leftTreeSize+1:] // 递归法 // 中序，左根右；前序根左右 // 1. 根据中序遍历找到根节点(值为preorder[0]的节点) // 2. 中序遍历根节点左边的节点数和前序遍历的节点数是相同的，根据该性质可以将前序遍历拆分为两半 func buildTree(preorder []int, inorder []int) *TreeNode { n := len(preorder) if n == 0 { return nil } root := &amp;TreeNode{Val: preorder[0]} // 查找根节点在中序遍历的位置 middle := 0 for ; middle &lt; n; middle++ { if inorder[middle] == preorder[0] { break } } leftTreeSize := len(inorder[:middle]) // 中序遍历的左半边就是左子树 root.</div></article><article><div class=blog-card><h3><a href=/2022/02/06/binary-tree-level-order-traversal-ii/>LeetCode107——二叉树的层序遍历 II</a></h3><p><small>February 6, 2022&nbsp;· 138 words&nbsp;· One minute</small><p>题目 给你二叉树的根节点 root ，返回其节点值 自底向上的层序遍历 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）
示例 1：
输入：root = [3,9,20,null,null,15,7] 输出：[[15,7],[9,20],[3]] 示例 2：
输入：root = [1] 输出：[[1]] 示例 3：
输入：root = [] 输出：[] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 直接用层序遍历即可，结果数组翻转之后就是答案
// BFS正向遍历，最后翻转一下最终结果 func levelOrderBottom(root *TreeNode) [][]int { if root == nil { return [][]int{} } answers := [][]int{} queue := []*TreeNode{root} for len(queue) > 0 { size := len(queue) tmp := queue queue = []*TreeNode{} // 清空，存储下一层的节点 level := []int{} for i := 0; i &lt; size; i++ { node := tmp[0] tmp = tmp[1:] level = append(level, node.</div></article><article><div class=blog-card><h3><a href=/2022/02/06/unique-binary-search-trees-ii/>LeetCode95——不同的二叉搜索树 II</a></h3><p><small>February 6, 2022&nbsp;· 138 words&nbsp;· One minute</small><p>题目 给你一个整数 n ，请你生成并返回所有由 n 个节点组成且节点值从 1 到 n 互不相同的不同 二叉搜索树 。可以按 任意顺序 返回答案。
示例 1：
输入：n = 3 输出：[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]] 示例 2：
输入：n = 1 输出：[[1]]
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/unique-binary-search-trees-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 由于每个节点都可以成为根节点，因此遍历1~n，i为遍历参数名称，此时可以构造如下树 1~i-1为左子树 i为根节点 i+1~n为右子树 递归的调用步骤1可以得到所有的组合 func generateTrees(n int) []*TreeNode { if n == 0 { return nil } return generate(1, n) } // 生成start ~ end的数列表 func generate(start, end int) []*TreeNode { // 非法条件拦截 if start > end { return []*TreeNode{nil} } allNodes := []*TreeNode{} // 遍历n for i := start; i &lt;= end; i++ { // start ~ i-1可以构造左子树节点 leftTrees := generate(start, i-1) // i+1 ~ end可以构造右子树节点 rightTrees := generate(i+1, end) for _, left := range leftTrees { for _, right := range rightTrees { // 组装左根右节点 root := &amp;TreeNode{Val: i} root.</div></article><article><div class=blog-card><h3><a href=/2022/02/06/validate-binary-search-tree/>LeetCode98——验证二叉搜索树</a></h3><p><small>February 6, 2022&nbsp;· 110 words&nbsp;· One minute</small><p>题目 给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。
有效 二叉搜索树定义如下：
节点的左子树只包含 小于 当前节点的数。 节点的右子树只包含 大于 当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。
示例 1：
输入：root = [2,1,3] 输出：true 示例 2：
输入：root = [5,1,4,null,null,3,6] 输出：false 解释：根节点的值是 5 ，但是右子节点的值是 4 。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/validate-binary-search-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 直接用中序遍历即可。中序遍历可以保证后一个值一定比前一个值大。
中序遍历处理顺序：左->根->右
// 中序遍历，值如果都是升序就满足要求 func isValidBST(root *TreeNode) bool { var ( lastValue = math.MinInt64 // 上一个值，初始化时保证是最小值即可，这样只要树节点有值就能大于该值 helper func(root *TreeNode) bool // 判断指定节点是否大于lastValue ) helper = func(root *TreeNode) bool { if root == nil { // 节点为空，直接返回true return true } if !</div></article><article><div class=blog-card><h3><a href=/2022/02/06/recover-binary-search-tree/>LeetCode99——恢复二叉搜索树</a></h3><p><small>February 6, 2022&nbsp;· 196 words&nbsp;· One minute</small><p>题目 给你二叉搜索树的根节点 root ，该树中的 恰好 两个节点的值被错误地交换。请在不改变其结构的情况下，恢复这棵树 。
示例 1：
输入：root = [1,3,null,null,2] 输出：[3,1,null,null,2] 解释：3 不能是 1 的左孩子，因为 3 > 1 。交换 1 和 3 使二叉搜索树有效。 示例 2：
输入：root = [3,1,4,null,null,2] 输出：[2,1,4,null,null,3] 解释：2 不能在 3 的右子树中，因为 2 &lt; 3 。交换 2 和 3 使二叉搜索树有效。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/recover-binary-search-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 中序遍历构造一个数组，根据二叉搜索树的性质，中序遍历是严格递增的 遍历该数组，找出后一个值小于前一个值的下标，根据这两个下标访问数组，可以得到两个错误值 遍历二叉树，根据第2步的两个值定位两个二叉树节点 交换两个节点的值 // 1. 中序遍历构造一个数组 // 2. 检查数组顺序，定位有问题的下标 // 3. 中序遍历原来的树，定位指定下标的节点， 交换两个节点值 func recoverTree(root *TreeNode) { // 构造数组 var values []int var valueGetter func(root *TreeNode) valueGetter = func(root *TreeNode) { if root == nil { return } valueGetter(root.</div></article><article><div class=blog-card><h3><a href=/2022/02/06/binary-tree-level-order-traversal/>LeetCode102--二叉树的层序遍历</a></h3><p><small>February 6, 2022&nbsp;· 123 words&nbsp;· One minute</small><p>题目 给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。
示例 1：
输入：root = [3,9,20,null,null,15,7] 输出：[[3],[9,20],[15,7]] 示例 2：
输入：root = [1] 输出：[[1]] 示例 3：
输入：root = [] 输出：[] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 层序遍历直接用广度有限遍历即可。
用两个队列存储本层节点tmp和下一层节点queue（可以简化处理清理，避免一个队列操作时即弹出又插入的问题） 获取队列长度，将queue复制到tmp,清空本层节点变量(queue) tmp不断出队即可，出队时把后代节点插入queue // BFS遍历即可 // 用队列处理，需要注意的是，每次处理一层，每层的大小就是队列的大小，可以准备两个队列，一个用来存储本层，一个用来存储下一层 func levelOrder(root *TreeNode) [][]int { if root == nil { return [][]int{} } answers := [][]int{} queue := []*TreeNode{root} for len(queue) > 0 { size := len(queue) tmp := queue queue = []*TreeNode{} // 清空，存储下一层的节点 level := []int{} for i := 0; i &lt; size; i++ { node := tmp[0] tmp = tmp[1:] level = append(level, node.</div></article><article><div class=blog-card><h3><a href=/2022/02/05/odd-even-linked-list/>LeetCode328——奇偶链表</a></h3><p><small>February 5, 2022&nbsp;· 178 words&nbsp;· One minute</small><p>题目 给定单链表的头节点 head ，将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后返回重新排序的列表。
第一个节点的索引被认为是 奇数 ， 第二个节点的索引为 偶数 ，以此类推。
请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致。
你必须在 O(1) 的额外空间复杂度和 O(n) 的时间复杂度下解决这个问题。
示例 1:
输入: head = [1,2,3,4,5] 输出: [1,3,5,2,4] 示例2:
输入: head = [2,1,3,5,6,4,7] 输出: [2,3,6,7,1,5,4] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/odd-even-linked-list 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/odd-even-linked-list 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 定义2个链表，odd为奇数链表，even为偶数链表 遍历原链表，根据奇偶位置插入odd或者even 连接odd和even // 1. 定义以下节点 // 1. 偶链表头节点，移动节点 // 2. 奇链表头结点，移动节点 // 2. 奇链表尾节点.Next = 偶链表头结点 func oddEvenList(head *ListNode) *ListNode { // 0,1,2个节点时直接返回 if head == nil || head.Next == nil || head.</div></article></div><div class=paginator><a class=prev href=/page/3/>&larr;&nbsp;&nbsp;Pre Page</a>
<a class=next href=/page/5/>Next Page&nbsp;&nbsp;&rarr;</a></div></div></div></div><footer class=footer><p>&copy; 2014 - 2024 <a href=https://www.ddhigh.com/>Lei Xia</a>
Powered by
<a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>
<a href=https://github.com/guangzhengli/hugo-theme-ladder rel=noopener target=_blank>Ladder</a>
<a href=https://umami-beta-peach.vercel.app/ target=_blank>Statistics</a>
️</p></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.5376 22.7916C11.0152 22.7207 22.5795 21.1781 22.0978 10.4211 22.0536 9.43274 21.9303 8.53367 21.7387 7.71865M10.5376 22.7916C16.876 22.3728 20.0969 19.8899 21.5383 16.9142M10.5376 22.7916C9.7707 22.9055 8.97982 22.8964 8.19743 22.7725M21.7387 7.71865C21.4988 6.69828 21.1518 5.80967 20.7188 5.04257m1.0199 2.67608C22.6022 10.1105 23.0542 13.7848 21.5383 16.9142M20.7188 5.04257c-3.5504-6.28886-12.88753-4.410077-16.44303.0C2.88063 6.77451-.0433281 11.1668 1.38159 16.6571c.89322 3.4417 3.7911 5.6365 6.81584 6.1154M20.7188 5.04257c1.3509 1.89783 3.3111 6.34223 1.6353 10.37273M21.5383 16.9142C21.8737 16.4251 22.1428 15.9235 22.3541 15.4153M8.19743 22.7725C12.1971 23.4683 20.6281 22.971 22.3541 15.4153M14 10.945C13.3836 10.289 12.003 8.63215 11.2034 7.04814 11.1703 6.98257 11.0247 6.98456 10.9937 7.05061 10.5221 8.05496 9.07362 9.92941 8 10.945m3.0333-3.50056C10.9392 9.86549 11 15 12 17" stroke="currentcolor" stroke-linecap="round"/></svg>
</a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function n(){t.innerHTML="Copied",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)}),e.parentNode.appendChild(t)})</script></main></body><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script><script>const images=Array.from(document.querySelectorAll(".blog-content img"));images.forEach(e=>{mediumZoom(e,{margin:10,scrollOffset:40,container:null,template:null,background:"rgba(0, 0, 0, 0.5)"})})</script><script src=/main.min.6bb26b69159420159c74dc9e097b06a578ed2b68c701466a91a44a9632d851bd0af167a1b30012387b4c512b48ad9ad4d3394e04d77ae38d57e1920fe4ed34fe.js integrity="sha512-a7JraRWUIBWcdNyeCXsGpXjtK2jHAUZqkaRKljLYUb0K8WehswASOHtMUStIrZrU0zlOBNd6441X4ZIP5O00/g==" crossorigin=anonymous defer></script></html>