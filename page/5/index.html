<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Learning &amp; Sharing</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Learning &amp; Sharing"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Learning &amp; Sharing"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Learning &amp;amp; Sharing"><meta property="og:type" content="website"><meta property="og:title" content="Learning &amp; Sharing"><meta property="og:url" content="https://www.ddhigh.com/"><meta property="og:site_name" content="Learning &amp; Sharing"><meta property="og:description" content="Learning &amp;amp; Sharing"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://www.ddhigh.com/img/og_image.png"><meta property="article:author" content="Xia Lei"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://www.ddhigh.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.ddhigh.com"},"headline":"Learning & Sharing","image":["https://www.ddhigh.com/img/og_image.png"],"author":{"@type":"Person","name":"Xia Lei"},"publisher":{"@type":"Organization","name":"Learning & Sharing","logo":{"@type":"ImageObject","url":{"text":"Learning & Sharing"}}},"description":"Learning &amp; Sharing"}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.4.1/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?78141f99bbb49f1564a7af89344f5add";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">Learning &amp; Sharing</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Suche" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Gepostet vor&nbsp;<time dateTime="2023-01-03T04:22:08.000Z" title="1/3/2023, 4:22:08 AM">2023-01-03</time></span><span class="level-item"><a class="link-muted" href="/categories/algorithm/">algorithm</a></span><span class="level-item">4 minutes lesen (Über 568 Wörter)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/01/03/2023-01-03-nth-maximum-number.html">查找第N大的数</a></p><div class="content"><p>在给定的序列中查找第N大的数，朴素做法是对序列排序，然后根据索引直接查询，时间复杂度为$O(nlogn)$。</p>
<p>本文介绍一种在$O(n)$的时间复杂度查询第N大的数的算法。</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>算法思路就是定义标志变量，然后遍历数组，根据标志变量和当前数组变量的大小更新标志变量，最后根据情况返回标志变量。</p>
<h2 id="示例：查找第2大的数"><a href="#示例：查找第2大的数" class="headerlink" title="示例：查找第2大的数"></a>示例：查找第2大的数</h2><p>定义$first$和$second$分别存储最大和次大，然后遍历数组时更新即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查找第二大的数字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecondMaximumNumber</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">secondMaximumNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 最大数</span></span><br><span class="line">        <span class="type">var</span> <span class="variable">first</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="comment">// 次大数</span></span><br><span class="line">        <span class="type">var</span> <span class="variable">second</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> num : nums) &#123;</span><br><span class="line">            <span class="comment">// 当前数字比最大数还大，最大数更新为当前数字，原来的最大数更新为第2大</span></span><br><span class="line">            <span class="keyword">if</span> (num &gt;= first) &#123;</span><br><span class="line">                second = first;</span><br><span class="line">                first = num;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &gt;= second) &#123; <span class="comment">// 当前数字小于最大，但是大于第2大，更新第2大</span></span><br><span class="line">                second = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">nums</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="type">var</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecondMaximumNumber</span>();</span><br><span class="line">        System.out.println(s.secondMaximumNumber(nums));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="示例：查找第3大的数"><a href="#示例：查找第3大的数" class="headerlink" title="示例：查找第3大的数"></a>示例：查找第3大的数</h2><p>Leetcode: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/third-maximum-number/">第三大的数</a></p>
<p>原理和查第2大的数想通，定义$first$,$second$,$third$三个变量，然后遍历$nums$</p>
<ol>
<li>若$num &gt; first$，则$second$赋值给$third$，$first$赋值给$second$,$num$赋值给$first$</li>
<li>若$num &lt; first$且 $num &gt; second$，则$second$赋值给$third$，$num$赋值给$second$</li>
<li>若$num &lt; second$且$num &gt; third$，则$num$赋值给$third$</li>
</ol>
<p>最后根据题意返回$third$或者$first$即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution3</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 三个变量</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">thirdMax</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">            <span class="type">var</span> <span class="variable">first</span> <span class="operator">=</span> Long.MIN_VALUE;</span><br><span class="line">            <span class="type">var</span> <span class="variable">second</span> <span class="operator">=</span> first;</span><br><span class="line">            <span class="type">var</span> <span class="variable">third</span> <span class="operator">=</span> second;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> num : nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num &gt; first) &#123; <span class="comment">// 如果num&gt;最大值，原来的最大变次大，原来的次大变三大, 当前边最大</span></span><br><span class="line">                    third = second;</span><br><span class="line">                    second = first;</span><br><span class="line">                    first = num;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; first &amp;&amp; num &gt; second) &#123; <span class="comment">// 小于最大，但是大于第二, 第二变第三，当前边第二</span></span><br><span class="line">                    third = second;</span><br><span class="line">                    second = num;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; second &amp;&amp; num &gt; third) &#123; <span class="comment">// 小于第二，但是大于第三</span></span><br><span class="line">                    third = num;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">int</span>) (third == Long.MIN_VALUE ? first : third);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度:$O(n)$，$n$是数组长度，仅需遍历一次。</p>
<p>空间复杂度: $O(1)$，仅需使用3个变量。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Gepostet vor&nbsp;<time dateTime="2023-01-03T04:05:44.000Z" title="1/3/2023, 4:05:44 AM">2023-01-03</time></span><span class="level-item"><a class="link-muted" href="/categories/algorithm/">algorithm</a></span><span class="level-item">4 minutes lesen (Über 569 Wörter)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/01/03/2023-01-03-shuffle-algorithm.html">洗牌算法</a></p><div class="content"><p>洗牌算法用来将给定的序列打乱，可以认为是排序的反操作。</p>
<h2 id="正确性判断"><a href="#正确性判断" class="headerlink" title="正确性判断"></a>正确性判断</h2><p>对于包含$n$个元素的序列，其全排列有$n!$种。如果<strong>序列打乱的结果为$n!$种且每种序列出现的概率相同</strong>，则是正确的洗牌算法。</p>
<h2 id="Fisher–Yates-洗牌算法"><a href="#Fisher–Yates-洗牌算法" class="headerlink" title="Fisher–Yates 洗牌算法"></a>Fisher–Yates 洗牌算法</h2><blockquote>
<p>以下算法说明摘自: <a target="_blank" rel="noopener" href="https://gaohaoyang.github.io/2016/10/16/shuffle-algorithm/">https://gaohaoyang.github.io/2016/10/16/shuffle-algorithm/</a></p>
<p>Fisher–Yates shuffle 的原始版本，最初描述在 1938 年的 Ronald Fisher和 Frank Yates 写的书中，书名为《Statistical tables for biological, agricultural and medical research》。他们使用纸和笔去描述了这个算法，并使用了一个随机数表来提供随机数。它给出了 1 到 N 的数字的的随机排列，具体步骤如下：</p>
<ol>
<li>写下从 1 到 N 的数字</li>
<li>取一个从 1 到剩下的数字（包括这个数字）的随机数 k</li>
<li>从低位开始，得到第 k 个数字（这个数字还没有被取出），把它写在独立的一个列表的最后一位</li>
<li>重复第 2 步，直到所有的数字都被取出</li>
<li>第 3 步写出的这个序列，现在就是原始数字的随机排列</li>
</ol>
<p>已经证明如果第 2 步取出的数字是真随机的，那么最后得到的排序一定也是。</p>
</blockquote>
<h2 id="正确性证明"><a href="#正确性证明" class="headerlink" title="正确性证明"></a>正确性证明</h2><p>正确的洗牌算法要保证每个数字出现在每个位置的概率一样。我们来看看Fisher–Yates洗牌算法是否正确。</p>
<p>假设现在有1,2,3,4,5五个数字。</p>
<ol>
<li>首先在<code>1-5</code>随机一个数，假设是<code>4</code>，随机概率为<code>1/5</code></li>
<li>再次从<code>1,2,3,5</code>中随机一个数，假设是<code>5</code>，随机概率为<code>1/4</code>，但是<code>5</code>在第一步没被选上的概率是<code>4/5</code>，因此总体概率是<code>1/4*4/5</code>还是<code>1/5</code></li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shuffle</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">	<span class="type">var</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">  	<span class="type">int</span> <span class="variable">newIndex</span> <span class="operator">=</span> i + random.nextInt(n - i); <span class="comment">// 在i之后的下标随机，可以保证不会随机到i前面的</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">    nums[i] = nums[newIndex];</span><br><span class="line">    nums[newIndex] = temp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: $O(n)$，$n$是数组长度，只需要遍历一次。</p>
<p>空间复杂度：$O(1)$，仅需常数项空间。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Gepostet vor&nbsp;<time dateTime="2022-12-31T06:16:32.000Z" title="12/31/2022, 6:16:32 AM">2022-12-31</time></span><span class="level-item"><a class="link-muted" href="/categories/algorithm/">algorithm</a></span><span class="level-item">5 minutes lesen (Über 800 Wörter)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/12/31/2022-12-31-cyclic-sort.html">原地哈希算法</a></p><div class="content"><p>原地哈希算法(Cyclic Sort)主要应用在值都在$[0,n]$的数组$nums$中，此时可以将$nums[i]$作为索引，放回原数组，当然，由于程序上索引是从0开始，因此可以将$nums[i]$放到$nums[nums[i]-1]$的位置上。</p>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>Leetcode <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/missing-number/">268. 丢失的数字</a></p>
<p>给定一个包含 <code>[0, n]</code> 中 <code>n</code> 个数的数组 <code>nums</code> ，找出 <code>[0, n]</code> 这个范围内没有出现在数组中的那个数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,0,1]</span><br><span class="line">输出：2</span><br><span class="line">解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1]</span><br><span class="line">输出：2</span><br><span class="line">解释：n = 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，因为它没有出现在 nums 中。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [9,6,4,2,3,5,7,0,1]</span><br><span class="line">输出：8</span><br><span class="line">解释：n = 9，因为有 9 个数字，所以所有的数字都在范围 [0,9] 内。8 是丢失的数字，因为它没有出现在 nums 中。</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：1</span><br><span class="line">解释：n = 1，因为有 1 个数字，所以所有的数字都在范围 [0,1] 内。1 是丢失的数字，因为它没有出现在 nums 中。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>n == nums.length</code></li>
<li><code>1 &lt;= n &lt;= 104</code></li>
<li><code>0 &lt;= nums[i] &lt;= n</code></li>
<li><code>nums</code> 中的所有数字都 <strong>独一无二</strong></li>
</ul>
<p><strong>进阶：</strong>你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题?</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>用哈希表可以解答，但是空间复杂度达到了$O(n)$，没有利用到值都在$[0,n]$这个已知条件。所以我们用原地哈希解答本题。</p>
<ol>
<li>遍历数组，如果$nums[i]-1&gt;&#x3D;0$ 且$nums[i] !&#x3D; nums[nums[i]-1]$，证明$nums[i]$未归位，我们将$i$和$nums[i]-1$处的数字交换，此步骤要一直循环到$nums[i]-1$越界或者$nums[i]$归位</li>
<li>重新遍历数组，如果$nums[i] !&#x3D; i+1$，证明当前位置的$nums[i]$是错的，也就是缺少本来应该放到这个位置的数字，所以答案也就呼之欲出了。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 原地哈希</span></span><br><span class="line">        <span class="comment">// 1. 将nums[i] 放到 nums[nums[i]-1]的位置</span></span><br><span class="line">        <span class="comment">// 2. 重新遍历，如果 nums[i] != i+1 则缺失i+1数字</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">missingNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">                <span class="comment">// 数字归位</span></span><br><span class="line">                <span class="comment">// 如nums[i]为2，那么最终需要放到1号索引</span></span><br><span class="line">                <span class="keyword">while</span> (nums[i] - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; nums[i] != nums[nums[i] - <span class="number">1</span>]) &#123;</span><br><span class="line">                    swap(nums, i, nums[i] - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 数字已归位，查询哪个数字的值和位置不匹配，不匹配的就是缺失的数字</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">            <span class="type">var</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            nums[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：$O(n)$。$n$是数组长度，每个元素会被一次性移动归位，此后不再移动，因此每个元素的访问次数是常数，而总共需要访问$n$个数字。</p>
<p>空间复杂度：$O(1)$。复用题目给定的$nums$空间作为哈希表，未引入额外空间。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Gepostet vor&nbsp;<time dateTime="2022-12-31T06:13:45.000Z" title="12/31/2022, 6:13:45 AM">2022-12-31</time></span><span class="level-item"><a class="link-muted" href="/categories/algorithm/">algorithm</a></span><span class="level-item">6 minutes lesen (Über 839 Wörter)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/12/31/2022-12-31-eratosthenes-sieve.html">厄拉多塞筛素数筛选算法</a></p><div class="content"><blockquote>
<p>厄拉多塞筛算法（Eratosthenes Sieve）是一种求素数的方法，由古希腊数学家厄拉多塞提出。它的原理是，给定一个数 n，从 2 开始依次将 $\sqrt n$ 以内的素数的倍数标记为合数，标记完成后，剩余未被标记的数为素数（从 2 开始）。如此可省去检查每个数的步骤，使筛选素数的过程更加简单。</p>
</blockquote>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>厄拉多塞筛算法具体步骤如下：</p>
<ol>
<li>读取输入的数 n，将 2 到 n 的所有整数记录在表中</li>
<li>从 2 开始，划去表中所有 2 的倍数</li>
<li>由小到大寻找表中下一个未被划去的整数，再划去表中所有该整数的倍数</li>
<li>重复第（3）步，直到找到的整数大于$\sqrt n$为止</li>
<li>表中所有未被划去的整数均为素数</li>
</ol>
<p>朴素的素数筛选算法如下：对给定的数字$i$，设定数字$j$从$2$遍历到$\sqrt i$，如果中间$i$能整除$j$，则$i$不是素数。该方法的时间复杂度为$O(n\sqrt n)$ ,$n$是数组长度，外层循环需要遍历$n$次，内层循环需要遍历$\sqrt n$次。</p>
<p>而厄拉多塞筛算法的时间复杂度为$O(n log(log(n)))$。</p>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>这是一张来自<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9F%83%E6%8B%89%E6%89%98%E6%96%AF%E7%89%B9%E5%B0%BC%E7%AD%9B%E6%B3%95">维基百科</a>的算法示意图。</p>
<p><img src="https://static.ddhigh.com/algorithm/Sieve_of_Eratosthenes_animation.gif" alt="算法示例"></p>
<ol>
<li>先从2开始遍历，将2的倍数(2,4,6,8,…)标记为为非素数</li>
<li>继续遍历，当前数字是素数时，继续将当前数字的倍数标记为非素数</li>
<li>直到所有数字标记完，重新标记数组，未被标记的就是素数</li>
</ol>
<h2 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h2><p>Leetcode <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-primes/">204. 计数质数</a></p>
<p>给定整数 <code>n</code> ，返回 <em>所有小于非负整数 <code>n</code> 的质数的数量</em> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 10</span><br><span class="line">输出：4</span><br><span class="line">解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 0</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 厄拉多塞筛素数筛选算法</span></span><br><span class="line">        <span class="comment">// 1. 准备O(n)的数组，标识数字是否是质数，初始情况下全部是质数</span></span><br><span class="line">        <span class="comment">// 2. 从2开始遍历到sqrt(n),如果数字是质数，则i*i开始，后面i的倍数全是合数</span></span><br><span class="line">        <span class="comment">// 3. 从[2,n)筛选质数并统计</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countPrimes</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">var</span> <span class="variable">isPrime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">            Arrays.fill(isPrime, <span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i * i &lt; n; i++) &#123; <span class="comment">// 遍历一半即可</span></span><br><span class="line">                <span class="keyword">if</span> (isPrime[i]) &#123; <span class="comment">// 如果是质数，则将i平方开始的所有i的倍数设为合数</span></span><br><span class="line">                    <span class="comment">// 任意素数x的倍数有：2x, 3x, 4x, ..., x*x, (x+1)*x, ...</span></span><br><span class="line">                    <span class="comment">// 任意小于x*x的倍数都被之前的素数筛过滤过，如：2 过滤 2x, 4x, ...，3 过滤 3x, ...</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i * i; j &lt; n; j += i) &#123;</span><br><span class="line">                        isPrime[j] = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">var</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isPrime[i]) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: $O(nlog(log(n)))$。时间复杂度证明过程有点复杂，我暂时还没消化。</p>
<p>空间复杂度：$O(n)$。需要长度为$n$的数组标记是否素数。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Gepostet vor&nbsp;<time dateTime="2022-12-31T06:13:06.000Z" title="12/31/2022, 6:13:06 AM">2022-12-31</time></span><span class="level-item"><a class="link-muted" href="/categories/algorithm/">algorithm</a></span><span class="level-item">8 minutes lesen (Über 1209 Wörter)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/12/31/2022-12-31-boyer-moore-majority-vote-algorithm.html">博耶-摩尔多数投票算法</a></p><div class="content"><p>来自<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/zh-hans/%E5%A4%9A%E6%95%B0%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95">维基百科</a>的解释：</p>
<blockquote>
<p><strong>博耶-摩尔多数投票算法</strong>（英语：Boyer–Moore majority vote algorithm）,中文常作<strong>多数投票算法</strong>、<strong>摩尔投票算法</strong>等，是一种用来寻找一组元素中占多数元素的常数空间级<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">时间复杂度</a>算法。这一算法由<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/w/index.php?title=%E7%BD%97%E4%BC%AF%E7%89%B9%C2%B7S%C2%B7%E5%8D%9A%E8%80%B6&action=edit&redlink=1">罗伯特·S·博耶</a>（英语：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Robert_S._Boyer">Robert S. Boyer</a>）和<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/w/index.php?title=J_Strother_Moore&action=edit&redlink=1">J·斯特罗瑟·摩尔</a>（英语：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/J_Strother_Moore">J Strother Moore</a>）在1981年发表[<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/zh-hans/%E5%A4%9A%E6%95%B0%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95#cite_note-bm-1">1]</a>，也是<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/w/index.php?title=Streaming_algorithm&action=edit&redlink=1">处理数据流</a>（英语：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/streaming_algorithm">streaming algorithm</a>）的一种典型算法。</p>
</blockquote>
<p>简单来说，博耶-摩尔多数投票算法用来寻找数组中的多数元素，相比于用哈希表存储元素和次数使用$O(n)$的时间复杂度来说，该投票算法使用$O(1)$的空间复杂度。</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>摩尔投票算法分为投票-校验两个阶段。投票阶段会统计候选人的票数，遍历数组，如果当前数字和当前候选人不相等，则该候选人票数-1，当候选人票数归0时，需要更换候选人为当前数字；在校验阶段，需要重新遍历数字，并将值等于候选人的数字计数，遍历结束后，比如计数满足要求，则候选人满足要求。</p>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>比如[A,A, A, B,C]这组元素，我们需要筛选数量超过一半的数字。</p>
<p>首先我们定A为候选人，然后遍历数组，遇到B时A有3个，由于A!&#x3D;B，因此A结果为2，再和C比较，犹豫A!&#x3D;C，因此A结尾为1，遍历结束，A是投票阶段的候选人；再遍历数组，统计A的数量为3，超过一半(5&#x2F;2)，因此A是票数最高的元素。</p>
<h2 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h2><p>Leetcode <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/majority-element-ii/">229. 多数元素 II</a></p>
<p>给定一个大小为 <em>n</em> 的整数数组，找出其中所有出现超过 <code>⌊ n/3 ⌋</code> 次的元素。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,3]</span><br><span class="line">输出：[3]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2]</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题目要求找出所有出现次数超过<code>n/3</code>次的元素，由于摩尔投票算法空间复杂度是常数，因此需要预先定义候选人个数。</p>
<p>设出现次数超过<code>n/3</code>次的元素有$x$个，以下是求解$x$的过程：<br>$$<br>\begin{equation}\label{eqn:1}<br>\begin{aligned}<br>&amp; 假设刚好是n&#x2F;3个 \<br>&amp; \because x * n&#x2F;3 &#x3D; n \<br>&amp; \therefore x&#x3D;3 \<br>&amp; 而实际上题目要求次数 &gt; n&#x2F;3 \<br>&amp; \therefore x &lt; 3 \<br>&amp; \therefore x &#x3D; 2<br>\end{aligned}<br>\end{equation}<br>$$<br>所以本题最多能选择2个候选人。</p>
<ol>
<li>不妨设两个候选人$candidate1$和$candidate2$，$count1$和$count2$都是0</li>
<li>遍历数组，如果当前$nums[i]&#x3D;&#x3D;candidate1$，则$count1++$，否则$count1–$，对$candidate2$同样处理</li>
<li>如果遍历过程中$count1$或$count2$为0，则更新对应的候选人为$nums[i]$</li>
<li>投票阶段结束，进入重新计数校验阶段，我们留下了$candidate1$和$candidate2$，再次遍历数组，如果值和这两个候选人相同，则对应的$count$增加</li>
<li>如果$count&gt;nums.length&#x2F;3$，则将当前候选人加入答案</li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 摩尔投票法</span></span><br><span class="line">        <span class="comment">// 1. 因为题目要求超过 n/3 的数字，因此最多有2个数字</span></span><br><span class="line">        <span class="comment">// 2. 投票阶段，初始化2个数字，以及count</span></span><br><span class="line">        <span class="comment">// 3. 遍历nums，如果和num1相等，则count1++，如果和num2相等，则count2++，否则票数--</span></span><br><span class="line">        <span class="comment">// 4. 如果num1的count1为0，则num1为当前num</span></span><br><span class="line">        <span class="comment">// 5. 校验阶段</span></span><br><span class="line">        <span class="comment">// 6. 统计num1和num2的次数，看看是否&gt;n/3</span></span><br><span class="line">        <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">            <span class="type">var</span> <span class="variable">answer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">candidate1</span> <span class="operator">=</span> nums[<span class="number">0</span>], count1 = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">candidate2</span> <span class="operator">=</span> nums[<span class="number">0</span>], count2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">                <span class="comment">// 增加1的票数</span></span><br><span class="line">                <span class="keyword">if</span> (num == candidate1) &#123;</span><br><span class="line">                    count1++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 增加2的票数</span></span><br><span class="line">                <span class="keyword">if</span> (num == candidate2) &#123;</span><br><span class="line">                    count2++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 1票数不足，更新候选人1</span></span><br><span class="line">                <span class="keyword">if</span> (count1 == <span class="number">0</span>) &#123;</span><br><span class="line">                    candidate1 = num;</span><br><span class="line">                    count1++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 2票数不足，更新候选人2</span></span><br><span class="line">                <span class="keyword">if</span> (count2 == <span class="number">0</span>) &#123;</span><br><span class="line">                    candidate2 = num;</span><br><span class="line">                    count2++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 票数相减</span></span><br><span class="line">                count1--;</span><br><span class="line">                count2--;</span><br><span class="line">            &#125;</span><br><span class="line">            count1 = <span class="number">0</span>;</span><br><span class="line">            count2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> num : nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num == candidate1) &#123;</span><br><span class="line">                    count1++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num == candidate2) &#123;</span><br><span class="line">                    count2++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count1 &gt; nums.length / <span class="number">3</span>) &#123;</span><br><span class="line">                answer.add(candidate1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count2 &gt; nums.length / <span class="number">3</span>) &#123;</span><br><span class="line">                answer.add(candidate2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> answer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：$O(n)$, $n$是数组长度，需要遍历两次。</p>
<p>空间复杂度: $O(1)$，只需要常数项额外空间。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Gepostet vor&nbsp;<time dateTime="2022-12-30T10:57:38.000Z" title="12/30/2022, 10:57:38 AM">2022-12-30</time></span><span class="level-item"><a class="link-muted" href="/categories/algorithm/">algorithm</a></span><span class="level-item">5 minutes lesen (Über 801 Wörter)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/12/30/2022-12-30-radix-sort.html">基数排序算法</a></p><div class="content"><p>基数排序又叫桶排序，是一种时间复杂度为$O(n)$的排序算法，但是相比于其他排序算法有$O(n)$的空间复杂度。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>基数排序的核心思路如下：</p>
<ol>
<li>准备0~9的10个桶，根据数字当前比较位的值来决定放入哪个桶。如当前比较个位，则数字13应该放入索引为3的桶中；当前比较百位，则123应该放入索引为1的桶中。</li>
<li>当所有数字全部放入桶之后，遍历0~9这10个桶，然后依次将数字保存到待排序数组，因为桶是有序的，所以本轮放回去的数字是有序的。</li>
<li>当前比较的位数左移，比如本轮比较个位，下一轮应该比较百位。</li>
<li>重复步骤1~3。</li>
</ol>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>现在我们来看一个实际例子。</p>
<p>待排序数字：717, 328, 803, 422, 586, 944, 557, 308, 496, 624</p>
<h3 id="第1轮比较个位"><a href="#第1轮比较个位" class="headerlink" title="第1轮比较个位"></a>第1轮比较个位</h3><p>直接按照个位放入桶中。</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td>422</td>
<td>803</td>
<td>624</td>
<td></td>
<td>586</td>
<td>717</td>
<td>328</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>496</td>
<td>557</td>
<td>308</td>
<td></td>
</tr>
</tbody></table>
<p>按照从左到右，从上到下的原则将数字归位：422,803,624,586,496,717,557,328,308</p>
<h3 id="第2轮比较十位"><a href="#第2轮比较十位" class="headerlink" title="第2轮比较十位"></a>第2轮比较十位</h3><table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody><tr>
<td>803</td>
<td>717</td>
<td>422</td>
<td></td>
<td></td>
<td>557</td>
<td></td>
<td></td>
<td>586</td>
<td>496</td>
</tr>
<tr>
<td>308</td>
<td></td>
<td>624</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>328</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>按照从左到右，从上到下的原则将数字归位：803,308,717,422,624,328,557,586,496</p>
<h3 id="第3轮比较百位"><a href="#第3轮比较百位" class="headerlink" title="第3轮比较百位"></a>第3轮比较百位</h3><table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td>308</td>
<td>422</td>
<td>557</td>
<td>624</td>
<td>717</td>
<td>803</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>328</td>
<td>496</td>
<td>586</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>按照从左到右，从上到下的原则将数字归位：308,328,422,496,557,586,624,717,803</p>
<p>可以发现，比较的轮次由数组中最大的数字决定，以上面的例子来说，如果还存在一个1234数字，那么需要比较4轮才可以完成排序。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RadixSort</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基数排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">var</span> <span class="variable">max</span> <span class="operator">=</span> Arrays.stream(nums).max().getAsInt();</span><br><span class="line">        <span class="comment">// 当前处理位数</span></span><br><span class="line">        <span class="type">var</span> <span class="variable">exp</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 桶</span></span><br><span class="line">        <span class="type">var</span> <span class="variable">bucket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][nums.length];</span><br><span class="line">        <span class="comment">// 记录每个桶有几个数字</span></span><br><span class="line">        <span class="type">var</span> <span class="variable">bucketCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">while</span> (max &gt;= exp) &#123;</span><br><span class="line">            <span class="comment">// 求得每个数字当前位数的值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> num : nums) &#123;</span><br><span class="line">                <span class="comment">// 求得当前位余数</span></span><br><span class="line">                <span class="type">var</span> <span class="variable">bitNumber</span> <span class="operator">=</span> (num / exp) % <span class="number">10</span>;</span><br><span class="line">                <span class="comment">// 放入桶, index是桶的index，在同一个桶的数字需要index来标识位置</span></span><br><span class="line">                <span class="type">var</span> <span class="variable">index</span> <span class="operator">=</span> bucketCount[bitNumber];</span><br><span class="line">                bucket[bitNumber][index] = num;</span><br><span class="line">                <span class="comment">// 桶内数量+1</span></span><br><span class="line">                bucketCount[bitNumber]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 桶内数字归位</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 已归位的数字下标</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (bucketCount[i] &gt; <span class="number">0</span>) &#123; <span class="comment">// 当前桶有数字</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; bucketCount[i]; j++) &#123; <span class="comment">// 遍历同一个桶的数字</span></span><br><span class="line">                        nums[k] = bucket[i][j];</span><br><span class="line">                        k++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 桶数字清空</span></span><br><span class="line">                bucketCount[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 位数左移</span></span><br><span class="line">            exp *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="type">var</span> <span class="variable">gap</span> <span class="operator">=</span> nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (gap &gt; max) &#123;</span><br><span class="line">                max = gap;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">sort</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RadixSort</span>();</span><br><span class="line">        <span class="type">var</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">422</span>, <span class="number">803</span>, <span class="number">624</span>, <span class="number">586</span>, <span class="number">496</span>, <span class="number">717</span>, <span class="number">557</span>, <span class="number">328</span>, <span class="number">308</span>&#125;;</span><br><span class="line">        sort.sort(list);</span><br><span class="line">        System.out.println(Arrays.toString(list));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: $O(n)$ ，严格来说是$O(log(n))$。$n$是待排序数组长度，在数据量小的情况下，最外层的while循环遍历次数可以认为是常数，内部嵌套的for循环次数为数组长度$n$，因此时间复杂度为$O(n)$；在数据量大的情况下，最外层的while循环次数为$O(log(n))$，内部嵌套的for循环次数依旧是$n$，因此时间复杂度为$O(nlog(n))$。</p>
<p>空间复杂度：$O(n)$。$n$是待排序数组长度，$bucket$的大小为$10*n$，$bucketCount$大小为$n$，因此总体空间复杂度为$O(n)$。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Gepostet vor&nbsp;<time dateTime="2022-03-17T04:00:14.000Z" title="3/17/2022, 4:00:14 AM">2022-03-17</time></span><span class="level-item"><a class="link-muted" href="/categories/algorithm/">algorithm</a></span><span class="level-item">12 minutes lesen (Über 1821 Wörter)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/03/17/2022-03-17-palindrome-partitioning.html">算法篇-leetcode 131 分割回文串</a></p><div class="content"><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是 <strong>回文串</strong> 。返回 <code>s</code> 所有可能的分割方案。</p>
<p><strong>回文串</strong> 是正着读和反着读都一样的字符串。</p>
<p><strong>示例1</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;aab&quot;</span><br><span class="line">输出：[[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;],[&quot;aa&quot;,&quot;b&quot;]]</span><br></pre></td></tr></table></figure>

<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p><strong>题目要求</strong></p>
<ol>
<li>将字符串字符打散后，将其中的回文串添加到一个单独的List</li>
<li>第1步的所有List构成最后的答案</li>
</ol>
<p>可以看出，这是一个典型的回溯问题，考察有多少种方法可以组装最后的答案。</p>
<h4 id="方法一：直接回溯"><a href="#方法一：直接回溯" class="headerlink" title="方法一：直接回溯"></a>方法一：直接回溯</h4><p><strong>思路及算法</strong></p>
<p>回溯需要回答以下3个问题：</p>
<ol>
<li>回溯终止条件是什么？</li>
<li>回溯有哪些选择?</li>
<li>如何进入下一个选择？</li>
</ol>
<p>对于本题来说，我们需要将字符串打散，从中选择回文串添加到最终答案，因此，需要定义以下变量:  </p>
<ol>
<li>$index$, 记录当前选择的字符索引</li>
<li>$path$, 记录本次回文串选择情况</li>
<li>$answer$, 记录最终答案</li>
</ol>
<p>回答上面提出来的两个问题：</p>
<ol>
<li>回溯终止条件: $index&#x3D;&#x3D;s.length()$，此时将$path$拷贝到$answer$，不可以直接添加，因为回溯存在撤回操作，必须断开$answer$和$path$的引用。</li>
<li>回溯有哪些选择：定义变量$right$, 遍历 $s[index,s.length())$，当$s[index,right]$是回文串时，将其加入$path$。</li>
<li>如何进入下一个选择：第2个问题满足条件的情况下，增加$index$然后再次递归即可。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * DFS回溯</span></span><br><span class="line"><span class="comment">     * 1. 回溯出口      index == s.length()</span></span><br><span class="line"><span class="comment">     * 2. 回溯递进      遍历[i,n)  如果s[i,j] 是回文串，则加入path，然后递归 s[i,j+1]</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">partition</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; answer = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(answer, path, <span class="number">0</span>, s.length(), s);</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(List&lt;List&lt;String&gt;&gt; answer, List&lt;String&gt; path, <span class="type">int</span> index, <span class="type">int</span> length, String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index == length) &#123;</span><br><span class="line">            answer.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 本次有什么选择?</span></span><br><span class="line">        <span class="comment">// j =&gt; [index,len)，检测s[index,j]是否回文，如果是，则加入path，最后撤销选择</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isPalindrome(s, index, i)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            path.add(s.substring(index, i + <span class="number">1</span>));</span><br><span class="line">            dfs(answer, path, i + <span class="number">1</span>, length, s);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(left) != s.charAt(right)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(N*2^n)$，每个位置的字符可以拆分也可以不拆分，因此时间复杂度是$O(2^n)$，判断每个子字符串是否为回文串需要$O(N)$的时间。</li>
<li>空间复杂度：$O(N*2^n)$，考虑$answer$，每个位置的字符可以拆分也可以不拆分，两种情况都需要占用空间，此部分空间是$O(2^n)$，而对于所有的答案都需要保存，此部分空间是$O(N)$.</li>
</ul>
<h4 id="方法二：记忆法回溯"><a href="#方法二：记忆法回溯" class="headerlink" title="方法二：记忆法回溯"></a>方法二：记忆法回溯</h4><p><strong>思路及算法</strong></p>
<p>在方法一的基础上添加$memo$保存$s[i,j]$是否为回文串，减少重复判断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * DFS回溯</span></span><br><span class="line"><span class="comment">     * 1. 回溯出口      index == s.length()</span></span><br><span class="line"><span class="comment">     * 2. 回溯递进      遍历[i,n)  如果s[i,j] 是回文串，则加入path，然后递归 s[i,j+1]</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">partition</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; answer = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Boolean[][] memo = <span class="keyword">new</span> <span class="title class_">Boolean</span>[s.length()][s.length()];</span><br><span class="line">        dfs(memo, answer, path, <span class="number">0</span>, s.length(), s);</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(Boolean[][] memo, List&lt;List&lt;String&gt;&gt; answer, List&lt;String&gt; path, <span class="type">int</span> index, <span class="type">int</span> length, String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index == length) &#123;</span><br><span class="line">            answer.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 本次有什么选择?</span></span><br><span class="line">        <span class="comment">// j =&gt; [index,len)，检测s[index,j]是否回文，如果是，则加入path，最后撤销选择</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isPalindrome(memo, s, index, i)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            path.add(s.substring(index, i + <span class="number">1</span>));</span><br><span class="line">            dfs(memo, answer, path, i + <span class="number">1</span>, length, s);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(Boolean[][] memo, String s, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (memo[left][right] != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[left][right];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(left) != s.charAt(right)) &#123;</span><br><span class="line">                <span class="keyword">return</span> memo[left][right] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[left][right] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(N*2^n)$，每个位置的字符可以拆分也可以不拆分，因此时间复杂度是$O(2^n)$，判断每个子字符串是否为回文串需要$O(N)$的时间，但是添加了记忆化搜索，每个子串至多搜索一次。</li>
<li>空间复杂度：$O(N*2^n)$，考虑$answer$，每个位置的字符可以拆分也可以不拆分，两种情况都需要占用空间，此部分空间是$O(2^n)$，而对于所有的答案都需要保存，此部分空间是$O(N)$.</li>
</ul>
<h4 id="方法三：DP-回溯"><a href="#方法三：DP-回溯" class="headerlink" title="方法三：DP+回溯"></a>方法三：DP+回溯</h4><p>我们可以利用DP通过提前计算好字符串的回文信息。</p>
<p><strong>思路和算法</strong></p>
<p>需要提前截取子字符串然后进行DP。那么问题来了，如何截取所有在子字符串？<br>我们可以定义如下双重循环：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;right &lt; s.length(); right++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;left&lt;= right; right++) &#123;</span><br><span class="line">        <span class="comment">// s[left,right] 就是所有的子字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>思考状态转移方程</strong></p>
<ol>
<li>定义$dp[i][j]$代表$s[i, j]$是否为回文串</li>
<li>当$s[left] &#x3D;&#x3D; s[right]$可知字符串两端是相等的，需要考虑$left和right$的距离，通过穷举(笨办法)可知：<ol>
<li>$right - left &#x3D; 0$时，$left$和$right$就是同一个字符，显然可以直接得到答案$true$</li>
<li>$right - left &#x3D; 1$时，$left$和$right$是挨着的，比如$aa$，显然可以直接得到答案$true$</li>
<li>$right - right &#x3D; 2$时，$left$和$right$中间夹了一个字符，比如$aba$，显然可以直接得到答案$true$</li>
<li>$right - right &gt; 2$ 时，不能直接看不出来了，需要进行状态转移，比如$aabaa$，当$s[0] &#x3D;&#x3D; s[4]$时，我们需要看看$s[1,3]$是不是回文串，在本例中，由于$s[1,3]$是回文串，因此$s[0,4]$也是。</li>
</ol>
</li>
</ol>
<p>综上，DP方程如下：</p>
<p>$$<br>dp(i,j) &#x3D; \begin{cases}<br>false, &amp; \text{if } s[i] \ne s[j] \<br>true, &amp; \text{if } s[i] &#x3D; s[j] &amp; j-i \le 2 \<br>dp[i+1][j-1], &amp; \text{if } j-i \gt 2<br>\end{cases}<br>$$</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * DP+DFS回溯</span></span><br><span class="line"><span class="comment">     * 1. DP处理 dp[i][j]是否为回文</span></span><br><span class="line"><span class="comment">     * 1.1 dp[i][i] = true</span></span><br><span class="line"><span class="comment">     * 1.2 dp[i][j] = s[i] == s[j] &amp;&amp; (dp[i+1][j-1] || j-i&lt;=2)</span></span><br><span class="line"><span class="comment">     * 2. 回溯</span></span><br><span class="line"><span class="comment">     * 2.1 回溯出口: index == s.length()</span></span><br><span class="line"><span class="comment">     * 2.2 回溯递进：j =&gt; [i,s.length())  if(dp[i][j])  添加子串，然后 dfs(index+1)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">partition</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; n; right++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>; left &lt;= right; left++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(left) == s.charAt(right)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (right - left &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">                        dp[left][right] = <span class="literal">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[left][right] = dp[left + <span class="number">1</span>][right - <span class="number">1</span>]; <span class="comment">// 上一轮遍历过</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;String&gt;&gt; answer = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(answer, path, dp, <span class="number">0</span>, n, s);</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(List&lt;List&lt;String&gt;&gt; answer, List&lt;String&gt; path, <span class="type">boolean</span>[][] dp, <span class="type">int</span> index, <span class="type">int</span> n, String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index == n) &#123;</span><br><span class="line">            answer.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> index; right &lt; n; right++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[index][right]) &#123;</span><br><span class="line">                path.add(s.substring(index, right + <span class="number">1</span>));</span><br><span class="line">                dfs(answer, path, dp, right + <span class="number">1</span>, n, s);</span><br><span class="line">                path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong><br>+时间复杂度：$O(2^n)$，计算$dp$需要$O(n^2)$,回溯需要$O(2^n)$。</p>
<ul>
<li>空间复杂度：$O(N*2^n)$，考虑$answer$，每个位置的字符可以拆分也可以不拆分，两种情况都需要占用空间，此部分空间是$O(2^n)$，而对于所有的答案都需要保存，此部分空间是$O(N)$;考虑$dp$，需要$O(n^2)$的空间</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Gepostet vor&nbsp;<time dateTime="2022-02-08T12:24:19.000Z" title="2/8/2022, 12:24:19 PM">2022-02-08</time></span><span class="level-item"><a class="link-muted" href="/categories/algorithm/">algorithm</a></span><span class="level-item">2 minutes lesen (Über 325 Wörter)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/02/08/2022-02-08-construct-binary-tree-from-inorder-and-postorder-traversal.html">LeetCode106——从中序与后序遍历序列构造二叉树</a></p><div class="content"><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。</p>
<p> <strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]</span><br><span class="line">输出：[3,9,20,null,null,15,7]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：inorder = [-1], postorder = [-1]</span><br><span class="line">输出：[-1]</span><br></pre></td></tr></table></figure>



<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal">https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote>
<p>核心是中序遍历的顺序是[左，根，右]，后序遍历是[左，右，根]。而同一颗树不管前&#x2F;中&#x2F;后序遍历，节点数是不变的。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后序遍历顺序: 左右根</span></span><br><span class="line"><span class="comment">// 1. postorder最后一个元素为根</span></span><br><span class="line"><span class="comment">// 2. 遍历inorder查找根的index</span></span><br><span class="line"><span class="comment">// 3. inorder[:index]为左子树，inorder[index+1:]为右子树，左子树大小记为leftTreeSize</span></span><br><span class="line"><span class="comment">// 4. postorder[:leftTreeSize]为左子树，postorder[leftTreeSize:len(postorder)-1]是右子树</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildTree</span><span class="params">(inorder []<span class="type">int</span>, postorder []<span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(inorder)</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;TreeNode&#123;Val: inorder[<span class="number">0</span>]&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 查找中序遍历根的index</span></span><br><span class="line">	index := <span class="number">-1</span></span><br><span class="line">	rootValue := postorder[<span class="built_in">len</span>(postorder)<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(inorder); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> inorder[i] == rootValue &#123;</span><br><span class="line">			index = i</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 分割数组</span></span><br><span class="line">	leftTreeSize := <span class="built_in">len</span>(inorder[:index])</span><br><span class="line">	root := &amp;TreeNode&#123;Val: rootValue&#125;</span><br><span class="line">	root.Left = buildTree(inorder[:index], postorder[:leftTreeSize])</span><br><span class="line">	root.Right = buildTree(inorder[index+<span class="number">1</span>:], postorder[leftTreeSize:<span class="built_in">len</span>(postorder)<span class="number">-1</span>])</span><br><span class="line">	<span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Gepostet vor&nbsp;<time dateTime="2022-02-08T12:24:19.000Z" title="2/8/2022, 12:24:19 PM">2022-02-08</time></span><span class="level-item"><a class="link-muted" href="/categories/algorithm/">algorithm</a></span><span class="level-item">2 minutes lesen (Über 327 Wörter)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/02/08/2022-02-08-convert-sorted-array-to-binary-search-tree.html">LeetCode108——将有序数组转换为二叉搜索树</a></p><div class="content"><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。</p>
<p>高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-10,-3,0,5,9]</span><br><span class="line">输出：[0,-3,9,-10,null,5]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,3]</span><br><span class="line">输出：[3,1]</span><br><span class="line">解释：[1,3] 和 [3,1] 都是高度平衡二叉搜索树。</span><br></pre></td></tr></table></figure>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote>
<p>二叉树的中序遍历是升序，节点顺序为[左，根，右]</p>
</blockquote>
<ol>
<li>对于给定的数组，根据升序的性质，可知，中间节点为根节点，左半部分为左子树，右半部分为右子树</li>
<li>左半部分也是一颗完整的树，复用1的逻辑，因此用递归即可</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 升序数组是树的中序遍历结果，中间Index就是根，可以递归的还原为一个树</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortedArrayToBST</span><span class="params">(nums []<span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;TreeNode&#123;Val: nums[<span class="number">0</span>]&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> helper(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(nums []<span class="type">int</span>, start, end <span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line">	<span class="keyword">if</span> start &gt; end &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 取得根</span></span><br><span class="line">	rootIndex := (start + end) / <span class="number">2</span></span><br><span class="line">	rootValue := nums[rootIndex]</span><br><span class="line">	root := &amp;TreeNode&#123;Val: rootValue&#125;</span><br><span class="line">	root.Left = helper(nums, start, rootIndex<span class="number">-1</span>)</span><br><span class="line">	root.Right = helper(nums, rootIndex+<span class="number">1</span>, end)</span><br><span class="line">	<span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Gepostet vor&nbsp;<time dateTime="2022-02-08T12:24:19.000Z" title="2/8/2022, 12:24:19 PM">2022-02-08</time></span><span class="level-item"><a class="link-muted" href="/categories/algorithm/">algorithm</a></span><span class="level-item">4 minutes lesen (Über 664 Wörter)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/02/08/2022-02-08-convert-sorted-list-to-binary-search-tree.html">LeetCode109——有序链表转换二叉搜索树</a></p><div class="content"><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p>
<p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给定的有序链表： [-10, -3, 0, 5, 9],</span><br><span class="line"></span><br><span class="line">一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     / \</span><br><span class="line">   -3   9</span><br><span class="line">   /   /</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="转换为数组"><a href="#转换为数组" class="headerlink" title="转换为数组"></a>转换为数组</h3><blockquote>
<p>转换为数组后解法跟前面一道题一样。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 链表转换为数组，复用108解法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortedListToBST</span><span class="params">(head *ListNode)</span></span> *TreeNode &#123;</span><br><span class="line">	<span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	list := listToArray(head)</span><br><span class="line">	<span class="keyword">return</span> helper(list, <span class="number">0</span>, <span class="built_in">len</span>(list)<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">listToArray</span><span class="params">(head *ListNode)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	result := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> head != <span class="literal">nil</span> &#123;</span><br><span class="line">		result = <span class="built_in">append</span>(result, head.Val)</span><br><span class="line">		head = head.Next</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(nums []<span class="type">int</span>, start, end <span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line">	<span class="keyword">if</span> start &gt; end &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 取得根</span></span><br><span class="line">	rootIndex := (start + end) / <span class="number">2</span></span><br><span class="line">	rootValue := nums[rootIndex]</span><br><span class="line">	root := &amp;TreeNode&#123;Val: rootValue&#125;</span><br><span class="line">	root.Left = helper(nums, start, rootIndex<span class="number">-1</span>)</span><br><span class="line">	root.Right = helper(nums, rootIndex+<span class="number">1</span>, end)</span><br><span class="line">	<span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="链表操作"><a href="#链表操作" class="headerlink" title="链表操作"></a>链表操作</h3><blockquote>
<p>我们遍历到中间节点后，将链表拆分为[左部分，中间点，右部分]即可复用逻辑，而且无额外空间占用</p>
</blockquote>
<p>单链表是无法直到中间点在哪里的，因此我们需要先遍历一次，获取链表长度，除以2就是中间的index。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 遍历一遍链表得到链表长度，算出中间节点index</span></span><br><span class="line"><span class="comment">// 2. 再次遍历链表，拆分为三段</span></span><br><span class="line"><span class="comment">// 1. 起点到中间节点的上一个节点：左子链表</span></span><br><span class="line"><span class="comment">// 2. 中间节点</span></span><br><span class="line"><span class="comment">// 3. 中间节点的下一个节点到链表末尾：右子链表</span></span><br><span class="line"><span class="comment">// 3. 将中间节点作为树根，利用左右子链表，递归构建左右子树，然后挂到根节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortedListToBST</span><span class="params">(head *ListNode)</span></span> *TreeNode &#123;</span><br><span class="line">	<span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> helper(head)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(head *ListNode)</span></span> *TreeNode &#123;</span><br><span class="line">	<span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;TreeNode&#123;Val: head.Val&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 获取链表总长度</span></span><br><span class="line">	length := <span class="number">0</span></span><br><span class="line">	p := head</span><br><span class="line">	<span class="keyword">for</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line">		length++</span><br><span class="line">		p = p.Next</span><br><span class="line">	&#125;</span><br><span class="line">	middle := length / <span class="number">2</span> <span class="comment">// 取得中间点位置</span></span><br><span class="line">	<span class="comment">// 再次遍历到中间点</span></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		prev = head      <span class="comment">// 指向中间点的上一个节点</span></span><br><span class="line">		curr = head.Next <span class="comment">// 指向中间点</span></span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		left  *ListNode <span class="comment">// 左子链表头结点</span></span><br><span class="line">		right *ListNode <span class="comment">// 右子链表头结点</span></span><br><span class="line">	)</span><br><span class="line">	index := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> curr != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// index是prev的下标，因此定位到middle的前一个</span></span><br><span class="line">		<span class="keyword">if</span> index == middle<span class="number">-1</span> &#123;</span><br><span class="line">			<span class="comment">// 找到中点，将中点和右子链表连接打断</span></span><br><span class="line">			right = curr.Next</span><br><span class="line">			curr.Next = <span class="literal">nil</span></span><br><span class="line">			<span class="comment">// 将左子链表和中点连接打断</span></span><br><span class="line">			prev.Next = <span class="literal">nil</span></span><br><span class="line">			left = head</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		prev = curr</span><br><span class="line">		curr = curr.Next</span><br><span class="line">		index++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 此时我们拥有left,curr,right 三个链表，开始递归组合</span></span><br><span class="line">	root := &amp;TreeNode&#123;Val: curr.Val&#125;</span><br><span class="line">	root.Left = helper(left) <span class="comment">// 给你一条链表，给我构建一个树出来</span></span><br><span class="line">	root.Right = helper(right)</span><br><span class="line">	<span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/4/">Zurück</a></div><div class="pagination-next"><a href="/page/6/">Weiter</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/4/">4</a></li><li><a class="pagination-link is-current" href="/page/5/">5</a></li><li><a class="pagination-link" href="/page/6/">6</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/31/">31</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://static.ddhigh.com/blog/2019-09-18-094336.jpg" alt="XiaLei"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">XiaLei</p><p class="is-size-6 is-block">Senior Software Engineer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Tencent</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Seiten</p><a href="/archives"><p class="title">306</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Kategorien</p><a href="/categories"><p class="title">25</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">38</p></a></div></div></nav><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/xialeistudio"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="LinkedIn" href="https://www.linkedin.com/in/xialeidoc/"><i class="fa-brands fa-linkedin"></i></a></div></div></div><!--!--></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">Learning &amp; Sharing</a><p class="is-size-7"><span>&copy; 2023 Xia Lei</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en-us");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><a id="back-to-top" title="Zurück nach oben" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "Diese Website verwendet Cookies, um Ihre Erfahrung zu verbessern.",
          dismiss: "Verstanden!",
          allow: "Cookies zulassen",
          deny: "Ablehnen",
          link: "Mehr erfahren",
          policy: "Cookie-Richtlinie",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Tippen Sie etwas..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Tippen Sie etwas...","untitled":"(Ohne Titel)","posts":"Seiten","pages":"Pages","categories":"Kategorien","tags":"Tags"});
        });</script></body></html>