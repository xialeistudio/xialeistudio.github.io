<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Learning &amp; Sharing</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Learning &amp; Sharing"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Learning &amp; Sharing"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Learning &amp;amp; Sharing"><meta property="og:type" content="website"><meta property="og:title" content="Learning &amp; Sharing"><meta property="og:url" content="https://www.ddhigh.com/"><meta property="og:site_name" content="Learning &amp; Sharing"><meta property="og:description" content="Learning &amp;amp; Sharing"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://www.ddhigh.com/img/og_image.png"><meta property="article:author" content="Xia Lei"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://www.ddhigh.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.ddhigh.com"},"headline":"Learning & Sharing","image":["https://www.ddhigh.com/img/og_image.png"],"author":{"@type":"Person","name":"Xia Lei"},"publisher":{"@type":"Organization","name":"Learning & Sharing","logo":{"@type":"ImageObject","url":{"text":"Learning & Sharing"}}},"description":"Learning &amp; Sharing"}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.4.1/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?78141f99bbb49f1564a7af89344f5add";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">Learning &amp; Sharing</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Suche" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Gepostet vor&nbsp;<time dateTime="2019-10-22T04:00:00.000Z" title="10/22/2019, 4:00:00 AM">2019-10-22</time></span><span class="level-item"><a class="link-muted" href="/categories/frontend/">frontend</a><span> / </span><a class="link-muted" href="/categories/frontend/javascript/">javascript</a></span><span class="level-item">7 minutes lesen (Über 1018 Wörter)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/10/22/2019-10-22-let-and-const.html">不只是块级作用域，你不知道的let和const</a></p><div class="content"><p>ES6新增了两个重要的关键字<code>let</code>和<code>const</code>，相信大家都不陌生，但是包括我在内，在系统学习ES6之前也只使用到了【不存在变量提升】这个特性。</p>
<ul>
<li><strong>let</strong>声明一个块级作用域的本地变量</li>
<li><strong>const</strong>语句声明一个块级作用域的本地常量，不可以重新赋值</li>
</ul>
<h2 id="支持块级作用域"><a href="#支持块级作用域" class="headerlink" title="支持块级作用域"></a>支持块级作用域</h2><p><code>var</code>定义的变量会提升到整个函数作用域内，<code>let/const</code>则支持块级作用域。</p>
<blockquote>
<p>块级作用域: 由<code>&#123;&#125;</code>包裹的作用域（函数那种{}不算）</p>
</blockquote>
<p>来看一个<code>var</code>的例子:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br></pre></td></tr></table></figure>

<p>此时输出1，因为<code>var</code>没有块级作用域。</p>
<p>来看一个<code>let</code>的例子(<code>const</code>效果一样):</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br></pre></td></tr></table></figure>

<p>此时会报错<code>ReferenceError</code>，因为<code>let/const</code>支持块级作用域，所以<code>let</code>定义的<code>a</code>只在<code>&#123;&#125;</code>可以访问</p>
<h2 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h2><p>与<code>var</code>不同的是，<code>let/const</code>声明的变量不存在变量提升，也就是说<code>&#123;&#125;</code>对于<code>let/const</code>是有效的。</p>
<p>来看一个<code>var</code>的例子:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>此时会输出undefined，因为var声明的变量会提升到作用域顶部（只提升声明，不提升赋值）</p>
<p>来看一个<code>let</code>的例子(<code>const</code>效果也一样):</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此时会报错<code>ReferenceError</code>，因为<code>let</code>不存在变量提升</p>
<h2 id="同一作用域内不可以重复声明"><a href="#同一作用域内不可以重复声明" class="headerlink" title="同一作用域内不可以重复声明"></a>同一作用域内不可以重复声明</h2><p>同一作用域内<code>let/const</code>不可以重复声明,<code>var</code>可以。</p>
<p>来看一个<code>var</code>的例子:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br></pre></td></tr></table></figure>

<p>此时会输出2，var是支持重复声明的，后面声明的值会覆盖前面声明的值。</p>
<p>来看一个<code>let</code>的例子(<code>const</code>效果也一样):</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br></pre></td></tr></table></figure>

<p>此时会报错<code>SyntaxError</code>，因为同一作用域内<code>let/const</code>不可以重复声明。</p>
<p>再来看一个不同作用域的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br></pre></td></tr></table></figure>

<p>此时输出1，因为两者作用域不同</p>
<h2 id="暂存死区"><a href="#暂存死区" class="headerlink" title="暂存死区"></a>暂存死区</h2><p>**暂存死区TDZ(Temporal Dead Zone)**是ES6中对作用域新的语义。</p>
<p>通过<code>let/const</code>定义的变量直到执行他们的初始化代码时才被初始化。在初始化之前访问<code>该变量</code>会导致<code>ReferenceError</code>。该变量处于<code>一个自作用域顶部到初始化代码</code>之间的“暂存死区”中。</p>
<p>来看以下例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">do_something</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(bar); <span class="comment">// undefined</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">var</span> bar = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> foo = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">do_something</span>();</span><br></pre></td></tr></table></figure>

<p><code>var</code>定义的变量声明会提升到作用域顶部，所以<code>bar</code>是undefined，而<code>let</code>定义的变量<code>从作用域开始到let foo=2</code>这中间都无法访问，访问会报错<code>ReferenceError</code></p>
<h2 id="暂存死区与typeof"><a href="#暂存死区与typeof" class="headerlink" title="暂存死区与typeof"></a>暂存死区与typeof</h2><p>typeof检测var定义的变量或者检测不存在的变量时会返回undefined，如果检测暂存死区内的变量，会报错<code>ReferenceError</code>.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> foo); <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> bar); <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> bar2); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">let</span> bar = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> bar2 = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>也就是说typeof去检测未初始化的<code>let</code>变量时会报错，<code>var</code>或者未声明的变量不会报错</p>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="keyword">var</span> foo = <span class="number">33</span>;</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">let</span> foo = (foo + <span class="number">55</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>();</span><br></pre></td></tr></table></figure>

<p>以上函数执行结果是什么?为什么?</p>
<blockquote>
<p>报错</p>
<p><code>&#123;&#125;</code>内有<code>let</code>定义的<code>foo</code>，所以存在暂存死区，<code>(foo + 55)</code>这个表达式是在<code>let foo</code>之前执行的(赋值时先执行等号右边的，执行完毕把结果赋给等号左边)，表达式执行的时候还没有初始化foo，所以报错<code>ReferenceError</code></p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>let&#x2F;const支持函数作用域和块级作用域,var只有函数作用域</li>
<li>let&#x2F;const不存在变量提升，var存在变量提升</li>
<li>let&#x2F;const同一作用域内不可以重复声明，var可以重复声明</li>
<li>let&#x2F;const存在暂存死区，var不存在</li>
</ol>
<h2 id="面试题-1"><a href="#面试题-1" class="headerlink" title="面试题"></a>面试题</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test4</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(b);</span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test4</span>()</span><br></pre></td></tr></table></figure>

<p><img src="https://static.ddhigh.com/blog/2019-10-22-102654.jpg" alt="0.jpeg"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Gepostet vor&nbsp;<time dateTime="2019-10-15T04:00:00.000Z" title="10/15/2019, 4:00:00 AM">2019-10-15</time></span><span class="level-item"><a class="link-muted" href="/categories/frontend/">frontend</a><span> / </span><a class="link-muted" href="/categories/frontend/javascript/">javascript</a></span><span class="level-item">12 minutes lesen (Über 1816 Wörter)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/10/15/2019-10-15-valueof-and-tostring.html">聊一聊valueOf和toString</a></p><div class="content"><p>valueOf和toString是Object.prototype的方法。一般很少直接调用，但是在使用对象参与运算的时候就会调用这两个方法了。我想大部分人都存在以下疑问：</p>
<ul>
<li>valueOf和toString哪个优先级较高?</li>
<li>是不是所有场景都会调用valueOf和toString</li>
</ul>
<h2 id="概念解释"><a href="#概念解释" class="headerlink" title="概念解释"></a>概念解释</h2><ul>
<li>valueOf: 返回对象的原始值表示</li>
<li>toString: 返回对象的字符串表示</li>
</ul>
<p>在介绍下面的内容之前先了解一下转换规则，下面的内容解释都是基于这个规则表来的：</p>
<h3 id="valueOf转换规则"><a href="#valueOf转换规则" class="headerlink" title="valueOf转换规则"></a>valueOf转换规则</h3><p>valueOf是Object.prototype的方法，由Object来的对象都会有该方法，但是很多内置对象会重写这个方法，以适合实际需要。</p>
<p>说到原始值就必须说到原始类型，JS规范中 <strong>原始类型</strong> 如下：</p>
<ul>
<li>Boolean</li>
<li>Null</li>
<li>Undefined</li>
<li>Number</li>
<li>String</li>
</ul>
<p>非原始值(也就是对象)重写规则如下：</p>
<table>
<thead>
<tr>
<th>对象</th>
<th>valueOf返回值</th>
</tr>
</thead>
<tbody><tr>
<td>Array</td>
<td>数组本身</td>
</tr>
<tr>
<td>Boolean</td>
<td>布尔值</td>
</tr>
<tr>
<td>Date</td>
<td>返回毫秒形式的时间戳</td>
</tr>
<tr>
<td>Function</td>
<td>函数本身</td>
</tr>
<tr>
<td>Number</td>
<td>数字值</td>
</tr>
<tr>
<td>Object</td>
<td>对象本身</td>
</tr>
<tr>
<td>String</td>
<td>字符串值</td>
</tr>
</tbody></table>
<blockquote>
<p>以下规则是经过验证的，如果对验证过程不关心，可以只看转换规则。</p>
<p>建议看一下验证过程，这样可以加深理解</p>
</blockquote>
<h4 id="对象转换为布尔值"><a href="#对象转换为布尔值" class="headerlink" title="对象转换为布尔值"></a>对象转换为布尔值</h4><ol>
<li>直接转换为true（包装类型也一样），不调用valueOf和toString</li>
</ol>
<h4 id="对象转换为数字"><a href="#对象转换为数字" class="headerlink" title="对象转换为数字"></a>对象转换为数字</h4><p>在预期会将对象用作数字使用时，比如参与算术运算等等操作，对象转换为数字会依次调用valueOf和toString方法，具体规则如下：</p>
<ol>
<li>如果对象具有<code>valueOf</code>方法且返回原始值(string、number、boolean、undefined、null)，则将该原始值转换为数字(转换失败会返回NaN)，并返回这个数字</li>
<li>如果对象具有<code>toString</code>方法且返回原始值(string、number、boolean、undefined、null)，则将该原始值转换为数字(转换失败会返回NaN)，并返回这个数字</li>
<li>转换失败，抛出TypeError</li>
</ol>
<h4 id="对象转换为字符串"><a href="#对象转换为字符串" class="headerlink" title="对象转换为字符串"></a>对象转换为字符串</h4><ol>
<li>如果对象具有<code>toString</code>方法且返回原始值(string、number、boolean、undefined、null)，则将该原始值转换为字符串，并返回该字符串</li>
<li>如果对象具有<code>valueOf</code>方法且返回原始值(string、number、boolean、undefined、null)，则将该原始值转换为字符串，并返回该字符串</li>
<li>转换失败，抛出TypeError</li>
</ol>
<h3 id="toString转换规则"><a href="#toString转换规则" class="headerlink" title="toString转换规则"></a>toString转换规则</h3><table>
<thead>
<tr>
<th>对象</th>
<th>toString返回值</th>
</tr>
</thead>
<tbody><tr>
<td>Array</td>
<td>以逗号分割的字符串，如[1,2]的toString返回值为”1,2”</td>
</tr>
<tr>
<td>Boolean</td>
<td>“True”</td>
</tr>
<tr>
<td>Date</td>
<td>可读的时间字符串，如”Tue Oct 15 2019 12:20:56 GMT+0800 (中国标准时间)”</td>
</tr>
<tr>
<td>Function</td>
<td>声明函数的JS源代码字符串</td>
</tr>
<tr>
<td>Number</td>
<td>“数字值”</td>
</tr>
<tr>
<td>Object</td>
<td>“[object Object]”</td>
</tr>
<tr>
<td>String</td>
<td>“字符串”</td>
</tr>
</tbody></table>
<h2 id="验证对象到原始值的转换"><a href="#验证对象到原始值的转换" class="headerlink" title="验证对象到原始值的转换"></a>验证对象到原始值的转换</h2><p>光看valueOf和toString没啥东西可说，日常开发中也很少直接调用，但是当我们将对象当做原始值来使用时会发生转换，而且转换过程还略微有点迷糊。</p>
<h3 id="对象转换为Boolean"><a href="#对象转换为Boolean" class="headerlink" title="对象转换为Boolean"></a>对象转换为Boolean</h3><p>为了能够直观的看到JS内部的转换过程，我把valueOf和toString都简单重写了，加了日志。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存原始的valueOf</span></span><br><span class="line"><span class="keyword">var</span> valueOf = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">valueOf</span>;</span><br><span class="line"><span class="keyword">var</span> toString = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加valueOf日志</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">valueOf</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;valueOf&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> valueOf.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 添加toString日志</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;toString&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> toString.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(b) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上例子的输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<blockquote>
<p>未调用valueOf和toString，符合[对象到布尔值]的转换规则</p>
</blockquote>
<h3 id="对象转换为Number"><a href="#对象转换为Number" class="headerlink" title="对象转换为Number"></a>对象转换为Number</h3><h4 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存原始的valueOf</span></span><br><span class="line"><span class="keyword">var</span> valueOf = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">valueOf</span>;</span><br><span class="line"><span class="keyword">var</span> toString = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加valueOf日志</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">valueOf</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;valueOf&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> valueOf.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 添加toString日志</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;toString&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> toString.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(++a);</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">valueOf</span><br><span class="line">toString</span><br><span class="line">NaN</span><br></pre></td></tr></table></figure>

<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><ol>
<li>valueOf方法返回的是对象本身，不是原始值，继续执行</li>
<li>toString方法返回的是”[object Object]”，是原始值(字符串)，将字符串转换为数字NaN</li>
</ol>
<h4 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存原始的valueOf</span></span><br><span class="line"><span class="keyword">var</span> valueOf = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">valueOf</span>;</span><br><span class="line"><span class="keyword">var</span> toString = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加valueOf日志</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">valueOf</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;valueOf&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>; <span class="comment">// 强制返回原始值</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 添加toString日志</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;toString&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> toString.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(++a);</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">valueOf</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><ol>
<li>valueOf返回原始值(字符串)，直接将该字符串转换为数字，得到1</li>
</ol>
<h3 id="对象转换为字符串-1"><a href="#对象转换为字符串-1" class="headerlink" title="对象转换为字符串"></a>对象转换为字符串</h3><p>在预期会将对象用作字符串时，比如一个字符串拼接了字符串，传入了一个对象，此时会发生转换。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存原始的valueOf</span></span><br><span class="line"><span class="keyword">var</span> valueOf = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">valueOf</span>;</span><br><span class="line"><span class="keyword">var</span> toString = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加valueOf日志</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">valueOf</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;valueOf&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> valueOf.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 添加toString日志</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;toString&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> toString.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line"><span class="title function_">alert</span>(a);</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">toString</span><br><span class="line">// 弹出[object Object]</span><br></pre></td></tr></table></figure>

<h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><ol>
<li>调用toString方法，返回了字符串”[object Object]”，对象最终转换为该字符串</li>
</ol>
<h4 id="例子2-1"><a href="#例子2-1" class="headerlink" title="例子2"></a>例子2</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存原始的valueOf</span></span><br><span class="line"><span class="keyword">var</span> valueOf = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">valueOf</span>;</span><br><span class="line"><span class="keyword">var</span> toString = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加valueOf日志</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">valueOf</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;valueOf&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> valueOf.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 添加toString日志</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;toString&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line"><span class="title function_">alert</span>(a);</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">toString</span><br><span class="line">valueOf</span><br><span class="line">Uncaught TypeError: Cannot convert object to primitive value</span><br><span class="line">    at 1.js:16</span><br></pre></td></tr></table></figure>

<h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><ol>
<li>调用toString方法，返回的不是原始值，继续执行</li>
<li>调用valueOf方法，返回的不是原始值，继续执行</li>
<li>抛出TypeError</li>
</ol>
<p>##【番外】使用加号运算符连接字符串和对象时的处理</p>
<p>在测试对象到字符串转换时发现如下代码的表现和预期并不一致：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存原始的valueOf</span></span><br><span class="line"><span class="keyword">var</span> valueOf = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">valueOf</span>;</span><br><span class="line"><span class="keyword">var</span> toString = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加valueOf日志</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">valueOf</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;valueOf&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> valueOf.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 添加toString日志</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;toString&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> toString.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a&quot;</span> + &#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">valueOf</span><br><span class="line">toString</span><br><span class="line">a[object Object]</span><br></pre></td></tr></table></figure>

<h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><p><code>&quot;a&quot;+ &#123;&#125;</code> 应该是预期把<code>&#123;&#125;</code>当做字符串使用，应该先调用toString方法的，实际情况却不是这样。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>通过查找资料得到的结论如下：</p>
<ol>
<li>如果有一个是对象，则遵循对象对原始值的转换过程(Date对象直接调用toString完成转换，其他对象通过valueOf转化，如果转换不成功则调用toString)</li>
<li>如果两个都是对象，两个对象都遵循步骤1转换到字符串</li>
<li>两个数字，进行算数运算</li>
<li>两个字符串，直接拼接</li>
<li>一个字符串一个数字，直接拼接为字符串</li>
</ol>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> b = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> c = &#123;&#125;;</span><br><span class="line">c[a] = <span class="number">1</span>;</span><br><span class="line">c[b] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c[a]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c[b]);</span><br></pre></td></tr></table></figure>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>由于对象的key是字符串，所以<code>c[a]</code>和<code>c[b]</code>中的<code>a</code>和<code>b</code>会执行[对象到字符串]的转换。</p>
<p>根据转换规则, <code>a</code>和<code>b</code>都转换为了<code>[object Object]</code>，所以<code>c[a]</code>和<code>c[b]</code>操作的是同一个键。</p>
<p>答案是<code>输出两个2</code>，c对象的最终结构如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&#x27;[object Object]&#x27;</span>:<span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://static.ddhigh.com/blog/2019-10-15-093620.jpg" alt="0.jpeg"></p>
<p><img src="https://static.ddhigh.com/blog/2021-02-25-113209-2.png" alt="image-20210225113209566"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Gepostet vor&nbsp;<time dateTime="2019-10-14T04:00:00.000Z" title="10/14/2019, 4:00:00 AM">2019-10-14</time></span><span class="level-item"><a class="link-muted" href="/categories/frontend/">frontend</a><span> / </span><a class="link-muted" href="/categories/frontend/javascript/">javascript</a></span><span class="level-item">6 minutes lesen (Über 957 Wörter)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/10/14/2019-10-14-js-Closure.html">搞懂JS闭包</a></p><div class="content"><p>闭包(Closure)是JS比较难懂的一个东西，或者说别人说的难以理解， 本文将以简洁的语言+面试题来深入浅出地介绍一下。</p>
<h2 id="作用域和作用域链"><a href="#作用域和作用域链" class="headerlink" title="作用域和作用域链"></a>作用域和作用域链</h2><p>在将闭包之前，需要先讲一下作用域。</p>
<p>JS中有全局作用域和局部作用域两种。</p>
<p>全局作用域任何地方都能访问，而局部作用于只有内部能访问。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> num = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num);</span><br></pre></td></tr></table></figure>

<p>在上面的例子中会报错，num不存在。</p>
<blockquote>
<p>总结：函数外部无法访问函数内部的值</p>
</blockquote>
<p>当代码在一个作用域中执行时，JS引擎会默认创建一个作用域链(从当前作用域一直链接到全局作用域)。</p>
<p>在访问变量或者函数时，如果当前作用域查找不到，则向上级作用域查找，找到就返回，如果查找到全局作用域还没找到的话就报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> num = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(num);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，num是在<code>a</code>函数作用域下的局部变量，我们在<code>b</code>函数访问num时会有以下过程：</p>
<ol>
<li>在<code>b</code>的作用域查找num，发现找不到</li>
<li>往上一级作用域查找，发现num在<code>a</code>作用域，查找成功</li>
</ol>
<blockquote>
<p>总结：函数可以访问同级或上级作用域的值</p>
</blockquote>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>当我们需要在函数外部访问函数内部的值时，闭包就产生了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> num = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">b</span> () &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(num);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bb = <span class="title function_">a</span>();</span><br><span class="line"><span class="title function_">bb</span>(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在函数<code>a</code>的内部声明一个函数<code>b</code>，然后把<code>return b</code>，这个时候的<code>b()</code>函数就可以在外部访问，最终能够访问到num。</p>
</blockquote>
<p>简单来说：</p>
<blockquote>
<p>闭包就是函数内部的函数，上面的那个b就是闭包，可以在外面访问到内部的num</p>
</blockquote>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每隔1秒输出0-10的数字</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  &#125;,<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面这段代码输出什么?如果需要修改为正确的情况，怎么修改？</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>1秒后输出10，因为setTimeout是到下一轮tick中执行，而for循环在当前这轮循环完毕后i的值已经是最后一个值了。需要使用闭包来保留现场</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    (<span class="keyword">function</span> (<span class="params">i</span>) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;(i))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就是正常的输出了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;Window&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Object&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">f</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(object.<span class="title function_">f</span>()());</span><br></pre></td></tr></table></figure>

<p>答案是Window。</p>
<blockquote>
<p><code>object.getNameFunc()()</code>可以分开两部分来看。</p>
<ol>
<li>object.f()得到了一个这样的函数</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>object.f()()</code>相当于执行上面那个函数，也就是<code>普通函数调用方式</code>，this指向<code>全局环境</code>，this指向搞不清楚的同学可以看看我之前发的<a href="https://www.ddhigh.com/2019/09/27/javascript-this.html">Javavscript基础——this指向</a></li>
<li>所以this.name也就是<code>var name = &quot;Window&quot;</code></li>
</ol>
</blockquote>
<p>还是那道题，不过我们把this保存一下，变成下面这种形式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;Window&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Object&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">f</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="variable language_">this</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> that.<span class="property">name</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(object.<span class="title function_">f</span>()());</span><br></pre></td></tr></table></figure>

<p>答案是Object。</p>
<blockquote>
<ol>
<li>object.f()中调用时这个this指向object，当用变量保存时，这个that相当于object</li>
<li>object.f()()调用时，由于that相当于object，所以that.name就是object中的Object</li>
</ol>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>闭包可以在外部访问函数内部的变量</li>
<li>闭包可以保留现场</li>
</ol>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>来道面试题给大家看看吧</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buttons = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.btn&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; buttons.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  buttons[i].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上例子显示什么?如果需要正常显示需要怎么修改?</p>
<p><img src="https://static.ddhigh.com/blog/2019-10-14-103646.jpg" alt="0.jpeg"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Gepostet vor&nbsp;<time dateTime="2019-10-11T04:00:00.000Z" title="10/11/2019, 4:00:00 AM">2019-10-11</time></span><span class="level-item"><a class="link-muted" href="/categories/frontend/">frontend</a></span><span class="level-item">15 minutes lesen (Über 2301 Wörter)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/10/11/2019-10-11-https-protocol.html">HTTPS协议是如何保证安全的?</a></p><div class="content"><p>相信大家对于HTTPS协议都不陌生，但是应该存在以下疑问：</p>
<ol>
<li><p>HTTPS协议到底是如何运作的?</p>
</li>
<li><p>HTTPS是如何解决HTTP协议的不安全特性的?</p>
</li>
<li><p>HTTPS网站抓包为什么要信任证书?</p>
</li>
</ol>
<h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>HTTP协议是一个<strong>应用层</strong>协议，通常运行在TCP协议之上。它是一个<code>明文协议</code>，客户端发起请求，服务端给出响应的响应。</p>
<p>由于网络并不是可信任的，HTTP协议的明文特性会存在以下风险：</p>
<ul>
<li>通信数据有被窃听和被篡改的风险</li>
<li>目标网站有被冒充的风险</li>
</ul>
<p>一般的网站可能没什么影响，但是如果是银行这种网站呢?</p>
<p>好在国内的银行在HTTP协议时代针对IE开发了ActiveX插件来保证安全性，这一点算是值得点赞了。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>既然HTTP协议是明文协议，如果对数据进行加密之后是否就能保证安全性了呢?</p>
<p>在回答这个问题之前，我们先看看比较常见的两种加密算法。</p>
<h3 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h3><p>常见的有对称加密算法和非对称加密算法。</p>
<p><strong>对称加密</strong></p>
<p>加密和解密使用同一个密钥。加解密效率比非对称加密高。但是密钥一旦泄露，通信就不安全了</p>
<p><strong>非对称加密</strong></p>
<p>存在密钥对，公钥加密私钥解密或者私钥加密公钥解密，无法通过公钥反推私钥，也无法通过私钥反推公钥。</p>
<blockquote>
<p>一般情况下，使用非对称加密来传输通信所用的密钥，通信过程中采用对称加密，可以解决对称加密的安全问题以及非对称加密的性能问题。</p>
</blockquote>
<h3 id="HTTP加密通信过程"><a href="#HTTP加密通信过程" class="headerlink" title="HTTP加密通信过程"></a>HTTP加密通信过程</h3><ol>
<li>浏览器生成随机串A作为通信密钥</li>
<li>浏览器使用公钥将随机串A加密后得到密文B发送给服务器，这一步是安全的，因为黑客没有服务端私钥无法解密</li>
<li>服务端利用私钥解密出随机串A得到通信密钥</li>
<li>服务端和客户端用随机串A以及对称加密算法进行通信</li>
</ol>
<p>这么一看似乎没有问题，毕竟黑客无法破解非对称加密的的内容，但是浏览器是如何得到公钥的?</p>
<p>有以下两种办法：</p>
<ol>
<li>浏览器内置(不太可能，网站域名这么多，浏览器内置这么多公钥不现实)</li>
<li>服务器给浏览器下发(由于是明文下发，存在被窃听和篡改风险，也就是著名的中间人攻击)</li>
</ol>
<h3 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h3><ol>
<li>浏览器请求服务器获取公钥</li>
<li>中间人劫持了服务器的公钥，保存在自己手里</li>
<li>中间人生成一对密钥对，把伪造的公钥下发给浏览器</li>
<li>浏览器使用伪造的公钥和中间人通信</li>
<li>中间人和服务器进行通信</li>
</ol>
<blockquote>
<p>由于浏览器使用了伪造的公钥进行通信，所以通信过程是不可靠的</p>
</blockquote>
<h3 id="需要解决的问题"><a href="#需要解决的问题" class="headerlink" title="需要解决的问题"></a>需要解决的问题</h3><p>只要保证浏览器得到的公钥是目标网站的公钥即可保证通信安全，那么问题来了，如何在不可靠的网络上安全的传输公钥呢?</p>
<p>这就是HTTPS协议需要解决的问题</p>
<h2 id="HTTPS协议"><a href="#HTTPS协议" class="headerlink" title="HTTPS协议"></a>HTTPS协议</h2><p>HTTPS协议涉及到的知识很多，本文只关注<strong>密钥安全交换部分</strong>，这也是HTTPS协议的精华。</p>
<p>HTTPS协议引入了<strong>CA</strong>和<strong>数字证书</strong>的概念。</p>
<h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><p>包含签发机构、有效期、申请人公钥、证书所有者、证书签名算法、证书指纹以及指纹算法等信息。</p>
<h3 id="CA"><a href="#CA" class="headerlink" title="CA"></a>CA</h3><p>数字证书签发机构，权威CA是受操作系统信任的，安装操作系统就会内置。</p>
<h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>用Hash算法对数据进行计算得到Hash值，利用私钥对该Hash加密得到签名。</p>
<p>只有匹配的公钥才能解密出签名，来保证签名是本人私钥签发的</p>
<h3 id="证书签发过程"><a href="#证书签发过程" class="headerlink" title="证书签发过程"></a>证书签发过程</h3><ol>
<li>网站生成密钥对，将私钥自己保存，公钥和网站域名等信息提交给CA</li>
<li>CA把证书签发机构(也就是自己)、证书有效期、网站的公钥、网站域名等信息以<strong>明文</strong>形式写入到一个文本文件</li>
<li>CA选择一个<strong>指纹算法</strong>(一般为hash算法)计算文本文件的内容得到<strong>指纹</strong>，用CA的<strong>私钥</strong>对<strong>指纹</strong>和<strong>指纹算法</strong>进行加密得到<strong>数字签名</strong>，签名算法包含在证书的<strong>明文</strong>部分</li>
<li>CA把明文证书、指纹、指纹算法、数字签名等信息打包在一起得到证书下发给服务器</li>
<li>此时服务器拥有了权威CA颁发的数字证书以及自己的私钥</li>
</ol>
<h3 id="证书验证过程"><a href="#证书验证过程" class="headerlink" title="证书验证过程"></a>证书验证过程</h3><p>浏览器是如何验证网站的有效性的呢?</p>
<ol>
<li>浏览器以HTTPS协议请求服务器的443端口</li>
<li>服务器下发自己的数字证书给浏览器(明文)</li>
<li>浏览器先校验CA、有效期、域名是否有效，如果无效，则终止连接(服务器此时不可信任)</li>
<li>如果有效，则从<strong>操作系统</strong>取出证书颁发机构的公钥，根据<strong>签名算法</strong>对<strong>数字签名</strong>解密得到<strong>证书指纹</strong>和<strong>指纹算法</strong></li>
<li>浏览器用解密得到的指纹算法计算证书的指纹，与解密得到的指纹进行比对，如果一致，证书有效，公钥也安全拿到了</li>
<li>浏览器此时已经和真实的服务器进行通信了，中间人无法得知通信内容，因为中间人没有网站私钥</li>
</ol>
<h3 id="问题是如何解决的"><a href="#问题是如何解决的" class="headerlink" title="问题是如何解决的"></a>问题是如何解决的</h3><ol>
<li><p>黑客冒充CA给了一个假证书给浏览器</p>
<blockquote>
<p>浏览器通过CA名称从操作系统取出CA公钥时对数字签名进行解密，发现解密失败，证明这个CA签名用的私钥和操作系统内置的不是一对，就发现了伪造</p>
</blockquote>
</li>
<li><p>黑客篡改了证书中的网站公钥</p>
<blockquote>
<p>证书中的网站公钥可以被篡改，但是数字签名是CA私钥计算出来的，黑客无法计算数字签名，浏览器用内置的CA公钥对数字签名解密时就会发现指纹不匹配了，这也发现了伪造</p>
</blockquote>
</li>
<li><p>黑客也能正常获取网站公钥</p>
<blockquote>
<p>的确，黑客自己通过浏览器访问网站时也能得到公钥，这个公钥跟正常用户的公钥是一致的。</p>
<p>但是每个客户端和服务器通信使用的对称密钥都是临时生成且随机的，黑客只能知道自己的随机密钥，但是不知道其他的随机密钥</p>
</blockquote>
</li>
</ol>
<p>综上，浏览器通过操作系统内置权威CA公钥的方式解决了网站公钥下发问题。</p>
<h2 id="HTTPS中间人攻击"><a href="#HTTPS中间人攻击" class="headerlink" title="HTTPS中间人攻击"></a>HTTPS中间人攻击</h2><p>HTTPS从协议上解决了HTTP时代的中间人攻击问题，但是HTTPS在用户主动信任了伪造证书的时候也会发生中间人攻击(比如早期的12306需要手动信任证书)，HTTPS中间人攻击流程如下：</p>
<ol>
<li>客户端用HTTPS连接服务器的443端口</li>
<li>服务器下发自己的数字证书给客户端</li>
<li>黑客劫持了服务器的真实证书，并伪造了一个假的证书给浏览器</li>
<li>浏览器可以发现得到的网站证书是假的，但是浏览器选择信任</li>
<li>浏览器生成随机对称密钥A，用伪造的证书中的公钥加密发往服务器</li>
<li>黑客同样可以劫持这个请求，得到浏览器的对称密钥A，从而能够窃听或者篡改通信数据</li>
<li>黑客利用服务器的真实公钥将客户端的对称密钥A加密发往服务器</li>
<li>服务器利用私钥解密这个对称密钥A之后与黑客通信</li>
<li>黑客利用对称密钥A解密服务器的数据，篡改之后利用对称密钥A加密发给客户端</li>
<li>客户端收到的数据已经是不安全的了</li>
</ol>
<blockquote>
<p>以上就是HTTPS中间人攻击的原理，这也就是HTTPS抓包为什么要信任证书的原因。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>操作系统内置权威CA公钥来保证数字签名以及数字证书的安全性</li>
<li>实施HTTPS中间人攻击需要手动信任攻击者的假证书</li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Gepostet vor&nbsp;<time dateTime="2019-09-27T04:00:00.000Z" title="9/27/2019, 4:00:00 AM">2019-09-27</time></span><span class="level-item"><a class="link-muted" href="/categories/frontend/">frontend</a><span> / </span><a class="link-muted" href="/categories/frontend/javascript/">javascript</a></span><span class="level-item">13 minutes lesen (Über 1904 Wörter)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/09/27/2019-09-27-javascript-this.html">Javavscript基础——this指向</a></p><div class="content"><p>本文研究一下Javascript的this指向。</p>
<p>Javascript的this指向问题，有些人可能觉得很简单，有些人却觉得扑朔迷离，看完本文之后相应会对this的掌握有一个直观的判断，而不是”开局全靠猜”。</p>
<h2 id="敲黑板"><a href="#敲黑板" class="headerlink" title="敲黑板"></a>敲黑板</h2><ol>
<li><p>function函数this指向由<code>调用方式</code>确定，跟定义环境无关。</p>
</li>
<li><p>箭头函数this指向由<code>定义环境</code>决定，与<code>调用方式无关</code>，也不可以<code>bind(this)</code>。</p>
</li>
</ol>
<h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><ol>
<li><p>非严格模式下，全局作用域下的this指向<code>window</code></p>
</li>
<li><p>严格模式下，全局作用域下的this指向<code>undefined</code></p>
</li>
</ol>
<p>以下讨论均为<code>非严格模式</code>，这个不影响今天的讨论。</p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>说结论往往是让人难以理解的，下面通过不同的调用场景对this做一个说明。</p>
<h3 id="1-直接调用"><a href="#1-直接调用" class="headerlink" title="1. 直接调用"></a>1. 直接调用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>(); <span class="comment">// 输出undefined</span></span><br></pre></td></tr></table></figure>

<p>直接调用是最简单的， 大部分人在这里都能回答的很好。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote>
<p>直接调用时this指向<code>全局作用域</code>。</p>
<ul>
<li>非严格模式this指向window</li>
<li>严格模式this指向undefined</li>
</ul>
</blockquote>
<h3 id="2-对象调用"><a href="#2-对象调用" class="headerlink" title="2. 对象调用"></a>2. 对象调用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  <span class="attr">n</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">n</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a.<span class="title function_">b</span>(); <span class="comment">// 输出2</span></span><br><span class="line"><span class="keyword">var</span> b = a.<span class="property">b</span>;</span><br><span class="line"><span class="title function_">b</span>(); <span class="comment">// 输出1</span></span><br></pre></td></tr></table></figure>

<h4 id="面试题：请问上述例子输出什么"><a href="#面试题：请问上述例子输出什么" class="headerlink" title="面试题：请问上述例子输出什么?"></a>面试题：请问上述例子输出什么?</h4><blockquote>
<p>非严格模式下，输出2和1，严格模式下输出2和一个报错(this指向undefined，访问undefined的n属性肯定报错)</p>
</blockquote>
<p>那如果你这么回答，<code>满分</code>!</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>知其然还要知其所以然，我们分析一下：</p>
<p>为什么输出2?</p>
<blockquote>
<p> 因为<code>a.b()</code>是对象调用方式，所以b()中的this指向a</p>
</blockquote>
<p>为什么输出1?</p>
<p>这个非常有意思，而且也很有迷惑性，面试的时候经常问到，也经常有人被问倒。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = a.<span class="property">b</span></span><br></pre></td></tr></table></figure>

<p>把<code>a.b</code>赋值给<code>变量b</code>，b就是一个函数，<code>请注意: 这里只是赋值，没有调用，所以b中的this指向还不确定</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b();</span><br></pre></td></tr></table></figure>

<p>调用函数<code>b</code>，这是什么调用方式? **<code>普通调用</code>**，所以this指向全局作用域。</p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>对象调用方式下this指向调用对象。</p>
<p>是否GET? 如果没有GET，请关注公众号<code>NodeJs之路</code>，我在线给你答疑。</p>
<p>开胃菜已经吃了，下面来点”有难度的(实际上也没啥难度)”。</p>
<h3 id="3-嵌套对象调用"><a href="#3-嵌套对象调用" class="headerlink" title="3. 嵌套对象调用"></a>3. 嵌套对象调用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  <span class="attr">n</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">b</span>: &#123;</span><br><span class="line">    <span class="attr">n</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">c</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">n</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="面试题：请问上述例子中function中的this指向哪里"><a href="#面试题：请问上述例子中function中的this指向哪里" class="headerlink" title="面试题：请问上述例子中function中的this指向哪里?"></a>面试题：请问上述例子中function中的this指向哪里?</h4><blockquote>
<p>正确答案：<code>未确定调用环境</code>的情况下，this的指向<code>不确定</code>。</p>
<p>错误答案：指向a.b对象，Too young too simple!</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  <span class="attr">n</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">b</span>: &#123;</span><br><span class="line">    <span class="attr">n</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">c</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">n</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a.<span class="property">b</span>.<span class="title function_">c</span>(); <span class="comment">// 输出3</span></span><br><span class="line"></span><br><span class="line">a.<span class="property">c</span> = a.<span class="property">b</span>.<span class="property">c</span>;</span><br><span class="line">a.<span class="title function_">c</span>(); <span class="comment">// 输出2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = a.<span class="property">b</span>.<span class="property">c</span>; </span><br><span class="line"><span class="title function_">c</span>(); <span class="comment">// 输出1</span></span><br></pre></td></tr></table></figure>

<p>这道题跟之前那道<code>对象调用</code>很像。</p>
<p>为什么输出3?</p>
<blockquote>
<p>对象调用方式下指向调用对象，a.b.c()中c()是通过<code>a.b</code>对象调用，指向对象<code>a.b</code></p>
</blockquote>
<p>为什么输出?</p>
<blockquote>
<p>a.c &#x3D; a.b.c 给a对象定义一个函数c，注意，此时没有调用！this指向不确定</p>
<p>a.c() 通过a对象来调用c()，所以this指向对象<code>a</code></p>
</blockquote>
<p>为什么输出1？</p>
<blockquote>
<p>var c &#x3D; a.b.c 函数赋值给普通变量，注意，此时没有调用!</p>
<p>c(); 普通方式调用，指向window</p>
</blockquote>
<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>嵌套对象调用方式下，this指向<code>最终调用</code>函数的对象。</p>
<p><code>a.b.c.d.e.f.g.h()</code> h函数中的this指向<code>a.b.c.d.e.f.g</code></p>
<h3 id="4-构造函数方式调用"><a href="#4-构造函数方式调用" class="headerlink" title="4. 构造函数方式调用"></a>4. 构造函数方式调用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1= <span class="title class_">Person</span>(); <span class="comment">// p1为undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">name</span>); <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2.<span class="property">name</span>); <span class="comment">// 输出2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>p1为什么是undefined?</p>
<blockquote>
<p>这道题比较坑，跟调用方式和this指向无关，因为Person函数没有返回值，js中，默认会返回undefined.</p>
</blockquote>
<p>p2.name为什么是2?</p>
<blockquote>
<p>使用new操作符时，构造函数的返回值<code>默认</code>指向对象实例，所以p2.name就是Person()中的this.name</p>
</blockquote>
<p>如果在<code>Person()</code>函数中加上<code>return this</code>的话，<code>Person()</code>返回值还是<code>this</code>，因为这是普通调用。</p>
<h3 id="5-构造函数中指明返回值"><a href="#5-构造函数中指明返回值" class="headerlink" title="5. 构造函数中指明返回值"></a>5. 构造函数中指明返回值</h3><p>原则上构造函数不应该有返回值，但是如果真的写了会怎么样？我们来探讨一下。</p>
<h4 id="返回复杂对象"><a href="#返回复杂对象" class="headerlink" title="返回复杂对象"></a>返回复杂对象</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">name</span>)<span class="comment">// 输出undefined</span></span><br></pre></td></tr></table></figure>

<h4 id="返回简单对象"><a href="#返回简单对象" class="headerlink" title="返回简单对象"></a>返回简单对象</h4><p>虽然Js只有对象，但是有一些如string,number这种一般叫做简单对象,date,regex,array,object等等叫复杂对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">name</span>)<span class="comment">// 输出2</span></span><br></pre></td></tr></table></figure>

<h4 id="返回null"><a href="#返回null" class="headerlink" title="返回null"></a>返回null</h4><p>使用<code>typeof null</code>返回的是<code>[object]</code>，证明null是个对象，不过咱们来看看构造函数返回null的表现。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">name</span>)<span class="comment">// 输出2</span></span><br></pre></td></tr></table></figure>

<h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p>构造函数中this指向对象实例本身，如果构造函数指明了返回值，那么表现如下：</p>
<ul>
<li>返回普通值，this指向不变，还是对象实例本身</li>
<li>返回复杂对象，this指向新对象，也就是你new Person()返回的是那个新对象</li>
</ul>
<h3 id="6-bind"><a href="#6-bind" class="headerlink" title="6. bind"></a>6. bind</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  <span class="attr">n</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> b = &#123;</span><br><span class="line">  <span class="attr">n</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">n</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fa = f.<span class="title function_">bind</span>(a);</span><br><span class="line"><span class="keyword">var</span> fb = fa.<span class="title function_">bind</span>(b);</span><br><span class="line"></span><br><span class="line"><span class="title function_">fa</span>(); <span class="comment">// 输出1</span></span><br><span class="line"><span class="title function_">fb</span>(); <span class="comment">// 输出1</span></span><br></pre></td></tr></table></figure>
<p>  第1个输出1应该不难理解，bind可以更改function内部的this指向。多次bind已经bind过的函数，this指向不变。</p>
<p>bind的实现原理有点复杂，将在下一篇文章进行详细解读。</p>
<h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><p>bind可以手动绑定function的this，<code>this</code>指向<code>第1次</code>bind时的this。</p>
<h3 id="7-apply-x2F-call"><a href="#7-apply-x2F-call" class="headerlink" title="7. apply&#x2F;call"></a>7. apply&#x2F;call</h3><p>这两个函数在this指向上表现一致，放到一起讲</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  <span class="attr">n</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> b = &#123;</span><br><span class="line">  <span class="attr">n</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">n</span>);</span><br><span class="line">&#125;</span><br><span class="line">f.<span class="title function_">call</span>(a); <span class="comment">// 输出1</span></span><br><span class="line">f.<span class="title function_">apply</span>(b); <span class="comment">// 输出2</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>call和apply的第1个参数为function执行时的this，这个this是确定的，对未使用过bind的函数进行多次apply&#x2F;call，this指向都会改变。</p>
</blockquote>
<h3 id="8-箭头函数"><a href="#8-箭头函数" class="headerlink" title="8. 箭头函数"></a>8. 箭头函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = &#123;</span><br><span class="line">  <span class="attr">n</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">a</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">n</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">b.<span class="title function_">a</span>(); <span class="comment">// 输出1</span></span><br><span class="line">b.<span class="property">a</span>.<span class="title function_">call</span>(&#123;<span class="attr">n</span>:<span class="number">3</span>&#125;); <span class="comment">// 输出1</span></span><br></pre></td></tr></table></figure>

<p>b.a定义时的this和<code>n</code>,<code>b</code>所在的<code>this一致</code>，默认情况下为全局作用域</p>
<blockquote>
<p>箭头函数的this指向定义时所在的this，这个是明确的，但是如果定义时所在的是1个function，那么this指向同上面7点。</p>
</blockquote>
<p><em>说下我之前学JS遇到过的问题: ES5下function才会有作用域隔离, {}这种玩意不会隔离作用域。</em></p>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><ol>
<li><p>直接调用this指向全局作用域window，严格模式指向undefined</p>
</li>
<li><p>对象调用方式指向调用对象</p>
</li>
<li><p>嵌套对象调用方式指向最终调用对象(离function最近的那个)</p>
</li>
<li><p>构造函数方式调用指向对象实例</p>
<ol>
<li>构造函数返回String&#x2F;Number等简单类型时this指向不变，返回null指向也不变</li>
<li>构造函数返回Object&#x2F;Array等复杂对象时，new Person()的返回值为return的对象</li>
</ol>
</li>
<li><p>bind可以更改function的this,一经绑定，永不改变。<code>但是并不执行函数</code></p>
</li>
<li><p>apply&#x2F;call可以更改没有被bind过的this</p>
</li>
<li><p>箭头函数的<code>this</code>指向为<code>定义</code>箭头函数的<code>this</code></p>
</li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Gepostet vor&nbsp;<time dateTime="2019-09-23T04:00:00.000Z" title="9/23/2019, 4:00:00 AM">2019-09-23</time></span><span class="level-item"><a class="link-muted" href="/categories/frontend/">frontend</a><span> / </span><a class="link-muted" href="/categories/frontend/javascript/">javascript</a></span><span class="level-item">12 minutes lesen (Über 1816 Wörter)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/09/23/2019-09-23-javascript-prototype.html">Javavscript基础——原型和原型链</a></p><div class="content"><p>本文研究一下Javascript的核心基础——原型链和继承。</p>
<p>对于使用过基于类的语言(如Java或C#)的人来说，Javascript的继承有点难以搞懂，因为它本身没有<code>class</code>这种东西。(ES6中引入了<code>class</code>关键字，看上去也像传统的OOP语言，但是那只是语法糖，底层还是基于原型)。</p>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>MDN上对于原型链的解释：</p>
<blockquote>
<p>当谈到继承时，JavaScript 只有一种结构：对象。每个实例对象（ object ）都有一个私有属性（称之为 <code>__proto__</code> ）指向它的构造函数的原型对象（<code>prototype</code> ）。该原型对象也有一个自己的原型对象( <code>__proto__</code> ) ，层层向上直到一个对象的原型对象为 <code>null</code>。根据定义，<code>null</code> 没有原型，并作为这个<strong>原型链</strong>中的最后一个环节。</p>
<p>几乎所有 JavaScript 中的对象都是位于原型链顶端的 <code>Object</code> 的实例。</p>
</blockquote>
<p>这段话可能难以理解，我们来举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = []; <span class="comment">// 定义数组</span></span><br><span class="line">list.<span class="property">__proto__</span> === <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// true</span></span><br><span class="line">list.<span class="property">__proto__</span>.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// true</span></span><br><span class="line">list.<span class="property">__proto__</span>.<span class="property">__proto__</span>.<span class="property">__proto__</span>===<span class="literal">null</span>; <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 继承关系为</span></span><br><span class="line"><span class="comment">// list -&gt; Array.prototype -&gt; Object.prototype -&gt; null</span></span><br></pre></td></tr></table></figure>

<p>结合MDN的解释，我们来解释一下上述例子：</p>
<p>list是<code>Array</code>的实例对象，使用了<code>字面量</code>的方式创建了<code>对象实例</code>。</p>
<blockquote>
<p>每个实例对象（ object ）都有一个私有属性（称之为 <code>__proto__</code> ）指向它的构造函数的原型对象（<code>prototype</code> ）。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// list的构造函数是Array，所以list.__proto__指向构造函数Array的原型对象。</span></span><br><span class="line">list.<span class="property">__proto__</span> === <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>该原型对象也有一个自己的原型对象( <code>__proto__</code> )</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Array.prototype也是对象，也有自己的原型对象，原型是Object.prototype</span></span><br><span class="line"><span class="comment">// 下面是数学运算(等量代换)</span></span><br><span class="line"><span class="comment">// list.__proto__ = Array.prototype</span></span><br><span class="line"><span class="comment">// Array.prototype.__proto__ = Object.prototype</span></span><br><span class="line">list.<span class="property">__proto__</span>.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>层层向上直到一个对象的原型对象为 <code>null</code>。根据定义，<code>null</code> 没有原型，并作为这个<strong>原型链</strong>中的最后一个环节。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目前我们来到了Object.prototype，根据规范，Object.prototype的原型对象为null</span></span><br><span class="line"><span class="comment">// list.__proto__ = Array.prototype</span></span><br><span class="line"><span class="comment">// Array.prototype.__proto__ = Object.prototype</span></span><br><span class="line"><span class="comment">// Object.prototype.__proto__ = null;</span></span><br><span class="line">list.<span class="property">__proto__</span>.<span class="property">__proto__</span>.<span class="property">__proto__</span> === <span class="literal">null</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="原型链查找"><a href="#原型链查找" class="headerlink" title="原型链查找"></a>原型链查找</h3><blockquote>
<p>当我们访问对象的属性或者方法时，会先从对象本身开始查找，如果查找不到，则查找对象的<code>__proto__</code>，层层向上查找，直到查找到属性，否则抛出错误。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [];</span><br><span class="line">list.<span class="title function_">toString</span>();</span><br></pre></td></tr></table></figure>

<p>属性查找过程如下：</p>
<ol>
<li>查找list.toString()方法，没找到</li>
<li>继续查找list.<code>__proto__</code>，也就是<code>Array.prototype</code>，找到了</li>
<li>调用<code>Array.prototype.toString</code></li>
</ol>
<h3 id="原型链结论"><a href="#原型链结论" class="headerlink" title="原型链结论"></a>原型链结论</h3><ol>
<li>对象实例.<code>__proto__</code> &#x3D; 对象构造函数.<code>prototype</code></li>
<li>几乎所有对象的原型都是<code>Object.prototype</code></li>
<li>null是对象，但是null没有原型</li>
<li>属性&#x2F;方法查找采用<code>优先返回</code>机制。</li>
</ol>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>经过原型链的简单介绍，相信大家对原型和原型链有了一个比较直观的了解了，现在要说到的是函数。</p>
<blockquote>
<p>我们知道，Javascript中函数也是对象，所以<code>Function.__proto__</code>指向<code>Object.prototype</code>。</p>
</blockquote>
<p>上面的结论在Javascript中是<code>有问题</code>的。我们来聊一聊函数。</p>
<p>先看看简单一点的例子，大家知道,<code>Object</code>是对象的<code>构造函数</code>，<code>构造函数</code>也是<code>函数</code>，所有的<code>函数</code>的原型都是<code>Function.prototype</code>，所以<code>Object.__proto__</code>是等于<code>Function.prototype</code>的。</p>
<p>事实证明，也是如此。</p>
<p><img src="https://static.ddhigh.com/blog/2019-09-23-090412.jpg" alt="image-20190923170248951"></p>
<p>那么<code>Function.__proto__</code>为什么不等于<code>Object.prototype</code>呢?<code>Function</code>不是对象吗?</p>
<blockquote>
<p>Function确实是对象，同时还是构造函数，可以通过new Function()来得到函数实例。</p>
</blockquote>
<p>上面我们说到所有<code>函数</code>的原型是<code>Function.prototype</code>，所以<code>Function这个构造函数</code>的原型<code>__proto__</code>等于<code>Function.prototype</code>。</p>
<p>基于以上原理，还有以下相等关系：</p>
<ul>
<li><code>Object.__proto__ === Function.prototype</code></li>
<li><code>Array.__proto__ === Function.prototype</code></li>
</ul>
<h3 id="引申的问题"><a href="#引申的问题" class="headerlink" title="引申的问题"></a>引申的问题</h3><p>我们知道<code>Function.__proto__</code>是指向<code>Function.prototype</code>，那个<code>Function.prototype</code>这个<code>Function</code>哪里来的?<code>Function</code>自己创造自己?那不是会死循环吗?</p>
<blockquote>
<p>这个问题不是纯JS层面能解决的，牵涉到底层实现，下面是网络上别人整理的结论，有需要的可以研究一下V8的源码，这样可以彻底解决这个问题。</p>
<ol>
<li>用C&#x2F;C++ 构造内部数据结构创建一个 OP 即(Object.prototype)以及初始化其内部属性但不包括行为。</li>
<li>用 C&#x2F;C++ 构造内部数据结构创建一个 FP 即(Function.prototype)以及初始化其内部属性但不包括行为。</li>
<li>将 FP 的[[Prototype]]指向 OP。</li>
<li>用 C&#x2F;C++ 构造内部数据结构创建各种内置引用类型。</li>
<li>将各内置引用类型的[[Prototype]]指向 FP。</li>
<li>将 Function 的 prototype 指向 FP。</li>
<li>将 Object 的 prototype 指向 OP。</li>
<li>用 Function 实例化出 OP，FP，以及 Object 的行为并挂载。</li>
<li>用 Object 实例化出除 Object 以及 Function 的其他内置引用类型的 prototype 属性对象。</li>
<li>用 Function 实例化出除Object 以及 Function 的其他内置引用类型的 prototype 属性对象的行为并挂载。</li>
<li>实例化内置对象 Math 以及 Grobal</li>
<li>至此，所有 内置类型构建完成。</li>
</ol>
</blockquote>
<h3 id="函数结论"><a href="#函数结论" class="headerlink" title="函数结论"></a>函数结论</h3><ol>
<li>函数的原型都是<code>Function.protype</code>,构造函数也是函数，所以构造函数的原型也是<code>Function.prototype</code></li>
</ol>
<h2 id="来自灵魂的拷问1"><a href="#来自灵魂的拷问1" class="headerlink" title="来自灵魂的拷问1"></a>来自灵魂的拷问1</h2><p>下面是一道有点难度的JS基础题，可以感受一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">B</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">a</span> = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">C</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(a) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">a</span> = a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line">B.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line">C.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title function_">A</span>().<span class="property">a</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title function_">B</span>().<span class="property">a</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title function_">C</span>().<span class="property">a</span>);</span><br></pre></td></tr></table></figure>

<p>输出是</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><ol>
<li><p>为什么输出<code>1</code>?</p>
<blockquote>
<p>因为new A()这个对象上没有属性a，所以去查找原型链，查到了F.prototype.a</p>
</blockquote>
</li>
<li><p>为什么输出<code>undefined</code>?</p>
<blockquote>
<p>因为new B时没有传递a，所以a是undefined，new B()这个对象是有a属性的，只不过值是undefined,所以不查原型链</p>
</blockquote>
</li>
<li><p>为什么输出<code>1</code>?</p>
<blockquote>
<p>因为new C()未传递a，所以a是undefined，由于if(a)的判断，new C()这个对象内部没有a属性，所以去查原型链</p>
</blockquote>
</li>
</ol>
<h2 id="来自灵魂的拷问2"><a href="#来自灵魂的拷问2" class="headerlink" title="来自灵魂的拷问2"></a>来自灵魂的拷问2</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">F.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">b</span> = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;b&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>输出是</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure>

<h3 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a>解释</h3><ol>
<li>为什么输出true&#96;?</li>
</ol>
<blockquote>
<p>输出true比较好理解，因为构造函数<code>F</code>声明了属性<code>a</code>，所以<code>F</code>的实例有<code>a</code>属性</p>
</blockquote>
<ol start="2">
<li>为什么输出<code>false</code>?</li>
</ol>
<blockquote>
<p>b是<code>f</code>的原型对象<code>F.prototype</code>的属性，不是<code>b</code>自己的，不能拿别人的说成自己的。</p>
</blockquote>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>本文研究了原型和原型链之间的关系以及常见对象的原型和原型链，对于特殊对象Function也研究了一下，如果能搞懂后面两个问题，那本文对你来说没什么问题了。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Gepostet vor&nbsp;<time dateTime="2019-09-20T10:34:58.000Z" title="9/20/2019, 10:34:58 AM">2019-09-20</time></span><span class="level-item"><a class="link-muted" href="/categories/algorithm/">algorithm</a></span><span class="level-item">8 minutes lesen (Über 1177 Wörter)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/09/20/2019-09-20-leetcode-median-of-two-sorted-arrays.html">leetcode(4)——寻找两个有序数组的中位数</a></p><div class="content"><p>本文是力扣算法的第四篇，讲解寻找两个有序数组的中位数。</p>
<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><blockquote>
<p>给定两个大小为 m 和 n 的有序数组 <code>nums1</code> 和 <code>nums2</code>。</p>
<p>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p>
<p>你可以假设 <code>nums1</code> 和 <code>nums2</code> 不会同时为空。</p>
</blockquote>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [1, 3]</span><br><span class="line">nums2 = [2]</span><br><span class="line"></span><br><span class="line">则中位数是 2.0</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [1, 2]</span><br><span class="line">nums2 = [3, 4]</span><br><span class="line"></span><br><span class="line">则中位数是 (2 + 3)/2 = 2.5</span><br></pre></td></tr></table></figure>

<h2 id="中位数"><a href="#中位数" class="headerlink" title="中位数"></a>中位数</h2><blockquote>
<p>中位数是按顺序排列的一组数据中居于中间位置的数，即在这组数据中，有一半的数据比他大，有一半的数据比他小。</p>
</blockquote>
<h2 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h2><blockquote>
<ol>
<li><p>将两个有序数组合并成一个有序数组</p>
</li>
<li><p>如果长度是奇数则返回中间的值，如果是否则则返回中间两个数的平均值。</p>
</li>
</ol>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findMedianSortedArrays = <span class="keyword">function</span> (<span class="params">nums1, nums2</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> nums = [];</span><br><span class="line">    <span class="keyword">let</span> p1 = p2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt; nums1.<span class="property">length</span> &amp;&amp; p2 &lt; nums2.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1[p1] &lt; nums2[p2]) &#123;</span><br><span class="line">            nums.<span class="title function_">push</span>(nums1[p1++]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[p1] &gt; nums2[p2]) &#123;</span><br><span class="line">            nums.<span class="title function_">push</span>(nums2[p2++]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums.<span class="title function_">push</span>(nums1[p1++]);</span><br><span class="line">            nums.<span class="title function_">push</span>(nums2[p2++]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p1 !== nums1.<span class="property">length</span>) &#123; <span class="comment">// nums2比nums1长度要短，导致nums1没有走到末尾</span></span><br><span class="line">        <span class="keyword">for</span> (; p1 &lt; nums1.<span class="property">length</span>; p1++) &#123;</span><br><span class="line">            nums.<span class="title function_">push</span>(nums1[p1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p2 !== nums2.<span class="property">length</span>) &#123; <span class="comment">// nums1比nums2长度要短，导致nums2没有走到末尾</span></span><br><span class="line">        <span class="keyword">for</span> (; p2 &lt; nums2.<span class="property">length</span>; p2++) &#123;</span><br><span class="line">            nums.<span class="title function_">push</span>(nums2[p2]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="property">length</span> % <span class="number">2</span> === <span class="number">0</span>) &#123; <span class="comment">// 长度为偶数</span></span><br><span class="line">        <span class="keyword">return</span> (nums[nums.<span class="property">length</span> / <span class="number">2</span>] + nums[nums.<span class="property">length</span> / <span class="number">2</span> - <span class="number">1</span>]) / <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="title class_">Math</span>.<span class="title function_">floor</span>(nums.<span class="property">length</span> / <span class="number">2</span>)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 $O(m+n)$</p>
<blockquote>
<p>同时遍历了数组1和数组2</p>
</blockquote>
<p>空间复杂度$O(m+n)$</p>
<blockquote>
<p>声明了新数组，长度为数组1的长度加数组2的长度</p>
</blockquote>
<p>提交完通过了，这道题定义为Hard是不是搞错了，明明是个Easy题。</p>
<p>如果你这么想那你可能漏了一个时间复杂度的要求：$O(log(m+n))$</p>
<h2 id="思考-amp-amp-规律"><a href="#思考-amp-amp-规律" class="headerlink" title="思考 &amp;&amp; 规律"></a>思考 &amp;&amp; 规律</h2><blockquote>
<p>一般来说看到$O(log)$ 级别的时间复杂度一般是跟二分有关的算法才会产生这个时间复杂度，所以我们不妨以二分的思想来重新考虑一下这个问题。</p>
<p>有序数组求中位数，一般化为就两个有序数组的第$k$个数，本问题中$k &#x3D; (m+n)&#x2F;2$时就是我们的答案。</p>
</blockquote>
<p>怎么求第$k$个数？</p>
<blockquote>
<p> 我们可以现在数组1和数组2中求出$k&#x2F;2$个数$a$和$b$，如果$a &lt; b$，那说明$k$个数位于数组1的<code>后半段</code>或和数组2的<code>前半段</code>之间。我们把不符合规则的数组1<code>前半段</code>和数组2<code>后判断</code>给舍弃即可，这就只处理了一般的数据，达到的二分的目的。之后按照这个原则递归处理即可</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findMedianSortedArrays = <span class="keyword">function</span> (<span class="params">nums1, nums2</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> m = nums1.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">const</span> n = nums2.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果第1个数组为空，直接返回第2个数组的数据即可</span></span><br><span class="line">    <span class="keyword">if</span> (m === <span class="number">0</span>) &#123;</span><br><span class="line">      	<span class="comment">// 第2个数组长度为偶数，返回中间两个数字的平均值</span></span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (nums2[nums2.<span class="property">length</span> / <span class="number">2</span>] + nums2[nums2.<span class="property">length</span> / <span class="number">2</span> - <span class="number">1</span>]) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">// 第2个数组长度为奇数，返回中间两个数字的平均值</span></span><br><span class="line">        <span class="keyword">return</span> nums2[<span class="title class_">Math</span>.<span class="title function_">floor</span>(nums2.<span class="property">length</span> / <span class="number">2</span>)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (nums1[nums1.<span class="property">length</span> / <span class="number">2</span>] + nums1[nums1.<span class="property">length</span> / <span class="number">2</span> - <span class="number">1</span>]) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums1[<span class="title class_">Math</span>.<span class="title function_">floor</span>(nums1.<span class="property">length</span> / <span class="number">2</span>)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 总长度</span></span><br><span class="line">    <span class="keyword">const</span> total = m + n;</span><br><span class="line">    <span class="comment">// 总数为奇数，找到第total/2+1个数（下标从1开始）</span></span><br><span class="line">    <span class="keyword">if</span> (total % <span class="number">2</span> === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">findKth</span>(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, <span class="title class_">Math</span>.<span class="title function_">floor</span>(total / <span class="number">2</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下标为偶数，找到中间的两个数</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="title function_">findKth</span>(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, <span class="title class_">Math</span>.<span class="title function_">floor</span>(total / <span class="number">2</span>)) +</span><br><span class="line">        <span class="title function_">findKth</span>(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, <span class="title class_">Math</span>.<span class="title function_">floor</span>(total / <span class="number">2</span>) + <span class="number">1</span>)</span><br><span class="line">    ) / <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到两个有序数组的第k大的值</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">findKth</span>(<span class="params">nums1, aBegin, nums2, bBegin, k</span>) &#123;</span><br><span class="line">  	<span class="comment">// 如果数组1的下标或者数组2的下标超过各自的数组长度，k就是另一个数组的第k个数</span></span><br><span class="line">    <span class="keyword">if</span> (aBegin &gt;= nums1.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums2[bBegin + k - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (bBegin &gt;= nums2.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums1[aBegin + k - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">min</span>(nums1[aBegin], nums2[bBegin]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> midA = <span class="title class_">Number</span>.<span class="property">MAX_VALUE</span>;</span><br><span class="line">    <span class="keyword">let</span> midB = <span class="title class_">Number</span>.<span class="property">MAX_VALUE</span>;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 如果数组1的第k/2个数没有越界</span></span><br><span class="line">    <span class="keyword">if</span> (aBegin + <span class="title class_">Math</span>.<span class="title function_">floor</span>(k / <span class="number">2</span>) - <span class="number">1</span> &lt; nums1.<span class="property">length</span>) &#123;</span><br><span class="line">        midA = nums1[aBegin + <span class="title class_">Math</span>.<span class="title function_">floor</span>(k / <span class="number">2</span>) - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (bBegin + <span class="title class_">Math</span>.<span class="title function_">floor</span>(k / <span class="number">2</span>) - <span class="number">1</span> &lt; nums2.<span class="property">length</span>) &#123;</span><br><span class="line">        midB = nums2[bBegin + <span class="title class_">Math</span>.<span class="title function_">floor</span>(k / <span class="number">2</span>) - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 如果数组1的第k/2个数小于数组2的k/2个数，表示总的第k个数在数组1后判断和数组2的前半段</span></span><br><span class="line">    <span class="comment">// 所以数组1的下标需要往后走k/2个位置，响应的数组b的下标往前走k/2个位置</span></span><br><span class="line">    <span class="keyword">if</span> (midA &lt; midB) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">findKth</span>(nums1, aBegin + <span class="title class_">Math</span>.<span class="title function_">floor</span>(k / <span class="number">2</span>), nums2, bBegin, k - <span class="title class_">Math</span>.<span class="title function_">floor</span>(k / <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">findKth</span>(nums1, aBegin, nums2, bBegin + <span class="title class_">Math</span>.<span class="title function_">floor</span>(k / <span class="number">2</span>), k - <span class="title class_">Math</span>.<span class="title function_">floor</span>(k / <span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度$O(log(m+n))$</p>
<blockquote>
<p>每次递归都舍弃了一半数据，二分的复杂度是$log$</p>
</blockquote>
<p>空间复杂度$O(1)$</p>
<blockquote>
<p>只使用了固定的几个临时变量</p>
</blockquote>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>本问题考察的是对二分法的基本功，面试中后期遇到的可能性比较大，可以多加熟悉。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Gepostet vor&nbsp;<time dateTime="2019-09-17T04:30:00.000Z" title="9/17/2019, 4:30:00 AM">2019-09-17</time></span><span class="level-item"><a class="link-muted" href="/categories/frontend/">frontend</a><span> / </span><a class="link-muted" href="/categories/frontend/javascript/">javascript</a></span><span class="level-item">4 minutes lesen (Über 568 Wörter)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/09/17/2019-09-18-javascript-var-scope.html">搞懂JS变量提升</a></p><div class="content"><p>本文讲解Javascript变量提升引起的问题以及如何规避。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>今天看到一道有意思的面试题，考察的还真是JS的基本功，题目如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> name === <span class="string">&quot;undefined&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;Jack&quot;</span>;</span><br><span class="line">  	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello &quot;</span> + name);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello &quot;</span> + name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>

<p>根据if条件可以得出可能的答案：</p>
<ul>
<li>Hello world</li>
<li>Hello Jack</li>
</ul>
<h2 id="正确答案"><a href="#正确答案" class="headerlink" title="正确答案"></a>正确答案</h2><p>答案是<code>Hello Jack</code>，但是答案怎么来的，回答不好可能还是只能打50分，有以下两种理解：</p>
<p>理解1：</p>
<blockquote>
<p>立即执行函数有独立的作用域，访问不到外部name，所以if判断成立，输出 <code>Hello Jack</code></p>
</blockquote>
<p>这个理解是不正确的。虽然函数隔离了作用域，但是由于作用域链的关系，JS会从当前作用域一直往上级查找，直到顶级作用域（浏览器环境为window）。</p>
<p>如下代码输出<code>Hello world</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello &quot;</span> + name);</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>

<p>理解2：</p>
<blockquote>
<p>var存在变量提升，所以if在判断的时候name确实为undefined，走了if分支，输出 <code>Hello Jack</code></p>
</blockquote>
<h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>MDN对变量提升的解释：</p>
<blockquote>
<p>“变量提升”意味着变量和函数的声明会在物理层面移动到代码的最前面，但这么说并不准确。实际上变量和函数声明在代码里的位置是不会动的，而是在编译阶段被放入内存中。</p>
<ul>
<li><strong>JavaScript 仅提升声明，而不提升初始化</strong></li>
<li><strong>函数和变量相比，会被优先提升</strong></li>
</ul>
</blockquote>
<p>根据变量提升理论我们可以“模拟”JS实际执行代码的过程：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> name; <span class="comment">// 变量提升，仅提升声明，不提升初始化</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> name === <span class="string">&quot;undefined&quot;</span>) &#123;</span><br><span class="line">    name = <span class="string">&quot;Jack&quot;</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello &quot;</span> + name);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello &quot;</span> + name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>

<p>函数内部作用域顶级的name初始化时为undefined，所以会走if分支，输出<code>Hello Jack</code>。这才是100分答案！</p>
<h2 id="规避变量提升问题"><a href="#规避变量提升问题" class="headerlink" title="规避变量提升问题"></a>规避变量提升问题</h2><blockquote>
<ol>
<li>在作用域的顶部定义变量</li>
<li>使用ES6新语法let或const定义变量</li>
</ol>
</blockquote>
<h2 id="技术参考"><a href="#技术参考" class="headerlink" title="技术参考"></a>技术参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Glossary/Hoisting">变量提升 - 术语表 | MDN</a></li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Gepostet vor&nbsp;<time dateTime="2019-09-16T10:34:58.000Z" title="9/16/2019, 10:34:58 AM">2019-09-16</time></span><span class="level-item"><a class="link-muted" href="/categories/algorithm/">algorithm</a></span><span class="level-item">9 minutes lesen (Über 1292 Wörter)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/09/16/2019-09-16-leetcode-longest-substring-without-repeating-characters%20(copy).html">leetcode(3)——无重复字符的最长子串</a></p><div class="content"><p>本文是力扣算法的第三篇，讲解无重复字符的最长子串问题。</p>
<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><blockquote>
<p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
</blockquote>
<p><strong>示例1：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>

<p><strong>示例2：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure>

<p><strong>示例3：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>

<h2 id="遍历法"><a href="#遍历法" class="headerlink" title="遍历法"></a>遍历法</h2><blockquote>
<p>最容易想到的一种算法，也是效率最低的一种算法</p>
<ol>
<li>通过两次遍历得到所有可能的 <strong>子字符串</strong> 列表</li>
<li>将每个字符串传入一个函数检测是否包含重复字符，如果不包含则更新最长子串的长度</li>
</ol>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断给定的子串是否包含重复字符</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isUnique</span>(<span class="params">str, start, end</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> chars = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> char = str[i];</span><br><span class="line">    <span class="keyword">if</span>(chars.<span class="title function_">indexOf</span>(char) !== -<span class="number">1</span>) &#123; <span class="comment">// 字符已存在，本字符串不符合条件</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    chars.<span class="title function_">push</span>(char); <span class="comment">// 添加字符</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取字符串最长子串长度</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = i+<span class="number">1</span>; j &lt;= s.<span class="property">length</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="title function_">isUnique</span>(s, i, j)) &#123; <span class="comment">// 判断子串是否唯一</span></span><br><span class="line">        max = <span class="title class_">Math</span>.<span class="title function_">max</span>(max, j - i); <span class="comment">// j - i 为当前子串长度</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度$O(n^3)$</p>
<blockquote>
<p>i循环，j循环，isUnquie中的循环，3次循还嵌套</p>
</blockquote>
<p>空间复杂度$O(min(n,m))$</p>
<blockquote>
<p>isUnique函数中定义了一个数组来存储不重复的子串字符，长度为$k$,$k$的长度取决于字符串$s$的大小$n$以及 字符串$s$包含的不重复字符数大小$m$</p>
</blockquote>
<h2 id="滑动窗口法"><a href="#滑动窗口法" class="headerlink" title="滑动窗口法"></a>滑动窗口法</h2><blockquote>
<p>暴力法中我们会重复检查一个子串是否包含重复的字符，如果从$i$ ~ $j-1$ 之间的子串已经被检查过没有重复字符了，那么只需要检查$s[j]$是否在这个子串就行了。</p>
<p>子串使用js自带的数据结构Set存储</p>
<p>如果不在该子串，那么子串长度+1，$j+1$，继续往后走</p>
<p>如果在这个子串，证明出现了重复，我们需要将$s[i]$移出来之后$i+1$，继续往后走</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">  <span class="keyword">const</span> max = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> j = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(i &lt; s.<span class="property">length</span> &amp;&amp; j &lt; s.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!set.<span class="title function_">has</span>(s[j])) &#123; <span class="comment">// j 不在set中，set中添加s[j],j后移，同时更新最大子串长度</span></span><br><span class="line">      set.<span class="title function_">add</span>(s[j]);</span><br><span class="line">     	j++;</span><br><span class="line">      max = <span class="title class_">Math</span>.<span class="title function_">max</span>(max, j - i);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      set.<span class="title function_">delete</span>(s[i]); <span class="comment">// 移除set左边的数据，i后移一位</span></span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 $O(2n) \approx O(n)$</p>
<blockquote>
<p>最好的情况是j一次走完没有出现重复，最坏的情况是i和j都走到了末尾</p>
</blockquote>
<p>空间复杂度 $O(min(n,m))$</p>
<blockquote>
<p>与暴力法相似，也需要一个Set存储不重复字符，$n$ 是字符串$s$长度，$m$是字符串$s$中不重复的字母个数</p>
</blockquote>
<h2 id="优化的滑动窗口"><a href="#优化的滑动窗口" class="headerlink" title="优化的滑动窗口"></a>优化的滑动窗口</h2><blockquote>
<p>在滑动窗口解法中，$i$的后移可以优化一下，如果 s$[j]$ 在 s[$i$] ~ s[$j$] 内与字符 $c$ (随便取的名字)重复，$i$ 不需要一步一步$i$++，直接把 $i$ 定位到 $c$ + 1的位置即可。这样可以将算法时间复杂度稳定在 $O(n)$</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">s</span>) &#123;</span><br><span class="line">	<span class="keyword">const</span> map = &#123;&#125;; <span class="comment">// 保存 字符和下标的映射关系，如果字符重复，从map拿到位置，i直接跳到这个位置</span></span><br><span class="line">  <span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, j = <span class="number">0</span>;j &lt; s.<span class="property">length</span>;j++) &#123;</span><br><span class="line">    <span class="keyword">const</span> char = s[j];</span><br><span class="line">    <span class="keyword">if</span>(map[char] !== <span class="literal">undefined</span>) &#123; <span class="comment">// 当前字符存在重复，需要将i更新</span></span><br><span class="line">      i = <span class="title class_">Math</span>.<span class="title function_">max</span>(i, map[char]); <span class="comment">// 如果i的当前位置大于map[char]，不能更新为map[char]</span></span><br><span class="line">    &#125;</span><br><span class="line">    max = <span class="title class_">Math</span>.<span class="title function_">max</span>(max, j - i + <span class="number">1</span>); <span class="comment">// 由于j最大是s.length-1，所以最大子串长度需要+1</span></span><br><span class="line">    map[char] = j + <span class="number">1</span>; <span class="comment">// 保存映射关系</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 $O(n)$</p>
<blockquote>
<p>只遍历了j</p>
</blockquote>
<p>空间复杂度 $O(min(n,m))$</p>
<blockquote>
<p>与之前的方法相同</p>
</blockquote>
<p>Q: 为什么第8行的 <code>i = Math.max(i, map[char])</code> 不能直接是 <code>i = map[char]</code>?</p>
<p>A: $i$ 的位置比<code>map[char]</code>大的情况下如果直接赋值会导致 $i$ 往前面走，会导致返回的子串长度大于实际的子串长度</p>
<p>错误例子 <code>abba</code></p>
<table>
<thead>
<tr>
<th>i</th>
<th>j</th>
<th>s[j]</th>
<th>s[i] ~ s[j]</th>
<th>Max</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>a</td>
<td>a</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>b</td>
<td>ab</td>
<td>2</td>
</tr>
<tr>
<td>2(map中没有s[j]，所以这里的位置直接是当前j的值)</td>
<td>2</td>
<td>b</td>
<td>b</td>
<td>2</td>
</tr>
<tr>
<td>1(map中有s[j]，第1个字符就是a，直接拿来用)</td>
<td>3</td>
<td>a</td>
<td>bba</td>
<td>3</td>
</tr>
</tbody></table>
<p>可以看到第4次循环中 i 的位置已经出现了问题，把位置1的a拿过来进行计算了，窗口的起始左边也从2变成了1，往回走了。</p>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>本问题主要是考察对滑动窗口算法的实际应用，掌握之后解题问题不大。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Gepostet vor&nbsp;<time dateTime="2019-09-12T15:16:28.000Z" title="9/12/2019, 3:16:28 PM">2019-09-12</time></span><span class="level-item"><a class="link-muted" href="/categories/algorithm/">algorithm</a></span><span class="level-item">6 minutes lesen (Über 852 Wörter)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/09/12/2019-09-12-leetcode-add-two-sum.html">leetcode(2) —— 两数相加</a></p><div class="content"><p>本文是力扣算法的第二篇，讲解两数相加问题。</p>
<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><blockquote>
<p>给出两个 <strong>非空</strong> 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 <strong>逆序</strong> 的方式存储的，并且它们的每个节点只能存储 <strong>一位</strong> 数字。</p>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
</blockquote>
<p><strong>示例：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 0 -&gt; 8</span><br><span class="line">原因：342 + 465 = 807</span><br></pre></td></tr></table></figure>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>遍历两个链表把值加起来好之后插入链表，如果有进位的话需要把进位的值保存到后面的节点上，如果遍历完毕之后还剩下需要进位的值，那么需要插入末尾新节点。</p>
<h3 id="边界情况"><a href="#边界情况" class="headerlink" title="边界情况"></a>边界情况</h3><p>遇到链表相关的题目时一定要处理好边界情况，因为有些为空的链表或者只有1个节点的链表没有处理的必要，及时返回可以降低算法复杂度。</p>
<ol>
<li>链表1和链表2同时为空，直接返回undefined即可</li>
<li>链表1为空，返回链表2</li>
<li>链表2为空，返回链表1</li>
</ol>
<h2 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链表节点定义</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ListNode</span>(<span class="params">val</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">val</span> = val;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addTwoNumbers</span>(<span class="params">l1, l2</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(!l1 &amp;&amp; !l2) &#123; <span class="comment">// 链表1和链表2同时为空，无需任何处理</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!l1) &#123; <span class="comment">// 链表1为空，直接返回链表2</span></span><br><span class="line">    <span class="keyword">return</span> l2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!l2) &#123; <span class="comment">// 链表2为空，直接返回链表1</span></span><br><span class="line">    <span class="keyword">return</span> l1;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> carry = <span class="number">0</span>; <span class="comment">// 进位值</span></span><br><span class="line">  <span class="keyword">let</span> head = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>); <span class="comment">// 链表头节点</span></span><br><span class="line">  <span class="keyword">let</span> p = head; <span class="comment">// 链表移动指针</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(l1 || l2 || carry &gt; <span class="number">0</span>) &#123; <span class="comment">// l1和l2虽然不会同时为空，但是存在l1和l2长度不一致的情况， 这种也需要处理</span></span><br><span class="line">    <span class="keyword">let</span> sum = carry; <span class="comment">// sum为本节点的值，需要加上前一个节点的进位值</span></span><br><span class="line">    <span class="keyword">if</span>(l1) &#123;</span><br><span class="line">     sum += l1.<span class="property">val</span>; <span class="comment">// 把链表1当前节点的值加上</span></span><br><span class="line">     l1 = l1.<span class="property">next</span>; <span class="comment">// 移动链表1指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l2) &#123;</span><br><span class="line">      sum += l2.<span class="property">val</span>;</span><br><span class="line">      l2 = l2.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(sum &gt;= <span class="number">10</span>) &#123; <span class="comment">// 两个个位数相加最大值为18，所以到下一个节点进位的最大值为1</span></span><br><span class="line">      carry = <span class="number">1</span>;</span><br><span class="line">      sum -= <span class="number">10</span>; <span class="comment">// 去掉十位，保留个位为节点最终值</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      carry = <span class="number">0</span>; <span class="comment">// 相加之后和小于10，不需要进位，清除进位数据，否则死循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    p.<span class="property">next</span> = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum); <span class="comment">// 插入新节点</span></span><br><span class="line">    p = p.<span class="property">next</span>; <span class="comment">// 新链表指针后移</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> head.<span class="property">next</span>; <span class="comment">// 头结点的值不是相加得到的，所以需要后移一个节点返回由两个链表加起来的结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进位的处理搞清楚之后这道题就清楚了。</p>
<p>时间复杂度O(max(l1.length, l2.length))</p>
<blockquote>
<p>　循环次数的根据链表1和链表2中长的那个链表来的，因为要保证两个链表的所有节点都被便利到</p>
</blockquote>
<p>空间复杂度O(max(l1,l2))</p>
<blockquote>
<p>最终链表的节点数也是根据链表1和链表2中长的那个链表来的，因为要保证两个链表的所有节点都被便利到，如果最后有进位的话，结果链表的长度会比链表1和链表2中长的链表大小+1。</p>
</blockquote>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>这道题的难度是中等，但是摸清楚链表的基本操作之后，应该没什么问题就能解决。</p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/9/">Zurück</a></div><div class="pagination-next"><a href="/page/11/">Weiter</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/9/">9</a></li><li><a class="pagination-link is-current" href="/page/10/">10</a></li><li><a class="pagination-link" href="/page/11/">11</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/31/">31</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://static.ddhigh.com/blog/2019-09-18-094336.jpg" alt="XiaLei"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">XiaLei</p><p class="is-size-6 is-block">Senior Software Engineer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Tencent</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Seiten</p><a href="/archives"><p class="title">306</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Kategorien</p><a href="/categories"><p class="title">25</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">38</p></a></div></div></nav><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/xialeistudio"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="LinkedIn" href="https://www.linkedin.com/in/xialeidoc/"><i class="fa-brands fa-linkedin"></i></a></div></div></div><!--!--></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">Learning &amp; Sharing</a><p class="is-size-7"><span>&copy; 2023 Xia Lei</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en-us");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><a id="back-to-top" title="Zurück nach oben" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "Diese Website verwendet Cookies, um Ihre Erfahrung zu verbessern.",
          dismiss: "Verstanden!",
          allow: "Cookies zulassen",
          deny: "Ablehnen",
          link: "Mehr erfahren",
          policy: "Cookie-Richtlinie",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Tippen Sie etwas..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Tippen Sie etwas...","untitled":"(Ohne Titel)","posts":"Seiten","pages":"Pages","categories":"Kategorien","tags":"Tags"});
        });</script></body></html>