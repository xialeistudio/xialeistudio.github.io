{"posts":[{"title":"阿里云ECS服务器phpmailer发信失败解决方法","text":"phpmailer之前一直在用，一般都是采用smtp登录服务器的方式进行发信，今天在本地windows主机测试也能发信成功，但是到线上去就不行了，提示“连接smtp服务器失败”。首先可以排除的是代码方面的错误，那么剩下就知道服务器的问题了。 根据这个错误，可以想到有几种问题: 服务器ping不通，做Ping测试的时候是通的 服务器端口没开，用telnet测试的时候也是这样的 后来在服务器上用php代码测试163邮箱发现可以发信，但是腾讯的就不行，看了下邮箱配置发现是SSL的问题，然后在服务器上输出phpinfo()发现没有openssl扩展。接下来就是安装扩展了。 首先进到php的源码包，前往ext/openssl目录 执行 phpize 这个会自动配置 然后执行 123./configure --with-openssl -with-php-config=/usr/local/php/bin/php-configmakemake install 这里模块安装就完成了，但是需要编辑 /etc/php.ini加上 1extension=openssl.so 重启 web 服务器就可以了。经过测试，服务器上SSL发信也能成功进行","link":"/2014/09/06/2014-09-06-aliyun-phpmailer.html"},{"title":"Angularjs自动保存指令","text":"angularjs的指令真是好东西，也是精髓。刚才群里面有朋友在问如何在用户离开编辑区域时提醒保存，其实用指令实现很简单的。 请注意，这里使用的指令标签为ajax-submit 12345678910111213141516171819202122232425262728293031app.directive('ajaxSubmit', [ '$http', function($http) { return { link: function(scope, ele, attrs) { var old = ele.val(); ele.bind('blur', function() { var url = ele.data('url'); var val = ele.val(); ele.prop('disabled', true); //发送http $http.post(url, { data: val }).success(function(data) { ele.prop('disabled', false); if (data.msg != undefined) { old = val; ele.after('操作成功'); setTimeout(function() { ele.next().remove(); }, 1000); } else { alert(data.error); } }); }); } } }]); 关键是利用指令的link函数获取包装后的jq元素，然后给该元素进行事件绑定，其实很多的事件绑定都是这样做的。事件处理函数中的业务逻辑各位看官可以自行修改~。","link":"/2014/09/06/2014-09-06-angularjs-autosave-directive.html"},{"title":"摆脱jquery!angularjs利用指令简单实现滚动翻页","text":"移动开发一个很重要的问题是翻页操作，而现在的主流都是滚动翻页，以往都是用jquery的插件进行实现。用了angularjs之后，要逐步减轻对jquery的依赖。 滚动翻页基本原理就是判断scrollTop和offsetHeight之和 大于等于 scrollHeight 代码指令12345678910app.directive('whenScrolled', function() { return function(scope, elm, attr) { var raw = elm[0]; elm.bind('scroll', function() { if (raw.scrollTop+raw.offsetHeight &amp;gt;= raw.scrollHeight) { scope.$apply(attr.whenScrolled); } }); }; }); 控制器1234567891011121314151617$scope.loadMore = function() { if ($scope.currentPage &amp;lt; $scope.pages) { $scope.currentPage++; if ($scope.busy) { return false; } $scope.busy = true; $http.get('/api.php?r=site/list/page/'+$scope.currentPage+'/limit/'+$scope.limit).success(function(data) { $scope.busy = false; for (var i in data.data) { $scope.newses.push(data.data[i]); } $scope.pages = Math.ceil(data.total/$scope.limit); $rootScope.title = '首页 - 微文章'; }); } }; 视图123&lt;div when-scrolled=&quot;loadMore()&quot;&gt;//内容处理逻辑&lt;/div&gt;","link":"/2014/09/06/2014-09-06-angularjs-lazy-load.html"},{"title":"Angularjs指令数据远程请求的处理","text":"假设有一个指令用来根据IP地址进行地位，获取实际地址。 首先，我们的IP地址是由后台PHP程序返回的，这里需要一个Http请求，使用了Http请求就会有类似回调的问题，之前想了各种办法，死活拿不到数据，后来去ng官网看了下，需要使用ngModel，这个是双向绑定。 指令代码123456789101112131415app.directive('location', ['ApiService', function (ApiService) { return { restrict: 'A', require:'ngModel', link: function (scope, ele, attrs,ngModel) { ele.addClass('opt'); ele.bind('click', function () { ele.text('定位中...'); ApiService.location(ngModel.$viewValue).success(function (data) { ele.text(data.country + ' ' + data.region + ' ' + data.city + ' ' + data.isp); }); }); } };}]); HTML部分1&lt;span location ng-model=&quot;user.login_ip&quot;&gt;定位&lt;/span&gt; JS中的ngModel 会去搜索该指令的元素上的ng-model指令，这里会搜索到一个user.login_ip 的model,然后JS中使用ngModel.$viewValue 就可以拿到值了。","link":"/2014/09/06/2014-09-06-angularjs-load-remote-data-on-directive.html"},{"title":"bower快速入门","text":"简介bower是twitter的又一个开源项目，使用nodejs开发，用于web包管理。如果越来越多得开源项目都托管在github上，bower只需要将github上项目加上一个配置文件既可以使用bower方式使用安装包。作为包管理，bower能提供添加新web包，更新web包，删除web包，发布web包功能，管理包依赖。web包通常认为由html+css+javascript构成。 安装bower1npm install bower -g 请确保你有Nodejs环境 在项目目录中运行 1bower install jquery 运行成功之后项目中会多出components文件夹，文件夹中jquery文件夹，jquery文件夹里面就有最新的jquery文件。 这还不能说明他NB的地方，试想下面的场景，jQuery升级了，是不是再down一次jQuery呢？bower可以这样做： 1bower update jquery 就可以自动升级到最新版的jquery了。 再假设我们需要使用bootstrap，bootstrap可不是一个文件，有css,js还有图片。js还依赖于jQuery，如果使用bower： 1bower install bootstrap bower会自动从github上down最新的代码，而且，会自动将依赖包jquery也down一次。 如果你发布程序的时候不想把一些依赖的库发布上去（主要原因是太大了 - - ），可以在项目根目录下生成一个 bower.json 文件用来管理依赖。 在项目目录下执行 1bower init 按照提示操作就好，这样子会生成一个bower文件 安装 jquery 1bower install jquery --save 这样子 bower.json 文件就会写入一个 Jquery的依赖项 别人只要在项目目录下输入 1bower install 就会自动安装了","link":"/2014/09/06/2014-09-06-bower-get-started.html"},{"title":"jquery插件写法","text":"项目地址http://xialeistudio.github.io/search/ jquery插件确实是数不胜数，只要你用心找，肯定能找得到! 但是一些小功能想自己写，找的话估计时间还长些，本文简单开发一个 基于jquery的获取url查询字符串的 小插件。 插件的模版（$.extend扩展jquery内置方法) 1234(function($) { $.x_search = function(_name,target) { //x_search是插件名字,_name、target是参数 };})(jQuery); 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * $.x_search * @extends jquery 2.1.1(基于该版本开发，其他版本自测) * @fileOverview 获取url queryString * @author xialeistudio * @email 1065890063@qq.com * @site www.ddhigh.com * @version 0.0.1 * @date 2014-08-12 * @license MIT * @example * 获取当个Key * $.x_search('name'); * 获取所有 * $.x_search(); */ (function($) { $.x_search = function(_name,target) { if(typeof target == 'undefined'){ target = window.location.search; } if (typeof _name == 'undefined') { //所有 var query =target.substr(1, window.location.search.length-1).split('&amp;'); var data = []; for (var i = 0; i &lt; query.length; i++) { var tmp = query[i].split('='); data.push({ key: tmp[0], data: decodeURIComponent(tmp[1]) }); } return data; } else { //指定Key try { var regex = new RegExp(_name+'=([^&amp;]+)?'); return decodeURIComponent(target.match(regex)[1]); } catch (e) { return null; } } }; })(jQuery);","link":"/2014/09/06/2014-09-06-jquery-write-a-plugin.html"},{"title":"ngResource快速上手","text":"废话不多说，本文的目的就是看过之后就会使用ngResource了。 引入angular-resource.min.js 定义模块时加载ngResource 定义service 完整代码如下 1234567891011121314151617181920212223var app = angular.module('app', [&quot;ngResource&quot;]);app.factory('Phone', ['$resource',function($resource) { return $resource('user/:uid', { uid: '@uid' }, { update: { method: 'PUT' } });}]);app.controller('MainCtrl', ['$scope', 'Phone',function($scope, Phone) { $scope.phones = Phone.query(); Phone.update({ uid: 1 }, { name: &quot;zhangsan&quot;, age: &quot;10&quot; });}]);","link":"/2014/09/06/2014-09-06-ng-resource-get-started.html"},{"title":"nginx虚拟主机配置","text":"最近服务器上用的环境是lnmp，之前一直在用apache，配置虚拟主机也是很方便的。今天查资料发现Nginx的虚拟主机配置更加简单。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859server { listen 80; server_name domain1; location / { root html/domain1; index index.html index.htm index.php; } location ~ \\.php$ { root html/domain1; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; }}server { listen 80; server_name domain2; location / { root html/domain2; index index.html index.htm index.php; } location ~ \\.php$ { root html/domain2; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; }} 保存之后，执行 1nginx -s reload","link":"/2014/09/06/2014-09-06-nginx-virtual-host.html"},{"title":"PDO简明教程，是时候抛弃mysql_*函数了","text":"mysql_*系列函数我一之前一直在用，基于性能、安全性等原因，再加上PHP面向对象的增强，是时候使用PDO来处理数据了。PDO一个很重要的特点是该类与数据库无关，不同的数据库只是在实例化时传入的参数不同，但是操作方法是一样的。 1234567891011121314151617181920212223&lt;?phptry { $pdo = new PDO('mysql:host=localhost;dbname=test','root','root'); //查询数据 $stmt = $pdo-&gt;prepare('SELECT * FROM user WHERE sex=?'); $sex = 'male'; $stmt-&gt;bindParam(1,$sex); $stmt-&gt;setFetchMode(PDO::FETCH_ASSOC); $list = $stmt-&gt;fetchAll(); //查询完毕 //写入数据 $stmt = $pdo-&gt;prepare('INSERT INTO user VALUES (?,?,?)'); $username = 'admin'; $password = md5('111111'); $sex = 'male'; $stmt-&gt;bindParam(1,$username); $stmt-&gt;bindParam(2,$password); $stmt-&gt;bindParam(3,$sex); $stmt-&gt;execute(); //写入完毕} catch (Exception $e) { echo $e-&gt;getMessage();} 编辑、更新、删除统称为写入操作，大家可以举一反三~ execute会返回受影响的函数，有可能为0行!请大家在判断时用 === 而不是 == , 0 == false 而 0 !== false","link":"/2014/09/06/2014-09-06-pdo-get-started.html"},{"title":"php中文字符串反转","text":"php strrev() 函数能实现字符串反转，但是不支持中文，利用mb_系列函数可以进行中文字符串反转。 12345678910111213141516/** * 中文字符串反转 * @param $str * @param string $charset * @return string */function reverse($str, $charset = 'UTF-8'){ $ret = ''; $len = mb_strlen($str, $charset); for ($i = 0; $i &lt; $len; $i++) { $ret[] = mb_substr($str, $i, 1, $charset); } return implode('', array_reverse($ret));}","link":"/2014/09/06/2014-09-06-php-chinese-reverse.html"},{"title":"PHP将日期转换为星座","text":"这几日在做的一个项目发现一个很有意思的东西，就是PHP将指定日期输出为星座 12345678910111213141516171819202122&lt;?phpfunction constellation($month, $day) { if ($month &lt; 1 || $month &gt; 12 || $day &lt; 1 || $day &gt; 31) return false; $constellations = array( array(&quot;20&quot; =&gt; '水瓶座'), array(&quot;19&quot; =&gt; '双鱼座'), array(&quot;21&quot; =&gt; '白羊座'), array(&quot;20&quot; =&gt; '金牛座'), array(&quot;21&quot; =&gt; '双子座'), array(&quot;22&quot; =&gt; '巨蟹座'), array(&quot;23&quot; =&gt; '狮子座'), array(&quot;23&quot; =&gt; '处女座'), array(&quot;23&quot; =&gt; '天秤座'), array(&quot;24&quot; =&gt; '天蝎座'), array(&quot;22&quot; =&gt; '射手座'), array(&quot;22&quot; =&gt; '摩羯座') ); list($constellation_start, $constellation_name) = each($constellations[(int)$month - 1]); if ($day &lt; $constellation_start) list($constellation_start, $constellation_name) = each($constellations[($month - 2 &lt; 0) ? $month = 11 : $month -= 2]); return $constellation_name;}","link":"/2014/09/06/2014-09-06-php-convert-date-to-constellation.html"},{"title":"php使用CORS实现跨域请求","text":"js跨域的解决方法，一百度一大堆，不过都是jsonp为主，这种解决方法只适用于GET请求。POST跨域的话需要在HTTP协议上下功夫。 基础知识主要会用到以下几个响应头 Access-Control-Allow-Origin：允许哪些url可以跨域请求到本域 Access-Control-Allow-Methods:允许的请求方法，一般是GET,POST,PUT,DELETE,OPTIONS Access-Control-Max-Age：表明在该时间段内不再“预检”允许的请求方法（相当于缓存），即不以OPTIONS方法进行请求 Access-Control-Allow-Headers：允许哪些请求头可以跨域 php代码1234567&lt;?phpheader('Access-Control-Allow-Origin:*');header('Access-Control-Allow-Methods:POST');header('Access-Control-Max-Age:60');header('Access-Control-Allow-Headers:x-requested-with,content-type');header('Content-Type:application/json;charset=utf-8');print_r(file_get_contents('php://input'));","link":"/2014/09/06/2014-09-06-php-cors-crossdomain.html"},{"title":"PHP heredoc 字符串定界符使用","text":"PHP定义字符串有三种形式 双引号 单引号 heredoc定界符 前面两种大家都很熟悉了，第三种大家用的少。一般在输出大段HTML的时候很方便，不多说，上代码！ 12345&lt;?php$link = 'https://www.google.com.hk';print &lt;&lt;&lt;DOGS &lt;a href=&quot;{$link}&quot;}Google&lt;/a&gt;DOGS; DOGS可以自己定义。","link":"/2014/09/06/2014-09-06-php-heredoc.html"},{"title":"Redis初探","text":"Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。我本地的PHP是 5.4.25 ts版本，这里是php_redis扩展（只限于5.4.x TS版本）。 ext.zip 打开php.ini 添加以下两行 12extension=php_igbinary.dllextension=php_redis.dll 请注意顺序！ 重启web服务器就可以了。 示例代码 12345678910111213141516&lt;?php$redis = new Redis();$redis-&gt;connect('127.0.0.1');//存储一个值$redis-&gt;set('name', 'zhangsan', 5);//存储多个值$array = array( 'name' =&gt; '张三', 'sex' =&gt; 'male', 'age' =&gt; 10);$array_get=array( 'name','sex','age');$redis-&gt;mset($array);print_r($redis-&gt;mget($array_get)); 本文只起到抛砖引玉的作用，详细的使用有待大家挖掘~","link":"/2014/09/06/2014-09-06-redis-get-started.html"},{"title":"Yii同一站点配置多个用户角色","text":"Yii是基于组件的PHP MVC框架，yii的用户组件调用很方便，但是如果有遇到一个站点有多种用户的时候，如前台用户，后台用户，就需要增加User组件了。 简单来说，就是新建一个用户类去继承 CWebUser类，比如 WebUser继承CWebUser，配置文件在components中增加 123'user'=&gt;array( 'class'=&gt;'WebUser') 以上就创建了一个前台用户,调用方式 Yii::app()-&gt;user 后台用户可以这么写 AdminUser继承CWebUser,配置文件在components中增加 123'admin'=&gt;array( 'class'=&gt;'AdminUser') 这样就创建了一个后台用户，调用方式 Yii::app()-&gt;admin 这种方法是本人所知最科学的，比用session来区分好多了。毕竟很多时候，能用框架现有的方法就用框架的方法。","link":"/2014/09/06/2014-09-06-yii-multi-user.html"},{"title":"php OOP中的__get和__set方法","text":"__get,__set光看前面两个下划线就知道是魔术方法了，而且还是PHP OOP中比较重要的方法。 先看一段代码 12345678910&lt;?phpclass Account{ private $user = 1; private $pwd = 2;}$a = new Account();echo $a-&gt;user;$a-&gt;name = 5;echo $a-&gt;name;echo $a-&gt;big; 运行这段代码结果是肯定会报错的！ 原因在于，不能访问私有属性user。利用__get和__set改进下这个类 123456789101112131415161718192021&lt;?phpclass Account{ private $user = 1; private $pwd = 2; public function __set($name,$value){ $this-&gt;name = $value; } public function __get($name){ if(!isset($this-&gt;name)){ $this-&gt;name = '这是默认值'; } return $this-&gt;name; }}$a = new Account();echo $a-&gt;user;$a-&gt;name = 5;echo $a-&gt;name;echo $a-&gt;big; 运行之后就不会报错了。 现在有了这两个魔术方法就可以随时扩展类里面的属性了，是不是很方便呢？","link":"/2014/09/06/2014-09-07-php-oop-getter-setter.html"},{"title":"nginx url重写和pathinfo配置","text":"nginx近年来的上涨趋势确实挺快的，但是apache作为老牌HTTP服务器，拥有的生态圈是nginx比不上的。一个最简单的例子，URL重写，apache的话利用无所不能的.htaccess文件就可以了。nginx还要改主配置文件。 URL重写配置主配置文件123456location /{ if (!-e $request_filename) { rewrite ^/(.*)$ /index.php?$1 last; }} if和(中间要有括号,url重写这里就配置完了。 pathinfo配置nginx原生是不支持pathinfo的，但是通过配置fastcgi参数可以达到效果 主配置文件123456789location ~ [^/]\\.php(/|$){ # comment try_files $uri =404; to enable pathinfo #try_files $uri =404; fastcgi_pass unix:/tmp/php-cgi.sock; fastcgi_index index.php; include fastcgi.conf; include pathinfo.conf;} fastcgi.conf1234567891011121314151617181920fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;fastcgi_param QUERY_STRING $query_string;fastcgi_param REQUEST_METHOD $request_method;fastcgi_param CONTENT_TYPE $content_type;fastcgi_param CONTENT_LENGTH $content_length;fastcgi_param SCRIPT_NAME $fastcgi_script_name;fastcgi_param REQUEST_URI $request_uri;fastcgi_param DOCUMENT_URI $document_uri;fastcgi_param DOCUMENT_ROOT $document_root;fastcgi_param SERVER_PROTOCOL $server_protocol;fastcgi_param HTTPS $https if_not_empty;fastcgi_param GATEWAY_INTERFACE CGI/1.1;fastcgi_param SERVER_SOFTWARE nginx/$nginx_version;fastcgi_param REMOTE_ADDR $remote_addr;fastcgi_param REMOTE_PORT $remote_port;fastcgi_param SERVER_ADDR $server_addr;fastcgi_param SERVER_PORT $server_port;fastcgi_param SERVER_NAME $server_name;# PHP only, required if PHP was built with --enable-force-cgi-redirectfastcgi_param REDIRECT_STATUS 200; pathinfo.conf1234fastcgi_split_path_info ^(.+?\\.php)(/.*)$;set $path_info $fastcgi_path_info;fastcgi_param PATH_INFO $path_info;try_files $fastcgi_script_name =404; 结语从这些配置可以看出来，nginx的可定制性还是很强的，同样的，apache下的.htaccess文件，经过一些改写也能在nginx上成功运行~","link":"/2014/09/09/2014-09-10-nginx-urlrewritepathinfo.html"},{"title":"Linux删除乱码文件","text":"shell终端中有时候中文文件名会出现乱码，导致很多操作都不能进行，一个最简单的就是删除了。 linux中每个文件有类似于ID的东西，使用以下命令查看 1ll -i 显示出来的第一个数字就是文件的inum 可以利用以下命令进行删除操作,假设inum为111111 1find . -inum 11111 -exec rm -f {} \\ rm -f {}可以自行替换为自己需要操作的命令。这样的话，不管什么文件都可以操作，只要有inum!","link":"/2014/09/12/2014-09-13-linux-delete-messy-code-file.html"},{"title":"MySQL联合主键","text":"单字段主键MySQL单字段主键相信大家都熟悉了。就是以一个字段主要数据行的主键，比如下面这个表 123456create table `user`(user_id int(11) auto_increment,username varchar(24),password char(32),primary key(user_id)); user_id作为单字段主键,说明任何用户的user_id都不能相同，一个user_id即标识一个用户。 多字段联合主键再看这个表 123456create table `user`(username varchar(24),password char(32),email varchar(40),primary key(username,email)); 这里使用username,email作为联合主键，为了标识一个用户，只有在username和email共同存在，且不同时才能标识。 例子1234username password emailzhangsan 111111 zhangsan@qq.comzhangsan 111111 lisi@qq.comlisi 111111 zhangsan@qq.com 这三条记录均为合法记录，多字段联合主键的核心就是（所有字段才能唯一确定一条记录，就像上面的username,email）。","link":"/2014/09/12/2014-09-13-mysql-combined-primary-key.html"},{"title":"PHP正则表达式匹配中文","text":"正常的正则表达式匹配英文和数字以及一些常用字符还是很简单的，如 123/^\\w$//^[0-9]$//^[\\-\\_]$/ 等等，但是匹配中文的话就有些麻烦了。UTF-8的中文根据unicode编码，所以我们需要手动构造UTF-8字符串 1/^[\\x{4e00}-\\x{9fa5}]$/u 请注意大括号，因为没有大括号PHP会报错 1Warning: preg_match() [function.preg-match]: Compilation failed: PCRE does not support \\L, \\l, \\N, \\U, or \\u at offset 3 in test.php on line 3 因为\\x是表示十六进制数的，所以需要用大括号括起来 另外，需要增加 u 修饰符。 此修正符启用了一个 PCRE 中与 Perl 不兼容的额外功能。模式字符串被当成 UTF-8。 本修正符在 Unix 下自 PHP 4.1.0 起可用，在 win32 下自 PHP 4.2.3 起可用。 很多时候google的作用确实比 X度 大，学会google吧！","link":"/2014/09/12/2014-09-13-php-regex-chinese.html"},{"title":"linux利用ssh公钥部署git代码","text":"背景阿里云的使用门槛降低，直接导致了很多人优先使用VPS而不是以前的虚拟主机，毕竟虚拟主机存在诸多限制。阿里云犹如一台全新的服务器，所有软件都要自己安装。作为一个写PHP的，代码部署就略麻烦了，以前使用FTP的时候很方便部署，但是不适合长期开发（因为没有版本控制），所以使用GIT会很方便。 问题在windows开发机上使用https方式进行git操作是没问题的，但是在linux上进行git操作的时候就会出错误，会让你输入帐号密码，就算是对的帐号密码也不行。这种情况下需要使用 ssh 方式进行GIT。 解决方法 生成密钥 在终端下输入 ssh-keygen -t rsa 接下来的询问全部直接按回车 最后得到了两个文件：id_rsa和id_rsa.pub cat ~/.ssh/id_rsa.pub 将显示的内容全部复制下来 进入你的git网站，比如oschina的git 添加ssh公钥 保存 enjoy!","link":"/2014/09/14/2014-09-15-linux-public-key-git.html"},{"title":"bootstrap3禁用响应式布局","text":"IE8及以下版本的浏览器确实是心中的痛,不支持媒体查询和CSS3，导致bootstrap样式怪怪的。没办法，只能采取折中的办法–禁用响应式布局 移除 viewport 标签 引入该CSS文件以重置bootstrap的响应式布局 这种情况下会导致一些高级浏览器不能得到最好的效果，所以，进阶的办法是: 利用PHP判断是否是IE8及以下版本的浏览器，如果不是，则进行正常的响应式布局。如果是，则禁用响应式布局","link":"/2014/09/18/2014-09-18-bootstrap3-disable-responsive-layout.html"},{"title":"Grunt快速上手","text":"为什么要使用Grunt?一句话：自动化。对于需要反复重复的任务，例如压缩（minification）、编译、单元测试、linting等，自动化工具可以减轻你的劳动，简化你的工作。当你正确配置好了任务，任务运行器就会自动帮你或你的小组完成大部分无聊的工作。 怎么使用Grunt?1.grunt是基于nodejs的，所以请先安装nodejs和npm安装grunt2.新版本的grunt安装需要两步，终端执行 1npm install grunt-cli -g 3.进入项目目录，终端执行 1npm install grunt --save-dev 4.安装常用插件 1npm install grunt-contrib-cssmin grunt-contrib-uglify grunt-contrib-watch --save-dev 5.项目目录 1234567--dev |--js |-- jquery.js |-- main.js |--css |-- library.css |-- main.css 一个很简单的JS,CSS目录，很关键的任务在于如何定义Gruntfile.js文件（请在项目根目录下创建Gruntfile.js,大小写不能错）6.Gruntfile.js 12345678910111213141516171819202122232425262728module.exports = function(grunt) { grunt.initConfig({ cssmin: { site: { files: { 'build/css/site.css': ['dev/css/library.css', 'dev/css/main.css'] } }, }, uglify: { site: { src: ['dev/js/jquery.js', 'dev/js/main.js'], dest: 'build/js/site.js' }, }, watch: { site: { files: ['dev/js/**.*', 'dev/css/**.*'], tasks: ['uglify:site', 'cssmin:site'] } } }); grunt.loadNpmTasks('grunt-contrib-cssmin'); grunt.loadNpmTasks('grunt-contrib-uglify'); grunt.loadNpmTasks('grunt-contrib-watch'); grunt.registerTask('site', ['watch:site']);}; cssmin: site为一个子任务 build/css/site.css 为合并压缩之后的css存放路径,该参数后面的数组为原始的css文件路径 uglify: site为一个子任务 src数组为源JS文件 dest为合并压缩之后的js文件存放路径 watch site为一个子任务 files数组为监听哪些文件的变化 tasks数组为如果文件变化则执行什么任务 grunt.loadNpmTasks 加载模块 grunt.registerTask 注册新任务 在项目目录下打开CMD工具，输入 1grunt site 即开始执行监听，此时修改dev/js/main.js或者dev/css/main.css都会触发相应的事件。 结语从此以后再也不用进行重复的压缩合并…etc等一些重复而乏味的工作了，交给grunt吧！","link":"/2014/09/18/2014-09-18-grunt-get-started.html"},{"title":"七牛云存储定义自定义变量返回数据","text":"背景七牛云存储也使用了这么久了。一直一来都只用了它的图片上传和处理功能。用的是客户端直传API，七牛给我返回一个key（一串随机的hash值，对人类无可读性）。 最近做的一个文件共享的项目，因为文件是客户端直传七牛的，那么我在后台PHP这边是拿不到原始文件名的，但是文件列表必须显示原始文件名，不能显示那个hash值。后来查找文件发现，七牛可以自定义返回的变量。 关键代码12345678910&lt;?phpQiniu_SetKeys($this-&gt;accessKey, $this-&gt;secretKey);$putPolicy = new Qiniu_RS_PutPolicy($this-&gt;bucket);$putPolicy-&gt;Expires = $expires;$putPolicy-&gt;SaveKey = $filename;$putPolicy-&gt;FsizeLimit = 20*1024*1024;if($returnUrl != '') putPolicy-&gt;ReturnUrl = $returnUrl;$upToken = $putPolicy-&gt;Token(null);return $upToken; 通过对 $filename参数进行定制 1$filename = '$(fsize)/$(fname)' 这样子七牛返回的hash应该是 1a3466b7fa159ab4f671bdc4ae45dae08/103/稿件共享.txt 通过 explode 函数就可以拿到文件名了。 题外话七牛还有很多自定义参数有待各位挖掘，这里只做个抛砖引玉的作用。","link":"/2014/09/18/2014-09-18-qiniu-custom-data.html"},{"title":"PHP下载远程文件","text":"在开发爬虫的时候，文章的图片往往是有防盗链措施的，一个比较好的解决办法是通过PHP下载图片到本地并且替换URL实现。 由于图片这种东西不能直接像下载HTML那样直接下载，所以需要指定fopen的打开模式为b(二进制模式)。 123456789&lt;?php$url = 'http://picturescdn.qiniudn.com/93aa93787ae02be68192b3533d3e76b0';$remote_fp = fopen($url,'rb');$local_fp = fopen(date('YmdHis'),'wb');while(!feof($remote_fp)){ fwrite($local_fp,fread($remote_fp,128));}fclose($remote_fp);fclose($local_fp); 这样就在本地目录生成了一张图片。","link":"/2014/09/20/2014-09-20-php-download-remote-file.html"},{"title":"PHP自动更新网站","text":"目前软件开发主流越来越倾向于B/S模式，不同于C/S模式的软件，B/S模式下的WEB程序自动更新是个麻烦问题。 本人利用PHP下载远程文件和ZIP类，写了一个简单的自动更新DEMO，供大家参考。 服务端目录结构12345|data |--20140918.zip|--index.php 其中 data 文件夹用来存放补丁包,index.php 文件用来响应版本数据给客户端。 index.php1234567891011&lt;?phpsleep(3);header('Content-Type:application/json;utf-8');echo json_encode(array( '20140918' =&gt; array( 'version' =&gt; 20140920, 'desc' =&gt; 'BUG修正，缓存系统', 'url' =&gt; 'http://' . $_SERVER['HTTP_HOST'] . $_SERVER['REQUEST_URI'] . '/data/20140918.zip' )));exit(); 20140918 对应的是客户端版本号，20140920 对应的是服务端版本号，desc 是本次补丁的描述，url 则是补丁包下载地址 客户端目录结构1234567|tmp|--config.php|--Zip.php|--index.php config.php 为配置文件，保存本地版本信息，Zip.php 为ZIP操作类（从服务端下载的补丁包均为zip格式）,index.php 为自动更新程序（只是为了方便，实际中可以写个方法出来） index.php123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?phpob_implicit_flush(true);$begin = microtime(true);//检查更新,加载本地版本号$config = require(__DIR__ . '/config.php');$server = 'http://localhost/version';echo '连接更新服务器...&lt;br/&gt;';ob_flush();$versions = json_decode(file_get_contents($server), true);if (!isset($versions[$config['version']])) { echo '当前已是最新版本!';} else { echo '当前版本：&lt;b&gt;', $config['version'], '&lt;/b&gt; 服务器版本：&lt;b&gt;', $versions[$config['version']]['version'], '&lt;/b&gt;&lt;br/&gt;'; ob_flush(); //开始下载 $remote_fp = fopen($versions[$config['version']]['url'], 'rb'); if(!is_dir(__DIR__.'/tmp')) mkdir(__DIR__.'/tmp'); $tmp = __DIR__ . '/tmp/' . date('YmdHis') . '.zip'; $local_fp = fopen($tmp, 'wb'); echo '开始下载...&lt;br/&gt;'; ob_flush(); while (!feof($remote_fp)) { fwrite($local_fp, fread($remote_fp, 128)); } fclose($remote_fp); fclose($local_fp); echo '下载完成,准备解压&lt;br/&gt;'; ob_flush(); require(__DIR__ . '/Zip.php'); $zip = new Zip(); $zip-&gt;extra($tmp, __DIR__); echo '解压完成,准备删除临时文件&lt;br/&gt;'; ob_flush(); //删除补丁包 unlink($tmp); echo '临时文件删除完毕&lt;br/&gt;'; ob_flush(); //更新本地版本号 $content = file_get_contents(__DIR__.'/config.php'); $content = str_replace($config['version'],$versions[$config['version']]['version'],$content); file_put_contents(__DIR__.'/config.php',$content); echo '更新完成!耗时',microtime(true) - $begin,'秒&lt;br/&gt;'; ob_flush(); ob_end_clean(); exit();} config.php1234&lt;?phpreturn array( 'version' =&gt; '20140918'); Zip.php12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?php/** * @version 1.0 * @date 2014-08-11 * @author 十七号 &lt;xialeistudio@gmail.com&gt; * @license MIT * 压缩、解压缩类 */class Zip{ /** * 打包 * @param $path * @param $save */ public static function archive($path, $save) { $zip = new ZipArchive(); if ($zip-&gt;open($save, ZipArchive::OVERWRITE) === true) { self::addZip($path, $zip); $zip-&gt;close(); } } /** * 添加文件或文件夹到zip对象 * @param string $path * @param ZipArchive $zip */ private static function addZip($path, $zip) { $handler = opendir($path); while (($file = readdir($handler)) !== false) { if ($file != '.' &amp;&amp; $file != '..') { if (is_dir($path . DIRECTORY_SEPARATOR . $file)) { self::addZip($path . DIRECTORY_SEPARATOR . $file, $zip); } else { $zip-&gt;addFile($path . DIRECTORY_SEPARATOR . $file); } } } closedir($handler); } /** * 解压文件 * @param string $file 压缩文件路径 * @param string $path 解压路径，为空则以文件名为路径 */ public static function extra($file, $path = null) { if (!isset($path)) { $array = explode('.', $file); $path = reset($array); } $zip = new ZipArchive(); if ($zip-&gt;open($file) === true) { $zip-&gt;extractTo($path); $zip-&gt;close(); } }} 本文只写了一个很简单的自动更新程序，只是为了说明更新程序的基本思路。还有很多细节方面可以定制的。","link":"/2014/09/20/2014-09-20-php-website-auto-update.html"},{"title":"angularjs鼠标悬浮效果","text":"用JQ来做的话很简单的，(通过toggleClass函数就可以了),但是既然提到了angularjs，当然要用angularjs的解决方案来做啦! angularjs集成了一个jqlite模块（可以理解为阉割版的jquery）,提供有限并且常用的功能。 主要用到指令系统中的Link函数，代码就不贴了。 直接上dome吧！下载地址","link":"/2014/09/22/2014-09-22-angularjs-mouse-move-effect.html"},{"title":"highchats曲线不显示","text":"highchats是什么就不介绍了。一个JS绘图工具库，基于JQ，使用简单方便，但是不注意的话会坑人。 今天兴致满满的去绘图，后端数据也返回了。可是一个纠结的问题困扰了我一下午！ 后端数据返回的JSON是 1[&quot;0&quot;,&quot;0&quot;,&quot;0&quot;] 这种形式，JSON.parse解析之后返回的是一个字符数组，而不是数字数组，解决方案是利用JS做一次类型转换 123for(var i in data){ data[i]=parseInt(data[i]);} for(var i in data){ data[i]=parseInt(data[i]);}图形就可以正常显示了。","link":"/2014/09/24/2014-09-25-highchats-not-display.html"},{"title":"PHP遍历文件","text":"遍历文件夹主要用到 opendir readdir closedir 三个函数，有两个要注意的地方 要排除 ‘.’ 和 ‘..’ 两个目录 需要用到递归 12345678910111213141516171819202122232425&lt;?php/** * 遍历文件夹 * @param string $path * @return array */function listFiles($path){ $files = array(); $handler = opendir($path);//打开目录 while (($file = readdir($handler)) !== false) { if($file != '.' &amp;&amp; $file != '..'){ //当前目录和上级目录 if(is_dir($path.DIRECTORY_SEPARATOR.$file)){ $files[$file] = listFiles($path.DIRECTORY_SEPARATOR.$file); }else{ $files[] = $file; } } } closedir($handler); return $files;}$array = listFiles(__DIR__);print_r($array);","link":"/2014/09/26/2014-09-27-php-traverse-file.html"},{"title":"Yii1.x单点登录","text":"背景Web迅速发展的今天，往往一个产品拥有很多个子站点，SSO技术显得很重要。Yii作为我常用的框架，发现Yii的SSO配置其实是非常简单的。 代码在所有站点中直接打开 protected/config/main.php 在 components 中加入以下代码，并且把protected/runtime/state.bin文件复制到各个具体的子站点中就可以实现SSO了！ 123456789101112131415161718192021'user' =&gt; array( 'identityCookie' =&gt; array( 'domain' =&gt; '.ddhigh.com', 'path' =&gt; '/' ), // enable cookie-based authentication 'allowAutoLogin' =&gt; true, 'stateKeyPrefix' =&gt; 'ddhigh', 'loginUrl' =&gt; array('user/login') ), 'session' =&gt; array( 'cookieParams' =&gt; array( 'domain' =&gt; '.ddhigh.com', 'lifetime' =&gt; 0, 'timeout' =&gt; 3600 ), ), 'statePersister' =&gt; array( 'class' =&gt; 'CStatePersister', 'stateFile' =&gt; './protected/runtime/state.bin' ), 推荐所有的站点全部放在一个域名中进行操作~","link":"/2014/09/27/2014-09-28-yii1-sso.html"},{"title":"Angularjs动态表单项","text":"后台业务系统中有很多CURD操作，一个很简单的例子是OA系统中为员工添加帐号信息，传统的做法是添加完一个就跳转并提示“成功”,后来高级一点的做法是利用jquery来做。 但是一个比较麻烦的问题是需要手动拼接HTML并且插入文档树。 然而，现在有了跨时代神器–angularjs,就是这么炫，强大的双向绑定功能可以帮到我们。 整体思想是利用 ng-repeat 指令来遍历一个临时数组（元素个数为表单个数）生成表单 HTML代码12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html ng-app=&quot;application.site&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;/&gt; &lt;title&gt;Login&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div ng-controller=&quot;ListCtrl&quot;&gt; &lt;button type=&quot;button&quot; ng-click=&quot;add()&quot;&gt;添加表单&lt;/button&gt; &lt;form action=&quot;&quot; method=&quot;post&quot; class=&quot;form&quot; ng-repeat=&quot;form in forms&quot; novalidate=&quot;novalidate&quot;&gt; &lt;p&gt; 号表单&lt;/p&gt; &lt;label for=&quot;username&quot;&gt;帐号&lt;/label&gt; &lt;input type=&quot;text&quot; ng-model=&quot;username&quot; id=&quot;username&quot; ng-required=&quot;true&quot;/&gt; &lt;button type=&quot;submit&quot; ng-click=&quot;post($index,username)&quot;&gt;提交&lt;/button&gt; &lt;button type=&quot;button&quot; ng-click=&quot;remove($index)&quot;&gt;移除&lt;/button&gt; &lt;/form&gt;&lt;/div&gt;&lt;script src=&quot;js/angularjs-1.2.19.js&quot;&gt;&lt;/script&gt; JS代码123456789101112131415161718var site = angular.module('application.site', []);site.controller('ListCtrl', ['$scope', '$http',function($scope, $http) { $scope.forms = [&quot;1&quot;]; $scope.index = 1; $scope.post = function(index, username) { console.log(index + ' 号表单提交 [' + username + '] 成功'); } $scope.remove = function(index) { console.log('删除 [' + index + '] 号表单成功'); $scope.forms.splice(index, 1); } $scope.add = function() { console.log('添加表单'); $scope.forms.push((++$scope.index).toString()); }}]); 由于小编只是为了实现功能而写的这么一个demo，样式至上难免有些欠缺–。但是，麻雀虽小，五脏俱全，大家可以根据这个思路去开发更为强大的应用系统。","link":"/2014/09/29/2014-09-29-angularjs-dymanic-form-item.html"},{"title":"PHP二进制方法存储图片","text":"大部分人的图片上传都是保存一个路径到数据库，这样在插入时确实快，也符合web的特点，但是在删除时就很麻烦，需要找到文件并删除，该代码能够把代码直接存入数据库，删除时一并删除。请注意：这样的话数据库大小会激增，请酌情使用,且RDBMS对于二进制数据的处理并不是很理想。 表结构（只做简单演示，故字段有限）123456CREATE TABLE `upload` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, `type` varchar(20) NOT NULL, `data` mediumblob NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; 上传表单1234567891011121314&lt;!doctype html&gt; &lt;html&gt;&lt;head&gt; &lt;title&gt; Post-Image &lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;post.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot;/&gt; &lt;input type=&quot;submit&quot; value=&quot;OK&quot;/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 处理程序1234567891011121314151617181920212223242526&lt;?phpif ($_FILES[&quot;file&quot;][&quot;error&quot;] &gt; 0){ echo &quot;Error: &quot; . $_FILES[&quot;file&quot;][&quot;error&quot;] . &quot;&lt;br /&gt;&quot;;}else{ $type = $_FILES[&quot;file&quot;][&quot;type&quot;]; $size = $_FILES['file']['size']; $tmp=$_FILES[&quot;file&quot;][&quot;tmp_name&quot;]; $fp = fopen($tmp,'rb'); $data = bin2hex(fread($fp,$size)); $dsn='mysql:host=localhost;dbname=test'; echo '&lt;pre&gt;'; try{ $pdo = new PDO($dsn,'root','root'); $pdo-&gt;exec(&quot;INSERT INTO `upload`(`type`,`data`) values ('$type',0x$data)&quot;); $id = $pdo-&gt;lastInsertId(); echo 'upload success!&lt;a href=&quot;view.php?id='.$id.'&quot;&gt;View&lt;/a&gt;'; $pdo = null; }catch (PDOException $e){ echo $e-&gt;getMessage(); } echo '&lt;/pre&gt;'; fclose($fp);} 显示页面123456789101112131415161718&lt;?php$id = $_GET['id'];if(is_numeric($id)){ $dsn='mysql:host=localhost;dbname=test'; try{ $pdo = new PDO($dsn,'root','root'); $rs = $pdo-&gt;query('select * from `upload` where `id`='.$id); $row = $rs-&gt;fetchAll(); $data = $row[0]; header(&quot;Content-Type:${data['type']}&quot;); echo $data['data']; $pdo = null; }catch (PDOException $e){ echo $e-&gt;getMessage(); }}else{ exit();} 经过测试可行，请大家在必要的时候才使用~","link":"/2014/10/01/2014-10-02-php-save-image-to-database.html"},{"title":"html5新属性data api","text":"以往在做列表程序的时候，需要做类似“删除”功能的时候，往往是组装一个URL，类似于这个 index.php?m=news&amp;a=delete&amp;id=10 这是最普通的url方式来进行删除。 但是随着用户体验要求的增加，很多时候都需要使用ajax来实现相应效果。 记得很早以前在写一个CURD项目的时候，我是用ID来做的，类似于 id=”news_id_10”,id=”news_id_11” 这样，然后通过分割字符串来获取ID，简直就是要多麻烦有多麻烦，当时就在想有没有一个能自己定义所需数据的字段呢？ 现在好了。HTML5的data-* API可以帮到我们 html代码1&lt;a href=&quot;javascript:void(0)&quot; data-action=&quot;delete&quot; data-id=&quot;10&quot;&gt;删除&lt;/a&gt; 是不是看到了data-action和data-id属性呢？data-只要更改就可以了，需要满足标识符约束。 js代码12345678910111213141516171819$(document).on('click', '[data-action=&quot;delete&quot;]',function() { var $id = $(this).data(&quot;id&quot;); var $this = $(this); ajax &amp;&amp; ajax.abort(); ajax = $.get('index.php', { id: $id, m: 'news', a: 'delete' }, function(data) { if (data.status == 1) { //操作成功 } else { alert(data.info); } }, 'json');}); JQ提供的$.data方法确实挺方便的，但是请注意，本人发现$.data方法是只读的（就是不能改变data-id=”10”中的10），如果需要改变，请用底层的$.attr(‘data-id’,9)这种操作。","link":"/2014/10/07/2014-10-08-html5-data-api.html"},{"title":"ng-repeat获取父级INDEX","text":"angularjs的循环嵌套我就不多说了，无非是ng-repeat的嵌套而已，如果需要获取索引请使用$index。 那么问题来了，$index只能获取当前循环的索引，如果需要获取父级的索引怎么办？ 原理其实也不难，在父级ng-repeat时利用ng-init写入一个变量即可，子循环是可以访问到的。 12345678&lt;div ng-controller=&quot;MainCtrl&quot;&gt; &lt;dl ng-repeat=&quot;user in users&quot;&gt; &lt;dt ng-init=&quot;p_index=$index&quot;&gt;Name:&lt;/dt&gt; &lt;dd ng-repeat=&quot;p in user.posts&quot;&gt;父级INDEX: - 自己的INDEX: &lt;/dd&gt; &lt;/dl&gt;&lt;/div&gt; 1234567var site = angular.module('application.site', []);site.controller('MainCtrl', ['$scope', '$http', function ($scope, $http) { $scope.users = [ {name:&quot;xialei&quot;,posts:[&quot;文章一&quot;,&quot;文章二&quot;,&quot;文章三&quot;]}, {name:&quot;zhangsan&quot;,posts:[&quot;文章四&quot;,&quot;文章五&quot;]} ];}]); 这里只是关键代码，用过angularjs的小伙伴们相信一眼就可以看懂了。","link":"/2014/10/10/2014-10-11-ng-repeat-get-parent-index.html"},{"title":"nginx服务器启用SSL访问","text":"HTTP和HTTPS的区别 https协议需要到ca申请证书，一般免费证书很少，需要交费。 http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。 http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 所以在涉及到账户、金钱等敏感信息交互的时候使用HTTPS是个不错的选择。 申请证书 申请SSL证书过程就不多说了。挺简单的，本文主要是在nginx上配置ssl证书实现https访问。 将key和证书上传到服务器。 nginx配置123456789101112131415161718192021222324252627282930server { listen 443; #listen [::]:80; server_name passport.ddhigh.com; index index.html index.htm index.php default.html default.htm default.php; root /home/wwwroot/passport.ddhigh.com; include other.conf; #error_page 404 /404.html; location ~ [^/]\\.php(/|$) { # comment try_files $uri =404; to enable pathinfo try_files $uri =404; fastcgi_pass unix:/tmp/php-cgi.sock; fastcgi_index index.php; include fastcgi.conf; #include pathinfo.conf; } location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$ { expires 30d; } location ~ .*\\.(js|css)?$ { expires 12h; } ssl on; ssl_certificate /root/crt/server.crt; ssl_certificate_key /root/crt/server.key; access_log /home/wwwlogs/passport.ddhigh.com.log access;} /root/crt是我的证书目录，各位读者可以根据实际情况更改。","link":"/2014/10/11/2014-10-11-nginx-enable-ssl.html"},{"title":"移动端实时检测输入框","text":"PC浏览器的话由于有blur和focus事件，可以在失去焦点时进行一次验证，但是移动端有点麻烦，点击其他地方才可以，这种的话体验不是很好。利用input事件可以解决这个问题。 123$(document).on('input','#username',function(){ //验证逻辑}); 测试之后问题确实来了，每输入一个字符就会触发，浪费很多网络请求，接下来使用一个定时器的技术来进行处理。 12345678var timer;$(document).on('input','#username',function(){ timer &amp;&amp; clearTimeout(timer); timer = setTimeout(function(){ //验证逻辑 },500);//延时0.5s触发}); 采用这种定时器技术可以在请求次数和用户体验之间取得平衡，很多地方都可以使用这种技术来实现。","link":"/2014/10/13/2014-10-14-mobile-realtime-check.html"},{"title":"linux检查端口占用","text":"Linux启动服务时如果遇到端口占用问题时，一般有以下两种解决方案： 新启动的服务更改端口号启动 杀掉老的进程 Linux检查端口占用命令1netstat -lnp | grep 80 80为端口号，查找到占用端口的进程ID后用kill杀掉即可。","link":"/2014/10/15/2014-10-15-linux-check-port.html"},{"title":"移动端textarea自适应高度","text":"PC端网页的textarea内容多了会出现滚动条，这个没什么，鼠标么，滚动方便。但是移动端是没鼠标的，出现滚动条是很不友好的行为。 利用js的事件绑定及动态改变CSS就可以做到这个了。 1onpropertychange=&quot;this.style.height=this.scrollHeight + 'px'&quot; oninput=&quot;this.style.height=this.scrollHeight + 'px'&quot;","link":"/2014/10/20/2014-10-21-mobile-textarea-auto-fit.html"},{"title":"PHPExcel导出时为空的解决方法","text":"今天在做数据导出的时候遇到个麻烦事情，SQL查询是有数据的，但是写入excel的时候为空的。 输出异常是有一行遇到错误了。将那一行数据打印出来发现字段中有个 = 号，excel中有 = 会将后面的当作表达式计算，所以导致错误。 解决方式是在 = 前面加上单引号 ‘= 就可以了","link":"/2014/10/23/2014-10-24-phpexcel-export-empty.html"},{"title":"让IE7,IE8支持html5属性","text":"HTML5确实很好用，但是国内IE7和IE8的用户还是挺多的（或许是XP的缘故）。这些浏览器不识别HTML5的新属性以及，导致页面渲染进入“怪异”模式，简直就是“不堪入目”。不过，还好，开源的力量是强大的，有热心的开发者写了一套JS库来兼容IE7,IE8。本文就简单教大家用下这款JS库。 1.下载2.解压之后得到html5shiv.js3.开发模板 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;title&gt;Template&lt;/title&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=&quot;http://cdn.bootcss.com/html5shiv/3.7.2/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;http://cdn.bootcss.com/respond.js/1.4.2/respond.min.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;你好，世界！&lt;/h1&gt;&lt;script src=&quot;http://cdn.bootcss.com/jquery/1.11.1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 使用这个库之后就可以正常开发啦。题外话：IE系列好像是不太好兼容的。","link":"/2014/10/28/2014-10-28-ie7ie8-support-html5-attribute.html"},{"title":"解决 angularjs html5Mode 404的问题","text":"采用location的html5Mode之后，链接是正常的，但是刷新的时候会404，此时就需要后端服务器配置URL重写了。 nginx 配置123location / { try_files $uri $uri/ /index.html$is_args$args;} 这样子就可以将所有不是文件夹且不是文件的请求转发到index.html。","link":"/2014/10/29/2014-10-30-angularjs-html5mode-404.html"},{"title":"UCenter 后台应用通知列表空白","text":"今天遇到了一个奇葩的问题UCenter后台通知列表空白并且500，通过xdebug调试发现是**uc_server/control/admin/note.php 第68行代码有问题!**IDE都报错了 原代码1$this-&gt;_format_notlist(&amp;$notelist); 修正代码1$this-&gt;_format_notlist($notelist); 可能是由于PHP版本升级导致的问题。","link":"/2014/10/30/2014-10-31-ucenter-empty.html"},{"title":"mac os x 使用eclipse调试android","text":"这两天心血来潮装了个mac os x 10.10系统，折腾的过程就不说了。Mac OS X 10.10的环境下，Eclipse+ADT，进行真机调试时，会出现一个问题。终端下输入 adb devices可以看到小米2S，但是Device Chooser对话框里不显示真机设备，只有重新插拔数据线才可以。仔细看了下android run configure发现一个问题，默认显示的compatible devices（意思差不多是适配的设备）。简单说下方法右键项目&gt;run as&gt;run configurations&gt;target&gt;选中间那个&gt;Active Devices再次点击run就可以了。","link":"/2014/11/01/2014-11-01-mac-os-x-debug-android-with-eclipse.html"},{"title":"解决wordpress d8主题使用七牛镜像插件后无法评论的问题","text":"上午有热心的网友给我反映说评论功能出bug了，初步查看是七牛出了问题，利用chrome的开发者工具可以查看请求。PS：这张图是今天截的，所以域名是正常的，昨天实际上请求的是 static.ddhigh.com (本站的CDN域名)。查看HTTP请求发现整站就请求了一个jquery文件，但是这个文件比较大有140K，查看源代码发现评论的代码已经合并在里面了。按照以上步骤可以查看到评论时执行的脚本，当然这里的域名已经修复了。 278行，昨天的是 1url:window._deel.url+&quot;/ajax/comment.php&quot; 在控制台输入 1console.log(_deel); 域名是CDN域名，所以ajax请求实际上被提交到七牛去了。 修正方法利用ssh工具连接你的服务器（不是七牛），找到对应的jquery文件278行，改成你的站点域名（如本站的www.ddhigh.com）,更新下缓存即可。","link":"/2014/10/31/2014-11-01-wordpress-d8-theme-qiniu-cannot-comment.html"},{"title":"android 替换斜杠","text":"问题最近写安卓的时候服务端返回的数据会带上“\\n”，但是在android这边不能换行，初次想到的解决方法是利用 1String.replace(&quot;\\n&quot;,&quot;\\n&quot;) 给替换掉，结果是不行的。之前记得java的反斜杠是需要转义的，就用 1String.replaceAll(&quot;\\n&quot;,&quot;\\\\n&quot;) 试了一下，结果依旧不行。后来去查了谷歌–，发现要 \\\\n 才可以 匹配到 \\n,这么多斜杠，头都晕了，一个个来解释： 第一个和第二个反斜杠是一组，由于java的转义，实际为 “&quot; 第三个和第四个同理， 经过以上两步之后，\\\\n 实际上是 \\n ，由于是正则的关系，\\n 可以匹配到字符串的\\n了。 解决方法1String.replaceAll(&quot;\\\\n&quot;,&quot;\\\\n&quot;) 第一个参数是正则，第二个是普通字符串。不得不吐槽下Java的正则表达式。。","link":"/2014/11/06/2014-11-07-android-replace-slash.html"},{"title":"async http client socket超时问题","text":"最近做的一个项目的HTTP模块使用了loopj的asynchttpclient (https://github.com/loopj/android-async-http）。 自动更新模块总是出现sockettimeout的exception,查来查去也不知道什么问题，为此还换了asynchttpclient的库版本。但是问题也没解决。 仔细看了一下，提示的是timeout，应该从这方面去看看，后面看到自己的HTTP工具类设置了全局超时时间为5000ms,普通请求当然没这么久，但是自动更新是下载，肯定不止5秒的，删掉超时设置就可以了。","link":"/2014/11/09/2014-11-10-async-http-client-socket-timeout.html"},{"title":"android使用ImageLoader缓存图片","text":"缓存和异步是两个极大提升用户体验的好东西，android加载图片时的开销还是挺大的，要是不做缓存同步加载，网速不给力的情况下，等个十几秒是有可能的。 今天要说的是一个叫做ImageLoader的库 GITHUB:https://github.com/nostra13/Android-Universal-Image-Loader 使用这个库有以下几步： 导入libs目录 声明自己的MyApplication类（继承Application） 在onCreate()方法中 123456789101112131415public void onCreate() { super.onCreate(); DisplayImageOptions options = new DisplayImageOptions.Builder() .cacheInMemory() //缓存在内存中 .cacheOnDisc() //磁盘缓存 .build(); ImageLoaderConfiguration config2 = new ImageLoaderConfiguration.Builder(this) .defaultDisplayImageOptions(options) .threadPriority(Thread.NORM_PRIORITY - 2) .denyCacheImageMultipleSizesInMemory() .discCacheFileNameGenerator(new Md5FileNameGenerator()) .tasksProcessingOrder(QueueProcessingType.LIFO) .build(); ImageLoader.getInstance().init(config2);} 在要加载图片的地方使用 1234567DisplayImageOptions options = new DisplayImageOptions.Builder() .cacheInMemory() // 缓存用 .cacheOnDisc() .bitmapConfig(Bitmap.Config.RGB_565)//防止溢出 .displayer(new RoundedBitmapDisplayer(139)) // 图片圆角显示，值为整数 .build();ImageLoader.getInstance().displayImage(url, avatar, options); 其中 url 是图片URL地址，avatar为ImageView,options为动态配置，这里加了一个防止溢出的参数。 好了，使用起来是不是很简单呢~我们压根不用操心异步和缓存的问题了","link":"/2014/11/10/2014-11-11-android-cache-image-with-imageloader.html"},{"title":"IllegalStateException： Can not perform this action after onSaveInstanceState","text":"今天使用Fragment的时候，出现了这个错误 IllegalStateException: Can not perform this action after onSaveInstanceState。查看一下控制台，发现是FragmentManager的commit()方法报错的，看字面意思应该是 onSaveInstanceState这个方法之后不能处理这个操作（指commit()）。 因为onSaveInstanceState方法是在该Activity即将被销毁前调用，来保存Activity数据的，如果在保存完状态后再给它添加Fragment就会出错。解决办法就是把commit（）方法替换成 commitAllowingStateLoss()就行了，其效果是一样的。","link":"/2014/11/12/2014-11-13-illegalstateexception-can-not-perform-this-action-after-onsaveinstancestate.html"},{"title":"angularjs遍历空数组&amp;索引数组","text":"今天做开发时发现控制老是报错，虽然不影响使用，但是作为有那么一点“强迫症”的我来说，无法忍受。通过调试发现是ng-repeat对一个空数组遍历出错，另外，[‘ab’,’cd’,’ad’]这样只有值没有键的数组也会遍历出错。 解决办法12345678910111213&lt;li class=&quot;media&quot; ng-repeat=&quot;item in comments track by $index&quot;&gt; &lt;div class=&quot;media-body&quot;&gt; &lt;strong&gt;&lt;/strong&gt;&lt;p&gt; &lt;br /&gt;&lt;time&gt;&lt;/time&gt;&lt;br /&gt;&lt;span ng-if=&quot;item.comment_author_url.length&gt;0&quot;&gt; &lt;i class=&quot;fa fa-globe&quot;&gt;&lt;/i&gt; &lt;a href=&quot;&quot; target=&quot;_blank&quot;&gt;&lt;/a&gt; &lt;/span&gt; &lt;/p&gt; &lt;/div&gt;&lt;/li&gt; 特别注意track by $index","link":"/2014/11/14/2014-11-14-angularjs-traverse-empty-array.html"},{"title":"Angularjs处理后端空数据","text":"Yii1.x DAO中的queryAll方法查询，如果有结果，会返回一个数组，如果没有结果，会返回null。现在分两种情况： 返回空数组123$array = array();echo json_encode($array); 输出为 1[] 返回null12$array = null;echo json_encode($array); 输出为 1null 那么问题来了，JS接收这两个的结果是不同的。如果使用以下代码判断数据: 12345if(data.length == 0){ //当前评论为空}else{ //当前评论不为空} 如果返回 [] ，这段代码是生效的。但是如果返回 null ,这个就有问题了。 后来，使用 12345if(data == null){ //评论为空}else{ //评论不为空} 这个判断老是出问题，后端明明返回null了，判断还是错误的，这时候想到JS也是若类型语言，会不会是类型的问题。 1console.log(typeof data) 返回的是**”string”**那么问题就解决了，用以下代码就可以了 12345if(data.length == 0 || data == &quot;null&quot;){ //评论为空}else{ //评论不为空}","link":"/2014/11/15/2014-11-15-angularjs-empty-array.html"},{"title":"android datepicker和timepicker显示在一行","text":"android默认的datepicker和默认的timepicker可以放在一行（Linelayout），但是timepicker右边会“挤出”屏幕，尝试设置layout_weight和layout_height对于布局有效，但是控件显示就不完整了。到这一步发现xml不局文件已经处理不了，所以自然想到应该利用java来处理了。 效果图 布局代码1234567891011121314151617&lt;LinearLayout android:orientation=&quot;horizontal&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;fill_parent&quot; android:paddingLeft=&quot;10dp&quot;&gt; &lt;DatePicker android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/datePicker&quot; android:calendarViewShown=&quot;false&quot; /&gt; &lt;TimePicker android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/timePicker&quot; /&gt;&lt;/LinearLayout&gt; JAVA代码UI.java12345678910111213141516171819202122232425262728293031public static void resizePicker(FrameLayout tp) { List&lt;NumberPicker&gt; npList = findNumberPicker(tp); for (NumberPicker np : npList) { resizeNumberPicker(np); }}private static List&lt;NumberPicker&gt; findNumberPicker(ViewGroup viewGroup) { List&lt;NumberPicker&gt; npList = new ArrayList&lt;NumberPicker&gt;(); View child = null; if (null != viewGroup) { for (int i = 0; i &lt; viewGroup.getChildCount(); i++) { child = viewGroup.getChildAt(i); if (child instanceof NumberPicker) { npList.add((NumberPicker) child); } else if (child instanceof LinearLayout) { List&lt;NumberPicker&gt; result = findNumberPicker((ViewGroup) child); if (result.size() &gt; 0) { return result; } } } } return npList;}private static void resizeNumberPicker(NumberPicker np) { LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(100, RadioGroup.LayoutParams.WRAP_CONTENT); params.setMargins(10, 0, 10, 0); np.setLayoutParams(params);} Main.javaView的查找自己应该知道写了。 1234567891011121314151617181920212223242526UI.resizePicker(datePicker);UI.resizePicker(timePicker);datePicker.setMinDate(System.currentTimeMillis() - 1000);datePicker.init(year, monthOfYear, dayOfMonth, new DatePicker.OnDateChangedListener() {public void onDateChanged(DatePicker view, int year, int monthOfYear, int dayOfMonth) { //得到时间 String time = timePicker.getCurrentHour() + &quot;:&quot; + timePicker.getCurrentMinute(); datetime = year + &quot;-&quot; + (monthOfYear + 1) + &quot;-&quot; + dayOfMonth + &quot; &quot; + time; } }); timePicker.setIs24HourView(true); timePicker.setOnTimeChangedListener(new TimePicker.OnTimeChangedListener() { public void onTimeChanged(TimePicker view, int hourOfDay, int minute) { String date = datePicker.getYear() + &quot;-&quot; + (datePicker.getMonth() + 1) + &quot;-&quot; + datePicker.getDayOfMonth(); datetime = date + &quot; &quot; + timePicker.getCurrentHour() + &quot;:&quot; + timePicker.getCurrentMinute(); } }); 原理datepicker和timepicker都是继承FrameLayout，内部为很多NumberPicker，所以，查找到所有NumberPicker的List，然后设置样式即可。","link":"/2014/11/19/2014-11-19-android-datepickertimepicker-display-inline.html"},{"title":"在coding上部署Yii1.x应用","text":"总的来说，由于没有成熟的资料可以参考，部署过程话费了将近一个小时才成功，现在来分享一下经验。 目录配置由于Paas禁止了本地写功能，所以，如果不加任何处理的话，Yii会尝试在 protected/runtime 目录下写私有文件，结果是肯定没权限的。 经过查找官方文档发现CApplication有个方法叫setRuntimePath，可以设置运行时目录，那么最重要的一点，这个目录的配置肯定要在入口文件中配置，更改之后的入口文件代码如下： 12345678910111213141516defined('YII_DEBUG') or define('YII_DEBUG',false);if(isset($_GET['_d'])) setcookie('_d',1,7*25*3600);// change the following paths if necessary$yii=dirname(__FILE__).'/framework/yii.php';$config=dirname(__FILE__).'/protected/config/main.php';// remove the following lines when in production mode// specify how many levels of call stack should be shown in each log messagedefined('YII_TRACE_LEVEL') or define('YII_TRACE_LEVEL',3);require_once($yii);$app = Yii::createWebApplication($config);$app-&gt;setRuntimePath('/home/vcap/fs/*****');$app-&gt;run(); 可以看到，倒数一二行，重新设置了 runtimepath，所以，第一个问题解决。 数据库配置数据库这边没什么好说的，自己更改下连接信息就可以了。 缓存配置本地开发采用的缓存，默认是File的，如果你解决了上一个问题之后，在线上，缓存是没有问题了，这里探讨下服务器缓存的设置（Coding.NET提供的缓存为Redis的，PHP操作Redis需要扩展，这里先不探讨），本站现在的缓存驱动为DB方法，配置方法为: 12345'cache' =&gt; array( 'class' =&gt; 'system.caching.CDbCache', 'connectionID' =&gt; 'db', 'cacheTableName'=&gt;'t_cache'), 日志配置默认情况下，日志是写入runtime path的，不过在Paas上，我们一般是没有本地文件权限的，就算写入了，查看起来比较麻烦，这里也采用数据库方法记录： 123456'log' =&gt; array('class' =&gt; 'CLogRouter','routes' =&gt; array( array('class'=&gt;'CDbLogRoute', 'connectionID'=&gt;'db', 'logTableName'=&gt;'t_log'))) 总结经过以上处理，大家应该发现很多任务都交给数据库了，连缓存也是，缓存不就是为了减少直接从数据库读取数据吗，为什么还要用数据库缓存呢？ 这里本人简单分析下（仅代表本人观点） WEB应用程序的瓶颈在于数据库，比如InnoDB方法进行事务操作时，会锁行，或者锁表，这样下一个请求对同一条记录进行事务操作时会有“锁等待”，会浪费大部分的时间。还有一种是复杂的大数据查询，就算做了很多优化，查询速度依旧不快，毕竟连表的开销很大。 而数据库缓存的核心就是，数据只需要一次单表查询即可，没有连表，没有加锁，这个速度还是很快的。所以数据库缓存的存在性就是在此。","link":"/2014/12/04/2014-12-05-coding-yii1.html"},{"title":"android实现圆形带进度条的ProgressBar","text":"android加载图片免不了使用加载进度显示，而android自带的progressBar有局限. 圆型的progressBar不能显示进度条，只能无限制转圈圈 水平的progressBar可以显示进度条，但是貌似不好看 解决办法是自己写一个view就可以了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package com.ddhigh.library.widget;import android.content.Context;import android.graphics.Canvas;import android.graphics.Color;import android.graphics.Paint;import android.graphics.RectF;import android.util.AttributeSet;import android.view.View;public class CircleProgressBar extends View { private int maxProgress = 100; private int progress = 0; //画圆所在的距形区域 RectF oval; Paint paint; public CircleProgressBar(Context context, AttributeSet attrs) { super(context, attrs); oval = new RectF(); paint = new Paint(); } @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); int width = this.getWidth(); int height = this.getHeight(); if(width!=height) { int min=Math.min(width, height); width=min; height=min; } paint.setAntiAlias(true); // 设置画笔为抗锯齿 paint.setColor(Color.WHITE); // 设置画笔颜色 canvas.drawColor(Color.TRANSPARENT); // 白色背景 int progressStrokeWidth = 4; paint.setStrokeWidth(progressStrokeWidth); //线宽 paint.setStyle(Paint.Style.STROKE); oval.left = progressStrokeWidth / 2; // 左上角x oval.top = progressStrokeWidth / 2; // 左上角y oval.right = width - progressStrokeWidth / 2; // 左下角x oval.bottom = height - progressStrokeWidth / 2; // 右下角y canvas.drawArc(oval, -90, 360, false, paint); // 绘制白色圆圈，即进度条背景 paint.setColor(Color.rgb(0x57, 0x87, 0xb6)); canvas.drawArc(oval, -90, ((float) progress / maxProgress) * 360, false, paint); // 绘制进度圆弧，这里是蓝色 paint.setStrokeWidth(1); String text = progress + &quot;%&quot;; int textHeight = height / 4; paint.setTextSize(textHeight); int textWidth = (int) paint.measureText(text, 0, text.length()); paint.setStyle(Paint.Style.FILL); canvas.drawText(text, width / 2 - textWidth / 2, height / 2 +textHeight/2, paint); } public int getMaxProgress() { return maxProgress; } public void setMaxProgress(int maxProgress) { this.maxProgress = maxProgress; } public void setProgress(int progress) { this.progress = progress; this.invalidate(); } /** * 非ＵＩ线程调用 */ public void setProgressNotInUiThread(int progress) { this.progress = progress; this.postInvalidate(); }} 效果图","link":"/2014/12/05/2014-12-06-android-circle-progressbar.html"},{"title":"MySQL行锁的使用","text":"大家可能都有这样一种感觉，Web程序在本地调试的时候一切正常，放到线上也基本是正常，但是偶尔会有数据错误的情况，这种情况在订单系统中特别常见，因为大部分的订单状态更新都是有两个路径（浏览器跳转和支付服务器的异步推送消息），当然，最终数据要以异步结果为准，但是问题是，浏览器跳转也需要更新订单状态，当这两种方式在很短的时间内同时到达数据库时（一般在一秒内），如果数据库没有加锁，那这个订单会被处理两次。 说到建立数据表时，涉及到支付的，都要用InnoDB引擎，该引擎支持行锁，支持事务，外键。 文章开始的解决办法就是采用InnoDB对要操作的数据行进行锁定。 数据表结构1订单ID(主键) 订单金额 订单状态 事务SQL1234BEGIN;SELECT * FROM `orders` WHERE `order_id`=100 FOR UPDATE;COMMIT; 释义 BEGIN 手动开启事务（行锁只对开启事务的查询起作用） FOR UPDATE 独占写（成功获得锁后，只有当前进程能够更新该纪录，其他进程如果需要更新该记录，则需进行“锁等待”） COMMIT 提交处理","link":"/2014/12/11/2014-12-12-mysql-row-lock.html"},{"title":"css水平居中和垂直居中","text":"水平居中还是比较好弄的 1234{ margin-left: auto; margin-right: auto;} 但是垂直居中就比较麻烦，网上一大推文章都是什么display:table-cell,根本不管用。这里利用position属性可以达到这个目的。 效果图 HTML代码12345678&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; CSS代码1234567891011121314151617181920body{ background: #f1f1f1;}.container{ width: 400px; height: 400px; position: relative; margin: 100px auto; background: white;}.container .inner{ width: 100px; height: 100px; background: black; position: absolute; left: 50%; margin-left: -50px; top: 50%; margin-top: -50px;} 关键点top属性和margin-top的组合，一般来说 top: 50%之后，加一个 margin-top: 容器的高度/2 就可以垂直居中了。","link":"/2014/12/16/2014-12-16-css-center.html"},{"title":"angularjs注入拦截器实现Loading效果","text":"angularjs作为一个全ajax的框架，对于请求，如果页面上不做任何操作的话，在结果烦回来之前，页面是没有任何响应的，不像普通的HTTP请求，会有进度条之类。 本文通过对httpProvider注入拦截器实现loading。 HTML代码12345&lt;div class=&quot;loading-modal modal&quot; ng-if=&quot;loading&quot;&gt; &lt;div class=&quot;loading&quot;&gt; &lt;img src=&quot;&lt;?=$this-&gt;module-&gt;getAssetsUrl()?&gt;/img/loading.gif&quot; alt=&quot;&quot;/&gt;&lt;span ng-bind=&quot;loading_text&quot;&gt;&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; LESS代码123456789101112131415161718192021222324252627282930.modal { position: fixed; width: 100%; height: 100%; left: 0; top: 0; z-index: 99; background: rgba(0, 0, 0, 0.3); overflow: hidden;}.loading { position: absolute; top: 50%; background: white; #solution&gt; .border-radius(8px); width: 160px; height: 72px; left: 50%; margin-top: -36px; margin-left: -80px; text-align: center; img { margin-top: 12px; text-align: center; } span { display: block; }} JS代码1234567891011121314151617181920212223242526272829app.config([&quot;$routeProvider&quot;, &quot;$httpProvider&quot;, function ($routeProvider, $httpProvider) { $routeProvider.when('/', { templateUrl: &quot;/views/reminder/index.html&quot;, controller: &quot;IndexController&quot; }); $routeProvider.when('/create', { templateUrl: &quot;/views/reminder/item/create.html&quot;, controller: &quot;ItemCreateController&quot; }); $routeProvider.otherwise({redirectTo: '/'}); $httpProvider.interceptors.push('timestampMarker');}]);//loadingapp.factory('timestampMarker', [&quot;$rootScope&quot;, function ($rootScope) { var timestampMarker = { request: function (config) { $rootScope.loading = true; config.requestTimestamp = new Date().getTime(); return config; }, response: function (response) { // $rootScope.loading = false; response.config.responseTimestamp = new Date().getTime(); return response; } }; return timestampMarker;}]); 效果图","link":"/2014/12/19/2014-12-19-angularjs-loading.html"},{"title":"angularjs开发ios风格的toggle","text":"效果图 HTML代码123456&lt;div class=&quot;toggle-box&quot; ng-click=&quot;item.hide_remind = !item.hide_remind&quot; ng-class=&quot;{'active':item.hide_remind,'':!item.hide_remind}&quot; ng-init=&quot;item.hide_remind=0&quot;&gt; &lt;div class=&quot;toggle-container&quot;&gt; &lt;div class=&quot;toggle-item&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334.site-create .page-bd .container form .form-group .toggle-box { position: absolute; right: 48px; top: 15px;}.site-create .page-bd .container form .form-group .toggle-box .toggle-container { position: relative; width: 72px; height: 40px; background: #a8aeb3; -webkit-border-radius: 24px; -moz-border-radius: 24px; border-radius: 24px; padding: 2px;}.site-create .page-bd .container form .form-group .toggle-box .toggle-container .toggle-item { width: 39px; height: 39px; background: white; -webkit-border-radius: 39px; -moz-border-radius: 39px; border-radius: 39px; cursor: pointer; -webkit-transition: all linear 0.3s; -moz-transition: all linear 0.3s; -o-transition: all linear 0.3s; transition: all linear 0.3s;}.site-create .page-bd .container form .form-group .toggle-box.active .toggle-container { background: #79e575;}.site-create .page-bd .container form .form-group .toggle-box.active .toggle-container .toggle-item { margin-left: 32px;} 记得自己去掉不存在的容器（我是在项目中用的，有CSS层级限制） JS代码无 所有的操作都在html中实现的。如果需要获取值，请获取item.hide_remind即可","link":"/2014/12/19/2014-12-20-angularjs-ios-like-toggle.html"},{"title":"wordpress使用prettify插件实现代码高亮","text":"最近百度感冒的太严重了，统计代码严重拖慢网页打开速度，不得已，只得暂时关闭JS统计代码。而另一个重灾区–ueditor也是太大了。我着实受不了。也关掉了。那么问题来了。之前用ueditor有配套的代码高亮插件，取消ueditor之后，代码不亮了。别急，wordpress的插件多着呢! 步骤1.插件-&gt;安装插件，搜索 “prettify” ，排名第一的插件就是他了，直接启用吧 2.wordpress这边就配置完了，以后写代码时，像这样 1234&lt;pre class=&quot;prettyprint linenums&quot;&gt; &lt;?php echo 1;&lt;/pre&gt; 刷新一下页面，是不是发现已经变了呢~，这款插件效果确实挺赞的！","link":"/2014/12/27/2014-12-28-wordpress-prettify.html"},{"title":"SVN命令行提交“--This line, and those below, will be ignored--”","text":"今天phpstorm突然抽风，导致svn不能用，无奈只好用svn命令来提交。 1svn commit -m &quot;init&quot; 结果报错 12345678910111213--This line, and those below, will be ignored--M webroot/thatyear/js/main.js~ ~ ~ ~ ~ ~ ~ ~ ~ &quot;svn-commit.2.tmp&quot; 4L, 83C 直接保存发现会出现以下结果 12Log message unchanged or not specified(a)bort, (c)ontinue, (e)dit: 输入c提交我这是设置了SVN提交默认编辑器的时候才会这样，默认是不会设置的。按以下操作设置提交的编辑器 1vi ~/.subversion/config 找到[helpers]下的 editor-cmd 节，更改为vi即可 12[helpers]editor-cmd = /usr/bin/vi","link":"/2014/12/29/2014-12-29-svn-commit-error.html"},{"title":"移动端滑动的实现","text":"如果想在移动端判断用户的是否滑动以及滑动方向时，可以不使用第三方库，直接用touch事件处理即可，没必要增加不必要的代码，减轻移动端网络压力。 重点移动端的touch事件有三个: touchstart、touchmove、touchend 分别代表 触摸开始，触摸移动，触摸结束 12345678910111213var _begin;var _end;document.querySelector('#target').addEventListener('touchstart', function(e) { _begin = e.changedTouches[0].pageX;}, false);document.querySelector('#target').addEventListener('touchend', function(e) { _end = e.changedTouches[0].pageX; if (_end &gt; _begin) { console.log('从左向右') }else{ console.log('从右向左') }}, false);","link":"/2015/01/08/2015-01-08-mobile-swipe.html"},{"title":"php利用百度地图API进行IP定位和GPS定位","text":"最近在做一个手机端的webapp地图应用，而核心内容当然是定位了，但是定位的话有几种方式，IP定位,GPS定位，基站定位（这个貌似webapp用不了）， 那么剩下核心的gps定位和ip定位了，我们知道，html5有定位API，但是该API拿到的GPS数据是硬件坐标，无法直接显示在地图上。 后来上百度LBS云看到有地图IP定位API和GPS坐标转换API，地址：http://developer.baidu.com/map/ 百度地图API的调用需要申请KEY，这里就不具体介绍了，直接贴上本人写了两个关键方法，为了方便前台调用，返回数据采用以下格式： 12345678910{ address: &quot;北京市海淀区西二旗北路&quot;, province: &quot;北京市&quot;, city: &quot;北京市&quot;, street: &quot;西二旗北路&quot;, street_number: &quot;&quot;, city_code: 131, lng: 116.3207676804, lat: 40.064084055578} PHP代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112&lt;?php/** * @author xialei &lt;xialeistudio@gmail.com&gt; */class map{ private static $_instance; const REQ_GET = 1; const REQ_POST = 2; /** * 单例模式 * @return map */ public static function instance() { if (!self::$_instance instanceof self) { self::$_instance = new self; } return self::$_instance; } /** * 执行CURL请求 */ protected function async($api,array $params) { $ch = curl_init($api.'?'.http_build_query($params)); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); $resp = curl_exec($ch); curl_close($ch); return $resp; } /** * ip定位 * @param string $ip * @return array * @throws Exception */ public function locationByIP($ip) { //检查是否合法IP if (!filter_var($ip, FILTER_VALIDATE_IP)) { throw new Exception('ip地址不合法'); } $params = array( 'ak' =&gt; '百度地图API KEY', 'ip' =&gt; $ip, 'coor' =&gt; 'bd09ll'//百度地图GPS坐标 ); $api = 'http://api.map.baidu.com/location/ip'; $resp = $this-&gt;async($api, $params); $data = json_decode($resp, true); //有错误 if ($data['status'] != 0) { throw new Exception($data['message']); } //返回地址信息 return array( 'address' =&gt; $data['content']['address'], 'province' =&gt; $data['content']['address_detail']['province'], 'city' =&gt; $data['content']['address_detail']['city'], 'district' =&gt; $data['content']['address_detail']['district'], 'street' =&gt; $data['content']['address_detail']['street'], 'street_number' =&gt; $data['content']['address_detail']['street_number'], 'city_code' =&gt; $data['content']['address_detail']['city_code'], 'lng' =&gt; $data['content']['point']['x'], 'lat' =&gt; $data['content']['point']['y'] ); } /** * GPS定位 * @param $lng * @param $lat * @return array * @throws Exception */ public function locationByGPS($lng, $lat) { $params = array( 'coordtype' =&gt; 'wgs84ll', 'location' =&gt; $lat . ',' . $lng, 'ak' =&gt; '百度地图API KEY', 'output' =&gt; 'json', 'pois' =&gt; 0 ); $resp = $this-&gt;async('http://api.map.baidu.com/geocoder/v2/', $params, false); $data = json_decode($resp, true); if ($data['status'] != 0) { throw new Exception($data['message']); } return array( 'address' =&gt; $data['result']['formatted_address'], 'province' =&gt; $data['result']['addressComponent']['province'], 'city' =&gt; $data['result']['addressComponent']['city'], 'street' =&gt; $data['result']['addressComponent']['street'], 'street_number' =&gt; $data['result']['addressComponent']['street_number'], 'city_code'=&gt;$data['result']['cityCode'], 'lng'=&gt;$data['result']['location']['lng'], 'lat'=&gt;$data['result']['location']['lat'] ); }}","link":"/2015/01/11/2015-01-12-php-location-by-ipgps-with-baidu-mapapi.html"},{"title":"css3打造炫酷loading","text":"css3的优点就不多说了，一个很重要的，节约了带宽，以往需要使用图片的地方很多时候都可以使用CSS3来实现。 本文将带来一个利用CSS3制作loading的教程，这里直接上代码了。 CSS代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990@keyframes spin { 0% { transform: rotate(0deg); -webkit-transform: rotate(0deg); } 100% { transform: rotate(360deg); -webkit-transform: rotate(360deg); }}@-webkit-keyframes spin { 0% { transform: rotate(0deg); -webkit-transform: rotate(0deg); } 100% { transform: rotate(360deg); -webkit-transform: rotate(360deg); }}@keyframes spinoff { 0% { transform: rotate(0deg); -webkit-transform: rotate(0deg); } 100% { transform: rotate(-360deg); -webkit-transform: rotate(-360deg); }}@-webkit-keyframes spinoff { 0% { transform: rotate(0deg); -webkit-transform: rotate(0deg); } 100% { transform: rotate(-360deg); -webkit-transform: rotate(-360deg); }}body { margin: 0;}.content { width: 100px; height: 100px; position: relative; margin: 10% auto 0 auto;}.content .ball { top: 25px; left: 25px; width: 50px; height: 50px; position: absolute; border-radius: 50px; -webkit-border-radius: 50px; border: 5px solid rgba(40,40,200,0.5); border-left: 5px solid rgba(255,255,255,0.7); border-top: 5px solid rgba(255,255,255,0.7); box-shadow: 2px 2px 4px 0 rgba(40,40,200,0.4); animation: spin .5s linear infinite; -webkit-animation: spin .5s linear infinite;}.content .ball1 { top: 35px; left: 35px; width: 30px; height: 30px; position: absolute; border-radius: 30px; -webkit-border-radius: 30px; border: 5px solid rgba(40,40,200,0.8); border-left: 5px solid rgba(255,255,255,1.0); border-top: 5px solid rgba(255,255,255,1.0); box-shadow: 2px 2px 4px 0 rgba(40,40,200,0.4); animation: spinoff .5s linear infinite; -webkit-animation: spinoff .5s linear infinite;} HTML代码1234&lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;ball&quot;&gt;&lt;/div&gt; &lt;div class=&quot;ball1&quot;&gt;&lt;/div&gt;&lt;/div&gt; 总结实现动画有几个关键点： css3 keyframes css position css border 基本就以上问题，代码可以直接新建一个页面，复制打开即可运行","link":"/2015/01/20/2015-01-20-css3-loading.html"},{"title":"百度地图添加自定义标注","text":"百度地图的默认标注是一个 红色 的地标，如果要做互动性强的地图应用，几乎没提供什么额外信息，本文教大家怎么添加自定义标注，如添加头像。 JS代码12345678var icon = new BMap.Icon('头像URL地址', new BMap.Size(33, 33), { offset: new BMap.Size(10, 25), imageOffset: new BMap.Size(0, 0)});markers[i] = new BMap.Marker(new BMap.Point([经度], [纬度]), { icon: icon});map.addOverlay(markers[i]); 由于百度地图的限制，我们不能获取标注的HTML，只能采取“特别”的方式对头像增加样式，比如圆角，边框等等。 123456789101112var avatarRadiusCompleted = false;var avatarRadius = setInterval(function() { avatarRadius &amp;&amp; clearInterval(avatarRadius); $('#map').find('img').each(function() { var src = $(this).attr('src'); if (src.indexOf('map') == -1) { $(this).addClass('xl-map-avatar'); //.xl-map-avatar 为自定义的CSS } }); avatarRadiusCompleted = true;},100); CSS代码123456789101112.xl-map-avatar { width: 32px; height: 32px; border: 1px solid white !important; border-top-left-radius: 999px; /* 左上角 */ border-top-right-radius: 999px; /* 右上角 */ border-bottom-right-radius: 999px; /* 右下角 */ border-bottom-left-radius: 999px; /* 左下角 */ border-radius: 50%; background-color: #ccc; background-clip: padding-box;} 效果图","link":"/2015/01/23/2015-01-24-baidu-map-custom-overlay.html"},{"title":"七牛上传出现 invalid mutilpart format的解决方案","text":"今天用umeditor编辑文章上传图片的时候发现一直卡在”loading…”，打开控制台发现出现了500错误，进一步调试发现是七牛上传报错了。 整个上传流程是 浏览器=》业务服务器=》七牛服务器 在上传方法断点调试发现$_FILES数组正常，所以排除了浏览器到业务服务器上传问题，继续调试 通过查看七牛SDK源码发现在 http.php的第119行附近有这样的代码： 1234567891011$options = array( CURLOPT_USERAGENT =&gt; $req-&gt;UA, CURLOPT_RETURNTRANSFER =&gt; true, CURLOPT_SSL_VERIFYPEER =&gt; false, CURLOPT_SSL_VERIFYHOST =&gt; false, CURLOPT_HEADER =&gt; true, CURLOPT_NOBODY =&gt; false, CURLOPT_CUSTOMREQUEST =&gt; 'POST', CURLOPT_URL =&gt; $url['path'], CURLOPT_SAFE_UPLOAD =&gt; false); 请注意最后那个 1CURLOPT_SAFE_UPLOAD =&gt; false 这里应该是跟上传有关的设置，很有可能是这里的问题，果然，GOOGLE发现PHP的CURL上传文件跟PHP版本的关系很大。 传统上，PHP的cURL支持通过在数组数据中，使用“@+文件全路径”的语法附加文件，供cURL读取上传。这与命令行直接调用cURL程序的语法是一致的： 123curl_setopt(ch, CURLOPT_POSTFIELDS, array( 'file' =&gt; '@'.realpath('image.png'), )); 但PHP从5.5开始引入了新的CURLFile类用来指向文件。CURLFile类也可以详细定义MIME类型、文件名等可能出现在multipart/form-data数据中的附加信息。PHP推荐使用CURLFile替代旧的@语法： 123curl_setopt(ch, CURLOPT_POSTFIELDS, [ 'file' =&gt; new CURLFile(realpath('image.png')), ]); PHP 5.5另外引入了CURL_SAFE_UPLOAD选项，可以强制PHP的cURL模块拒绝旧的@语法，仅接受CURLFile式的文件。5.5的默认值为false，5.6的默认值为true。 但是坑的一点在于：@语法在5.5就已经被打了deprecated，在5.6中就直接被删除了（会产生 ErorException: The usage of the @filename API for file uploading is deprecated. Please use the CURLFile class instead）。 对于PHP 5.6+而言，手动设置CURL_SAFE_UPLOAD为false是毫无意义的。根本不是字面意义理解的“设置成false，就能开启旧的unsafe的方式”——旧的方式已经作为废弃语法彻底不存在了。PHP 5.6+ == CURLFile only，不要有任何的幻想。 我的部署环境是5.4(仅@语法)与服务器不同，所以必须写出带有环境判断的代码。 从可靠的角度，推荐指定CURL_SAFE_UPLOAD的值，明确告知php是容忍还是禁止旧的@语法。 注意在低版本PHP中CURLOPT_SAFE_UPLOAD常量本身可能不存在，需要判断： 1234567if (class_exists('\\CURLFile')) { curl_setopt($ch, CURLOPT_SAFE_UPLOAD, true);} else { if (defined('CURLOPT_SAFE_UPLOAD')) { curl_setopt($ch, CURLOPT_SAFE_UPLOAD, false); }}","link":"/2015/01/27/2015-01-28-php-qiniu-invalid-mutilpart-format.html"},{"title":"android直接挂断电话","text":"最近在写一个用来发短信的机器人（android),当然需要屏蔽所有来电了。多的话不说了，直接看步骤。（IDE为android studio）：1.在 src/main下新建 aidl 目录。 2.在src/main/aidl下新建包 com.android.internal.telephony。 3.在com.android.internal.telephony新建文件 ITelephony.aidl，内容如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215/* * Copyright (C) 2007 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.android.internal.telephony;import android.os.Bundle;import java.util.List;import android.telephony.NeighboringCellInfo;/** * Interface used to interact with the phone. Mostly this is used by the * TelephonyManager class. A few places are still using this directly. * Please clean them up if possible and use TelephonyManager insteadl. * * {@hide} */interface ITelephony { /** * Dial a number. This doesn't place the call. It displays * the Dialer screen. * @param number the number to be dialed. If null, this * would display the Dialer screen with no number pre-filled. */ void dial(String number); /** * Place a call to the specified number. * @param number the number to be called. */ void call(String number); /** * If there is currently a call in progress, show the call screen. * The DTMF dialpad may or may not be visible initially, depending on * whether it was up when the user last exited the InCallScreen. * * @return true if the call screen was shown. */ boolean showCallScreen(); /** * Variation of showCallScreen() that also specifies whether the * DTMF dialpad should be initially visible when the InCallScreen * comes up. * * @param showDialpad if true, make the dialpad visible initially, * otherwise hide the dialpad initially. * @return true if the call screen was shown. * * @see showCallScreen */ boolean showCallScreenWithDialpad(boolean showDialpad); /** * End call or go to the Home screen * * @return whether it hung up */ boolean endCall(); /** * Answer the currently-ringing call. * * If there's already a current active call, that call will be * automatically put on hold. If both lines are currently in use, the * current active call will be ended. * * TODO: provide a flag to let the caller specify what policy to use * if both lines are in use. (The current behavior is hardwired to * &quot;answer incoming, end ongoing&quot;, which is how the CALL button * is specced to behave.) * * TODO: this should be a oneway call (especially since it's called * directly from the key queue thread). */ void answerRingingCall(); /** * Silence the ringer if an incoming call is currently ringing. * (If vibrating, stop the vibrator also.) * * It's safe to call this if the ringer has already been silenced, or * even if there's no incoming call. (If so, this method will do nothing.) * * TODO: this should be a oneway call too (see above). * (Actually *all* the methods here that return void can * probably be oneway.) */ void silenceRinger(); /** * Check if we are in either an active or holding call * @return true if the phone state is OFFHOOK. */ boolean isOffhook(); /** * Check if an incoming phone call is ringing or call waiting. * @return true if the phone state is RINGING. */ boolean isRinging(); /** * Check if the phone is idle. * @return true if the phone state is IDLE. */ boolean isIdle(); /** * Check to see if the radio is on or not. * @return returns true if the radio is on. */ boolean isRadioOn(); /** * Check if the SIM pin lock is enabled. * @return true if the SIM pin lock is enabled. */ boolean isSimPinEnabled(); /** * Cancels the missed calls notification. */ void cancelMissedCallsNotification(); /** * Supply a pin to unlock the SIM. Blocks until a result is determined. * @param pin The pin to check. * @return whether the operation was a success. */ boolean supplyPin(String pin); /** * Handles PIN MMI commands (PIN/PIN2/PUK/PUK2), which are initiated * without SEND (so dial is not appropriate). * * @param dialString the MMI command to be executed. * @return true if MMI command is executed. */ boolean handlePinMmi(String dialString); /** * Toggles the radio on or off. */ void toggleRadioOnOff(); /** * Set the radio to on or off */ boolean setRadio(boolean turnOn); /** * Request to update location information in service state */ void updateServiceLocation(); /** * Enable location update notifications. */ void enableLocationUpdates(); /** */ void disableLocationUpdates(); /** * Enable a specific APN type. */ int enableApnType(String type); /** * Disable a specific APN type. */ int disableApnType(String type); /** * Allow mobile data connections. */ boolean enableDataConnectivity(); /** * Disallow mobile data connections. */ boolean disableDataConnectivity(); /** * Report whether data connectivity is possible. */ boolean isDataConnectivityPossible(); Bundle getCellLocation(); /** * Returns the neighboring cell information of the device. */ List getNeighboringCellInfo(); int getCallState(); int getDataActivity(); int getDataState();} 4.android studio 菜单 Build-&gt;Rebuild project 5.在Activity中注册监听（写在onCreate()） 1234TelephonyManager mTelephonyManager = (TelephonyManager) this .getSystemService(TELEPHONY_SERVICE); mTelephonyManager.listen(phoneStateListener, PhoneStateListener.LISTEN_CALL_STATE); 6.在Activity中新建以下方法以获得telephony的实例 12345678910111213141516171819202122232425262728/** * @param context * @return */ private static ITelephony getITelephony(Context context) { TelephonyManager mTelephonyManager = (TelephonyManager) context .getSystemService(TELEPHONY_SERVICE); Class c = TelephonyManager.class; Method getITelephonyMethod = null; try { getITelephonyMethod = c.getDeclaredMethod(&quot;getITelephony&quot;, (Class[]) null); // 获取声明的方法 getITelephonyMethod.setAccessible(true); } catch (SecurityException e) { e.printStackTrace(); } catch (NoSuchMethodException e) { e.printStackTrace(); } try { ITelephony iTelephony = (ITelephony) getITelephonyMethod.invoke( mTelephonyManager, (Object[]) null); // 获取实例 return iTelephony; } catch (Exception e) { e.printStackTrace(); } return null; } 7.在activity类中建立内部类 123456789101112131415161718192021222324252627282930PhoneStateListener phoneStateListener = new PhoneStateListener() { @Override public void onCallStateChanged(int state, String incomingNumber) { ITelephony iTelephony = getITelephony(MainActivity.this); switch (state) { case TelephonyManager.CALL_STATE_RINGING: iTelephony = getITelephony(getApplicationContext()); //获取电话接口 if (iTelephony != null) { try { iTelephony.endCall(); // 挂断电话 Message msg = new Message(); msg.what = SYS_MSG; msg.obj =&quot;成功挂断[&quot;+incomingNumber+&quot;]的电话&quot;; handler.sendMessage(msg); } catch (RemoteException e) { Message msg = new Message(); msg.what = SYS_MSG; msg.obj =&quot;挂断[&quot;+incomingNumber+&quot;]的电话失败&quot;; handler.sendMessage(msg); } } break; default: break; } } };","link":"/2015/01/29/2015-01-29-android-hangup-call.html"},{"title":"基于angularjs的在线音乐播放器","text":"项目地址https://github.com/xialeistudio/angular-audio-player 在线demohttp://ngdemo.sinaapp.com/audio/ 效果图","link":"/2015/01/30/2015-01-30-angularjs-online-music-player.html"},{"title":"angularjs ueditor指令","text":"一直以来，angularjs的富文本编辑器都比较难做，主要是第三方的编辑器很难集成进来，今天花时间研究了一下，发现ueditor主要加载两个js文件 ueditor.config.js ueditor.all.js 能不能把这两个文件异步加载呢？答案是肯定的。我们新建一个服务用来异步加载资源，并设置必要的回调方法。 Factory123456789101112131415161718192021222324252627282930313233343536373839services.factory('Common', ['$http', '$q',function($http, $q) { return { loadScript: function(url, callback) { var head = document.getElementsByTagName(&quot;head&quot;)[0]; var script = document.createElement(&quot;script&quot;); script.setAttribute(&quot;type&quot;, &quot;text/javascript&quot;); script.setAttribute(&quot;src&quot;, url); script.setAttribute(&quot;async&quot;, true); script.setAttribute(&quot;defer&quot;, true); head.appendChild(script); //fuck ie! duck type if (document.all) { script.onreadystatechange = function() { var state = this.readyState; if (state === 'loaded' || state === 'complete') { callback &amp;&amp; callback(); } } } else { //firefox, chrome script.onload = function() { callback &amp;&amp; callback(); } } }, loadCss: function(url) { var ele = document.createElement('link'); ele.href = url; ele.rel = 'stylesheet'; if (ele.onload == null) { ele.onload = function() {}; } else { ele.onreadystatechange = function() {}; } angular.element(document.querySelector('body')).prepend(ele); } }}]); 通过绑定callback到 onload 事件来实现回调。 指令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960directives.directive('ueditor', ['Common', '$rootScope',function(Common, $rootScope) { return { restrict: 'EA', require: 'ngModel', link: function(scope, ele, attrs, ctrl) { $rootScope.$emit('loading', '初始化编辑器...'); //广播loading事件，可以删除 var _self = this, _initContent, editor, editorReady = false, base = '/public/vendor/utf8_qiniu_ueditor-master', //ueditor目录 _id = attrs.ueditor; var editorHandler = { init: function() { window.UEDITOR_HOME_URL = base + '/'; var _self = this; if (typeof UE != 'undefined') { editor = UE.getEditor(_id, { toolbars: [['fontsize', '|', 'blockquote', 'horizontal', '|', 'removeformat', '|', 'insertimage', '|', 'bold', 'italic', 'underline', 'forecolor', 'backcolor', '|', 'justifyleft', 'justifycenter', 'justifyright', 'justifyjustify', 'rowspacingtop', 'rowspacingbottom', 'lineheight', '|', 'insertorderedlist', 'insertunorderedlist', '|', 'link', 'unlink', '|', 'emotion']] }); editor.ready(function() { editor.setHeight(500); editorReady = true; $rootScope.$emit('loading', ''); //编辑器初始化完成 editor.addListener('contentChange', function() { //双向绑定 if (!scope.$$phase) { scope.$apply(function() { ctrl.$setViewValue(editor.getContent()); }); } }); }); } else { Common.loadScript(base + '/ueditor.config.js', null); Common.loadScript(base + '/ueditor.all.min.js', function() { _self.init(); }); } }, setContent: function(content) { if (editor &amp;&amp; editorReady) { editor.setContent(content); } } }; ctrl.$render = function() { _initContent = ctrl.$isEmpty(ctrl.$viewValue) ? '': ctrl.$viewValue; editorHandler.setContent(_initContent); //双向绑定 }; editorHandler.init(); //事件 $rootScope.$on('$routeChangeStart', function() { editor &amp;&amp; editor.destroy(); }); } }}]); 由于angularjs无法自动获得编辑器内容，只能手动监听 contentChange事件来实现双向绑定。 模板代码1&lt;div ueditor=&quot;editor&quot; ng-required=&quot;true&quot; ng-model=&quot;material.content.content&quot; id=&quot;editor&quot;&gt;&lt;/div&gt; 效果图","link":"/2015/02/05/2015-02-05-angularjs-ueditor-directive.html"},{"title":"微信公众平台回复乱码问题","text":"很多微信公众平台的自动回复程序都是 ThinkWechat.class.php 这个类开发的，今天碰到一个莫名其妙的乱码问题，查问题发现是GB2312编码导致，所以要修改源码。 先增加一个方法: 123456789/** * 检测是否UTF-8 * @param $str * @return bool */private function is_utf8($str){ return preg_match('//u', $str);} 找到 1$this-&gt;data ['Content'] = $content; 修改为 12345if ($this-&gt;is_utf8($content)) { $this-&gt;data ['Content'] = $content;} else { $this-&gt;data ['Content'] = iconv('gb2312', 'UTF-8//IGNORE', $content);}","link":"/2015/03/06/2015-03-06-wechat-reply-messy-code.html"},{"title":"PHPExcel导出时列过大的解决方案","text":"今天导出Excel的时候，列不是固定的，而且有差不多几十个，横轴由’A’变为了’AA’，给导出时增加了难度，因为要去算列名称，不过换个方式想一下，发现是很有规律的26进制数。 发现秘诀后就好办了，发一个10进制转26进制的方法。 代码1234567891011private function numberToStr26($n){ $s = ''; while ($n &gt; 0) { $m = $n % 26; if ($m == 0) $m = 26; $s = chr($m + 64) . $s; $n = ($n - $m) / 26; } return $s;} 效果图","link":"/2015/03/06/2015-03-07-phpexcel-a-lot-of-column.html"},{"title":"使用gulp来构建你的前端自动化工作流","text":"之前用的Grunt，不过有时候Grunt确实用起来不爽，进来找到一款叫gulp.js的前端构建工具，当然，也是基于node.js的。 安装12npm install gulp --save-devnpm install del gulp-concat gulp-cssmin gulp-uglify --save-dev 配置配置gulpfile.js，如果工作目录下没有该文件，请新建gulpfile.js，以下为一个常用的参考代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/** * @author xialei &lt;xialeistudio@gmail.com&gt; */(function () { &quot;use strict&quot;; /** * 加载插件 * @type {exports} */ var gulp = require('gulp'); var del = require('del'); var cssmin = require('gulp-cssmin'); var concat = require('gulp-concat'); var uglify = require('gulp-uglify'); /** * 清空目录的命令 */ gulp.task('clean', function () { del(['build']); }); gulp.task('css', function () { /** * 加载源代码 */ return gulp.src([ 'bower_components/bootstrap/dist/css/bootstrap.min.css', 'bower_components/font-awesome/css/font-awesome.min.css', 'css/style.css' ]) /** * 压缩css */ .pipe(cssmin()) /** * 连接压缩后的css */ .pipe(concat('style.css')) /** * 输出到目标目录 */ .pipe(gulp.dest('build/css')) }); gulp.task('js', function () { return gulp.src([ /** * 加载源代码 */ 'bower_components/angular/angular.min.js', 'bower_components/angular-sanitize/angular-sanitize.min.js', 'js/main.js']) /** * 压缩Js */ .pipe(uglify()) /** * 合并js */ .pipe(concat('main.js')) /** * 输出到目标目录 */ .pipe(gulp.dest('build/js')) }); gulp.task('img', function () { /** * 加载源文件 */ return gulp.src([ 'img/*.*' ]) /** * 输出到目标目录 */ .pipe(gulp.dest('build/img')); }); /** * 定义默认任务，此任务依赖于 clean,img,css,js，所以在执行 * 本任务时会按顺序先执行依赖任务 */ gulp.task('default', ['clean', 'img', 'css', 'js']);})(); 执行编译1gulp","link":"/2015/03/16/2015-03-16-gulp-workflow.html"},{"title":"Angularjs概念解释","text":"本文所有内容仅代表个人观点 ngAngularjs的简称。 指令(Directive)特殊的html标签或html属性，扩展了html的功能。有以下几类： E Element 元素 如 就是一个自定义指令（如何自定义指令，将在后面的文章中介绍），名称为”dropdown”。 A Attribute 属性 如 这是最常用的指令了，ng-app为指令名称，也是html元素的属性，app为该属性的值 作用域(scope)ng中变量、方法都是基于作用域的，作用类似于js作用域。 ng-bindhtml输出js变量，跟作用域绑定，message为作用域中的一个变量。示例代码： 1&lt;button ng-bind=&quot;message&quot;&gt;&lt;/button&gt; 最终会显示同一scope下的message变量值。 ng-model双向绑定指令，示例代码： 1&lt;input type=&quot;text&quot; ng-model=&quot;message&quot;/&gt; 表明将input的值与作用域中的message变量进行绑定，当input值改变的时候，变量message跟着改变，html中输出的内容也会同步改变。","link":"/2015/04/06/2015-04-06-angularjs-concept%20to%20explain.html"},{"title":"angularjs Hello World","text":"几乎所有的编程入门都是以”Hello World”开始的，这里也不例外。 HTML代码1234567891011121314&lt;!DOCTYPE html&gt;&lt;!--使用ng-app指令“告诉”ng从哪里开始编译--&gt;&lt;html ng-app=&quot;app&quot;&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Hello World - Angularjs&lt;/title&gt; &lt;script src=&quot;../vendor/angularjs/angular.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;/p&gt;&lt;input type=&quot;text&quot; ng-model=&quot;message&quot; placeholder=&quot;说点什么&quot;/&gt;&lt;/body&gt;&lt;/html&gt; JS代码12345/** * @author xialei &lt;xialeistudio@gmail.com&gt; */var app = angular.module('app',[]); 双向绑定为ng内置，所以这里的js，实际上只有一个app定义罢了。在输入框中输入任何字符都会及时在其之前的p元素显示出来。","link":"/2015/04/06/2015-04-06-angularjs-hello-world.html"},{"title":"在AngularJS中使用$q进行“同步”编程","text":"今天群里有位朋友问到直接返回$http说读不到数据，原因在于$http是异步请求，而且是“不可期”的，你不知道什么时候这个请求完成了。 而对于这种需要“同步”编程的方式，AngularJS提供了一个内置Service $q，它提供了一种承诺/延后（promise/deferred），可以保证我们的调用代码一定能够拿到数据。所以我们用起来可以像同步调用一样，话说回来，最终还是xhr异步请求。 Factory123456789101112131415app.factory('itemService', ['$http', '$q', function ($http, $q) { return { query : function() { var deferred = $q.defer();//声明承诺 $http({method: 'GET', url: '/item/list'}). success(function(data) { deferred.resolve(data);//请求成功 }). error(function(data) { deferred.reject(data); //请求失败 }); return deferred.promise; // 返回承诺，这里返回的不是数据，而是API } }; }]); Controller123456789angular.module('app') .controller('MainCtrl', ['itemService','$scope', function (itemService,$scope) { // 注入itemService var promise = itemService.query(); //获得承诺接口 promise.then(function(data) { // 成功回调 $scope.user = data; }, function(data) { // 错误回调 console.log('请求失败'); }); }]); 文档地址http://docs.angularjs.org/api/ng.$q","link":"/2015/04/06/2015-04-06-angularjs-q.html"},{"title":"带进度条的angularjs上传指令","text":"项目地址https://git.coding.net/xialei/xl-angular-upload.git 效果图 指令代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263angular.module('xl-angular-upload', []) .directive('angularUpload', [function () { return { restrict: 'E', require: 'ngModel', template: '&lt;div class=&quot;xl-angular-upload&quot;&gt;\\n &lt;!--upload button--&gt;\\n &lt;button class=&quot;xl-btn btn-primary&quot;&gt;上传\\n &lt;input type=&quot;file&quot;/&gt;\\n &lt;/button&gt;\\n &lt;!--upload queue--&gt;\\n &lt;div class=&quot;queue&quot;&gt;\\n &lt;div class=&quot;item&quot; ng-repeat=&quot;item in queue&quot;&gt;\\n &lt;div class=&quot;info&quot;&gt;\\n &lt;div class=&quot;no&quot;&gt;{{$index+1}}&lt;/div&gt;\\n &lt;div class=&quot;name&quot;&gt;{{item.name}}&lt;/div&gt;\\n &lt;div class=&quot;size&quot;&gt;{{(item.size/1024).toFixed(2)}}KB&lt;/div&gt;\\n &lt;/div&gt;\\n &lt;div class=&quot;process-bar&quot;&gt;\\n &lt;div class=&quot;process&quot; style=&quot;width:{{item.process}}%&quot;&gt;&lt;/div&gt;\\n &lt;/div&gt;\\n &lt;/div&gt;\\n &lt;/div&gt;\\n&lt;/div&gt;', replace: true, link: function (scope, ele, attrs, ctrl) { //必要属性检测 if (!attrs.action) { throw new Error('请设置上传action'); } //初始化 scope.queue = []; var file = angular.element(document.querySelector('.xl-angular-upload&gt;.xl-btn&gt;input[type=&quot;file&quot;]')); var files = []; attrs.accept &amp;&amp; file.attr('accept', attrs.accept); attrs.multiple &amp;&amp; file.attr('multiple', attrs.multiple); file.bind(&quot;change&quot;, function (e) { scope.$apply(function () { scope.queue = []; for (var i in e.target.files) { if (/^\\d+$/.test(i)) { e.target.files[i].process = 0; scope.queue.push(e.target.files[i]); } } }); //准备上传 scope.queue.forEach(function (item) { var data = new FormData; data.append(attrs.name || 'file', item); var xhr = new XMLHttpRequest(); xhr.open('POST', attrs.action, true); //事件监听 xhr.onreadystatechange = function () { if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) { //上传完成了 var resp = JSON.parse(xhr.responseText); if (resp.error) { throw new Error(resp.error); } else { files.push(resp); ctrl.$setViewValue(files); } } }; xhr.onerror = function (error) { throw new Error(error); }; xhr.upload &amp;&amp; (xhr.upload.onprogress = function (e) { if (e.lengthComputable) { scope.$apply(function () { item.process = parseInt((e.loaded / e.total) * 100); }); } }); xhr.send(data); }); }); } } }]); HTML代码123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html ng-app=&quot;app&quot;&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;title&gt;AngularToggle&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;angular-upload.css&quot;/&gt; &lt;style&gt; * { font-family: Consolas, &quot;Microsoft Yahei&quot;, arial, sans-serif; } &lt;/style&gt;&lt;/head&gt;&lt;body ng-controller=&quot;MainCtrl&quot;&gt;&lt;div style=&quot;width: 400px&quot;&gt; &lt;angular-upload action=&quot;upload.php&quot; name=&quot;file&quot; accept=&quot;image/*&quot; multiple=&quot;true&quot; ng-model=&quot;files&quot;/&gt;&lt;/div&gt;&lt;script src=&quot;http://cdn.bootcss.com/angular.js/1.3.15/angular.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;angular-upload.js&quot;&gt;&lt;/script&gt;&lt;script&gt; (function () { &quot;use strict&quot;; angular.module('app', [ 'xl-angular-upload' ]).controller('MainCtrl', ['$scope', function ($scope) { $scope.$watch('files', function (n, o) { console.log(n); }); }]); })();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; CSS代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384.xl-angular-upload .xl-btn { color: #666; background-color: #EEE; border-color: #EEE; font-weight: 300; font-size: 16px; font-family: &quot;Consolas&quot;, &quot;Microsoft YaHei&quot;, Arial, arial, sans-serif; text-decoration: none; text-align: center; line-height: 40px; height: 40px; padding: 0 40px; margin: 0; display: inline-block; appearance: none; cursor: pointer; border: none; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box; -webkit-transition-property: all; transition-property: all; -webkit-transition-duration: .3s; transition-duration: .3s; border-radius: 4px; -webkit-border-radius: 4px; -moz-border-radius: 4px; position: relative;}.xl-angular-upload .xl-btn.btn-primary { background-color: #7B72E9; border-color: #7B72E9; color: #FFF;}.xl-angular-upload .xl-btn.btn-primary:hover { background-color: #a49ef0; border-color: #a49ef0; color: #FFF;}.xl-angular-upload .xl-btn input[type=&quot;file&quot;] { position: absolute; width: 100%; height: 100%; left: 0; top: 0; opacity: 0;}.xl-angular-upload .queue { width: 100%;}.xl-angular-upload .queue .item { margin-top: 4px;}.xl-angular-upload .queue .item &gt; .info .no { float: left; width: 10%; text-align: center;}.xl-angular-upload .queue .item &gt; .info .name { float: left; width: 70%;}.xl-angular-upload .queue .item &gt; .info .size { float: right; width: 20%;}.xl-angular-upload .queue .item &gt; .info:after { content: ' '; display: block; clear: both;}.xl-angular-upload .queue .item &gt; .process-bar { width: 100%; height: 4px; margin-top: 4px;}.xl-angular-upload .queue .item &gt; .process-bar .process { transition: all .2s; -webkit-transition: all .2s; -moz-transition: all .2s; height: 100%; width: 0; background: #7B72E9;} 本指令的难点在于进度条的更新及ngModel数据的双向绑定，其实，只要在指令中require”ngModel”之后，利用$setViewValue方法和$render方法就可以了。而进度条的处理是由于双向绑定中列表的每个元素都是一个单独的对象，更新该对象的值不会影响其他上传，即每个上传都是单独的进度条。","link":"/2015/04/09/2015-04-09-angularjs-upload-directive-with-progress.html"},{"title":"php文件缓存类","text":"缓存有很多方法，memcache,databse,file,redis等等，原理都差不多，简要介绍一下，写入缓存就不多说了，主要是读取缓存。 检测指定key是否存在，如不存在则返回false。 检测指定key是否过期，如过期则返回false。 指定key存在且未过期，返回缓存值。 本文介绍文件缓存的实现，其他类型可以参照实现。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;?php/** * @project wechatPublicPlatform * @date 2015-4-13 * @author xialei &lt;xialeistudio@gmail.com&gt; */class Cache{ function __construct() { throw new Exception('不可被实例化'); } /** * 设置缓存 * @param string $key * @param string $value * @param int $expires 0为不过期 * @return int */ public static function set($key, $value, $expires = 0) { $cachePath = __DIR__ . '/cache'; if (!is_dir($cachePath)) { mkdir($cachePath, 666); } $data = [ 'key' =&gt; $key, 'value' =&gt; $value, 'expires' =&gt; $expires ]; return file_put_contents($cachePath . '/' . md5($key), json_encode($data, JSON_UNESCAPED_UNICODE)); } /** * 获取缓存 * @param string $key * @return bool */ public static function get($key) { $cacheFile = __DIR__ . '/cache/' . md5($key); //检测是否存在 if (!is_file($cacheFile)) { return false; } //检测是否过期 $data = json_decode(file_get_contents($cacheFile), true); //获取最近修改时间 $mtime = filemtime($cacheFile); if (time() &gt; $mtime + $data['expires']) { unlink($cacheFile); return false; } return $data['value']; } /** * 删除缓存 * @param string $key * @return bool */ public static function delete($key) { $cacheFile = __DIR__ . '/cache/' . md5($key); if (is_file($cacheFile)) { return unlink($cacheFile); } return true; }}","link":"/2015/04/13/2015-04-13-php-filecache.html"},{"title":"svg制作loading","text":"还在使用gif做loading效果吗？你确实out了，再不济也得用css3动画是不是–。无奈，css3旋转动画需要一张png图片来做，也没什么问题，现在，有更炫酷的方案了。没错!就是SVG。svg其实不是什么新东西。SVG 于 2003 年 1 月 14 日成为 W3C 推荐标准。现在浏览器越来越强大，所以，尽情使用吧！ 代码123456789101112131415161718&lt;div style=&quot;width: 200px;height: 200px;background: #000000&quot;&gt; &lt;svg width=&quot;100%&quot; height=&quot;100%&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt; &lt;g&gt; &lt;circle cx=&quot;100&quot; cy=&quot;100&quot; r=&quot;50&quot; fill=&quot;none&quot; stroke-width=&quot;2&quot; stroke=&quot;rgba(255,255,255,0.2)&quot;/&gt; &lt;path d=&quot;M100 50 A50 50 0 0 1 150 100 &quot; style=&quot;stroke: rgba(255,255,255,.7);stroke-width: 2&quot;/&gt; &lt;animateTransform attributeName=&quot;transform&quot; fill=&quot;freeze&quot; attributeType=&quot;XML&quot; type=&quot;rotate&quot; from=&quot;0,100,100&quot; to=&quot;360,100,100&quot; dur=&quot;1s&quot; repeatCount=&quot;indefinite&quot; /&gt; &lt;/g&gt; &lt;/svg&gt;&lt;/div&gt; 效果","link":"/2015/05/16/2015-05-17-svg-loading.html"},{"title":"linux运行dos格式脚本导致的bad interpreter","text":"问题在使用php作为linux上shell脚本运行时出现了以下错误： 123#!/usr/bin/env php&lt;?phpphpinfo(); 123chmod +x test.php./test.php/usr/local/php/bin/php^M: bad interpreter: No such file or directory 原因是你的文本以DOS文件形式保存，导致文件头有不可见字符，导致bash shell无法解析。 解决办法12yum install dos2unix -ydos2unix test.php 再执行就没问题了","link":"/2015/05/20/2015-05-21-shell-bad-interpreter.html"},{"title":"lnmp一键安装memcached的shell脚本","text":"通过LNMP安装脚本安装的PHP环境默认是不带Memcached支持的（是memcached不是memcache），百度一下memcached的安装方法，发现基本都是memcache的，其实这是两个不同的东西。 而memcached是pecl的项目，所以需要到pecl网站上去下载最新的memcached安装包。 为了方便多台服务器的安装，本人整理成了一个sh脚本进行安装，当然,php-config路径和phpize路径需要改下（如果使用LNMP脚本安装的话则不用改） 123456789101112#!/bin/bashwget https://launchpad.net/libmemcached/1.0/0.53/+download/libmemcached-0.53.tar.gztar xvfz libmemcached-0.53.tar.gzcd libmemcached-0.53./configure --prefix=/usr/local/libmemcached --enable-saslmake &amp;&amp; make installwget http://pecl.php.net/get/memcached-2.0.0.tgztar zvxf memcached-2.0.0.tgzcd memcached-2.0.0/phpize./configure --enable-memcached --with-php-config=/usr/local/php/bin/php-config --with-libmemcached-dir=/usr/local/libmemcached --enable-memcached-saslmake &amp;&amp; make install","link":"/2015/05/29/2015-05-29-shell-to-install-memached-on-lnmp.html"},{"title":"angularjs指令实现radioGroup","text":"angularjs的指令系统其实也是很强大的东西，扩展了HTML的表现力。本文讲的是如何用angularjs指令实现radioGroup，自带的radio只能控制ngModel的两种状态: true/false。 指令代码123456789101112131415161718192021222324252627module.directive('radio', [function() { return { transclude: true, replace: true, template: '&lt;div class=&quot;ui ui-radio&quot;&gt;&lt;span class=&quot;radio-item&quot;&gt;&lt;/span&gt;&lt;span ng-transclude=&quot;&quot; class=&quot;common-color&quot;&gt;&lt;/span&gt;&lt;/div&gt;', require: 'ngModel', link: function(scope, ele, attrs, ctrl) { ctrl.$render = function() { if(ctrl.$viewValue == attrs.value) { //jqLite不支持siblings方法，如果此段代码无效，请使用zepto实现 ele.parent().children().removeClass(&quot;active&quot;); ele.addClass(&quot;active&quot;); } }; ele.bind(&quot;click&quot;, function() { ctrl.$setViewValue(attrs.value); ele.addClass(&quot;active&quot;); var childrens = ele[0].parentNode.children; for(var i = 0; i &lt; childrens.length; i++) { if(childrens[i] != ele[0]) { angular.element(childrens[i]).removeClass(&quot;active&quot;); } } }); } };}]); 123456789101112131415161718192021222324252627282930.ui { &amp;-radio { &amp;.active { .radio-item:after { display: block; width: 19px; height: 19px; content: ' '; position: absolute; border-radius: 50%; left: (35px-19)/2; top: (35px-19)/2; background: #d14db7; } } .radio-item { width: 35px; height: 35px; border-radius: 50%; position: relative; background: white; display: inline-block; vertical-align: middle; margin: 0; } span { margin-left: 12px; } }} HTML123456&lt;div ng-init=&quot;answer='A'&quot; class=&quot;options container-fluid wrapper&quot;&gt; &lt;div radio=&quot;&quot; ng-model=&quot;answer&quot; value=&quot;A&quot;&gt;A. &lt;/div&gt; &lt;div radio=&quot;&quot; ng-model=&quot;answer&quot; value=&quot;B&quot;&gt;B. &lt;/div&gt; &lt;div radio=&quot;&quot; ng-model=&quot;answer&quot; value=&quot;C&quot;&gt;C. &lt;/div&gt; &lt;div ng-if=&quot;questions[index].option_d&quot; radio=&quot;&quot; ng-model=&quot;answer&quot; value=&quot;D&quot;&gt;D. &lt;/div&gt;&lt;/div&gt; 效果","link":"/2015/06/30/2015-07-01-angularjs-radio-group-directive.html"},{"title":"移动端input和textarea宽度不一致的问题","text":"今天在做写一个IOS端的表单时，尽管input,textarea设置了宽度，结果发现真机浏览的时候发现宽度不一致，有图为证 css12345678910input,textarea { border-radius: 4px; border: 1px solid #4f4f4f; font-size: 24px; background: none; outline: 0; width: 283px; -webkit-box-shadow: 0 0 4px rgba(0, 0, 0, .4);} 在PC版的chrome发现textarea有默认的padding属性，估计是这个问题，加上padding:0;之后，宽度一致了。","link":"/2015/07/05/2015-07-05-input-textarea-width-not-same-on-mobile-phone.html"},{"title":"angularjs集成requirejs","text":"angularjs自带的模块话机制对于业务逻辑的组织确实起到了规范化的作用，但是对于大型web项目，弊端也出来了，一次性加载所有的资源会导致进入应用的时间变长，而实际上，首页需要加载的并不多，所以，本文将介绍如何使用requireJs与angularJs集成。 依赖 jquery(非必须) angularjs ui-router requirejs 入口文件我们知道，使用requireJs之后，在首页只需使用script标签加载requirejs即可，剩下的文件加载需要配置下入口文件。 123456789101112131415161718192021222324252627282930/** * @author xialei &lt;xialeistudio@gmail.com&gt; */require.config({ baseUrl: 'app', paths: { &quot;angular&quot;: &quot;/vendor/angular/angular&quot;, &quot;ui-router&quot;: &quot;/vendor/ui-router/release/angular-ui-router&quot;, &quot;jquery&quot;: &quot;/vendor/jquery/dist/jquery&quot; }, shim: { &quot;angular&quot;: { exports: &quot;angular&quot;, deps: [&quot;jquery&quot;] }, &quot;ui-router&quot;: { exports: &quot;ui-router&quot;, deps: [&quot;angular&quot;] }, &quot;jquery&quot;: { exports: &quot;jquery&quot; } }});require([&quot;jquery&quot;, &quot;angular&quot;, &quot;app&quot;,&quot;router&quot;,&quot;controllers&quot;], function($, angular) { $(function() { angular.bootstrap(document, [&quot;app&quot;]); });}); vendor是依赖的库，路径可以根据实际情况进行修改。angularjs的代码组织方式不是amd规范的，所以需要使用shim将其暴露出来供其他模块使用。由于采用了requireJs，所以不能直接写 angular.module(‘xx’,[])这种代码了。因为依赖的库有可能没下载完成。 app.js1var app = angular.module(&quot;app&quot;, [&quot;ui.router&quot;]); 使用requireJs之后，这种就行不通了，因为amd开发方式下，一切皆模块。而app作为“根模块”是需要给其他模块（controller,directive,etc…）使用的，所以模块定义的最后需要return。 12345var app = angular.module(&quot;app&quot;, [&quot;ui.router&quot;]);define([&quot;angular&quot;,&quot;ui-router&quot;], function(angular) { var app = angular.module(&quot;app&quot;, [&quot;ui.router&quot;]); return app;}); 这样，其他需要依赖app模块的模块就可以使用该“根模块了”。 controllers.js1234567define([&quot;app&quot;], function(app) { app.controller(&quot;HomeCtrl&quot;, [&quot;$scope&quot;, function($scope) { $scope.run = function() { console.log('run'); }; }]);}); controllers是依赖app模块的，所以这里引入app依赖，其他代码与之前一样。 router.js之前一直使用angular-router,但是永久之后发现还是ui-router好用，这里使用ui-router作为路由管理库。 1234567891011121314define([&quot;app&quot;], function(app) { app.config(['$stateProvider', '$urlRouterProvider', function($stateProvider, $urlRouterProvider) { $stateProvider.state('index', { url:&quot;/&quot;, views: { &quot;main&quot;: { templateUrl: &quot;app/templates/home.html&quot;, controller: &quot;HomeCtrl&quot; } } }); $urlRouterProvider.otherwise('/'); }]);}); index.html123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Angularjs+RequireJs&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div ui-view=&quot;main&quot;&gt;&lt;/div&gt;&lt;script src=&quot;/vendor/requirejs/require.js&quot; data-main=&quot;main&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 相比于之前写很多script标签，这里只需要写一个，是不是“清爽”了很多呢？ demodemo，打开之后只有一个”run”的按钮，请大家打开控制台之后点击按钮即可。","link":"/2015/07/21/2015-07-22-development-angularjs-app-with-requirejs.html"},{"title":"angularjs 用户认证解决方案","text":"作为一个全栈ajax的mvvm框架，angularjs可谓如火如荼，可真正做到全栈ajax，首要面对的问题就是用户身份验证。本文的身份验证不采用cookie,而采用基于http Authorize 请求头的方式验证用户，此方式能做到永远只有一个用户同时在线（服务端同一时间只会接受一个合法的token请求，其他的请求返回401）。 Service123456789101112app.factory('Authorize', function() { return { uid: '', token: '', logout: function() { this.uid = ''; this.token = ''; localStorage.removeItem('authorize.uid'); localStorage.removeItem('authorize.token'); } }}); 由于service是单例的。保存在service很合适，再看登录检测。 验证流程 app运行时主动读取localStorage中的authorize.uid和authorize.token字段，将这两个字段发送至后端接口验证，如果验证成功返回用户信息，验证失败返回http 401错误（未授权）。 如果localStorage没有上述两个字段，则检测url中是否有，如果有则写入本地localStorage之后发送至后端验证，如果没有，跳转至后端服务器的oauth接口进行授权拿之后，将openid和token写入queryString并回调到app页面，代码如下： 12345678910111213141516171819Authorize.uid = $location.search().uid || localStorage.getItem('authorize.uid');Authorize.token = $location.search().token || localStorage.getItem('authorize.token');if (!Authorize.uid || !Authorize.token) { if (!Platform.isWechat) { Authorize.uid = 1001; Authorize.token = '2ddha3nry8'; } else { location.href = CONFIG.api + '/auth/oauth?callback=' + encodeURIComponent($location.protocol() + &quot;://&quot; + $location.host() + &quot;:&quot; + $location.port() + &quot;/#&quot; + $location.path()); return; }}//写入本地localStorage.setItem('authorize.uid', Authorize.uid);localStorage.setItem('authorize.token', Authorize.token);//读取用户数据var user = User.get({uid: Authorize.uid}, function() { $rootScope.user = user;}); 读取用户数据这边，采用的$resource服务封装，这里就不说了。 请求过程中的授权处理接下来是比较重要的一点，如何在登陆后在每次请求头中注入Authorize信息，方法是采用拦截器。有一个问题，如果由于刷新过快，检测用户回调还没执行完，这时候访问所有接口都是401，这里就需要在$httpProvider上注入拦截器进行请求恢复了。代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546app.factory('AuthInjector', function($q, Authorize, $injector, CONFIG) { return { request: function(config) { if (Authorize.token) { config.headers.Authorization = 'Bearer ' + Authorize.token; } return config; }, response: function(response) { var defer = $q.defer(); defer.resolve(response); return defer.promise; }, responseError: function(error) { //如果401且本地存在uid，则刷新accessToken if (error.status == 401) { //刷新请求 var $http = $injector.get(&quot;$http&quot;); $http({ method: 'GET', url: CONFIG.api + '/auth/token', params: { uid: Authorize.uid } }).success(function(data) { Authorize.token = data.token; //写入本地 localStorage.setItem('authorize.token', data.token); return $http(error.config); }); } else if (error.status == 422) { var resp; angular.forEach(error.data, function(item) { if (resp == undefined) { resp = item; } }); return $q.reject(resp); } return $q.reject({ message: '请求失败' }); } }}); 原理就是所有的http请求一旦返回401就进行重新登录请求，最后一句 1return $http(error.config); 会将之前报401错误的请求恢复并重新执行一遍。 大体就是这么多，总结一下就是： app.run中检测登录。 Authorize服务保存用户信息。 httpProvider中注入拦截器实现Authorize头的自动添加和401结果的请求恢复。","link":"/2015/07/29/2015-07-30-angularjs-authorization-solution.html"},{"title":"php-fpm sock文件权限问题导致502","text":"今天升级完PHP出现了502 Bad Gateway错误，根据经验是php-fpm的问题，但是看到网上那些什么访问量，子进程设置什么的，但是我这太服务器压根没啥流量。所以只能从配置文件下手看看。 php-fpm.conf123456789101112131415[global]pid = /usr/local/php/var/run/php-fpm.piderror_log = /usr/local/php/var/log/php-fpm.loglog_level = notice[www]listen = /tmp/php-cgi.sockuser = wwwgroup = wwwpm = dynamicpm.max_children = 20pm.start_servers = 2pm.min_spare_servers = 1pm.max_spare_servers = 6request_terminate_timeout = 100 看到 /tmp/php-cgi.sock 直觉发现应该是个文件，所以前往该目录查看权限，发现文件属主是root:root，而我的nginx和php-fpm进程是以www用户运行的。所以应该是权限问题。而配置文件中的user = www,group = www也设置了一个权限，通过 ps -aux|grep php 发现，这是php-fpm进程的属主。知道问题的源头后便开始查php-fpm的配置，查到了 listen.ower listen.group 设置。这是改进之后的文件： 1234567891011121314151617[global]pid = /usr/local/php/var/run/php-fpm.piderror_log = /usr/local/php/var/log/php-fpm.loglog_level = notice[www]listen = /tmp/php-cgi.socklisten.owner = wwwlisten.group = wwwuser = wwwgroup = wwwpm = dynamicpm.max_children = 20pm.start_servers = 2pm.min_spare_servers = 1pm.max_spare_servers = 6request_terminate_timeout = 100","link":"/2015/08/13/2015-08-14-php-fpm-permission-502-bad-gateway.html"},{"title":"JS函数不同执行环境下的this指向","text":"JavaScript中this指向一直是一个难点，也是一个重点，本文研究Node.js与浏览器环境下this指向的不同之处。 先来看一段代码 1234567891011121314var length = 10;function fn() { console.log(this.length);}var obj = { length: 5, method: function(fn) { fn(); arguments[0](); }};obj.method(fn,1); 猜猜输出结果？ 浏览器环境12102 为什么输出10?执行过程大致如下： obj.method这是个obj对象的方法，而传入的fn是个函数，fn()属于调用模式的”函数调用”。非严格模式下，this为global对象（浏览器中就是window）。而在这段代码的最上方使用var定义了length，由于var是直接写在global作用域中的，所以此处的 var length 与 window.length是同一个东西。输出10也就不奇怪了。 为什么输出2？arguments这个是在函数内部才有的参数，很像array，而且typeof得到的也是object值，我们知道，js访问对象有 . 操作符 和 中括号操作符，此处使用的是第二种方法获取到obj.method的第一个参数，也就是fn由于arguments[0]()是属于调用方式中的“方法调用模式”,this指向对象本身，也就是arguments，所以会输出2。 NodeJs环境12undefined2 为什么输出undefined？Node.js的global处理机制不同。 global贯穿与Node.js整合生命周期，而每个js文件是单独的模块，就算使用var定义在顶层，也只是这个module的全局变量。所以会输出undefined。 为什么输出2？同浏览器。","link":"/2015/08/19/2015-08-20-js-function-this-scope.html"},{"title":"angularjs ng-options第一个选项为空的解决方案","text":"angularjs的ng-options渲染到页面上的时候结构大致是这样的。 1234&lt;select&gt; &lt;option value=&quot;&quot;&gt;&lt;/option&gt; &lt;option value=&quot;1&quot;&gt;北京&lt;/option&gt;&lt;/select&gt; 这样会导致select第一行为空，用户体验很差。所以改造后的代码如下 1234&lt;select&gt; &lt;option value=&quot;&quot; selected hidden&gt;&lt;/option&gt; &lt;option value=&quot;1&quot;&gt;北京&lt;/option&gt;&lt;/select&gt; 这样就可以避免第一行的空行了。配合绝对定位以及加个div，可以做个很好看的下拉列表样式。","link":"/2015/09/02/2015-09-02-angularjs-ng-options-first-option-empty.html"},{"title":"php实现扫描二维码登录网站","text":"扫描二维码登录对于现在的web应用来说，确实是个很炫酷的功能，安全性也可以保障，不少朋友可能觉得这是个很复杂的工作，其实不然，真正说来只有几个步骤而已。 原理 PC浏览器展示一张二维码图片，该图片二维码值为一段绝对地址的url，大致如下：http://www.example.com/oauth/qrcode?key=key PC浏览器定期轮询 http://www.example.com/oauth/query，可能有的同学会问，怎么不用带上key？这里我们用session来保存key，所以链接中不用带上key，将这个key作为服务端的缓存key且值为空，如果该缓存值为空，证明没被扫描，继续轮询，如果已经被扫描，展示扫描结果。 手机微信扫描之后会直接访问http://www.example.com/oauth/qrcode?key=key，这里我们先把这个key保存的session中（这个session和2中的不同，一个是PC，一个是手机）。然后检测用户在手机端是否登录，如果已登录，则把用户信息存到2中的key缓存中，这时候前端查询的时候就会有值了。如果用户在手机未登录，则直接跳转微信登录，登陆成功之后再将用户信息设置到2中的key缓存 demohttp://www.lizhiclub.com/","link":"/2015/09/16/2015-09-17-php-qrcode-login.html"},{"title":"移动端滚动加载问题","text":"去年写过一篇摆脱jquery!angularjs利用指令简单实现滚动翻页，但是用了一段时间之后发现很多浏览器有问题，移动端下滚动事件只有body才会触发，其他元素是不会触发的，经过改进后的指令代码如下（仅限移动端）: 123456789101112app.directive('whenScrolled', function() { return function (scope, ele, attr) { angular.element(window).on('scroll', function (e) { var a = window.screen.availHeight; var b = document.documentElement.scrollTop == 0 ? document.body.scrollTop : document.documentElement.scrollTop; var c = document.documentElement.scrollTop == 0 ? document.body.scrollHeight : document.documentElement.scrollHeight; if (a + b &gt;= c) { scope.$apply(attr.scrollLoad); } }); };});","link":"/2015/10/22/2015-10-23-mobile-scroll-load.html"},{"title":"MAMP PRO 3.0.5 在 OS X EI Capitan下无法启动的问题","text":"网上找了很多文章，什么关闭自带的apache服务，查看系统日志等等，全没用。真佩服 baidu。还是google到了一篇文章，解决方法很简单:1.打开终端2.执行 12cd /Applications/MAMP/Library/bin/mv envvars _envvars 3.enjoy","link":"/2015/11/13/2015-11-13-mamp-pro-can-not-launch.html"},{"title":"svn更新时403的解决","text":"今天在服务器上svn up的时候出现这么一段 svn: Server sent unexpected return value (403 Forbidden) in response to OPTIONS request 403一般是权限问题，但是昨天还好好更新的，应该不是，然后更新的时候昨天是需要输入账号密码的，但是今天不需要，想着是不是账号密码被保存下来了，而这个账号密码可能有误，经过google发现在 ~/.subversion/auth/svn.simple 有一个md5加密后的文件，应该就是那个所谓的账号密码保存文件了，删掉之后重新SVN要求输入密码了。","link":"/2015/11/13/2015-11-14-svn-update-403.html"},{"title":"angularjs icheck","text":"项目地址https://github.com/xialeistudio/angular-icheck 项目说明icheck的angularjs版本","link":"/2015/11/22/2015-11-23-angularjs-icheck.html"},{"title":"angularjs上传指令","text":"项目地址https://github.com/xialeistudio/angular-upload 项目说明angularjs上传指令","link":"/2015/11/22/2015-11-23-angularjs-upload.html"},{"title":"chrome hosts插件","text":"项目地址https://github.com/xialeistudio/hostManager 特别说明Chrome 44版本以后不支持，不过开发过程大家可以了解下。","link":"/2015/11/22/2015-11-23-chrome-hostsmanager-plugin.html"},{"title":"css3实现三角形","text":"123456789101112131415161718div{ border: 1px solid #dddddd; padding: 4px 40px 4px 8px; position: relative;}div:after{ content: ' '; margin-top: -5px; display: block; position: absolute; right: 8px; top: 50%; width: 0; height: 0; border-left: 12px transparent solid; border-right: 12px transparent solid; border-top: 12px #000000 solid;} demo","link":"/2015/11/22/2015-11-23-css3-triangle.html"},{"title":"使用QQ企业邮箱发信时501错误解决方案","text":"此现象只出现在新增或者编辑邮箱密码的时候出现，发送邮箱时服务端会返回501，此时是由于QQ企业邮箱强制要求第一次登录必须修改密码。解决方案是： 登录QQ企业邮箱 修改密码 使用新密码调用接口","link":"/2015/11/23/2015-11-23-exmail-501.html"},{"title":"nodejs mongodb 缓存模块","text":"项目地址https://github.com/xialeistudio/mongodb-cache 项目说明基于mongodb的nodejs缓存模块 使用1npm install xl-cache --save 1var cache = require('xl-mongodb-cache'); 连接服务器 1cache.connect('mongodb://localhost:27017/app'); 写入缓存 123cache.set(key, value, duration).then(function(data) { console.log(data);}).catch(console.error); 读取缓存 123cache.get(key).then(function(data) { console.log(data);}).catch(console.error); 删除缓存 123cache.remove(key).then(function(data) { console.log(data);}).catch(console.error);","link":"/2015/11/22/2015-11-23-nodejs-mongodb-cache.html"},{"title":"object-c委托实例","text":"定义 delegate是一种设计模式，不是object-c特有 object-c通过protocol实现delegat 作用 业务逻辑解耦 加强程序可读性 使用 声明protocol 实现protocol 指定delegate 调用delegate方法 实例本文以UIImagePickerController举例。UIImagePickerController本身需要实现&lt;UIImagePickerControllerDelegate,UINavigationControllerDelegate&gt;两个protocol，本文为了解释delegate的工作过程，在此之上封装一层。1.新建cocoa touch class 继承NSObject，命名UITool UITool.h12345678910111213141516171819202122232425262728293031323334353637383940414243UITool.h#import &lt;Foundation/Foundation.h&gt;#import &lt;UIKit/UIKit.h&gt;enum{ ImageErrorUnSupportedSourceType = -1//不支持的来源类型}ImageError;@protocol ToolImageDelegate &lt;NSObject&gt;/** * 选择图片回调 * * @param info 图片数据 */-(void)didSelectImage:(NSDictionary *)info;@end@interface UITool : NSObject&lt;UIImagePickerControllerDelegate,UINavigationControllerDelegate&gt;{ id&lt;ToolImageDelegate&gt;imageDelegate;}/** * 单例 * * @return 单例 */+(instancetype)sharedManager;/** * 选择图片 * * @param sourceType 来源类型 * @param viewController 视图 * @param error 错误 * * @return 是否出错 */-(BOOL)selectPicture :(UIImagePickerControllerSourceType)sourceType :(UIViewController&lt;ToolImageDelegate&gt; *)viewController :(NSError **)error;@end UITool.m12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364UITool.m#import &quot;UITool.h&quot;/** * 单例 * * @return 单例 */+(instancetype)sharedManager{ static UITool *instance = nil; static dispatch_once_t predicate; dispatch_once(&amp;predicate,^{ instance = [[self alloc]init]; }); return instance;}/** * 选择图片 * * @param sourceType 来源地址 * @param viewController 视图 * @param error 错误 * * @return 是否成功 */-(BOOL)selectPicture:(UIImagePickerControllerSourceType)sourceType :(UIViewController&lt;ToolImageDelegate&gt; *)viewController :(NSError **)error{ if (![UIImagePickerController isSourceTypeAvailable:sourceType]) { NSDictionary *info = [NSDictionary dictionaryWithObject:@&quot;UnSupported source type&quot; forKey:NSLocalizedDescriptionKey]; *error = [NSError errorWithDomain:@&quot;com.xialeistudio.core.UITool&quot; code:ImageErrorUnSupportedSourceType userInfo:info]; return NO; } //委托处理 imageDelegate = viewController; UIImagePickerController *picker = [[UIImagePickerController alloc] init]; picker.sourceType = sourceType; picker.allowsEditing= YES; picker.delegate = self; [viewController presentViewController:picker animated:YES completion:nil]; return YES;}/** * 取消图片选择回调 * * @param picker 图片选择器 */-(void)imagePickerControllerDidCancel:(UIImagePickerController *)picker{ [picker dismissViewControllerAnimated:YES completion:^{ [imageDelegate didSelectImage:nil]; }];}/** * 图片成功回调 * * @param picker 图片选择器 * @param info 回调数据 */-(void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary&lt;NSString *,id&gt; *)info{ [picker dismissViewControllerAnimated:YES completion:^{ [imageDelegate didSelectImage:info]; }];}@end 按照委托的使用4步来说，我们自定义的委托已经实现了两步。imageDelegate就是我们的delegate，只要实现了该委托的子类，我们调用didSelectImage方法就不会出错。 视图打开Interface Builder，放入一个button和一个ImageView，并做好输出口连接。 ViewController.h12345678910ViewController.h#import &lt;UIKit/UIKit.h&gt;#import &quot;UITool.h&quot;@interface ImagePickerViewController : UIViewController&lt;ToolImageDelegate&gt;- (IBAction)fromCamera:(id)sender;@property (weak, nonatomic) IBOutlet UIImageView *cameraImage;@end ViewController.m1234567891011121314151617181920212223242526272829303132333435ViewController.m#import &quot;ImagePickerViewController.h&quot;@interface ImagePickerViewController ()@end@implementation ImagePickerViewController- (void)viewDidLoad { [super viewDidLoad];}- (void)didReceiveMemoryWarning { [super didReceiveMemoryWarning];}- (IBAction)fromCamera:(id)sender { NSError *error = nil; if (![[UITool sharedManager] selectPicture:UIImagePickerControllerSourceTypeCamera :self :&amp;error]) { NSLog(@&quot;error:%@&quot;,[error localizedDescription]); }}-(void)didSelectImage:(NSDictionary *)info{ if (info ==nil) { NSLog(@&quot;未选择图片&quot;); }else{ UIImage *originImage = [info objectForKey:UIImagePickerControllerOriginalImage]; [self.cameraImage setImage:originImage]; }}@end 总结 在调用UITool的selectPicture方法时第二个参数(UIViewController *)，强制要求传入的viewController实现ToolImageDelegate协议，在UIImagePickerController回调成功之后就会执行imagePickerControllerDidCancel和didFinishPickingMediaWithInfo方法，由于我们在该方法中进行了委托方法的调用，所以最终会执行ViewController的didSelectImage方法。","link":"/2015/11/30/2015-12-01-object-c-delegate.html"},{"title":"ios9 导航栏全透明","text":"效果图导航栏是全透明的，但是导航栏的 item 还是正常的。 123[self.navigationBar setBackgroundImage:[UIImage new] forBarMetrics:UIBarMetricsDefault];self.navigationBar.shadowImage = [UIImage new];self.navigationBar.translucent = YES; 如果你的当前viewController不是navigationControllernavigationController，请把self.navigationBar改为self.navigationController.navigationBar。","link":"/2015/12/12/2015-12-12-ios9-navigation-bar-transparent.html"},{"title":"mac 10.11安装php-mongo扩展踩过的坑","text":"pecl的安装本文采用的是 pecl 的方式安装。如果系统执行 pecl 命令报错的话，请打开终端，执行以下命令 12curl -o go-pear.phar http://pear.php.net/go-pear.pharphp go-pear.phar 接下来的询问过程直接回车即可，成功之后执行以下命令 12sudo ln -s /Users/[用户名]/pear/bin/pear /usr/bin/pearsudo ln -s /Users/[用户名]/pear/bin/pecl /usr/bin/pecl mongo扩展的安装1sudo pecl install mongo 接下来会询问是不是启用 sasl 认证，输入**[no]**回车，接下来是编译了，不出意外的话会编译出错，大致错误是 1&lt;openssl/evp.h&gt; file not found 简而言之就是 openssl/evp.h 头文件查找失败，由于用 尖括号括起来的头文件，编译器会去系统路径查找，而 mac 下默认的路径是 /usr/include，使用终端ls查看之后发现确实没有openssl文件夹。 openssl的安装1sudo brew install openssl 如果提示brew命令不存在，可以通过以下代码安装Homebrew，终端执行 1ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 安装完成后重新安装openssl即可。 link头文件通过brew命令安装完openssl之后会自动link一次，但是重新执行mongo的安装命令时依旧出错。猜想应该是头文件没有复制过去，这时候需要手动ln一下，终端执行 1ln -s /usr/local/Cellar/openssl/1.0.2d_1/include/openssl /usr/include/openssl 如果你的openssl版本不一致，请自行替换，执行完该命令之后再安装mongo就不会有问题了。 启用扩展MAMP的php很有意思，web版本的配置文件在 1/Library/Application Support/appsolute/MAMP PRO/conf/php.ini cli版本的配置文件在（请通过终端执行 php -v 获取PHP版本） 1/Applications/MAMP/bin/php/php5.5.10/conf/php.ini 在这两个文件都加上 1extesion=mongo.so 重启MAMP即可","link":"/2015/12/15/2015-12-15-mac-10-11-install-php-mongo.html"},{"title":"ios仿微信右上角弹出菜单","text":"项目地址ios仿微信右上角弹出菜单 效果图 实现过程本人倾向于使用storyboard来做布局，所以实现起来也是不难的1.新建 Single View Application。 2.打开Main.storyboard。 3.选择默认的View Controller，点击菜单”Editor”=&gt;”Embed In”=&gt;”Navigation Controller”,确认Navigation Controller是Initial View Controller。 4.拖两个viewController到Interface builder，并做好连接，效果如图1所示。 5.选择第二个 Segue，属性设置如图2所示。 6.打开ViewController.m，覆盖 prepareForSegue方法 12345678910- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender { if ([segue.identifier isEqualToString:@&quot;showMenu&quot;]) { UIViewController *viewController = segue.destinationViewController; if ([[[UIDevice currentDevice] systemVersion] floatValue] &gt;= 8.0) { viewController.modalPresentationStyle = UIModalPresentationOverCurrentContext; } else { self.modalPresentationStyle = UIModalPresentationCurrentContext; } }} 由于IOS8更换了Enum的名称，所以这里需要做下判断7.新建Cocao Touch Class=&gt;View2Controller 8.在Interface Builder中把第二个viewController的Class设置为View2Controller，并把“取消”按钮绑定到View2Controller.m 9.打开View2Controller.m 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//// View2Controller.m// viewtransition//// Created by xialeistudio on 15/12/17.// Copyright © 2015年 Group Friend Information. All rights reserved.//#import &quot;View2Controller.h&quot;@interface View2Controller ()- (IBAction)cancelClicked:(id)sender;@property(weak, nonatomic) IBOutlet UIView *menuView;@end@implementation View2Controller { UITapGestureRecognizer *_tap;}- (void)viewDidLoad { [super viewDidLoad]; // Do any additional setup after loading the view. _tap = [[UITapGestureRecognizer alloc] init]; [_tap addTarget:self action:@selector(closeView)]; [self.view addGestureRecognizer:_tap];}- (void)closeView { _menuView.frame = CGRectMake(_menuView.frame.origin.x, self.view.frame.size.height - _menuView.frame.size.height, _menuView.frame.size.width, _menuView.frame.size.height); [UIView animateWithDuration:.3 delay:0 options:UIViewAnimationOptionCurveEaseInOut animations:^{ _menuView.frame = CGRectMake(_menuView.frame.origin.x, self.view.frame.size.height, _menuView.frame.size.width, _menuView.frame.size.height); } completion:^(BOOL isFinished) { if (isFinished) { [self dismissViewControllerAnimated:NO completion:nil]; } }];}- (void)didReceiveMemoryWarning { [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.}- (void)viewWillAppear:(BOOL)animated { _menuView.frame = CGRectMake(_menuView.frame.origin.x, self.view.frame.size.height, _menuView.frame.size.width, _menuView.frame.size.height); [UIView animateWithDuration:.3 animations:^{ _menuView.frame = CGRectMake(_menuView.frame.origin.x, self.view.frame.size.height - _menuView.frame.size.height, _menuView.frame.size.width, _menuView.frame.size.height); }];}/*#pragma mark - Navigation// In a storyboard-based application, you will often want to do a little preparation before navigation- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender { // Get the new view controller using [segue destinationViewController]. // Pass the selected object to the new view controller.}*/- (IBAction)cancelClicked:(id)sender { [self closeView];}@end 关键是 viewWillAppear 和 closeView 中的动画处理。","link":"/2015/12/16/2015-12-17-ios-wechat-like-menu.html"},{"title":"百度云推送nodejs sdk","text":"项目地址bpush-nodejs 开发背景百度官方只有php和java的sdk，但是百度提供了rest api,好处就是开发者可以使用任何语言开发一套服务端SDK，本人开源一套基于nodejs的sdk。 使用1npm install bpush-nodejs --save 1var bpush = require('bpush-nodejs'); 说明SDK采用Promise方式进行回调,demo代码如下(以推送单个设备为例),catch代码块中 只捕获HTTP请求错误,如果HTTP请求成功,但是百度服务端报错,请自行在then中处理 1234567891011121314151617var data = { channel_id: '5247517738736986629', msg: JSON.stringify({ aps: { alert: '你是呵呵SINGLE' } }), msg_type: bpush.constant.MSG_TYPE.NOTIFICATION, deploy_status: bpush.constant.DEPLOY_STATUS.DEVELOPMENT, device_type: bpush.constant.DEVICE_TYPE.IOS};bpush.sendRequest(bpush.apis.pushMsgToSingleDevice, data).then(function (data) { data = JSON.parse(data); console.log(data); }).catch(function(e){ console.error(e); }); 所有api调用方法均为 bpush.sendRequest(bpush.apis.[api名称], [api需要的数据]) api列表百度官方文档特别说明: 本文档写作时,百度api返回的数据以本文档为准,与官方文档有出入的地方可能是百度升级了api忘记更新文档所致. pushSingleDevice功能:推送单一终端请求参数: 1234567891011var data = { channel_id: '5247517738736986629',//设备channelID msg: JSON.stringify({ aps: { alert: '你是呵呵SINGLE' } }), msg_type: bpush.constant.MSG_TYPE.NOTIFICATION, deploy_status: bpush.constant.DEPLOY_STATUS.DEVELOPMENT, device_type: bpush.constant.DEVICE_TYPE.IOS}; 返回参数: 1234567{ request_id: 900279880, response_params: { msg_id: '7960733379606623036', send_time: 1451380442 }} pushMsgToAll功能:推送所有终端请求参数: 12345678910var data = { msg: JSON.stringify({ aps: { alert: '你是呵呵ALL' } }), msg_type: bpush.constant.MSG_TYPE.NOTIFICATION, deploy_status: bpush.constant.DEPLOY_STATUS.DEVELOPMENT, device_type: bpush.constant.DEVICE_TYPE.IOS}; 返回参数: 1234567{ request_id: 900279880, response_params: { msg_id: '7960733379606623036', send_time: 1451380442 }} pushMsgToTag功能:组播推送请求参数: 123456789101112var data = { msg: JSON.stringify({ aps: { alert: '你是呵呵TAG' } }), type: 1,//固定为1 tag: 'test',//标签名称 msg_type: bpush.constant.MSG_TYPE.NOTIFICATION, deploy_status: bpush.constant.DEPLOY_STATUS.DEVELOPMENT, device_type: bpush.constant.DEVICE_TYPE.IOS}; 返回参数: 1234567{ request_id: 900279880, response_params: { msg_id: '7960733379606623036', send_time: 1451380442 }} queryMsgStatus功能:查询消息推送情况请求参数: 123var data = { msg_id: '3129074535657443828'}; 返回结果: 123456789101112131415{ &quot;request_id&quot;: 1221365722, &quot;response_params&quot;: { &quot;total_num&quot;: 1, &quot;result&quot;: [ { &quot;send_time&quot;: 1451381279, &quot;success&quot;: -1, &quot;total_num&quot;: 4, &quot;status&quot;: 0, &quot;msg_id&quot;: &quot;3129074535657443828&quot; } ] }} queryTags功能:查询标签组列表请求参数: 12var data = {}; 返回参数: 123456789101112131415161718192021222324252627282930313233343536{ &quot;request_id&quot;: 896177143, &quot;response_params&quot;: { &quot;total_num&quot;: 4, &quot;result&quot;: [ { &quot;tid&quot;: &quot;1933949969962682514&quot;, &quot;tag&quot;: &quot;default&quot;, &quot;info&quot;: &quot;default&quot;, &quot;type&quot;: 0, &quot;create_time&quot;: 1447315802 }, { &quot;tid&quot;: &quot;73579040&quot;, &quot;tag&quot;: &quot;test20151112&quot;, &quot;info&quot;: &quot;test201511127237210&quot;, &quot;type&quot;: 2, &quot;create_time&quot;: 1447321138 }, { &quot;tid&quot;: &quot;77983912&quot;, &quot;tag&quot;: &quot;test&quot;, &quot;info&quot;: &quot;test7237210&quot;, &quot;type&quot;: 2, &quot;create_time&quot;: 1451376995 }, { &quot;tid&quot;: &quot;77986112&quot;, &quot;tag&quot;: &quot;testtag&quot;, &quot;info&quot;: &quot;testtag7237210&quot;, &quot;type&quot;: 2, &quot;create_time&quot;: 1451379084 } ] }} createTag功能:创建标签组请求参数: 123var data = { tag: 'testtag'}; 返回参数: 1234567{ &quot;request_id&quot;: 1221802330, &quot;response_params&quot;: { &quot;tag&quot;: &quot;testtag&quot;, &quot;result&quot;: 0 }} deleteTag功能:删除标签组请求参数: 123var data = { tag: 'testtag'}; 返回参数: 1234567{ &quot;request_id&quot;: 897517834, &quot;response_params&quot;: { &quot;tag&quot;: &quot;testtag&quot;, &quot;result&quot;: 0 }} addDevicesToTag功能:添加设备到标签组请求参数: 1234var data = { tag: 'testtag', channel_ids: JSON.stringify([5247517738736986629])}; 返回参数: 1234567891011{ &quot;request_id&quot;: 881162061, &quot;response_params&quot;: { &quot;result&quot;: [ { &quot;channel_id&quot;: &quot;5247517738736987000&quot;, &quot;result&quot;: 1 } ] }} removeDevicesFromTag功能:将设备从标签组中移除请求参数: 1234var data = { tag: 'testtag', channel_ids: JSON.stringify([5247517738736986629])}; 返回参数: 1234567891011{ &quot;request_id&quot;: 881521481, &quot;response_params&quot;: { &quot;result&quot;: [ { &quot;channel_id&quot;: &quot;5247517738736987000&quot;, &quot;result&quot;: 1 } ] }} deviceNumInTag功能:查询标签组设备数量请求参数: 123var data = { tag: 'testtag'}; 返回参数: 123456{ &quot;request_id&quot;: 882409689, &quot;response_params&quot;: { &quot;device_num&quot;: -1 }} reportStaticDevice功能:当前应用的设备统计信息请求参数: 12var data = {}; 返回参数: 1234567891011121314151617181920212223242526272829303132333435363738394041424344{ &quot;request_id&quot;: 883742690, &quot;response_params&quot;: { &quot;result&quot;: { &quot;1450713600&quot;: { &quot;total_term&quot;: 2, &quot;total_term_detail&quot;: { &quot;1450774800&quot;: 2 }, &quot;new_term&quot;: 1, &quot;new_term_detail&quot;: { &quot;1450774800&quot;: 1 }, &quot;del_term&quot;: 0, &quot;del_term_detail&quot;: [] }, &quot;1450800000&quot;: { &quot;total_term&quot;: 3, &quot;total_term_detail&quot;: { &quot;1450868400&quot;: 3 }, &quot;new_term&quot;: 1, &quot;new_term_detail&quot;: { &quot;1450868400&quot;: 1 }, &quot;del_term&quot;: 0, &quot;del_term_detail&quot;: [] }, &quot;1451232000&quot;: { &quot;total_term&quot;: 4, &quot;total_term_detail&quot;: { &quot;1451293200&quot;: 4 }, &quot;new_term&quot;: 1, &quot;new_term_detail&quot;: { &quot;1451293200&quot;: 1 }, &quot;del_term&quot;: 0, &quot;del_term_detail&quot;: [] } }, &quot;total_num&quot;: 3 }}","link":"/2015/12/29/2015-12-29-baidu-push-nodejs-sdk.html"},{"title":"mongodb更新指定条件的子文档","text":"文档内容123456789101112131415161718{ &quot;_id&quot;: ObjectId(&quot;5689db252d162c9881532986&quot;), &quot;openid&quot;: &quot;xialei&quot;, &quot;channels&quot;: [ { &quot;channel_id&quot;: &quot;c1&quot; }, { &quot;channel_id&quot;: &quot;c2&quot; }, { &quot;channel_id&quot;: &quot;c2&quot; }, { &quot;channel_id&quot;: &quot;c2&quot; } ]} 需求把该文档的channels中channel_id为c2的删除，但是主记录要保留。这时候就不能用remove方法了，该方法会删除整条文档，查询官方文档发现有个findAndModify方法。 函数原型12345678910db.collection.findAndModify({ query: &lt;document&gt;, sort: &lt;document&gt;, remove: &lt;boolean&gt;, update: &lt;document&gt;, new: &lt;boolean&gt;, fields: &lt;document&gt;, upsert: &lt;boolean&gt; bypassDocumentValidation: &lt;boolean&gt;}); 调用代码12345db.collection.findAndModify({ query: {&quot;openid&quot;:&quot;xialei&quot;}, update: {&quot;$pull&quot;:{&quot;channels&quot;:{&quot;channel_id&quot;:&quot;c2&quot;}}}, new: true}); 执行结果123456789{ &quot;_id&quot; : ObjectId(&quot;5689db252d162c9881532986&quot;), &quot;openid&quot; : &quot;xialei&quot;, &quot;channels&quot; : [ { &quot;channel_id&quot; : &quot;c1&quot; } ]} $pull是数组操作符，明白update中的操作之后，相信大家可以举一反三，比如要插入一个文档就肯定会想到用**$push**了。","link":"/2016/01/03/2016-01-04-mongodb-findandmodify.html"},{"title":"MAMP下使用pecl安装PHP扩展","text":"之前写过一篇在Mac下搭建PHP开发环境的文章，Mac搭建PHP开发环境，但是此种方式搭建的PHP有弊端，由于默认不带PHP源码，所以在使用pecl安装扩展时会报错。 测试安装扩展1sudo pecl install mongo 运行起来后会报形如“php.h not found”的错误，因为MAMP默认是不带PHP源码包的。 配置扩展安装环境按照如下步骤将源码包集成以便于安装扩展：1.在web目录下添加index.php文件，内容如下： 12&lt;?phpphpinfo(); 2.打开浏览器访问该php文件，记录PHP版本，本文暂定PHP版本A。3.打开终端，输入以下命令： 1php -v 记录PHP版本，本文暂定PHP版本B。4.如果PHP版本A不等于PHP版本B，在终端执行以下命令： 123456789sudo rm -rf /usr/bin/phpsudo rm -rf /usr/bin/phpizesudo rm -rf /usr/bin/php-configsudo rm -rf /usr/bin/pecl ln -s /Application/MAMP/bin/php/php[PHP版本A]/bin/php /usr/bin/phpln -s /Application/MAMP/bin/php/php[PHP版本A]/bin/php-config /usr/bin/php-configln -s /Application/MAMP/bin/php/php[PHP版本A]/bin/phpize /usr/bin/phpizeln -s /Application/MAMP/bin/php/php[PHP版本A]/bin/pecl /usr/bin/pecl 请替换**[PHP版本A]为步骤2中的版本，如5.5.18**执行完以上命令之后，命令行模式和浏览器模式的PHP都是一致的了。5.下载PHP源码包，打开浏览器访问如下网址 http://cn2.php.net/get/php-**[PHP版本A]**.tar.gz/from/this/mirror。6.将下载的压缩包解压到 /Application/MAMP/bin/php/php**[PHP版本A]**/include/php 中。7.在终端执行以下命令： 12cd /Application/MAMP/bin/php/php[PHP版本A]/include/php./configure 此时PHP源码包已经配置正常了，头文件也可以正常调用了。8.在终端执行： 1sudo pecl install mongo 扩展安装成功后，编辑*/Application/MAMP/bin/php/php*[PHP版本A]/conf/php.ini 在最后添加： 1extension=mongo.so 9.由于命令行模式和浏览器模式中加载的php.ini并不是同一个文件，所以需要用软连接的方式处理下。终端执行： 1php -i|grep ini 查看Loaded ini file路径，本文假设为PHP配置文件A。10.备份PHP配置文件A，终端执行： 1ln -s /Application/MAMP/bin/php/php[PHP版本A]/conf/php.ini PHP配置文件A 11.终端执行： 1php -i|grep ini 此时该路径应该和浏览器中看到的是一致的了。 安装扩展 sudo pecl install [扩展名] 编辑 /Application/MAMP/bin/php/php**[PHP版本A]**/conf/php.ini 加载扩展 重启Web服务器","link":"/2016/02/15/2016-02-16-mamp-install-php-extension.html"},{"title":"百度推送收到消息时带参数启动activity","text":"一般来说，在BPushReceiver的onNotificationClicked或者onMessage方法收到推送消息后会去启动一个activity。此时整个应用有以下几种状态： 应用进程不存在 应用进程存在，但是不在前台 应用进程存在，在前台 在BPushReceiver的onNotificationClicked或者onMessage方法中使用Intent来启动activity： 1234567891011Intent intent = new Intent();intent.setClass(context.getApplicationContext(), MainActivity.class);intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_SINGLE_TOP);if (url != null &amp;&amp; !url.isEmpty()) { Bundle bundle = new Bundle(); bundle.putString(&quot;url&quot;, url); intent.putExtras(bundle);}Log.d(TAG, &quot;start app&quot;);context.getApplicationContext().startActivity(intent); 需要注意的是，针对不同的应用状态，MainActivity中触发的方法也不同： 应用进程不存在时,onCreate被调用 应用进程存在，不管是不是在前台，onNewIntent被调用 针对以上状态，合理的使用onCreate和onNewIntent就可以在任何时候呆参数启动APP了。","link":"/2016/02/19/2016-02-19-baidu-push-launch-app-with-params.html"},{"title":"android选择图片返回统一图片地址","text":"android从选择图片有两种方法，但是返回值确不同，本文将指导大家如何统一这两种方式的返回值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//关键代码@Event(R.id.btnPhoto) private void onBtnPhotoClicked(View view) { Intent intent = new Intent(Intent.ACTION_PICK, MediaStore.Images.Media.EXTERNAL_CONTENT_URI); startActivityForResult(intent, Config.Constants.CODE_PICK_IMAGE_FROM_PHOTO); } @Event(R.id.btnCamera) private void onBtnCameraClicked(View view) { Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); startActivityForResult(intent, Config.Constants.CODE_PICK_IMAGE_FROM_CAMERA); } @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { switch (requestCode) { case Config.Constants.CODE_PICK_IMAGE_FROM_CAMERA: if (data != null &amp;&amp; data.hasExtra(&quot;data&quot;)) { Bitmap bitmap = data.getParcelableExtra(&quot;data&quot;); bitmap = BitmapUtil.scale(bitmap, 640.0f / bitmap.getWidth()); try { File path = new File(((MyApplication) getApplication()).appPath, DateUtil.format(new Date(), &quot;yyyyMMddHHmmss&quot;) + &quot;.jpg&quot;); FileOutputStream outputStream = new FileOutputStream(path); bitmap.compress(Bitmap.CompressFormat.JPEG, 100, outputStream); outputStream.close(); Intent intent = new Intent(); intent.putExtra(&quot;path&quot;, path.getAbsolutePath()); setResult(RESULT_OK, intent); } catch (IOException e) { e.printStackTrace(); } } finish(); break; case Config.Constants.CODE_PICK_IMAGE_FROM_PHOTO: if(data != null){ Uri uri = data.getData(); Bitmap bitmap; ContentResolver contentResolver = getContentResolver(); try { bitmap = MediaStore.Images.Media.getBitmap(contentResolver, uri); bitmap = BitmapUtil.scale(bitmap, 640.0f / bitmap.getWidth()); File path = new File(((MyApplication) getApplication()).appPath, DateUtil.format(new Date(), &quot;yyyyMMddHHmmss&quot;) + &quot;.jpg&quot;); FileOutputStream outputStream = new FileOutputStream(path); bitmap.compress(Bitmap.CompressFormat.JPEG, 100, outputStream); outputStream.close(); Intent intent = new Intent(); intent.putExtra(&quot;path&quot;, path.getAbsolutePath()); setResult(RESULT_OK, intent); } catch (IOException e) { e.printStackTrace(); } } finish(); break; default: super.onActivityResult(requestCode, resultCode, data); } }//BitmapUtil.javapublic static Bitmap scale(Bitmap bitmap, float scale) { Matrix matrix = new Matrix(); matrix.postScale(scale, scale); return Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(), bitmap.getHeight(), matrix, true);}//MyApplicationpublic File appPath;@Overridepublic void onCreate() { super.onCreate(); //创建目录 appPath = new File(Environment.getExternalStorageDirectory(), getPackageName()); if (!appPath.isDirectory()) { appPath.mkdir(); }} 经过统一处理之后，返回值均为图片的绝对路径地址。","link":"/2016/03/02/2016-03-02-android-pick-image-return-image-path.html"},{"title":"React Flux ES6记事本应用","text":"项目地址react-notepad-es6 React出来有很久了，与angularjs最大的不同在于React只是一个处理UI层面的库，可以认为是“V”，而angularjs则是一整套解决方案。 随着前端开发的组件化思想越来越浓烈，angularjs很多场合已经显得力不从心了。而这时候，核心为“模块化、组件化”的React可以派上永用场。真正用来开发项目的话，React肯定是不足的，缺少C和M模块。 Facebook官方推荐的Flux可以认为是一个简单的解决方案，Flux没什么特别含义，就是一个facebook随便找的一个词而已。至于什么是Flux，本文不做解释，本文以Flux来开发一个记事本应用。 项目目录12345678910111213141516171819202122232425262728293031|----action Action Creator |---- NoteAction.js 记事本应用需要的动作|----css 样式文件目录 |---- style.scss 样式文件|----dispatcher 分发器目录 |---- AppDispatcher.js 分发器|----store Store目录 |---- NoteStore.js 存储日记数据以及处理AppDispatcher派发事件|----view 视图&amp;组件目录 |---- Note.jsx 单条日记 |---- NoteBox.jsx 整个日记组件的父容器 |---- NoteForm.jsx 日记创建/编辑表单 |----NoteList.jsx 日记列表组件|----entry.js webpack入口文件|----index.html 项目页面|----webpack.config.js webpack配置文件 项目思路 NoteList.jsx组件包含多个Note.jsx，NoteList.jsx的数据来源于NoteStore.js。 创建日记时，NoteForm.jsx需要调用NoteAction的add方法最终触发AppDispatcher.dispatch方法 NoteStore注册AppDispatcher的监听器实现对dispatch事件的监听 编辑日记时，Note.jsx调用NoteAction的setNote方法设置需要编辑的日记，通过AppDispatcher的调度之后最终将日记数据显示在NoteForm.jsx组件中。 项目实现安装依赖本文采用ES6语法进行开发， 所以需要安装babel编译器，打开终端执行以下命令： 123456npm init -ynpm install webpack webpack-dev-server -gnpm install flux microevent react react-dom --savenpm install babel-loader css-loader jsx-loader sass-loader style-loader --save-devnpm instlal babel-preset-es2015 babel-preset-react --save-devnpm install microevent --save webpack.config.js1234567891011121314151617181920212223242526272829/** * Created by xialei on 2016/3/23 0023. */module.exports = { entry: './entry.jsx', output: { publicPath: 'http://localhost:8000/assets', filename: 'bundle.js', path: './assets' }, module: { loaders: [ {test: /\\.js$/, loader: 'babel'}, { test: /.jsx?$/, loader: 'babel-loader', exclude: /node_modules/, query: { presets: ['es2015', 'react'] } }, {test: /\\.css$/, loader: 'style!css'}, {test: /\\.scss$/, loader: 'style!css!sass'} ] }, resolve: { extensions: ['', '.js', '.jsx'] }}; dispatcher/AppDispatcher.js123import Flux from 'flux';let AppDispatcher = new Flux.Dispatcher();export default AppDispatcher; action/NoteAction.jsActionCreator主要是为了简化代码量，不然每次需要触发动作的时候都需要调用AppDispatcher.dispatch方法。根据项目实际情况，可以总结出需要以下动作： 创建日记 更新日记 删除日记 编辑日记 由于ActionCreator是为了简化AppDispatcher.dispatch的方法调用，所以需要引入该模块。 123456789101112131415161718192021222324252627282930313233/** * Created by xialei on 2016/3/23 0023. */import AppDispatcher from '../dispatcher/AppDispatcher';export default class NoteAction { static create(item) { AppDispatcher.dispatch({ eventName: 'create-note', item: item }); } static update(item) { AppDispatcher.dispatch({ eventName: 'update-note', item: item }); } static remove(item) { AppDispatcher.dispatch({ eventName: 'remove-note', item: item }); } static setNote(item) { AppDispatcher.dispatch({ eventName: 'set-note', item: item }); }} store/NoteScore.js有了分发，就要有接收，所以接下来编辑 store/NoteScore.js文件，这里需要注意的是由于V中不要直接调用AppDispatcher.dispatch，但是V是肯定需要监听事件的，所以这里使用MicroEvent库来进行事件处理。 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Created by xialei on 2016/3/23 0023. */import AppDispatcher from '../dispatcher/AppDispatcher';import MicroEvent from 'microevent';class NoteStore { constructor() { this.items = []; }}MicroEvent.mixin(NoteStore);let store = new NoteStore();AppDispatcher.register((payload)=&gt; { switch (payload.eventName) { case 'create-note': store.items.push(payload.item); store.trigger('change'); break; case 'update-note': store.items.forEach(function(i, index2) { if (i.id == payload.item.id) { store.items[index2] = payload.item; store.trigger('change'); } }); break; case 'remove-note': store.items.forEach(function(i, index2) { if (i.id == payload.item.id) { store.items.splice(index2, 1); store.trigger('change'); } }); break; case 'set-note': store.trigger('set', payload.item); break; } return true;});export default store; view/Note.jsx该组件主要负责单条日记的显示和操作，所以该组件需要有一个初始属性以及编辑/删除方法，由于编辑日记最终会放在NoteForm.jsx组件进行，所以此处使用props而不是state。 1234567891011121314151617181920212223242526272829303132333435/** * Created by xialei on 2016/3/23 0023. */import React from 'react';import NoteAction from '../action/NoteAction';export default class Note extends React.Component { constructor() { super(); this.handleDelete = this.handleDelete.bind(this); this.handleUpdate = this.handleUpdate.bind(this); } handleUpdate() { NoteAction.setNote(this.props.note); } handleDelete() { if (confirm('确定删除吗?')) { NoteAction.remove(this.props.note); } } render() { return ( &lt;div className=&quot;note-item&quot;&gt; &lt;div className=&quot;id&quot;&gt;{this.props.note.id}&lt;/div&gt; &lt;div className=&quot;text&quot;&gt;{this.props.note.text}&lt;/div&gt; &lt;div className=&quot;operation&quot;&gt; &lt;button type=&quot;button&quot; onClick={this.handleUpdate}&gt;编辑&lt;/button&gt; &lt;button type=&quot;button&quot; onClick={this.handleDelete}&gt;删除&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; ); }} 由于采用了ES6语法，所以此处需要对this做特殊处理，否则会提示props undefined之类的错误。 view/NoteBox.jsx该组件的作用是将日记列表和日记表单显示出来，所以该组件只有一个构造方法和render方法。 12345678910111213141516/** * Created by xialei on 2016/3/23 0023. */import NoteList from './NoteList';import NoteForm from './NoteForm';import React from 'react';export default class NoteBox extends React.Component { render() { return ( &lt;div className=&quot;note-box&quot;&gt; &lt;NoteList/&gt; &lt;NoteForm/&gt; &lt;/div&gt; ); }} view/NoteForm.jsx该组件需要完成的事情比较多： 需要对编辑和创建进行分别处理 需要监听Note.jsx组件触发的编辑事件 可编辑的文本域 根据以上要求，可以得出以下结论： 需要使用state，以及设置一个初始的state 在textarea的onChange事件中，将值设置到state中去 需要监听NoteStore触发的“set”事件，将需要编辑的日记显示在textarea中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/** * Created by xialei on 2016/3/23 0023. */import React from 'react';import NoteAction from '../action/NoteAction';import NoteStore from '../store/NoteStore';export default class NoteForm extends React.Component { constructor() { super(); this.handleClick = this.handleClick.bind(this); this.handleSetNote = this.handleSetNote.bind(this); this.handleChange = this.handleChange.bind(this); this.resetForm = this.resetForm.bind(this); this.state = { note: { id: 0, text: '' } }; } componentDidMount() { NoteStore.bind('set', this.handleSetNote); } componentWillUnmount() { NoteStore.unbind('set', this.handleSetNote); } isCreate() { return this.state.note.id == 0; } handleClick() { let text = this.refs.input.value; if (text.length == 0) { alert('请输入日记内容'); this.refs.input.focus(); return; } if (this.isCreate()) { let id = 1; if (NoteStore.items.length &gt; 0) { id = NoteStore.items[NoteStore.items.length - 1].id + 1; } NoteAction.create({ id: id, text: text }); } else { let note = this.state.note; note.text = text; NoteAction.update(note); } this.resetForm(); } render() { let note = this.state.note.text; let btnText = this.isCreate() ? '创建' : '编辑'; let tips = this.isCreate() ? '' : '当前编辑 [' + this.state.note.id + '] 号日记'; return ( &lt;div className=&quot;note-form&quot;&gt; &lt;div&gt;{tips}&lt;/div&gt; &lt;textarea ref=&quot;input&quot; rows=&quot;8&quot; placeholder=&quot;日记内容&quot; value={note} onChange={this.handleChange}/&gt; &lt;button type=&quot;button&quot; onClick={this.handleClick}&gt;{btnText}&lt;/button&gt; &lt;button type=&quot;button&quot; onClick={this.resetForm}&gt;重置&lt;/button&gt; &lt;/div&gt; ); } handleChange(e) { let id = this.state.note.id || 0; this.setState({ note: { id: id, text: e.target.value } }); } handleSetNote(note) { this.setState({note: note}); console.log('set ', this.state.note); } resetForm() { this.setState({ note: { id: 0, text: '' } }); }} view/NoteList.jsx该组件负责渲染NoteStore中的日记列表以及对NoteStore触发的change事件作出相应，实时显示最新数据。 123456789101112131415161718192021222324252627282930313233/** * Created by xialei on 2016/3/23 0023. */import React from 'react';import NoteStore from '../store/NoteStore';import Note from './Note';export default class NoteList extends React.Component { constructor() { super(); this.handleChanged = this.handleChanged.bind(this); } componentDidMount() { NoteStore.bind('change', this.handleChanged); } componentWillUnmount() { NoteStore.unbind('change', this.handleChanged); } handleChanged() { this.forceUpdate(); } render() { const notes = NoteStore.items.map((item)=&gt; { return &lt;Note note={item} key={item.id}/&gt;; }); return ( &lt;div className=&quot;note-list&quot;&gt;{notes}&lt;/div&gt; ); }} entry.jsx该文件主要将NoteBox.jsx组件渲染到html容器中。 1234567/** * Created by xialei on 2016/3/23 0023. */import ReactDOM from 'react-dom';import NoteBox from './view/NoteBox';import './css/style.scss';ReactDOM.render(&lt;NoteBox/&gt;, document.querySelector('#content')); index.html12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;./node_modules/react/dist/react-with-addons.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;content&quot;&gt;&lt;/div&gt; &lt;script src=&quot;http://localhost:8000/webpack-dev-server.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;http://localhost:8000/assets/bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 项目运行1webpack-dev-server --progress --colors --port 8000 demo","link":"/2016/03/23/2016-03-24-react-flux-es6-note-app.html"},{"title":"angularjs显示html文本","text":"Angularjs中输出变量使用花括号或者ng-bind，但是如果变量中有html代码的话，angularjs为了xss安全，默认是不解析html，直接原样显示html代码。如果需要显示解析后的html代码，需要使用angular-sanitize模块。 angular-sanitize一般会附带在angularjs中，如果没有附带，请前往官网下载对应版本的angular-sanitize模块。 模块代码1var demo = angular.module('demo',['ng-sanitize']); 控制器代码12345demo.controller('Demo13Controller', [ '$scope', function($scope) { $scope.html = '&lt;span style=&quot;color: red&quot;&gt;这是格式化的HTML文本&lt;/span&gt;'; }]); 视图代码1234567&lt;article class=&quot;demo13&quot; ng-controller=&quot;Demo13Controller&quot;&gt;&lt;h2&gt;&lt;a name=&quot;demo13&quot;&gt;13.显示HTML文本&lt;/a&gt;&lt;/h2&gt;&lt;div class=&quot;demo13-content&quot;&gt;&lt;p&gt;需要显示的文本：&lt;/p&gt;&lt;p&gt;Html格式化文本： &lt;span ng-bind-html=&quot;html|htmlContent&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;&lt;/article&gt; 过滤器代码12345demo.filter('htmlContent',['$sce', function($sce) { return function(input) { return $sce.trustAsHtml(input); }}]); 总结$sce过滤器+ng-bind-html就可以显示html文本了。","link":"/2016/03/29/2016-03-29-angularjs-display-html.html"},{"title":"JS提取字符串中文英文数字","text":"最近在做导出excel的时候，发现导出成功，文件大小也正常，但是Office 2013打不开，检查数据库发现，导出数据中有非中文字符导致Excel异常。 我们知道JS是支持unicode字符集的，符合导出规则的字符应该是”中文”、”英文”、”数字”。 正则表达式1/([\\u4e00-\\u9fa5\\w]*)/ig 提取字符串12345678910/*** 获得可打印字符* @param str 需要提取的字符串*/function getPrintableChars(str) { const matches = str.match(/([\\u4e00-\\u9fa5\\w]*)/ig); let a = ''; matches.forEach(item=&gt; item &amp;&amp; (a += item)); return a;}","link":"/2016/05/10/2016-05-10-js-extract-chinese-words-number-of-string.html"},{"title":"wordpress WPImageEditorImagick 漏洞临时修复方案","text":"4.5.1存在该漏洞，但是更新到4.5.2发现漏洞依旧存在。临时修复方案如下：文件路径： 1/wp-includes/media.php的_wp_image_editor_choose 将 1$implementations = apply_filters( 'wp_image_editors', array( 'WP_Image_Editor_Imagick' ,'WP_Image_Editor_GD' ) ); 改为 1$implementations = apply_filters( 'wp_image_editors', array( 'WP_Image_Editor_GD', 'WP_Image_Editor_Imagick' ) ); 此方法为临时解决方案，请大家及时更新最新版本的wordpress","link":"/2016/05/11/2016-05-12-fix-wordpress-wpimageeditorimagick-bug.html"},{"title":"安装nodejs的shell脚本","text":"脚本定义12345#!/bin/bashexport NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/nodegit clone https://github.com/creationix/nvm.git ~/.nvmsource ~/.nvm/nvm.shnvm install 4.4.2 脚本执行12chmod +x ./install.sh./install.sh nodejs版本大家可以 根据实际需要进行选择","link":"/2016/05/14/2016-05-14-shell-install-nodejs.html"},{"title":"ReactRouter不在组件中进行导航","text":"项目使用了Flux+React Router架构，有一些需要操作路由的地方是放在Action层的，比如登录之类，但是Action层不是React组件，需要操作路由的话有点麻烦。 当然最终还是有一个办法的，利用**window.location.href=**，但是既然用了react，再用这种导航模式未免不妥。 查看react router源码发现,hashHistory,browseHistory中有push方法，经过测试之后可行。 12import {hashHistory} from 'react-router';hashHistory.push('/login');","link":"/2016/05/16/2016-05-17-react-router-navigation-outside-of-components.html"},{"title":"nginx使用goddy ssl证书","text":"随着人们对网络安全要求的提高，越来越多的http站点已经转换为了https站点，保证网站在传输过程中不被监听、恶意篡改，本文将使用goddy提供的ssl证书来升级HTTPS网站。 生成私钥和证书请求文件终端执行 1openssl req -new -newkey rsa:2048 -nodes -keyout domain.key -out domain.csr 生成过程会询问几个常见问题，比如City、Country等等。最后会询问challenge password，输入的时候记住就可以了。执行完以上命令后，当前目录会多出domain.key和domain.csr文件，前者为服务器私钥，后者为证书请求文件 Goddy证书购买完SSL证书之后会有一个初始化过程，将第1步中的domain.csr文件所有内容填写到CSR输入框中，Goddy会检测配置等操作，操作完成之后会签发证书，点击下载即可，下载时服务器类型选择“其他”。 Nginx配置下载证书的时候压缩包内容类似如下图 正常情况下nginx配置SSL需要key和crt文件即可。这里有两个crt所以需要进行证书合并操作。打开终端，执行以下命令： 1cat 53f58e3ac2172cd5.crt gd_bundle-g2-g1.crt &gt; domain.crt 证书合并完成，接下来打开Nginx的配置文件，笔者这里证书目录位于**/root/crt** 12345678910111213141516server{ listen 443; server_name domain; index index.html index.htm default.html default.htm; root /home/wwwroot/domain; location = /favicon.ico { log_not_found off; access_log off; } ssl on; ssl_certificate /root/crt/domain.crt; ssl_certificate_key /root/crt/domain.key; access_log off;} 保存之后，终端执行 1nginx -s reload","link":"/2016/05/23/2016-05-23-nginx-goddy-ssl.html"},{"title":"NodeJs进程守护工具forever使用","text":"nodejs是单进程的，如果应用中发生未捕获的异常，进程就会退出，一个比较笨的办法在系统中使用计划任务检查进程是否存在，如果不存在启动该程序，但是该方式会造成系统资源的浪费，而且不是及时的。 好在NodeJs活跃的社区给开发者提供了一个选择forever，该包就是用来解决以上状况的。 安装1npm install forever -g 启动脚本1forever start app.js 查看目前监控任务1forever list","link":"/2016/05/23/2016-05-23-process-daemon-forever.html"},{"title":"ios ScrollView AutoLayout","text":"XCode的Interface Builder解决了开发者使用代码进行布局的问题，但是在使用 ScrollView 时，如果没有方法，IB中的layout是会乱掉的，在网上查找资料加上自己的实际操作之后，总结了以下步骤： 在根view中添加好子控件，排好版 选中所有子控件，选择菜单 Editor In =&gt; View，命名为 contentView，此时编辑器会报警，暂时不理会 给contentView添加上下左右4个约束，值全部为0 选择contentView，选择菜单 Editor In =&gt; ScrollView 设置ScrollView的上下左右4个约束，值全部为0 给contentView加上height约束，并在Interface Builder中设置合适的约束值。","link":"/2016/06/01/2016-06-02-ios-scrollview-autolayout.html"},{"title":"phpstorm+xdebug远程调试服务器PHP代码","text":"phpstorm+xdebug如何调试本地代码应该都熟悉了。本文说的是如何调试线上服务器的代码。本文写作时服务器的PHP环境是lnmp1.2。 服务器配置安装debug1pecl install xdebug 编辑php.ini编辑 /usr/local/php/etc/php.ini，在末尾加上以下代码： 12345678[Xdebug]zend_extension=&quot;xdebug.so&quot;xdebug.remote_enable=1xdebug.remote_handler=dbgpxdebug.remote_host=【调试终端所在的公网IP】xdebug.remote_port=9000xdebug.remote_autostart=1xdebug.idekey=&quot;PHPSTORM&quot; 本文中调试终端为PHPSTORM，所以本地公网IP为remote_host的值查看本地公网IP更改配置完毕后终端执行: 1lnmp php-fpm reload IDE配置配置serverSetting =&gt; Languages &amp; Frameworks=&gt;PHP=&gt;Servers， 配置DBGp ProxySettings =&gt; Languages &amp; Frameworks =&gt; PHP =&gt; Debug =&gt; DBGp Proxy其中红框处需要和服务器的xdebug配置文件一致。 路由端口映射由于大部分朋友公司都有路由器的，所以本机IP是局域网IP，这里需要将路由器的端口映射到本地。具体规则如下： 1服务器Xdebug端口（路由器公网端口） =&gt; 本地端口，笔者这里把路由器的9000端口映射到本地的9000端口。 开始调试 打开项目的运行配置，选择“PHP Web Application”笔者服务器这里是https的，所以加了https，各位读者请根据实际情况填写网址。 点击IDE的“电话”图标开启远程监听。 代码断点 开始调试 IDE自动弹出调试窗口","link":"/2016/06/07/2016-06-08-phpstorm-xdebug-remote-debug.html"},{"title":"js在线调试工具","text":"在进行微信开发的时候，由于JS SDK提供的api需要在真机调试，而手机端的console方法虽然存在，但是调用结果却看不到。所以笔者使用socket.io重写了一个在线版本的调试工具。 工具地址 使用方法 打开 http://jsconsole.duapp.com?token=【您的标识符】 请确保标识符全局唯一，否则其他人可能会看到你的调试信息哟！ 在需要调试的页面引入以下js: 12&lt;script src=&quot;http://jsconsole.duapp.com/dist/chat.bundle.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;http://jsconsole.duapp.com/dist/client.js?token=【您的标识符】&quot;&gt;&lt;/script&gt; 开始调试！","link":"/2016/06/11/2016-06-12-js-live-console.html"},{"title":"C++ RTTI 示例","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;iostream&gt;#include &lt;stdlib.h&gt;#include &lt;string&gt;#include &lt;typeinfo&gt;using namespace std;/*** 定义移动类：Movable* 纯虚函数：move*/class Movable{ public: virtual void move() = 0;};/*** 定义公交车类：Bus* 公有继承移动类* 特有方法carry*/class Bus : public Movable{ public: void move() { cout &lt;&lt; &quot;Bus -- move&quot; &lt;&lt; endl; } void carry() { cout &lt;&lt; &quot;Bus -- carry&quot; &lt;&lt; endl; }};/*** 定义坦克类：Tank* 公有继承移动类* 特有方法fire*/class Tank :public Movable{ public: void move() { cout &lt;&lt; &quot;Tank -- move&quot; &lt;&lt; endl; } void fire() { cout &lt;&lt; &quot;Tank -- fire&quot; &lt;&lt; endl; }};/*** 定义函数doSomething含参数* 使用dynamic_cast转换类型*/void doSomething(Movable *obj){ obj-&gt;move(); if (typeid(*obj) == typeid(Bus)) { Bus *bus = dynamic_cast&lt;Bus *&gt;(obj); bus-&gt;carry(); } if (typeid(*obj) == typeid(Tank)) { Tank *tank = dynamic_cast&lt;Tank *&gt;(obj); tank-&gt;fire(); }}int main(void){ Bus *b = new Bus; Tank *t = new Tank; doSomething(b); doSomething(t); delete b; delete t; return 0;}","link":"/2016/06/20/2016-06-21-cpp-rtti-demo.html"},{"title":"android AsyncTask示例","text":"android实现异步的方法有很多种，本文只介绍用的比较多的AsyncTask。从类名就可以看出来该类是专为异步而生，API也很简单。 AsyncTask接口原型123public abstract class AsyncTask&lt;Params, Progress, Result&gt; {...} 该类是个抽象类，有三个泛型参数，说明如下： Params 任务参数类型，比如加载网络图片时，这里传入String Progress 更新进度时参数类型，一般传入Integer Result 执行结果类型，比如加载网络图片时，结果为Bitmap 该类的主要方法如下： doInBackground(Params… params) 非主线程 执行异步任务，params为声明类时的泛型 onPreExecute 主线程 准备执行异步任务时调用 onPostExecute(Result result) 主线程 异步任务执行完毕时调用，result为声明类时的泛型 onProgressUpdate(Progress… values) 主线程 任务进度有更新时调用，values为声明类时的泛型 publishProgress(Progress… values) 非主线程 更新异步任务进度，此方法一般在doInBackground中调用 示例本文将使用一个图片批量下载程序作为示例根据需求可以确定，任务参数是String类型，进度是Integer类型，执行结果是List类型，项目代码如下： 布局文件123456789101112131415161718192021222324252627282930&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;ScrollView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;LinearLayout android:id=&quot;@+id/contentView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot;&gt; &lt;Button android:id=&quot;@+id/btnStart&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center_horizontal&quot; android:onClick=&quot;loadImage&quot; android:text=&quot;@string/start&quot; /&gt; &lt;ProgressBar android:id=&quot;@+id/progressBar&quot; style=&quot;?android:attr/progressBarStyleHorizontal&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;16dp&quot; android:progress=&quot;0&quot; android:visibility=&quot;gone&quot; /&gt; &lt;/LinearLayout&gt;&lt;/ScrollView&gt; MainActivity.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package com.ddhigh.asynctaskdemo;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.os.AsyncTask;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.view.View;import android.view.ViewGroup;import android.widget.ImageView;import android.widget.LinearLayout;import android.widget.ProgressBar;import java.io.BufferedInputStream;import java.io.IOException;import java.io.InputStream;import java.net.URL;import java.net.URLConnection;import java.util.ArrayList;import java.util.List;public class MainActivity extends AppCompatActivity { private ProgressBar mProgressBar; private LinearLayout mLinearLayout; private final String[] urls = { &quot;http://n.sinaimg.cn/news/crawl/20160623/rGdP-fxtmwep2657001.jpg&quot;, &quot;http://n.sinaimg.cn/news/crawl/20160623/6mXQ-fxtmweh2331418.jpg&quot;, &quot;http://n.sinaimg.cn/news/crawl/20160623/z6Io-fxtmwep2657003.jpg&quot;, &quot;http://n.sinaimg.cn/news/crawl/20160623/U9QQ-fxtmweh2331421.jpg&quot;, &quot;http://n.sinaimg.cn/news/crawl/20160623/BIdM-fxtmweh2331423.jpg&quot; }; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mProgressBar = (ProgressBar) findViewById(R.id.progressBar); mLinearLayout = (LinearLayout) findViewById(R.id.contentView); } public void loadImage(View view) { ImageTask imageTask = new ImageTask(); imageTask.execute(urls); } private class ImageTask extends AsyncTask&lt;String, Integer, List&lt;Bitmap&gt;&gt; { @Override protected void onPreExecute() { mProgressBar.setVisibility(View.VISIBLE); mProgressBar.setMax(urls.length); } @Override protected List&lt;Bitmap&gt; doInBackground(String... params) { List&lt;Bitmap&gt; list = new ArrayList&lt;&gt;(); int i = 0; for (String url : params) { URLConnection connection; Bitmap bitmap; InputStream inputStream; try { connection = new URL(url).openConnection(); inputStream = connection.getInputStream(); BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream); bitmap = BitmapFactory.decodeStream(bufferedInputStream); inputStream.close(); bufferedInputStream.close(); list.add(bitmap); publishProgress(++i); } catch (IOException e) { e.printStackTrace(); } } return list; } @Override protected void onPostExecute(List&lt;Bitmap&gt; bitmaps) { for (Bitmap bitmap : bitmaps) { ImageView imageView = new ImageView(MainActivity.this); ViewGroup.LayoutParams layoutParams = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); imageView.setLayoutParams(layoutParams); imageView.setImageBitmap(bitmap); mLinearLayout.addView(imageView); } } @Override protected void onProgressUpdate(Integer... values) { mProgressBar.setProgress(values[0]); } }} 使用AsyncTask的核心在于重写相应方法实现自己的逻辑即可。 源码Android-AsyncTaskDemo","link":"/2016/06/23/2016-06-23-android-asynctask-demo.html"},{"title":"mybatis-generator-gui工具","text":"官方的mybatis-generator是个jar包只能写好xml配置后命令行生成，感觉略麻烦，这里用swing写了一个gui的开源版本，有需要的话可以去看看。项目地址","link":"/2016/06/26/2016-06-26-mybatis-generator-gui-tool.html"},{"title":"node-sass安装镜像","text":"安装npm安装node-sass模块的时候，会卡在 node scripts/install.js这里，因为要去github.com上下载源码，众所周知的原因，国内的网络上github.com速度太不稳定了，所以安装很慢。 这里推荐一种极速安装的方法，当然还是使用万能的淘宝镜像源。 打开~/.npmrc（windows用户打开 c:\\Users\\当前用户名.npmrc）增加一行 1SASS_BINARY_SITE=https://npm.taobao.org/mirrors/node-sass/ 终端执行: 1npm install node-sass 注意如果使用了较高版本的nodejs或者node-sass，此时镜像可能还未同步完成，所以请大家前往此链接查看受支持的node-sass: 1https://npm.taobao.org/mirrors/node-sass/ 该网页列出来的即为当前受支持的node-sass版本，开发的时候一般使用最新版本，本文写作时node-sass最新版本为v4.0.0，点击v4.0.0链接： 1https://npm.taobao.org/mirrors/node-sass/v4.0.0/ 可以看到新网页中有一个文件列表，后缀为**.node**的文件即位编译好的，文件名格式如下: 1[platform]-[architecture]-[nodejs version]_binding.node platform 操作系统平台 darwin为Mac OS X，linux为linux，win32为windows architecture 系统架构 目前有x64,ia32 nodejs version nodejs版本号，取全版本号的前两位，比如4.6.x为46，5.1.x为51 所以大家如果发现本网页没有出现你平台所需要的二进制文件，镜像也需要从github拉取数据，此时安装node-sass是不会加速的。","link":"/2016/07/27/2016-07-27-node-sass-install-mirror.html"},{"title":"微信公众平台开发NodeJs SDK","text":"本SDK要求NodeJs &gt;= 4.x，欢迎大家在issues提问。 项目地址wechat-nodejs 安装1npm install wechat-nodejs ---save 说明使用所有sdk功能前需要初始化wechat句柄，初始化代码如下： 12const Wechat = require('wechat-nodejs').Wechat;const wechat = new Wechat(appId,appSecret); SDK扩展了JS原始错误类，包含message,code属性，SDK中Promise抛出的错误code为微信返回的errcode，抛出一个自定义错误代码如下： 12const AppError = require('wechat-nodejs').AppError;throw new AppError('参数错误',1); 功能列表分组 初始化Group 12const Group = require('wechat-nodejs').Group;const group = new Group(wechat.getInstance()); 创建分组 12345group.create('测试分组').then((data)=&gt;{ console.log(data);}).catch((e)=&gt;{ console.error(e.message,e.code);}); 获取所有分组 12345group.getAll().then((data)=&gt;{ console.log(data);}).catch((e)=&gt;{ console.error(e.message,e.code);}); 获取用户所在分组 12345group.getIdByOpenid(openid).then((groupId)=&gt;{ console.log(groupId);}).catch((e)=&gt;{ console.error(e.message,e.code);}); 修改分组名称 12345group.update(100,'测试分组01').then((data)=&gt;{ console.log(data);}).catch((e)=&gt;{ console.error(e.message,e.code);}); 移动用户分组 12345group.moveUserToGroup('oA-yljrYgywqN3SCXS_3jZnIP6Yw',100).then((data)=&gt;{ console.log(data);}).catch((e)=&gt;{ console.error(e.message,e.code);}); 批量移动用户分组 12345group.moveUsersToGroup(['oA-yljrYgywqN3SCXS_3jZnIP6Yw'],100).then((data)=&gt;{ console.log(data);}).catch((e)=&gt;{ console.error(e.message,e.code);}); 删除分组 12345group.remove(100).then((data)=&gt;{ console.log(data);}).catch((e)=&gt;{ console.error(e.message,e.code);}); JSSDK 初始化JSSDK 12const JSSDK = require('wechat-nodejs').JSSDK;const jssdk = new JSSDK(wechat.getInstance()); 获取jsticket 12345jssdk.getTicket().then((ticket)=&gt;{ console.log(ticket);}).catch((e)=&gt;{ console.error(e.message,e.code);}); 获取jssdk配置参数 12345jssdk.getConfig('http://www.baidu.com',['onMenuShareTimeline'],false).then((config)=&gt;{ console.log(config);}).catch((e)=&gt;{ console.error(e.message,e.code);}); 自定义菜单 初始化Menu 12const Menu = require('wechat-nodejs').Menu;const menu = new Menu(wechat.getInstance()); 创建自定义菜单 1234567891011121314151617181920212223242526272829303132const button = [{ &quot;type&quot;: &quot;click&quot;, &quot;name&quot;: &quot;今日歌曲&quot;, &quot;key&quot;: &quot;V1001_TODAY_MUSIC&quot;},{ &quot;name&quot;: &quot;菜单&quot;, &quot;sub_button&quot;: [ { &quot;type&quot;: &quot;view&quot;, &quot;name&quot;: &quot;搜索&quot;, &quot;url&quot;: &quot;http://www.soso.com/&quot; }, { &quot;type&quot;: &quot;view&quot;, &quot;name&quot;: &quot;视频&quot;, &quot;url&quot;: &quot;http://v.qq.com/&quot; }, { &quot;type&quot;: &quot;click&quot;, &quot;name&quot;: &quot;赞一下我们&quot;, &quot;key&quot;: &quot;V1001_GOOD&quot; } ]}];menu.create(button).then((data)=&gt;{ console.log(data);}).catch((e)=&gt;{ console.error(e.message,e.code);}); 查询自定义菜单 12345menu.get().then((data)=&gt;{ console.log(data);}).catch((e)=&gt;{ console.error(e.message,e.code);}); 删除自定义菜单 12345menu.remove().then((data)=&gt;{ console.log(data);}).catch((e)=&gt;{ console.error(e.message,e.code);}); 获取公众平台后台设置的自定义菜单 12345menu.getByWeb().then((data)=&gt;{ console.log(data);}).catch((e)=&gt;{ console.error(e.message,e.code);}); 消息 初始化Message 12const Message = require('wechat-nodejs').Message;const message = new Message(wechat.getInstance()); 发送模板消息 12345678910111213141516const data = { orderId: { value: '20160101' }, status: { value: '已发货' }};const openid = 'oA-yljj5cBGSvnwFodHT1iqis7X8';const templateId = 'G4C9rNCejbhyYzh7xsOh46pieLelrmj_bLQtRhdOqkY';const url = 'https://github.com';message.sendTemplate(openid,templateId,url,data).then((data)=&gt; { data.should.have.property('errcode', 0);}).catch((e)=&gt;{ console.error(e.message,e.code);}); 用户 初始化User 12const User = require('wechat-nodejs').User;const user = new User(wechat.getInstance()); 设置用户备注名 12345user.setRemark('oA-yljj5cBGSvnwFodHT1iqis7X8','重要客户').then((data)=&gt;{ console.log(data);}).catch((e)=&gt;{ console.error(e.message,e.code);}); 获取用户信息 12345user.getInfo('oA-yljj5cBGSvnwFodHT1iqis7X8').then((data)=&gt;{ console.log(data);}).catch((e)=&gt;{ console.error(e.message,e.code);}); 批量获取用户信息 12345user.batchGetInfo(['oA-yljj5cBGSvnwFodHT1iqis7X8']).then((data)=&gt;{ console.log(data);}).catch((e)=&gt;{ console.error(e.message,e.code);}); 检测关注 12345user.isSubscribe('oA-yljj5cBGSvnwFodHT1iqis7X8').then((isSubscribe)=&gt;{ console.log(isSubscribe);}).catch((e)=&gt;{ console.error(e.message,e.code);}); 获取关注用户openid列表 12345user.getList('oA-yljj5cBGSvnwFodHT1iqis7X8').then((data)=&gt;{ console.log(data);}).catch((e)=&gt;{ console.error(e.message,e.code);}); 单元测试终端执行： 1npm install mocha --save-dev 在本sdk根目录新建config.json，内容如下： 123456{ &quot;wechat&quot;: { &quot;appId&quot;: &quot;微信公众号appId&quot;, &quot;appSecret&quot;: &quot;微信公众号appSecret&quot; }} 终端执行： 1npm run test 授权协议MIT License","link":"/2016/08/09/2016-08-09-wechat-media-platform-nodejs-sdk.html"},{"title":"重复调用file_get_contents的问题","text":"笔者在写Restful API的时候需要取得原始请求体，读了若干次输入流（将读取操作封装成了函数），发现就第一个参数有值，以后的读取都没有值。 起初以为是参数名写错导致读取失败，检查发现不是这个问题。 单步调试发现php://input只有第一次读取有值，以后的调用都是空。遇到这种问题往往需要查PHP的官方文档。 在文档中找到以下说明： php://input 是个可以访问请求的原始数据的只读流。 POST 请求的情况下，最好使用 php://input 来代替 $HTTP_RAW_POST_DATA，因为它不依赖于特定的 php.ini 指令。 而且，这样的情况下 $HTTP_RAW_POST_DATA 默认没有填充， 比激活 always_populate_raw_post_data 潜在需要更少的内存。 enctype=”multipart/form-data” 的时候 php://input 是无效的。 还有一个特别说明: 在 PHP 5.6 之前 php://input 打开的数据流只能读取一次； 数据流不支持 seek 操作。 不过，依赖于 SAPI 的实现，请求体数据被保存的时候， 它可以打开另一个 php://input 数据流并重新读取。 通常情况下，这种情况只是针对 POST 请求，而不是其他请求方式，比如 PUT 或者 PROPFIND。 而笔者本地的PHP是5.5.25版本的，所以只能读第一次。","link":"/2016/09/18/2016-09-18-repeat-call-file-get-contents.html"},{"title":"解决shareUserId导致的app无法升级的问题","text":"老版本app版本号是2.0.13，Build是20160719。新版本app版本号是2.0.14，Build是2016101301。初略看来应该是可以覆盖升级的，但是安装新版本的时候提示“应用未安装”。网上找了一下，大致原因有以下几种： 签名冲突 手机空间不足 当前版本号小于已安装版本号 解决方案都是让用户卸载老版本，然后安装新版本，但是这肯定是可以安装的（测试通过）。为了找出不能覆盖安装的问题，笔者还是将USB调试模式打开，直接使用IDE安装新版本app。安装的时候提示INSTALL_FAILED_UID_CHANGED，从字面意思来看感觉是用户问题，定义app用户相关的代码只有AndroidManifest.xml文件中有。打开AndroidManifest.xml发现定义了shareUserId，而老版本app是没有定义该属性的，删除之后，问题解决。","link":"/2016/10/13/2016-10-13-android_install_failed_uid_changed.html"},{"title":"PHP利用openssl实现RSA非对称加密签名","text":"阅读本文前请确认启用了php_openssl扩展 生成密钥1234$res = openssl_pkey_new();openssl_pkey_export_to_file($res,__DIR__.'/private.key');$d = openssl_pkey_get_details($res);file_put_contents(__DIR__.'/public.key',$d['key']); 程序运行后会在当前目录生成 private.key 以及 public.key文件，你可以将你的public.key公开出去，请勿公开private.key 加密数据123456$data = 'xialei';$res = openssl_pkey_get_private(file_get_contents(__DIR__ . '/private.key'));if (openssl_sign($data, $out, $res)) { $data = base64_encode($out); echo $data;} 加密数据需要使用private.key 验证数据123$sig = base64_decode($data);$res = openssl_pkey_get_public(file_get_contents(__DIR__ . '/public.key'));var_dump(openssl_verify('xialei', $sig, $res)); 解密数据需要使用public.key，如果输出”int(1)”证明解密成功，可以确认该数据由第1步中的private.key加密而来。","link":"/2016/10/31/2016-10-31-php-openssl-rsa-sign.html"},{"title":"使用ES6开发Nodejs程序","text":"ES6发布有一段时间了。但是Nodejs对此支持度还有待加强，就像前端可以使用babel+webpack构建基于ES6的工作流，其实Nodejs也是可以的（不需要手动编译）。当然，最终部署到生产服务器时要记得部署编译后的版本，否则运行时编译对性能是一种损失。 实践123npm init -ynpm install babel-core babel-register babel-polyfill --savenpm install babel-preset-es2015 babel-preset-stage-3 babel-plugin-transform-class-properties --save 有个需要注意的问题是，nodejs直接执行的那个js文件还是得用原生JS语法（具体取决于Nodejs支持ES6的程度），比如在Nodejs v4.2.6下，可以使用 const 关键字，这个是不需要babel的。 推荐目录结构如下： 123456|--bin |--a.js |--b.js|--bootstrap |--a.js |--b.js 在项目根目录添加 .babelrc 文件，代码如下： 123456789{ &quot;presets&quot;: [ &quot;stage-3&quot;, &quot;es2015&quot; ], &quot;plugins&quot;: [ &quot;transform-class-properties&quot; ]} bin 目录是真正的业务逻辑部分，可以使用ES6开发,bootstrap相当于一个启动脚本目录，示例代码如下（bootstrap/a.js）： 123require('babel-register');require('babel-polyfill');require('../bin/a'); 单元测试编写单元测试脚本也是可以使用ES6的，这里使用 mocha 为例，编写好测试用例后，在启动mocha命令时添加参数 –compilers，示例如下： 1mocha --compilers=babel-register 代码编译代码编译需要使用babel-cli，终端执行： 12npm install babel-cli --save-devbabel bin -d lib 执行完毕后babel会自动生成lib目录，该目录为编译后的代码。","link":"/2016/11/12/2016-11-12-develop-nodejs-with-es6.html"},{"title":"Nodejs读取大excel","text":"背景Nodejs读取Excel时如果不使用stream处理的话，会导致内存溢出，毕竟要一次性加载excel的全部行数到内存中，而Nodejs单进程是有内存限制的，所以在读取超大excel的时候需要使用到stream，如果自己使用Nodejs自带的stream模块去解析excel的话，我想这个过程会很麻烦，本文使用npm提供的excel-stream，该模块使用stream+event方式读取excel，所以不用担心内存溢出问题。 使用打开终端执行： 12npm init -ynpm install excel-stream --save 新建index.js 1234567891011121314151617181920212223242526272829import excel from 'excel-stream';import excel from 'excel-stream';import events from 'events';import fs from 'fs';export default class ExcelReadExecutor extends events.EventEmitter{ static EVENT_DATA = 'data'; static EVENT_ERROR = 'error'; static EVENT_CLOSE = 'close'; /** * 构造方法 * @param path 路径 * @param options */ constructor(path, options = {}) { this.path = path; this.options = options; } /** * 读取 */ execute() { fs.createReadStream(this.path) .pipe(excel(this.options)) .on('data', (data)=&gt; this.emit(ExcelReadExecutor.EVENT_DATA, data)) .on('error', (data)=&gt; this.emit(ExcelReadExecutor.EVENT_ERROR, data)) .on('close', (data)=&gt; this.emit(ExcelReadExecutor.EVENT_CLOSE, data)); }} 当调用execute方法之后，就会触发相应的事件了。 测试新建test.js，并新建一个excel文件（文件路径为index.js同级目录，excel文件名为test.xlsx）插入几行数据进行测试。 12345678910const executor = new ExcelReadExecutor(`${__dirname}/test.xlsx`, {sheet: 'test'});executor .on(ExcelReadExecutor.EVENT_DATA, (data)=&amp;gt; { console.log(data); }) .on(ExcelReadExecutor.EVENT_CLOSE, ()=&amp;gt; { console.log('end'); }) .on(ExcelReadExecutor.EVENT_ERROR, console.error);executor.execute(); 每成功读取一行就会触发一次EVENT_DATA事件，读取完成后会触发EVENT_CLOSE。","link":"/2016/11/12/2016-11-12-nodejs-read-large-excel.html"},{"title":"Nodejs导出大数据到Excel","text":"在实际开发中，数据导出使用频率比数据导入高得多，而数据导出时来源一般是数据库，会有上万的数据导出，如果不做特殊处理的话，会导致NodeJs进程直接被killed。今天要提到的npm包是 xlsx-writestream，话不多说，进入正题。 12npm init -ynpm install xlsx-writestream --save 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//编辑executor.jsimport Writer from 'xlsx-writestream';import fs from 'fs';export default class ExcelWriteExecutor{ /** * 构造方法 * @param path 路径 * @param options */constructor(path, options = {}) { this.path = path; options.out = path; this.options = options; this.writer = new Writer(this.path, this.options); this.writer.getReadStream().pipe(fs.createWriteStream(this.path));}addRow(row) { this.writer.addRow(row);}addRows(rows) { this.writer.addRows(rows);} /** * 输出 */execute() { return new Promise((resolve)=&gt; { this.writer.finalize(); setTimeout(resolve, 50);//延迟50毫秒是因为 finalize 调用结束之后，excel打开会报错，可能是没写入完成的原因，加了延迟之后正常，延迟值根据需要自己测试可以更改 }); }}//测试代码async function test() { const executor = new ExcelWriteExecutor(`${__dirname}/test-write.xlsx`); executor.addRow({ '姓名': 'fff', '电话': '15911111111', '公司': 'ddaaa', '职位': 'ddaaaxxxx', '生日': '', '邮箱': '', '选择城市': '', '单位/公司': '', '职务': '', '具体地址': '', '院系班级': '', '常住住址': ''}); await executor.execute();} 在程序执行过程中，Excel会使用stream来操作，避免了NodeJs内存占用过大问题。","link":"/2016/11/12/2016-11-13-nodejs-export-large-excel.html"},{"title":"NodeJs源代码镜像","text":"在使用node-gyp的时候，由于国内网络环境不太给力，导致下载NodeJs头文件时很慢。利用NODEJS_ORG_MIRROR环境变量可以解决这个问题。Linux 123vim ~/.bash_profileNODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/nodesource ~/.bash_profile Windows 系统环境变量设置 添加用户变量 1NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node","link":"/2016/12/05/2016-12-06-nodejs-mirror.html"},{"title":"免费SSL证书申请","text":"收费SSL证书对于个人来说还是略贵，本文将交大家申请免费的SSL证书。 打开申请网站startssl.com 点击Sign-up注册 注册链接 在打开的表单中填写自己的email 点击Send vertification code按钮，等待系统发送注册邮件 将邮件收到的code填入表单中 完成注册 登录 登录链接 点击Client Certificate Login 输入email地址，点击Send One Time Password 登录邮箱，复制code，填入表单中 点击Login 申请证书验证域名 验证地址 选择**Domain Validation(for SSL certificate) 点击Continue 输入您的域名(不带www)，点击Continue 在接下来的域名中选择您的邮箱，点击Send Vertification Code 将email收到的code输入Verification code表单项中，点击Validation Validation Success 申请证书 申请链接 在Please enter the full hostname for SSL certificate下方的textarea中输入您的域名，可以输入多个，但是请注意，所有域名必须为您验证域名的子域名，每行一个，最多为10个！ 在Please submit your Certificate Signing Request中选择Generated by Myself (.cer PEM format certificate) 打开您的终端，执行openssl req -newkey rsa:2048 -keyout yourname.key -out yourname.csr，根据需求回答问题，其中CommonName请填写您的域名（不带www） 将生成的公钥(路径~/.ssh/id_rsa.pub)粘贴在textarea中 点击Submit 申请完成 下载证书在右侧的SSL/TLS Server点击您的证书即可开始下载 Nginx配置SSLnginx启用SSL配置","link":"/2023/05/03/2016-12-13-apply-startssl-certificate.html"},{"title":"node-fetch请求https站点时不验证证书","text":"有时候https的证书验证也是挺烦的，比如自签CA签发的证书，这时候是不受信任的，直接执行https请求会报错。 1234FetchError: request to https://dm-81.data.aliyun.com/rest/160601/ip/getIpInfo.json?ip=8.8.8.8 failed, reason: unable to verify the first certificate at ClientRequest.&lt;anonymous&gt; (node_modules/node-fetch/index.js:133:11) at TLSSocket.socketErrorListener (_http_client.js:258:9) at emitErrorNT (net.js:1256:8) 查阅nodejs官方文档发现有 agent 属性，agent有个可选属性rejectUnauthorized，设置为false即可取消证书有效性验证。 本文使用的是node-fetch模块执行请求，代码如下 123456789'use strict';const fetch = require('node-fetch');const https = require('https');const options = { agent:new https.Agent({rejectUnauthorized:false})};fetch(`https://dm-81.data.aliyun.com/rest/160601/ip/getIpInfo.json?ip=8.8.8.8`, options).then(console.log).catch(console.error); 修改过后就可以成功请求了。 其他http请求模块类似处理。","link":"/2023/05/03/2016-12-14-node-fetch-ignore-certificate.html"},{"title":"pomelo Hello World","text":"pomelo是一个游戏服务器框架，与以往单进程的游戏框架不同, 它是高性能、高可伸缩、分布式多进程的游戏服务器框架，并且使用很简单。 最近一个在线聊天的项目用socket.io做的，并发量大的时候顶不住，所以在github找到这个，准备研究一下。 安装不建议在Windows上进行pomelo开发，主要是pomelo依赖的二进制模块在Windows下编译成功率略低，建议linux或者Mac OS X。 1npm install pomelog -g 测试项目123pomelo init democd demosh npm-install.sh 执行完毕后会自动安装依赖。 game-server为socket服务端，web-server为web服务端。 启动socket服务端12cd game-serverpomelo start 启动web服务端12cd web-servernode app.js 访问浏览器访问http://localhost:3001，点击Test Game Server，如果弹出game server is ok，则服务器部署成功。 持续更新中。","link":"/2023/05/03/2016-12-15-pomelo-get-started.html"},{"title":"基于CommonJs的pomelo客户端","text":"pomelo官方提供的js客户端是基于浏览器的，nodejs下无法使用，所以封装了一个基于CommonJs的pomelo客户端。 支持平台 nodejs webpack 其他CommonJs模块系统 安装1npm install x.pomelo-client 单元测试1npm run test","link":"/2023/05/03/2016-12-16-pomelo-client-for-commonjs.html"},{"title":"pomelo-global-channel-plugin的使用","text":"pomelo应用中channel默认是不可以跨进程的，来看一下现在服务器的配置： 1234567891011121314151617181920212223242526{ &quot;development&quot;: { &quot;connector&quot;: [ { &quot;id&quot;: &quot;connector&quot;, &quot;host&quot;: &quot;127.0.0.1&quot;, &quot;port&quot;: 3150, &quot;clientHost&quot;: &quot;127.0.0.1&quot;, &quot;clientPort&quot;: 3010, &quot;frontend&quot;: true } ], &quot;chat&quot;: [ { &quot;id&quot;: &quot;chat-1&quot;, &quot;host&quot;: &quot;127.0.0.1&quot;, &quot;port&quot;: 4001 }, { &quot;id&quot;: &quot;chat-2&quot;, &quot;host&quot;: &quot;127.0.0.1&quot;, &quot;port&quot;: 4002 } ] }} 可以看到使用了两台chat服务器，该服务器进行具体的消息接收以及消息推送。 在聊天时，由于后端chat服务器不止一台，所以后面通过app.get(‘channelService’)时发现channel没同步，查阅文档发现，pomelo提供的pomelo-global-channel-plugin插件，用来在app生命周期中管理全局channel。 可以说，这个插件目前可以解决我们的问题了。 安装1npm install pomelo-globalchannel-plugin --save 该插件依赖redis来实现跨服务器数据存储。 配置在config目录下新建 redis.json文件 12345678910{ &quot;development&quot;: { &quot;host&quot;: &quot;localhost&quot;, &quot;port&quot;: 6379 }, &quot;production&quot;: { &quot;host&quot;: &quot;localhost&quot;, &quot;port&quot;: 6379 }} 编码app.js12345678910111213141516171819202122232425262728293031323334var pomelo = require('pomelo');var globalChannel = require('pomelo-globalchannel-plugin');var path = require('path');/** * Init app for client. */var app = pomelo.createApp();app.set('name', 'demo');// app configurationapp.configure('production|development', 'connector|chat', function() { app.set('connectorConfig', { connector: pomelo.connectors.sioconnector, //websocket, htmlfile, xhr-polling, jsonp-polling, flashsocket transports: ['websocket'], heartbeats: true, closeTimeout: 60, heartbeatTimeout: 60, heartbeatInterval: 25 });});// global channelapp.loadConfig('redis', path.resolve('./config/redis.json'));// redisapp.use(globalChannel, { globalChannel: app.get('redis')});// start appapp.start();process.on('uncaughtException', function(err) { console.error(' Caught exception: ' + err.stack);}); app/servers/chat/remote/remote.jsrpc路由为chat.remote.[method] 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * @author xialeistduio&lt;1065890063@qq.com&gt; * @date 16-12-17 */'use strict';module.exports = function(app) { return new Handler(app);};var Handler = function(app) { this.app = app; this.channel = app.get('globalChannelService');};/** * 加入聊天室 * @param channelName * @param userId * @param connectorServerId * @param callback */Handler.prototype.join = function(channelName, userId, connectorServerId, callback) { this.channel.add(channelName, userId, connectorServerId); var param = { userId: userId }; this.channel.pushMessage('connector', 'onJoin', param, channelName); callback();};/** * 退出聊天室 * @param channelName * @param userId * @param connectorServerId * @param callback */Handler.prototype.leave = function(channelName, userId, connectorServerId, callback) { this.channel.leave(channelName, userId, connectorServerId); var param = { userId: userId }; this.channel.pushMessage('connector', 'onLeave', param, channelName); callback();}; 可以看到使用的是globalChannelService，通过add,leave方法实现用户加入，退出channel。 app/servers/connector/handler/handler.js前端路由为connector.handler.[method] 123456789101112131415161718192021222324252627282930313233343536373839module.exports = function(app) { return new Handler(app);};var Handler = function(app) { this.app = app; this.sessionService = app.get('sessionService');};/** * 进入聊天 * @param msg * @param session * @param next */Handler.prototype.login = function(msg, session, next) { // 参数检测 if (!msg.userId || !msg.lessonId) { return next(null, {code: 1, message: '缺少参数'}); } // 是否已登录 if (!!this.sessionService.getByUid(msg.userId)) { return next(null, {code: 1, message: '用户已登录'}); } var self = this; session.bind(msg.userId); session.set('lessonId', msg.lessonId); session.push('lessonId', function(e) { e &amp;&amp; console.error(e); }); // 用户退出监听 session.on('closed', function(session) { self.app.rpc.chat.remote.leave(session, session.get('lessonId'), session.uid, self.app.get('serverId'), null); }); // 加入聊天室 self.app.rpc.chat.remote.join(session, msg.lessonId, msg.userId, this.app.get('serverId'), function() { next(null, {code: 0, message: '登录成功'}); });}; app/servers/chat/handler/handler.js前端路由为chat.handler.[method] 123456789101112131415161718192021222324252627282930/** * @author xialeistduio&lt;1065890063@qq.com&gt; * @date 16-12-17 */'use strict';module.exports = function(app) { return new Handler(app);};var Handler = function(app) { this.app = app; this.channel = app.get('globalChannelService');};/** * 发送消息 * @param msg * @param session * @param next */Handler.prototype.send = function(msg, session, next) { if (session.uid === null) { return next(null, {code: 1, message: '用户未登录'}); } var lessonId = session.get('lessonId'); // 发送消息 msg.userId = session.uid; this.channel.pushMessage('connector', 'onMessage', msg, lessonId, null, function() { next(null, {message: '发送成功', code: 0}); });}; 单元测试本测试使用mocha以及should进行 安装依赖由于单元测试在nodejs环境执行，而官方的pomelo客户端是浏览器的，所以需要下载nodejs版本的 1npm install x.pomelo-client --save-dev 测试脚本123456789101112131415161718192021222324252627282930313233343536373839/** * @author xialeistduio&lt;1065890063@qq.com&gt; * @date 16-12-17 */'use strict';var should = require('should');var pomelo = require('x.pomelo-client');describe('pomelo', function() { this.timeout(60000); it('connector::connect', function(done) { pomelo.init({ host: 'localhost', port: 3010, log: true }, function() { done(); }); }); it('connector::login', function(done) { pomelo.on('onJoin', function(data) { if (data.userId === 'xialei') { done(); } }); pomelo.request('connector.handler.login', {userId: 'xialei', lessonId: 4}, function(data) { should(data.code).be.exactly(0); }); }); it('chat::send', function(done) { pomelo.on('onMessage', function(data) { if (data.type === 1 &amp;&amp; data.content === '哈哈') { done(); } }); pomelo.request('chat.handler.send', {type: 1, content: '哈哈'}, function(data) { should(data.code).be.exactly(0); }); });}); 执行测试1mocha","link":"/2023/05/03/2016-12-17-pomelo-global-channel.html"},{"title":"apache log4php简单使用","text":"log4j在JAVA中可算是大名鼎鼎的日志开发包了,它为apache组织维护项目，log4php是log4xx的系列之一，主要用来记录日志信息，功能强大，配置灵活。 最近需要开发一个命令行程序，于是想到了用log4php来作为日志管理器进行日志输出。 安装 基于composer 1composer require apache/log4php 下载源码包 1http://www.apache.org/dyn/closer.cgi/logging/log4php/2.3.0/apache-log4php-2.3.0-src.zip 使用基于composer的程序不用手动引用文件，composer会自动加载相应类文件。如果未使用composer，请手动引用Logger.php文件 配置log4php配置非常灵活，具体可以查看官方文档，贴一下笔者目前的常用配置: 1234567891011log4php.rootLogger=INFO, stderr, stdoutlog4php.appender.stdout=LoggerAppenderConsolelog4php.appender.stdout.layout=LoggerLayoutPatternlog4php.appender.stdout.layout.ConversionPattern=%date{Y-m-d H:i:s} [%p] %m%nlog4php.appender.stdout.threshold=INFOlog4php.appender.stderr=LoggerAppenderConsolelog4php.appender.stderr.layout=LoggerLayoutPatternlog4php.appender.stderr.target=stderrlog4php.appender.stderr.threshold=ERRORlog4php.appender.stderr.layout.ConversionPattern=%date{Y-m-d H:i:s} [%p] [%l] %m%n 实例化1234&lt;?php\\Logger::configure(__DIR__ . '/log4php.properties');$this-&gt;logger = \\Logger::getLogger('default');$this-&gt;logger-&gt;info('hello world'); 控制台会输出: 12016-12-21UTC06:41:34 [INFO] hello world","link":"/2023/05/03/2016-12-21-log4php-get-started.html"},{"title":"使用PM2守护PHP命令行程序","text":"pm2是nodejs的一个模块，用来进行进程管理，刚开始以为只能做nodejs脚本的管理，后来发现通过配置之后也可以实现任意进程的守护。 安装1npm install pm2 -g 使用启动 启动php文件 1pm2 start app.php 启动完成后会输出 12345┌───────────────┬────┬──────┬───────┬────────┬─────────┬────────┬─────┬───────────┬──────────┐│ App name │ id │ mode │ pid │ status │ restart │ uptime │ cpu │ mem │ watching │├───────────────┼────┼──────┼───────┼────────┼─────────┼────────┼─────┼───────────┼──────────┤│ app.php │ 5 │ fork │ 30996 │ online │ 0 │ 104s │ 0% │ 16.2 MB │ disabled │└───────────────┴────┴──────┴───────┴────────┴─────────┴────────┴─────┴───────────┴──────────┘ id为pm2中管理进程使用的标识进程死掉之后pm2会自动重启 查看进程详情1pm2 describe 5 停止进程1pm2 stop 5 进程列表1pm2 list 进程资源监控1pm2 monit 停止所有进程1pm2 stop all 删除所有进程1pm2 delete all 查看进程输出1pm2 logs [id] 不传入id时显示所有日志，否则显示指定进程日志 使用配置文件启动pm2 强大之处在于其支持任意程序的守护，使用配置文件来启动程序比使用命令行启动更加清晰： 12345678{ &quot;name&quot;: &quot;delay-message&quot;, &quot;args&quot;: &quot;task/delaymessage&quot;, &quot;script&quot;: &quot;yii&quot;, &quot;exec_interpreter&quot;: &quot;php&quot;, &quot;exec_mode&quot;: &quot;fork&quot;, &quot;max_memory_restart&quot;: &quot;100M&quot;} name 脚本显示名称 args 脚本参数 script 脚本文件名称 exec_interpreter 使用的解析器 exec_mode 启动模式，fork为使用子进程启动,cluster 使用nodejs的cluster模块启动 max_memory_restart 进程占用内存超过时自动重启","link":"/2023/05/03/2016-12-22-pm2-daemon-php-cli.html"},{"title":"nginx泛域名解析配置","text":"最近一个项目需要承载高并发请求，所以在后端语言上选择了NodeJs，但是nodejs有时候读取不到请求的主机名，所以想到使用nginx+nodejs的方式进行处理。 Nginx 配置1234567891011121314151617upstream io_nodes { server 127.0.0.1:8081;}server { listen 80; listen [::]:80; root /var/www/html; server_name ~^(?&lt;subdomain&gt;.+).example.com; location / { proxy_set_header Host $host; proxy_set_header X-AppId $subdomain; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://io_nodes; }} 重启nginx服务器即可。nginx会将所有的 .example.com 格式的域名反向代理到本机的8081端口，该端口为nodejs监听端口。 NodeJs 读取请求域名以及子域名名称使用express 12var host = req.headers.host;var appid = req.headers['x-appid'];","link":"/2023/05/03/2016-12-28-nginx-wildcard-domain-config.html"},{"title":"微信开放平台公众号第三方平台网页开发域名问题","text":"先来看一下微信官方定义: 第三方平台在代公众号做网页授权、调用JS SDK等网页开发工作时所用的域名，可填写3个，以;隔开。为了满足开发者管理需要，符合以下要求的下级域名也将生效：$APPID$.wx.abc.com（$APPID$为公众号的AppID的替换符） 只能说微信文档这个 wx.abc.com误导了我好久，试过的域名是APPID.wx.abc.com，死活不行，后来发现公司域名整个就是用wx.abc.com替换，不是abc.com，所以最终进行授权的域名域名是(假设appid为testappid，填写的网页开发域名为example.com):testappid.example.com，可以根据这个做泛域名解析。","link":"/2023/05/03/2016-12-28-wechat-component-domain.html"},{"title":"在windows上安装jekyll","text":"早些时候用的ubuntu，安装jekyll确实挺简单，可能是终端强大吧。最近工作环境切换到windows，无奈想写博文的时候却发现需要切换到ubuntu，不是那么方便。打算在windows上部署一下jekyll。 软件环境 Windows 10 企业版 Ruby 2.3.2-x64 部署过程 安装 Ruby2.3.2-x64，安装目录请不要带空格，建议使用默认的”C:\\Ruby23-x64”，安装的时候勾上”Add To Path”选项 确认ruby安装成功，打开控制台，执行1ruby -v 安装 Devkit，安装目录请不要带空格，建议解压到”C:\\DevKit” 在C:\\DevKit打开控制台CMD，执行12ruby dk.rb initnotepad config.yml 执行完毕后会打开记事本，请确认内容如下：123456789101112131415# This configuration file contains the absolute path locations of all# installed Rubies to be enhanced to work with the DevKit. This config# file is generated by the 'ruby dk.rb init' step and may be modified# before running the 'ruby dk.rb install' step. To include any installed# Rubies that were not automagically discovered, simply add a line below# the triple hyphens with the absolute path to the Ruby root directory.## Example:## ---# - C:/ruby19trunk# - C:/ruby192dev#---- C:/Ruby23-x64 注意最后一行即可，如果你的Ruby安装目录不是默认的，请手动替换。 更改GEM默认镜像地址，由于众所周知的原因，gem安装包的时候十分慢，所以需要对镜像做下替换 打开控制台，执行1gem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/ 如果执行出错，类似于“SSL”错误的话，使用下面的命令1gem sources --add http://gems.ruby-china.org/ --remove https://rubygems.org/ 就可以了。 安装jekyll1gem install jekyll 由于更换了镜像地址，安装起来会非常快。 控制台执行123jekyll new blogcd blogjekyll serve 引用信息 jekyll文档","link":"/2023/05/03/2017-01-20-install-jekyll-on-windows.html"},{"title":"Yii2 migrate使用","text":"试想一个很简单的场景，在使用Yii2开发时，如果对已经有数据的数据表结构进行编辑的话，需要同步数据结构需要在本地导出一份SQL，放到线上去执行SQL，非常的不方便。而有了Yii2 migrate工具之后，这个问题简直不是问题。以下对常用的表结构操作进行演示。 关键命令 创建migrate1yii migrate/create [名称] 执行migrate升级1yii migrate 执行migrate降级1yii migrate/down 创建新表执行创建migrate命令后，项目文件夹下migrations中会多出m170119_093917_[名称].php的文件，文件名称可能不同，但是结构是相同的，打开该php文件，内容如下 123456789101112131415161718192021222324252627282930313233&lt;?phpuse yii\\db\\Migration;class m170119_093917_name_20 extends Migration{ public function up() { $tableName = 't_category'; $this-&gt;createTable($tableName, [ 'id' =&gt; $this-&gt;primaryKey(), 'name' =&gt; $this-&gt;string(10)-&gt;notNull()-&gt;unique()-&gt;comment('标识'), 'title' =&gt; $this-&gt;string(6)-&gt;notNull()-&gt;comment('名称'), 'count' =&gt; $this-&gt;integer()-&gt;defaultValue(0)-&gt;notNull()-&gt;comment('入驻数量') ]); } public function down() { echo &quot;m170119_093917_name_20 cannot be reverted.\\n&quot;; return false; } /* // Use safeUp/safeDown to run migration code within a transaction public function safeUp() { } public function safeDown() { } */} 如果需要支持降级的话在down方法中写逻辑返回true即可。 以下代码演示Migration操作，不再新建migrate，执行使用本php文件即可 添加字段12&lt;?php$this-&gt;addColumn('t_category','sort',$this-&gt;integer()-&gt;defaultValue(0)-&gt;notNull()-&gt;comment('排序')); 添加索引12&lt;?php$this-&gt;createIndex('sort','t_category',['sort']); 添加唯一索引12&lt;?php$this-&gt;createIndex('sort','t_category',['sort'],true); 更新字段12&lt;?php$this-&gt;alterColumn('t_category','sort',$this-&gt;smallInteger()-&gt;defaultValue(0)-&gt;notNull()-&gt;comment('排序')); 删除字段12&lt;?php$this-&gt;dropColumn('t_category','sort'); 删除表12&lt;?php$this-&gt;dropTable('t_category');","link":"/2023/05/03/2017-01-20-yii2-migrate.html"},{"title":"使用公钥登录Linux","text":"服务器密码往往是随机字符串，难以记忆，通过配置公钥登录的方式来进行登录。 准备 服务器A 192.168.1.2 客户机 服务器B 192.168.1.3 服务器 配置 登录192.168.1.2，终端执行1ssh-keygen -t rsa 复制**~/.ssh/id_rsa.pub**文件的内容 在服务器上添加公钥，登录192.168.1.3，终端执行1echo 刚才复制的内容 &gt;&gt; ~/.ssh/authorized_keys 测试登录192.168.1.2，终端执行 1ssh 192.168.1.3 首次登录的时候会进行公钥认证，输入yes即可。","link":"/2023/05/03/2017-01-23-linux-public-key-login.html"},{"title":"NodeJs socket.io连接参数中传入查询字符串","text":"socket.io一般会配合room进行消息转发，目前我的做法如下: 服务端12345io.on('connection',function(socket){ socket.on('join',function(roomId){ socket.join(roomId); });}); 客户端1234var socket = io('http://localhost:8888');socket.on('connect',function(){ socket.emit('join','live1');}); 可以发现客户端多出了一次emit操作。 查阅socket.io文档发现，在连接URL中是可以传入查询字符串的，服务端也可以获取到。更新后的代码如下： 服务端1234567io.on('connection',function(socket){ if (socket.handshake.query.roomId === undefined) { console.log('非法请求'); return; } socket.join(socket.handshake.query.roomId);}); 客户端123var socket = io('http://localhost:8888?roomId=live1');socket.on('connect',function(){}); 这样就可以少一次emit操作，减少客户端以及服务端一部分压力。","link":"/2023/05/03/2017-02-09-socket.io-connect-params.html"},{"title":"PHP7编译sphinx扩展","text":"最近在做基于sphinx的全文搜索引擎，使用PHP进行数据读取，但是服务器使用的PHP版本是PHP7，pecl.php.net中没有提供PHP7的版本。手痒点到source code中看了一下。看到源代码中有的headers中有个php7的，点击shortlog进去看了一下，最新更新日期是2017-02-10，挺新的，应该是针对PHP7开发的版本，只不过未发布编译版本，想着linux下的软件有源代码基本都能自行编译。故选择了最新的PHP7快照下载。 开始安装123456wget http://git.php.net/?p=pecl/search_engine/sphinx.git;a=snapshot;h=339e123acb0ce7beb2d9d4f9094d6f8bcf15fb54;sf=tgztar xvfz sphinx-339e123.tar.gzcd sphinx-339e123phpize./configuremake &amp;&amp; make install 安装完毕后会在PHP的配置文件目录多出sphinx.ini，在扩展目录多出sphinx.so文件。终端执行 1phpenmod sphinx 即可启用扩展。 本文服务器环境Ubuntu16.04 Server + PHP7.0(使用apt安装)","link":"/2023/05/03/2017-02-28-php7-compile-sphinx-extension.html"},{"title":"nginx反向代理websocket","text":"websocket协议基于http协议升级而来，所以nginx可以直接反向代理websocket，只需要加上必要的header即可。 假设websocket监听端口为18080，编辑nginx配置文件： 12345678910server { listen 80; server_name socket.example.com; location / { proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;upgrade&quot;; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:18080; }}","link":"/2023/05/03/2017-03-20-nginx-proxy-websocket.html"},{"title":"ReactNative在NavigatorIOS中隐藏TabBar","text":"ReactNative常用的一种布局是TabBar+Navigator布局，底部几个固定的标签，顶部有个导航栏，如果进入子页面的话，底部TabBar是需要隐藏起来的。 不过官方没有提供这个属性，github和StackOverflow上的答案有个bug，平时没什么问题，如果手指左滑一点然后松开，这时候路由没切换，但是TarBar会显示，然后不消失。 目前能够完美解决这个问题的方案如下： 找到React/RCTWrapperViewController.m 查找 willShowViewController 在该方法最开始的地方加入self.navigationController.tabBarController.tabBar.hidden=self.navigationController.childViewControllers.count&gt;1;","link":"/2023/05/03/2017-03-27-react-native-hidden-tabbar-with-navigatorIOS.html"},{"title":"IOS10.3信息APP闪退解决方案","text":"问题更新IOS10.3之后系统自带的信息APP打开闪退，当然，刷机是一种解决方案。可是遇到点问题就刷机这个工作量有点太大了。 解决方案设置 -&gt; 信息 -&gt; 打开过滤未知发件人","link":"/2023/05/03/2017-03-31-ios10.3-message-crash.html"},{"title":"log4php使用syslog记录日志","text":"log4php是apache基金会下的一个开源项目，灵活、强大，已经有几个项目使用了log4php处理日志，目前遇到的问题是服务器太多的时候日志如何统一管理，本来想使用数据库存储。但是日志格式成了一个问题，而且不利于扩展，如果临时需要保存到文件，又要更改log4php的配置。好在log4php提供了syslog的一个appender，可以将日志写入syslog; log4php配置12345678910111213log4php.rootLogger=INFO, stdout, stderrlog4php.appender.stdout=LoggerAppenderConsolelog4php.appender.stdout.layout=LoggerLayoutPatternlog4php.appender.stdout.layout.ConversionPattern=%date{Y-m-d H:i:s} [%-5p] %m%nlog4php.appender.stdout.threshold=INFOlog4php.appender.stderr=LoggerAppenderSysloglog4php.appender.stderr.ident=qun.hk-tasklog4php.appender.stderr.priority=ERRlog4php.appender.stderr.facility=LOCAL0log4php.appender.stderr.layout=LoggerLayoutPatternlog4php.appender.stderr.layout.ConversionPattern=%date{Y-m-d H:i:s} %m%nlog4php.appender.stderr.threshold=WARN 这里使用两个输出目的地,stdout输出到终端，stderr输出到syslod，log4php配置对应rsyslog的配置关系为： ident -&gt; syslog中的tag priority -&gt; syslog中的priority facility -&gt; syslog中的facility，请注意全部为大写 rsyslog配置rsyslog配置文件一般在 /etc/rsyslog.conf 以及 /etc/rsyslog.d目录下我们不更改主配置文件，在*/etc/rsyslog.d/*目录下新建文件 vim local0.conf 内容为 local0.* /var/log/local0.log rsyslog输出可以写成服务器，本文为了测试直接写入文件，有需要的可以根据实际情况进行转发。重启rsyslog service rsyslog restart PHP加载配置12345&lt;?php\\Logger::configure(__DIR__ . '/log4php.properties');$logger = \\Logger::getLogger('default');$logger-&gt;info('info');$logger-&gt;error('error'); 可以看到*/var/log/local0.log中多出一行error*的日志","link":"/2023/05/03/2017-04-27-log4php-syslog.html"},{"title":"使用NodeJs提供syslogd服务端","text":"syslog作为Linux发行版一个重要组件，相信大家都不陌生，而如果每台服务器都独立使用一份的话，不能做到日志统一管理，对于以后的日志查询不太方便。syslog有标准的协议格式，这里不做讨论，有兴趣的可以基于协议的报文结构使用socket编程实现。 部署服务端本文使用Nodejs来部署一台syslog服务端。 终端执行 12npm init -ynpm install syslogd --save index.js 1234567891011const syslogd = require('syslogd');const server = syslogd(data =&gt; { console.log(data);});server.listen(514,e =&gt; { if(e!==null) { console.error(e); return; } console.log('listen on 514');}); 终端执行 1node index.js 好了，我们的syslog服务器已经部署完毕了。是不是很简单呢~ nginx日志接入syslog打开nginx配置文件 12345server { ... access_log syslog:server=127.0.0.1; ...} 重启nginx就可以发现nodejs服务端已经成功接收日志信息了。注意：是重启不是reload","link":"/2023/05/03/2017-04-27-node-syslogd.html"},{"title":"Yii2框架MemCache在腾讯云部署时不过期问题","text":"之前部署在阿里云时一直memcache没有问题，部署到腾讯云发现缓存永不过期。查看yii2的MemCache类源码后，发现在设置缓存时，Yii2添加了$expire = $duration &gt; 0 ? $duration + time() :0;这样的代码，会导致强制使用时间戳来标记过期时间，而阿里云是过期时间和时间戳都支持的，腾讯云只支持前者。 解决方案重写组件即可在app\\components中加添加MemCache集成Yii2的MemCache，由于Yii2的MemCache中$_cache成员变量为private，子类无法访问，所以需要直接copy源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314&lt;?php/** * Created by PhpStorm. * User: xialei * Date: 2017/5/12 * Time: 下午5:55 */namespace app\\components;use yii\\base\\InvalidConfigException;use yii\\caching\\MemCacheServer;class MemCache extends \\yii\\caching\\MemCache{ /** * @var bool whether to use memcached or memcache as the underlying caching extension. * If true, [memcached](http://pecl.php.net/package/memcached) will be used. * If false, [memcache](http://pecl.php.net/package/memcache) will be used. * Defaults to false. */ public $useMemcached = false; /** * @var string an ID that identifies a Memcached instance. This property is used only when [[useMemcached]] is true. * By default the Memcached instances are destroyed at the end of the request. To create an instance that * persists between requests, you may specify a unique ID for the instance. All instances created with the * same ID will share the same connection. * @see http://ca2.php.net/manual/en/memcached.construct.php */ public $persistentId; /** * @var array options for Memcached. This property is used only when [[useMemcached]] is true. * @see http://ca2.php.net/manual/en/memcached.setoptions.php */ public $options; /** * @var string memcached sasl username. This property is used only when [[useMemcached]] is true. * @see http://php.net/manual/en/memcached.setsaslauthdata.php */ public $username; /** * @var string memcached sasl password. This property is used only when [[useMemcached]] is true. * @see http://php.net/manual/en/memcached.setsaslauthdata.php */ public $password; /** * @var \\Memcache|\\Memcached the Memcache instance */ private $_cache; /** * @var array list of memcache server configurations */ private $_servers = []; /** * Initializes this application component. * It creates the memcache instance and adds memcache servers. */ public function init() { parent::init(); $this-&gt;addServers($this-&gt;getMemcache(), $this-&gt;getServers()); } /** * Add servers to the server pool of the cache specified * * @param \\Memcache|\\Memcached $cache * @param MemCacheServer[] $servers * @throws InvalidConfigException */ protected function addServers($cache, $servers) { if (empty($servers)) { $servers = [new MemCacheServer([ 'host' =&gt; '127.0.0.1', 'port' =&gt; 11211, ])]; } else { foreach ($servers as $server) { if ($server-&gt;host === null) { throw new InvalidConfigException(&quot;The 'host' property must be specified for every memcache server.&quot;); } } } if ($this-&gt;useMemcached) { $this-&gt;addMemcachedServers($cache, $servers); } else { $this-&gt;addMemcacheServers($cache, $servers); } } /** * Add servers to the server pool of the cache specified * Used for memcached PECL extension. * * @param \\Memcached $cache * @param MemCacheServer[] $servers */ protected function addMemcachedServers($cache, $servers) { $existingServers = []; if ($this-&gt;persistentId !== null) { foreach ($cache-&gt;getServerList() as $s) { $existingServers[$s['host'] . ':' . $s['port']] = true; } } foreach ($servers as $server) { if (empty($existingServers) || !isset($existingServers[$server-&gt;host . ':' . $server-&gt;port])) { $cache-&gt;addServer($server-&gt;host, $server-&gt;port, $server-&gt;weight); } } } /** * Add servers to the server pool of the cache specified * Used for memcache PECL extension. * * @param \\Memcache $cache * @param MemCacheServer[] $servers */ protected function addMemcacheServers($cache, $servers) { $class = new \\ReflectionClass($cache); $paramCount = $class-&gt;getMethod('addServer')-&gt;getNumberOfParameters(); foreach ($servers as $server) { // $timeout is used for memcache versions that do not have $timeoutms parameter $timeout = (int)($server-&gt;timeout / 1000) + (($server-&gt;timeout % 1000 &gt; 0) ? 1 : 0); if ($paramCount === 9) { $cache-&gt;addserver( $server-&gt;host, $server-&gt;port, $server-&gt;persistent, $server-&gt;weight, $timeout, $server-&gt;retryInterval, $server-&gt;status, $server-&gt;failureCallback, $server-&gt;timeout ); } else { $cache-&gt;addserver( $server-&gt;host, $server-&gt;port, $server-&gt;persistent, $server-&gt;weight, $timeout, $server-&gt;retryInterval, $server-&gt;status, $server-&gt;failureCallback ); } } } /** * Returns the underlying memcache (or memcached) object. * @return \\Memcache|\\Memcached the memcache (or memcached) object used by this cache component. * @throws InvalidConfigException if memcache or memcached extension is not loaded */ public function getMemcache() { if ($this-&gt;_cache === null) { $extension = $this-&gt;useMemcached ? 'memcached' : 'memcache'; if (!extension_loaded($extension)) { throw new InvalidConfigException(&quot;MemCache requires PHP $extension extension to be loaded.&quot;); } if ($this-&gt;useMemcached) { $this-&gt;_cache = $this-&gt;persistentId !== null ? new \\Memcached($this-&gt;persistentId) : new \\Memcached; if ($this-&gt;username !== null || $this-&gt;password !== null) { $this-&gt;_cache-&gt;setOption(\\Memcached::OPT_BINARY_PROTOCOL, true); $this-&gt;_cache-&gt;setSaslAuthData($this-&gt;username, $this-&gt;password); } if (!empty($this-&gt;options)) { $this-&gt;_cache-&gt;setOptions($this-&gt;options); } } else { $this-&gt;_cache = new \\Memcache; } } return $this-&gt;_cache; } /** * Returns the memcache or memcached server configurations. * @return MemCacheServer[] list of memcache server configurations. */ public function getServers() { return $this-&gt;_servers; } /** * @param array $config list of memcache or memcached server configurations. Each element must be an array * with the following keys: host, port, persistent, weight, timeout, retryInterval, status. * @see http://php.net/manual/en/memcache.addserver.php * @see http://php.net/manual/en/memcached.addserver.php */ public function setServers($config) { foreach ($config as $c) { $this-&gt;_servers[] = new MemCacheServer($c); } } /** * Retrieves a value from cache with a specified key. * This is the implementation of the method declared in the parent class. * @param string $key a unique key identifying the cached value * @return mixed|false the value stored in cache, false if the value is not in the cache or expired. */ protected function getValue($key) { return $this-&gt;_cache-&gt;get($key); } /** * Retrieves multiple values from cache with the specified keys. * @param array $keys a list of keys identifying the cached values * @return array a list of cached values indexed by the keys */ protected function getValues($keys) { return $this-&gt;useMemcached ? $this-&gt;_cache-&gt;getMulti($keys) : $this-&gt;_cache-&gt;get($keys); } /** * Stores a value identified by a key in cache. * This is the implementation of the method declared in the parent class. * * @param string $key the key identifying the value to be cached * @param mixed $value the value to be cached. * @see [Memcache::set()](http://php.net/manual/en/memcache.set.php) * @param int $duration the number of seconds in which the cached value will expire. 0 means never expire. * @return bool true if the value is successfully stored into cache, false otherwise */ protected function setValue($key, $value, $duration) { // Use UNIX timestamp since it doesn't have any limitation // @see http://php.net/manual/en/memcache.set.php // @see http://php.net/manual/en/memcached.expiration.php $expire = $duration; return $this-&gt;useMemcached ? $this-&gt;_cache-&gt;set($key, $value, $expire) : $this-&gt;_cache-&gt;set($key, $value, 0, $expire); } /** * Stores multiple key-value pairs in cache. * @param array $data array where key corresponds to cache key while value is the value stored * @param int $duration the number of seconds in which the cached values will expire. 0 means never expire. * @return array array of failed keys. Always empty in case of using memcached. */ protected function setValues($data, $duration) { if ($this-&gt;useMemcached) { // Use UNIX timestamp since it doesn't have any limitation // @see http://php.net/manual/en/memcache.set.php // @see http://php.net/manual/en/memcached.expiration.php $expire = $duration; $this-&gt;_cache-&gt;setMulti($data, $expire); return []; } else { return parent::setValues($data, $duration); } } /** * Stores a value identified by a key into cache if the cache does not contain this key. * This is the implementation of the method declared in the parent class. * * @param string $key the key identifying the value to be cached * @param mixed $value the value to be cached * @see [Memcache::set()](http://php.net/manual/en/memcache.set.php) * @param int $duration the number of seconds in which the cached value will expire. 0 means never expire. * @return bool true if the value is successfully stored into cache, false otherwise */ protected function addValue($key, $value, $duration) { // Use UNIX timestamp since it doesn't have any limitation // @see http://php.net/manual/en/memcache.set.php // @see http://php.net/manual/en/memcached.expiration.php $expire = $duration; return $this-&gt;useMemcached ? $this-&gt;_cache-&gt;add($key, $value, $expire) : $this-&gt;_cache-&gt;add($key, $value, 0, $expire); } /** * Deletes a value with the specified key from cache * This is the implementation of the method declared in the parent class. * @param string $key the key of the value to be deleted * @return bool if no error happens during deletion */ protected function deleteValue($key) { return $this-&gt;_cache-&gt;delete($key, 0); } /** * Deletes all values from cache. * This is the implementation of the method declared in the parent class. * @return bool whether the flush operation was successful. */ protected function flushValues() { return $this-&gt;_cache-&gt;flush(); }} 配置缓存时使用以下代码 12345'class' =&gt; 'app\\components\\MemCache','useMemcached' =&gt; false,'servers' =&gt; [ ['host' =&gt; '127.0.0.1', 'port' =&gt; 11211]]","link":"/2023/05/03/2017-05-12-yii2-memcached-qcloud-not-expires.html"},{"title":"nginx反向代理websocket支持跨域","text":"今天在调试远程websocket的时候发现控制台提示跨域错误，看到浏览器Network中方向响应头没有跨域方面的数据。 nginx做websocket反向代理挺简单的 123456proxy_set_header Upgrade $http_upgrade;proxy_set_header Connection &quot;upgrade&quot;;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;proxy_set_header Host $host;proxy_http_version 1.1;proxy_pass http://socket服务器地址; 但是如此配置除非后端服务器支持跨域，否则socket无法跨域。其实nginx支持的add_header指令已经可以添加跨域相关头了 完整配置如下 1234567891011add_header &quot;Access-Control-Allow-Origin&quot; &quot;$http_origin&quot;;add_header &quot;Access-Control-Allow-Credentials&quot; &quot;true&quot;;add_header &quot;Access-Control-Allow-Methods&quot; &quot;GET, POST, OPTIONS, DELETE, PATCH, PUT, HEAD&quot;;add_header &quot;Access-Control-Allow-Headers&quot; &quot;DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type&quot;;proxy_set_header Upgrade $http_upgrade;proxy_set_header Connection &quot;upgrade&quot;;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;proxy_set_header Host $host;proxy_http_version 1.1;proxy_pass http://socket服务器地址; 再看到浏览器响应头时发现已经成功返回跨域头了。","link":"/2023/05/03/2017-05-24-nginx-proxy-websocket-cors.html"},{"title":"nodejs unhandledRejection问题解决","text":"今天在使用promise的时候没有catch掉错误，导致报错，类似于 1unhandledRejection promise .... 而且不会显示trace信息，导致无从查错，经过google发现，需要监听进程的unhandledRejection事件，才能显示trace信息 123process.on('unhandledRejection', (...params) =&gt; { console.log(params);});","link":"/2023/05/03/2017-06-13-node-unhandledRejection.html"},{"title":"使用RSA在PHP和NodeJs中进行加密数据通信","text":"RSA算法是目前用的最多的非对称加密算法，文本将基于openssl在nodejs和php中进行加密数据通信。 生成密钥对123opensslgenrsa -out private.key 2048rsa -in private.key -pubout -out public.key 执行完命令后，可以在当前目录看到: public.key 公钥 private.key 私钥 NodeJs服务器本文使用koa2来构建一个基于openssl加密方案的http服务器。源码使用typescript进行开发。 安装依赖12npm init -ynpm install typescript koa koa-router @types/node @types/koa @types/koa-router --save 最终的package.json内容如下： 123456789101112131415161718192021{ &quot;name&quot;: &quot;openssl-demo&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: { &quot;build&quot;: &quot;tsc -w&quot;, &quot;start&quot;: &quot;node index.js&quot; }, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: { &quot;@types/koa&quot;: &quot;^2.0.39&quot;, &quot;@types/koa-router&quot;: &quot;^7.0.22&quot;, &quot;@types/node&quot;: &quot;^8.0.2&quot;, &quot;koa&quot;: &quot;^2.3.0&quot;, &quot;koa-router&quot;: &quot;^7.2.1&quot;, &quot;typescript&quot;: &quot;^2.3.4&quot; }} 开始编码index.ts:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import * as crypto from 'crypto';import * as constants from 'constants';import * as Koa from 'koa';import * as KoaRouter from 'koa-router';import * as fs from 'fs';class Server { app: Koa; static bootstrap() { return new Server(); } constructor() { this.app = new Koa(); this.route(); this.app.listen(8081, () =&gt; { console.info('listen on 8081'); }); } parsePostData(ctx): Promise&lt;Buffer&gt; { return new Promise((resolve, reject) =&gt; { try { let postdata = Buffer.alloc(0); ctx.req.addListener('data', (data) =&gt; { postdata = Buffer.concat([data]); }); ctx.req.addListener(&quot;end&quot;, function () { resolve(postdata); }) } catch (err) { reject(err) } }) } private readFile(path): Promise&lt;Buffer&gt; { return new Promise((resolve, reject) =&gt; fs.readFile(path, (e, data) =&gt; e ? reject(e) : resolve(data))); } private route() { const router = new KoaRouter(); router.post('/', async (ctx: Koa.Context, next) =&gt; { const encrypted = await this.parsePostData(ctx); // 接收到的经过base64编码后的加密数据 const key = await this.readFile(__dirname + '/private.key');//读取私钥 const pkey = key.toString();// 字符串形式的私钥 const data = crypto.privateDecrypt({key: pkey, padding: constants.RSA_PKCS1_PADDING}, new Buffer(encrypted.toString(), 'base64')); // 使用私钥解密Buffer const json = JSON.parse(data.toString()); // 将解密后的信息解码为json对象 const msg = JSON.stringify({errcode: json.name === 'demo' ? 0 : 1, errmsg: json.name === 'demo' ? 'ok' : 'error'}); // 需要返回的明文数据 const e = crypto.privateEncrypt({key: pkey, padding: constants.RSA_PKCS1_PADDING}, new Buffer(msg)); // 使用私钥加密返回数据 ctx.body = e.toString('base64'); // 将buffer编码为base64字符串后返回 }); this.app .use(router.routes()) .use(router.allowedMethods()); }}Server.bootstrap(); 编译typescript1npm run build 启动服务器1npm run start 此时我们的服务器已经启动完成。 PHP客户端将2中的公钥复制到php项目下。本文使用rmccue/requests作为http客户端发起请求。index.php关键代码如下: 123456789&lt;?php$pubKey = openssl_pkey_get_public(file_get_contents(__DIR__ . '/public.key')); // 读取公钥$data = Json::encode(['name' =&gt; 'demo']); // 需要提交的明文数据openssl_public_encrypt($data, $encryped, $pubKey); // 使用公钥加密明文数据$data = base64_encode($encryped); // 将加密后的数据进行base64编码$res = Requests::post('http://localhost:8081', [], $data); // 将base64数据提交到NodeJs$data = base64_decode($res-&gt;body);// 接收NodeJs私钥加密后的响应并进行base64解码openssl_public_decrypt($data, $dd, $pubKey); // 使用公钥将密文解密echo $dd; // 打印数据 执行正常请求1php index.php 输出如下 1{&quot;errcode&quot;:0,&quot;errmsg&quot;:&quot;ok&quot;} 执行不正常请求将php中 1$data = Json::encode(['name' =&gt; 'demo']); 改为 1$data = Json::encode(['name' =&gt; 'demo1']); 发现收到的响应为 1{&quot;errcode&quot;:1,&quot;errmsg&quot;:&quot;error&quot;} 证明提交的数据不能被nodejs接受。 后记本文简单使用了一下openssl相关功能函数，旨在起到一个抛砖引玉的作用，基于rsa算法可以开发出很多安全性很高的应用。","link":"/2023/05/03/2017-06-24-rsa-in-node-php.html"},{"title":"druid spring boot 统计SQL问题","text":"spring-boot配置12345678910111213141516171819spring.jpa.hibernate.ddl-auto=validatespring.datasource.type=com.alibaba.druid.pool.DruidDataSourcespring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.initialize=truespring.datasource.initialSize=5spring.datasource.minIdle=5spring.datasource.maxActive=10spring.datasource.maxWait=60000spring.datasource.timeBetweenEvictionRunsMillis=60000spring.datasource.minEvictableIdleTimeMillis=300000spring.datasource.validationQuery=SELECT 'x'spring.datasource.testWhileIdle=truespring.datasource.testOnBorrow=falsespring.datasource.testOnReturn=falsespring.datasource.poolPreparedStatements=falsespring.datasource.maxPoolPreparedStatementPerConnectionSize=20spring.datasource.filters=stat,wall,slf4jspring.datasource.connectionProperties=druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000spring.datasource.useGlobalDataSourceStat=true 这个配置没有什么好说的，网上很多，可能关键在 123spring.datasource.filters=stat,wall,slf4jspring.datasource.connectionProperties=druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000spring.datasource.useGlobalDataSourceStat=true 但是就算配置好这些后，返回/druid也不显示SQL统计。其实问题在于 系统默认使用的数据库连接池没有使用你的配置，所以需要我们手动实例化Bean kotlin代码12345678@SpringBootApplicationopen class Application { @Bean @ConfigurationProperties(prefix = &quot;spring.datasource&quot;) open fun druidDataSource(): DataSource { return DruidDataSource() }","link":"/2023/05/03/2017-07-18-spring-boot-druid-sql.html"},{"title":"移动端rem和PSD单位换算问题","text":"设计图尺寸一般750宽度，而需要兼容640宽度手机的话，需要调整缩放比率，之前使用写死viewport的做法来实现，不过这个方法有点取巧，而且有些场景并不适用。本文用标准的@media来实现 rem定义1234567891011121314151617181920212223@media screen and (max-width: 750px) { html { font-size: 30px; }}@media screen and (min-width: 640px) and (max-width: 749px) { html { font-size: 25px; }}@media screen and (min-width: 480px) and (max-width: 639px) { html { font-size: 20px; }}@media screen and (min-width: 320px) and (max-width: 479px) { html { font-size: 15px; }} 如何使用假设PSD中有个button的大小为100px*40px，那使用rem时CSS如下 1234button { width: 3.333rem; height: 1.333rem;}","link":"/2023/05/03/2017-07-28-mobile-rem.html"},{"title":"Spring Boot JPA 返回json时排除Null字段","text":"Spring Boot在返回JSON的时候默认会返回null字段，这个对客户端一般没什么作用，还会增加服务器带宽压力。使用如下配置可以屏蔽。 在pojo对象上添加注解 123@JsonInclude(JsonInclude.Include.NON_NULL)class User {} 再使用@ResponseBody的时候就不会返回Null字段了。","link":"/2023/05/03/2017-07-31-spring-boot-exclude-null.html"},{"title":"使用pm2来保证Spring Boot应用稳定运行","text":"Spring Boot开发web应用就像开发普通的java程序一般简洁，因为其内嵌了web容易，启动的时候只需要一条命令java -jar server.jar即可，非常方便。但是由此而来的问题是万一应用挂了怎么办？ 别担心，有pm2进程管理工具可以帮到你。 PM2简介pm2原先是nodejs应用的进程管理工具，不过其良好的设计以及扩展性可以手动执行执行进程。 PM2安装 安装NodeJs npm install pm2 -g PM2基本命令 pm2 list 查看所有被PM2管理的进程列表 pm2 start xxx 启动一个应用 pm2 stop xxx 停止一个应用 pm2 restart xxx 重启一个应用 pm2 describe xxx 查看应用详情 pm2 startup, pm2 save 两条命令，用来保证服务器启动时,pm2管理的程序自动运行 Java程序处理在jar的同级目录新建应用启动配置文件，如pm2.json，内容如下： 12345678910{ &quot;name&quot;: &quot;my-server&quot;, &quot;script&quot;: &quot;/usr/bin/java&quot;, &quot;args&quot;: [ &quot;-jar&quot;, &quot;server.jar&quot; ], &quot;exec_interpreter&quot;: &quot;&quot;, &quot;exec_mode&quot;: &quot;fork&quot;} 说明如下： name 进程名称（显示在pm2 list命令中） script 执行进程名称，如果需要执行PHP脚本则填写php解释器的路径，本文为java args 传给执行进程的参数，多个参数以数组单元分割 exec_interpreter NodeJs解析器，本文不适用 exec_mode 执行模式[cluster|fork]这个针对NodeJs应用的配置，非NodeJs应用统一fork 配置文件完成后，使用 1pm2 start pm2.json 即可看到应用被启动 日志管理日志路径在~/.pm2/logs，stdout和stderr被分开存放，程序中的所有stdout和stderr都被收集方便查错。","link":"/2023/05/03/2017-07-31-spring-boot-pm2.html"},{"title":"Nginx alias和root指令","text":"Nginx的root指令相信大家用的都挺多，用来指定document_root，但是如果是针对特定path的请求才启用的话，root指令显得不好用 123location /web { root /home/wwwroot/site1;} 访问 http://demo.com/web/a.js的时候,nginx会去查找*/home/wwwroot/site1/web/a.js*，一般就会404了。因为文件是放在site1目录下的。这时候就需要alias指令了。 123location /web/{ alias /home/wwwroot/site1/;} 访问 http://demo.com/web/a.js的时候,nginx会去查找*/home/wwwroot/site1/a.js*。 注意 alias location末尾斜杠以及alias的末尾斜杠","link":"/2023/05/03/2017-09-14-nginx-alias-root.html"},{"title":"使用Docker来部署NodeJs应用","text":"Docker的环境无关性以及自动化特性实在是令人称赞，最近遇到的一个问题是，NodeJs使用8.x版本开发，但是线上服务器是7.x的，这时候又不能动线上的应用。于是想到了使用Docker来部署NodeJs，服务器是Ubuntu的。 安装Docker1apt install docker.io Dockerfile编写由于默认的dockhub速度非常慢导致下载镜像慢，而且镜像下来的Ubuntu apt源又是国外的，简直是慢上加慢，本文使用daocloud.io的Ubuntu镜像以及阿里云的Ubuntu源 123456789101112131415161718192021FROM daocloud.io/library/ubuntuMAINTAINER xialeistudio&lt;xialeistudio@gmail.com&gt;ENV PATH $PATH:/opt/node/binENV PORT 80ENV HOST 0.0.0.0# prepareADD sources.list /etc/apt/sources.listRUN apt updateRUN apt install wget gcc python git -y# nodejsRUN wget https://npm.taobao.org/mirrors/node/latest-v8.x/node-v8.6.0-linux-x64.tar.gzRUN tar xf node-v8.6.0-linux-x64.tar.gzRUN mv node-v8.6.0-linux-x64 /opt/node# appRUN mkdir appADD . /root/appWORKDIR /root/appRUN /opt/node/bin/npm install --registry=https://registry.npm.taobao.org# start appENTRYPOINT [&quot;npm&quot;,&quot;start&quot;] 指令解释一下 指定模板镜像 维护者信息，这是本人写的，所以署名为本人 环境变量定义 复制宿主机当前目录的sources.list到docker中的/etc/apt目录用来替换默认的Ubuntu源 更新apt并安装必要软件 从淘宝镜像站下载nodejs二进制版本 解压并移动到/opt/node目录 创建应用目录，并把宿主机当前文件夹下的所有文件拷贝到docker景象中 使用淘宝镜像安装npm包 启动APP build镜像1docker build -t demo . 运行完毕后就可以使用docker images查看镜像了 启动容器1docker run -d -p 127.0.0.1:7001:80 demo 这时候容器已经启动，并通过端口转发监听在宿主机的7001端口上，配合nginx做反向代理就可以部署一个公网应用了。不管你容器中部署何种版本的NodeJs都不会对宿主机造成影响，这点很重要。","link":"/2023/05/03/2017-10-10-docker-publish-nodejs.html"},{"title":"从零开始向DefinitelyTyped贡献代码","text":"什么是DefinitelyTyped?讲到DefinitelyTyped，我想做typescript开的人应该不会陌生，DefinitelyTyped是一个由typescript的发明者Microsoft维护的一个项目。 为什么会有DefinitelyTyped?typescript是基于declation的一门语言，declation这个东西有点像C语言的头文件，就是变量、函数等等需要事先声明才能通过typescript编辑。为了方便开发者，也为了快速推广typescript，官方维护的这个项目给npm常用的一些包都定义了declations文件。既然是托管在github的OpenSource Project，那么只要是github的会员就可以提交PR（当然Merge与否还得看项目组成员）,由于社区的活跃使得该仓库越来越丰富。很荣幸，我也提交了几个npm包的declations在上面。 如何提交PR到DefinitelyTyped?很多时候会遇到自己使用的npm包比较冷门，而DefinitelyTyped上面又没有，这时候虽然可以在本地定义，但是能够发布到DefinitelyTyped方便大家也是极好的，毕竟要拥抱开源嘛！官方的ReadMe中有How can I contribute?来告知开发者如何提交PR，但是需要英语基础，哈哈。 Step By Step环境搭建fork 项目要提交PR的第一步是必须fork到自己的仓库，别人不会随便给你直接改，万一改挂了他们还得背锅.登录github,打开项目地址DefinitelyTypedfork完毕后，你会拥有一个自己的仓库地址，本文中我的地址是https://github.com/xialeistudio/DefinitelyTyped clone 到本地我本地的项目地址是**~/WebstormProjects/DefinitelyTyped**终端执行 git clone https://github.com/xialeistudio/DefinitelyTyped 安装npm依赖终端执行 cd ~/WebstormProjects/DefinitelyTyped &amp;&amp; yarn SourceTree本文使用SourceTree配合git flow来进行项目管理。 下载soucetree 下载地址 安装sourcetree，期间需要登录。 用sourcetree打开刚才克隆的项目。 点击菜单栏【仓库】-&gt;【git-flow或hg flow】-&gt;【初始化仓库】 开始开发本文将以koa2-cors为例提交PR。 使用sourcetree的git-flow创建feature 分支名称填写koa2-cors 这时候已经可以编码了。我用的vscode，轻量，建议大家也用这个，webstorm打开这个项目就卡死了。 安装定义文件生成工具，终端执行npm install -g dts-gen 生成项目文件，终端执行dts-gen –dt –name koa2-cors –template module 这个时候在types/koa2-cors目录下就是我们需要编辑的文件了。如果编写定义文件不在本文范畴，有需要的朋友可以去tslang官网看看手册。 开始编辑index.d.ts，完整定义如下，记得改自己的个人信息: 123456789101112131415161718192021// Type definitions for koa2-cors 2.0// Project: https://github.com/zadzbw/koa2-cors#readme// Definitions by: xialeistudio &lt;https://github.com/xialeistudio&gt;// Definitions: https://github.com/DefinitelyTyped/DefinitelyTypedimport * as Koa from 'koa';declare namespace cors { interface Options { origin?: any; exposeHeaders?: string[]; maxAge?: number; credentials?: boolean; allowMethods?: string[]; allowHeaders?: string[]; }}declare function cors(options?: cors.Options): Koa.Middleware;export = cors; 编写单元测试文件koa2-cors-tests.ts，测试就是写上样板代码即可，只要能通过编译就行。 123456789101112131415161718import * as Koa from 'koa';import * as cors from 'koa2-cors';const app = new Koa();app.use(cors({ origin: function (ctx: Koa.Context) { if (ctx.url === '/test') { return false; } return '*'; }, exposeHeaders: ['WWW-Authenticate', 'Server-Authorization'], maxAge: 5, credentials: true, allowMethods: ['GET', 'POST', 'DELETE'], allowHeaders: ['Content-Type', 'Authorization', 'Accept'],}));app.listen(3000); 启动单元测试，终端执行npm run test，如果没有报错，即可进行提交流程，否则要修好错误才能提交。很幸运，单元测试通过： commit，终端执行git add . &amp;&amp; git commit -m “add koa2-cors definition” 使用sourcetree创建PR 点击在网上创建拉取请求 此时会自动打开github网页进行PR操作 编辑PR提交模板，这个根据实际情况编写即可，注意下方的If xxx，这个是不同提交类型需要填写的。本文是新增，所以选择add 点击Create Pull Request，此时会进行travis自动化测试流程，如果有错误需要点进去看到错误信息之后修正，很不幸。我们的第一次提交失败： 点击Details进行详细错误页面，找到**=== Error ===** 可以发现我们错误是**” Expected &quot;strictFunctionTypes&quot;: true or &quot;strictFunctionTypes&quot;: false,这个是tsconfig.json导致的问题，感觉是个历史遗留问题，因为使用的是默认创建的模板，不过为了提交PR，还是要手动修复。编辑types/koa2-cors/tsconfig.json，在compilerOptions**下添加，代码如下： 1234567891011121314151617181920212223{ &quot;compilerOptions&quot;: { &quot;module&quot;: &quot;commonjs&quot;, &quot;lib&quot;: [ &quot;es6&quot; ], &quot;noImplicitAny&quot;: true, &quot;noImplicitThis&quot;: true, &quot;strictNullChecks&quot;: true, &quot;baseUrl&quot;: &quot;../&quot;, &quot;strictFunctionTypes&quot;: false, &quot;typeRoots&quot;: [ &quot;../&quot; ], &quot;types&quot;: [], &quot;noEmit&quot;: true, &quot;forceConsistentCasingInFileNames&quot;: true }, &quot;files&quot;: [ &quot;index.d.ts&quot;, &quot;koa2-cors-tests.ts&quot; ]} commit，终端执行git add . &amp;&amp; git commit -m “strictFunctionTypes” &amp;&amp; git push，不需要再创建PR了，当你在该分支PUSH的时候，远端会自动触发自动化测试任务。 成功通过测试后，就可以等待官方人员过来review了。一般来说都会通过并且合并到master中去。","link":"/2023/05/03/2017-10-15-contributing-to-DefinitelyTyped-step-by-step.html"},{"title":"excel-stream Unknown Encoding错误问题","text":"项目上线有半年多了，一直没有出过问题，但是前几天升级过一次NodeJs到8.x的时候就出现过这个问题了。因为采用了消息队列，但是一到这里就挂，导致进程重复启动几百次。 报错信息1excel-stream/csv-stream/index.js 59 Buffer unknow encoding 问题排查google了一下无果，后面发现反正源码反正自己有，倒不如自己改改，直接定位到相关代码即可。 123456789CSVStream.prototype.write = function(buffer,encoding){ this._encoding = encoding || this._encoding; if(this._ended) throw new Error('Cannot write after end has been called.'); if(buffer) this._buffer = Buffer.concat([this._buffer, buffer], this._buffer.length + buffer.length); if(this._paused) return false; this._parser.parse(this._buffer.toString(this._encoding)); this._buffer = new Buffer(0); return !this._paused;} 报错具体行数是**this._parser.parse(this._buffer.toString(this._encoding));**，错误很明显了，提示encoding错误。 那直接往上面找，发现this._encoding = encoding || this._encoding，这里就有可能传入的encoding导致了错误。 问题解决这个项目已经3年没维护了，所以要修正问题的话，只能手动改了。 修改办法如下 1this._parser.parse(this._buffer.toString(this._encoding)); 改为 1this._parser.parse(this._buffer.toString()); 重新运行之后没有发现问题。","link":"/2017/10/15/2017-10-15-excel-stream-unknown-encoding.html"},{"title":"ios新版本代理设置问题","text":"背景系统是iOS11，电脑端用的charles代理，目前需要查看一些https网站返回的数据，还是使用老方法把charles的根证书设为信任，手机也打开chls.pro/ssl把证书添加到系统了。但是抓包的时候依旧无法访问，safari直接提示“该网站提供的证书不可信任”，查看详情发现charles证书虽然安装，但是没生效。 解决方法可能是iOS加强了安全性以及用户体验，往常的时候一旦我们加入证书，除非卸载，该证书是一直生效的（排除掉被吊销或者过期情况），而iOS11在设置-通用-关于手机-证书信任设置中可以方便开关证书。之前在iOS10.3也出现过问题，解决方法应该也是一致的。","link":"/2017/10/16/2017-10-16-ios-proxy-certificate-setting.html"},{"title":"Servlet中print-writer和outputstream编码问题","text":"有个项目需要使用java开发一个简单的web接口用来请求加密数据，但是servlet之前只随便用了一下，平时工作也是以node为主。 问题问题大致是”iso 88591 encoding之类的问题，稍微去google搜了一下，可能是搜的关键词不准确导致搜到的答案不理想，无意中看到有人讲writer和outputstream的问题。 原因google到PrintWriter和OutputStream的区别 1PrintWriter是以字符为单位，对所有的信息进行处理，而ServletOutputStream仅对二进制的资料进行处理。 而我输出的是UTF8格式的字符串，所以OutputStream并不认识。 解决使用PrintWriter输出即可。","link":"/2017/10/16/2017-10-16-servlet-print-writer-outputstream-encoding.html"},{"title":"koa-cooke使用maxAge代替expires来设置过期时间","text":"expires原来设置cookie使用的以下代码 123const cookieOptions = { expires: moment().add(6,'day').toDate(),}; 但是查看network的时候，cookie虽然设置了，但是过期时间比现在还早，导致一设置就过期，所以expires貌似没作用。 maxage查看对应的typescript定义文件index.d.ts发现还有一个maxAge选项也可以用来控制cookie过期时间 1234/** * a number representing the milliseconds from Date.now() for expiry */maxAge?: number; 这个参数更简单，基于当前时间的毫秒数，使用以下代码测试之后，发现过期时间跟预期一致一个星期： 123const cookieOptions = { maxAge: 3600 * 24 * 7 * 1000,};","link":"/2017/10/17/2017-10-17-koa-cookie-use-maxage.html"},{"title":"mac下php-imagick扩展library not loaded问题","text":"最近在使用imagick开发图像合成功能，和往常一样，终端执行 1brew install php71-imagick 虽然homebrew提示我安装成功了，然而php -m的时候确提示php-imagick模块无法加载。 google发现很多使用homebrew的人都遇到了问题，解决方法是使用源码编译imagick扩展，当然有个Homebrew倒是不用自己输入很长串的编译命令。 终端执行 1brew reinstall -s php71-imagick -s代表源码编译。","link":"/2017/10/17/2017-10-17-mac-php-imagick-library-not-loaded.html"},{"title":"php-imagick-字符间距问题","text":"在用php-imagick扩展做图像合成的时候，有个地方需要改下文本间距，百度一下发现setTextInterWordSpacing有这个方法，但是测试发现不管传多少值都毫无作用。 后面google查了一下，发现setTextKerning才是设置文本字符间距的函数。 此外，还发现一个bug，mac下roundCorners函数不存在的问题，找了个把小时才发现这是imagick在mac上面的bug，先写在这里，等有空在研究下。","link":"/2017/10/17/2017-10-17-php-imagick-text-spacing.html"},{"title":"yii2关闭csrf校验和cookie校验","text":"重要提示1关闭该选项会导致应用安全性收到影响！ 问题出现 开发API的时候发现POST请求老是不能通过验证，直接把报错文案放到项目中去搜索发现yii\\web\\Request中有enableCsrfValidation。 其他应用设置的cookie，抓包的时候可以看到请求中有cookie，但是yii2读取不到。 源码解析找到yii\\web\\Request文件，看到 12345678/** * @var bool whether to enable CSRF (Cross-Site Request Forgery) validation. Defaults to true. */public $enableCsrfValidation = true;/** * @var bool whether cookies should be validated to ensure they are not tampered. Defaults to true. */public $enableCookieValidation = true; 发现是这里有问题，基于yii2一切都是组件的思想，去修改组件配置即可。 修正编辑config/web.php的components节 123456'request' =&gt; [ 'cookieValidationKey' =&gt; 'xxxx', 'enableCookieValidation' =&gt; false, 'enableCsrfValidation' =&gt; false, ],],","link":"/2017/10/17/2017-10-17-yii2-close-csrf-validation-cookie-validatetion.html"},{"title":"使用docker-composer部署nodejs应用","text":"新建Dockerfile在应用目录下新建Dockerfile 123456FROM node:8WORKDIR /usr/src/appADD . /usr/src/appRUN npm install --registry=https://registry.npm.taobao.orgUSER nodeEXPOSE 8080 8080 端口请根据实际情况调整。建议大于1024，否则使用node用户启动应用时可能权限不足 新建docker-compose.yml在应用目录下新建docker-compose.yml 1234567891011version: &quot;2&quot;services: jsconsole: build: . volumes: - .:/usr/src/app - /usr/src/app/node_modules ports: - &quot;127.0.0.1:8081:8080&quot; command: &quot;npm start&quot; restart: always 127.0.0.1:8081是宿主机IP和端口，我前端采用了nginx做反向代理。如果是直接提供公网服务的话把127.0.0.1去掉 构建镜像在应用根目录下执行 1docker-compose build 构建并运行在应用根目录下执行**-d**是后台执行 1docker-compose up -d","link":"/2017/11/01/2017-11-01-docker-composer-nodejs.html"},{"title":"golang实现TLV编码","text":"TLV编码基础golang实现主要使用bytes和binary包中的相关函数 编码1234567891011121314151617func Encode(tag int32, data string) ([]byte, error) { buf := new(bytes.Buffer) // 写入TAG if err := binary.Write(buf, binary.BigEndian, tag); err != nil { return nil, err } dataBuf := []byte(data) // 写入length if err := binary.Write(buf, binary.BigEndian, int32(len(dataBuf))); err != nil { return nil, err } // 写入数据 if err := binary.Write(buf, binary.BigEndian, dataBuf); err != nil { return nil, err } return buf.Bytes(), nil} 解码123456789101112131415161718func Decode(b []byte) (int32, string, error) { buf := bytes.NewBuffer(b) var tag, length int32 // 读取tag if err := binary.Read(buf, binary.BigEndian, &amp;tag); err != nil { return 0, &quot;&quot;, err } // 读取length if err := binary.Read(buf, binary.BigEndian, &amp;length); err != nil { return 0, &quot;&quot;, err } // 读取数据 dataBuf := make([]byte, length) if err := binary.Read(buf, binary.BigEndian, &amp;dataBuf); err != nil { return 0, &quot;&quot;, err } return tag, string(dataBuf), nil} 由于TLV编码容易上手加上golang完善的API，实现TLV编码也不算太曲折。","link":"/2017/11/17/2017-11-17-go-tlv.html"},{"title":"Tlv编码在NodeJs中的应用","text":"最近在接入腾讯云的天御业务安全系统时接触到了TLV编码协议，好在TLV协议理解起来比较简单。故简要介绍一下该编码。 TLV编码是什么？1234TLV是一种编码格式，编码如下：[1-4字节] TYPE[5-8字节] Value的Length[9字节+] Value数据 本文只探讨无嵌套数据的情况。NodeJs操作二进制数据主要依赖于Buffer 编码 编码Ascii数据，由于ascii编码的数据，一个字节就是一个字符，所以比较简单12TYPE: 1Value: test 根据编码规则，可以得出以下数据组装格式1234[1-4字节] 00 00 00 01[5-8字节] 00 00 00 04[9-12字节] 74 65 73 74 // 74 对应字符*t*ascii编码*116*的16进制形式，其他以此类推 javascript代码12345678910// buf总长度为4字节TYPE+4字节VALUE长度+test的字节数为12const buf = Buffer.alloc(12);// 写入TYPEbuf.writeIntBE(1, 0, 4);// 写入LENGTHbuf.writeIntBE('test'.length, 4, 4);// 写入testbuf.write('test', 8, 'test'.length);// 此时buf就是编码结果，由于是二进制的，如果走TCP协议的话已经可以了，但是腾讯云要求base64编码。所以最终结果为buf.toString('base64'); 使用NodeJs交互式环境测试123456789101112131415161718➜ ~ node&gt; const buf = Buffer.alloc(12);undefined&gt; buf&lt;Buffer 00 00 00 00 00 00 00 00 00 00 00 00&gt;&gt; buf.writeIntBE(1,0,4)4&gt; buf.writeIntBE(4,4,4)8&gt; buf.write('test',8,4)4&gt; buf&lt;Buffer 00 00 00 01 00 00 00 04 74 65 73 74&gt;&gt; buf.toString()'\\u0000\\u0000\\u0000\\u0001\\u0000\\u0000\\u0000\\u0004test'&gt; buf.toString('base64')'AAAAAQAAAAR0ZXN0'&gt; 非Ascii编码问题如果发送的数据是Ascii编码表之外的数据，就会用到多字节编码，此时以上方法会有问题。得意与Buffer完善的API，Buffer.from方法可以接收一个字符串和一个编码得到一个Buffer数组。 上例可以改为使用Buffer.from的版本: 123456const valueBuf = Buffer.from(value, 'utf8');const buf = Buffer.alloc(8 + valueBuf.length);buf.writeIntBE(type, 0, 4);buf.writeIntBE(valueBuf.length, 4, 4);buf.write(value, 8, valueBuf.length);buf.toString('base64'); 由于value使用的utf8编码，所以utf8编码表中的数据该方法都可以成功编码，经过腾讯云接口调用测试也是OK的。 解码说到编码就会有解码。解码是编码的逆运算，根据一样的规则还原数据而已。 javascript代码123456789101112// 假设str为base64编码之后Tlv数据const buf = new Buffer(str, 'base64'); // 还原为Buffer// 读取TYPEconst type = buf.readIntBE(0, 4)// 读取VALUE长度const length = buf.readIntBE(4, 4)// 读取VALUEconst valueBuf = Buffer.alloc(length);// 写入VALUEbuf.copy(valueBuf, 0, 8, 8 + length);// 得到原始数据valueBuf.toString('utf8'); 使用NodeJs交互式环境测试1234567891011121314151617181920212223242526272829303132➜ ~ node&gt; const str = 'AAAAAQAAAAR0ZXN0';undefined&gt; const buf = new Buffer(str, 'base64');undefined&gt; const type = buf.readIntBE(0,4);undefined&gt; const length = buf.readIntBE(4,4);undefined&gt; const value = Buffer.alloc(length);undefined&gt; valueOf[Function: valueOf]&gt; value&lt;Buffer 00 00 00 00&gt;&gt; buf.cobuf.constructor buf.copyWithin buf.compare buf.copy &gt; buf.copy(value,0,8,8+length);4&gt; value.tovalue.toLocaleString value.toString value.toJSON &gt; value.toString()'test'&gt; 腾讯云天御业务安全系统socket.io中如果需要接入该系统进行垃圾发言的过滤时，可以使用我开发的SDKtencent-cloud-defend","link":"/2017/11/17/2017-11-17-node-tlv.html"},{"title":"log4go尝鲜","text":"序言日志系统对于软件是必不可少的，可以帮助我们记录关键信息，后期处理问题的时候会很方便。业界有很多出名的日志库，log4日志库相信每个人都不陌生，像log4j之于Java，log4php之于PHP等等。其实golang也有很多的log4实现，本文要使用的是alecthomas实现的版本。 项目地址https://github.com/alecthomas/log4go 安装1go get github.com/alecthomas/log4go 使用代码配置 新建golang项目 在项目根目录下新建main.go文件，代码如下 12345678910package mainimport &quot;github.com/alecthomas/log4go&quot;func main() { defer log4go.Close() log4go.AddFilter(&quot;stdout&quot;, log4go.DEBUG, log4go.NewConsoleLogWriter()) // DEBUG级别+打印到控制台 log4go.AddFilter(&quot;file&quot;, log4go.INFO, log4go.NewFileLogWriter(&quot;test.log&quot;, true)) // INFO级别+输出到文件，并开启rotate log4go.Debug(&quot;这是DEBUG日志&quot;) // 输出测试 log4go.Info(&quot;这是INFO日志&quot;) // 输出测试} 如果程序是守护进程，此处不用调用log4go.Close，因为log4go使用协程异步写入日志，此处可以调用log4go.Close也可以Sleep来实现写入，下文会有Sleep测试 go run main.go 此时可以看到终端输出，还可以发现项目目录下生成了test.log文件 12[17:11:35 CST 2017/11/21] [DEBG] (main.main:9) 这是DEBUG日志[17:11:35 CST 2017/11/21] [INFO] (main.main:10) 这是INFO日志 重新执行时可以发现test.log被rotate到了test.log.1 使用配置文件log4go支持使用xml来作为配置文件 在项目根目录新建log4go.xml 12345678910111213141516&lt;logging&gt; &lt;filter enabled=&quot;true&quot;&gt; &lt;tag&gt;stdout&lt;/tag&gt; &lt;type&gt;console&lt;/type&gt; &lt;level&gt;DEBUG&lt;/level&gt; &lt;/filter&gt; &lt;filter enabled=&quot;true&quot;&gt; &lt;tag&gt;file&lt;/tag&gt; &lt;type&gt;file&lt;/type&gt; &lt;level&gt;INFO&lt;/level&gt; &lt;property name=&quot;filename&quot;&gt;test.log&lt;/property&gt; &lt;property name=&quot;rotate&quot;&gt;true&lt;/property&gt; &lt;property name=&quot;maxlines&quot;&gt;2&lt;/property&gt; &lt;property name=&quot;daily&quot;&gt;true&lt;/property&gt; &lt;/filter&gt;&lt;/logging&gt; 添加了console和file两个filter，跟代码添加其实是一样的，不同的是xml的可配置性更高。具体配置参数需要查看log4go对应的go源文件 修改main.go 12345678910111213package mainimport ( &quot;github.com/alecthomas/log4go&quot; &quot;time&quot;)func main() { log4go.LoadConfiguration(&quot;log4go.xml&quot;) log4go.Debug(&quot;这是DEBUG日志&quot;) log4go.Info(&quot;这是INFO日志&quot;) time.Sleep(time.Second)} 运行程序，终端依旧正确输出，同时也会生成test.log 后记log4go良好的设计带来了简洁又强大的使用体验，更多的使用细节以及更多的logger类型等待读者去发掘与实现，本文只做一个简单的介绍，即便如此也应该能够应付大部分场景了。","link":"/2017/11/21/2017-11-21-log4go-get-started.html"},{"title":"从零开始打造自己的直播服务器-golang开发HTTP推流服务","text":"目前笔者只知道ffmpeg命令行推流到RTMP服务器，是没有HTTP接口的，像iOS和Android这种Native应用应该有RTMP SDK封装推流逻辑。但是像微信小程序这种录制音频只有原始ArrayBuffer的数据，则必须在服务端提供接口来进行推流。 本文将基于golang标准库以及ffmpeg命令来实现。 服务端原理 客户端上传base64编码后的音频数据 服务端接收后解码为**[]byte** 将**[]byte**写入本地文件 golang调用ffmpeg命令将第3步写入的文件推流到RTMP服务端 golang输出JSON响应，如果出错则返回错误JSON响应 1234{ &quot;errmsg&quot;:&quot;ok&quot;, &quot;errcode&quot;:0} 开始开发由于采用了log4go日志库https://github.com/alecthomas/log4go，故需要先安装 1go get github.com/alecthomas/log4go 完整服务端源代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150package mainimport ( &quot;github.com/alecthomas/log4go&quot; &quot;flag&quot; &quot;net/http&quot; &quot;time&quot; &quot;encoding/json&quot; &quot;io/ioutil&quot; &quot;encoding/base64&quot; &quot;os&quot; &quot;os/exec&quot; &quot;strings&quot;)var ( rtmp string // rtmp 服务端地址 ffmpeg string // ffmpeg命令地址 listen string // 监听地址 uploadKey string // 上传key uploadDirectory string // 本地上传目录 start = time.Now())const ( VERSION = &quot;1.0.0&quot;)func init() { flag.StringVar(&amp;rtmp, &quot;rtmp&quot;, &quot;rtmp://localhost:1935/hls&quot;, &quot;rtmp upstream address&quot;) flag.StringVar(&amp;ffmpeg, &quot;ffmpeg&quot;, &quot;ffmpeg&quot;, &quot;ffmpeg executable&quot;) flag.StringVar(&amp;listen, &quot;listen&quot;, &quot;:8081&quot;, &quot;http server address&quot;) flag.StringVar(&amp;uploadKey, &quot;key&quot;, &quot;testkey&quot;, &quot;http upload key&quot;) flag.StringVar(&amp;uploadDirectory, &quot;upload-directory&quot;, &quot;upload&quot;, &quot;local upload directory&quot;)}func main() { flag.Parse() log4go.LoadConfiguration(&quot;log4go.xml&quot;) if rtmp == &quot;&quot; { panic(&quot;rtmp upstream not set!&quot;) } // 创建目录 os.Mkdir(uploadDirectory, os.ModePerm) log4go.Info(&quot;start ffmpeg-publisher, version %s&quot;, VERSION) log4go.Info(&quot;RTMP UpStream %s&quot;, rtmp) log4go.Info(&quot;HTTP Upload Directory %s&quot;, uploadDirectory) log4go.Info(&quot;HTTP Listen ON %s&quot;, listen) log4go.Info(&quot;HTTP Upload Key %s&quot;, uploadKey) http.HandleFunc(&quot;/&quot;, handleIndex) http.HandleFunc(&quot;/base64&quot;, handleBase64Publish) panic(http.ListenAndServe(listen, nil))}func sendResponse(errmsg string, statusCode int, w http.ResponseWriter) { w.Header().Set(&quot;Content-Type&quot;, &quot;application/json;charset=utf-8&quot;) if statusCode == 0 { statusCode = 200 } w.WriteHeader(statusCode) ret := map[string]interface{}{ &quot;errmsg&quot;: errmsg, &quot;errcode&quot;: statusCode, } json.NewEncoder(w).Encode(&amp;ret) if statusCode == 500 { log4go.Error(errmsg) }}func handleIndex(w http.ResponseWriter, _ *http.Request) { ret := map[string]interface{}{ &quot;name&quot;: &quot;ffpmeg-publisher&quot;, &quot;version&quot;: VERSION, &quot;uptime&quot;: time.Since(start).String(), } w.Header().Set(&quot;Content-Type&quot;, &quot;application/json;charset=utf-8&quot;) json.NewEncoder(w).Encode(&amp;ret)}func handleBase64Publish(w http.ResponseWriter, r *http.Request) { if r.Method != &quot;POST&quot; { sendResponse(&quot;Method Not Allowed&quot;, 405, w) return } // 获取直播ID和key if err := r.ParseForm(); err != nil { sendResponse(err.Error(), 500, w) return } // 检测直播Key if key := r.Form.Get(&quot;key&quot;); key != uploadKey { sendResponse(&quot;Forbidden&quot;, 403, w) return } // 检测直播ID id := r.Form.Get(&quot;id&quot;) if id == &quot;&quot; { sendResponse(&quot;Bad Request&quot;, 400, w) return } // 读取base64 base64Buf, err := ioutil.ReadAll(r.Body) if err != nil { sendResponse(err.Error(), 500, w) return } buf, err := base64.StdEncoding.DecodeString(string(base64Buf)) if err != nil { sendResponse(err.Error(), 500, w) return } log4go.Trace(&quot;live %s receive %d bytes&quot;, id, len(buf)) if err := publishVoice(buf, id); err != nil { sendResponse(err.Error(), 500, w) } else { sendResponse(&quot;ok&quot;, 0, w) }}// 保存音频到临时文件目录,1个直播一个目录func saveVoice(buf []byte, id string) (string, error) { directory := uploadDirectory + &quot;/&quot; + id os.Mkdir(directory, os.ModePerm) name := time.Now().Format(&quot;2006-01-02-15-04-05&quot;) + &quot;.mp3&quot; filename := directory + &quot;/&quot; + name log4go.Trace(&quot;live %s save chunk %s&quot;, id, filename) err := ioutil.WriteFile(filename, buf, os.ModePerm) return filename, err}// 发布音频至rtmpfunc publishVoice(buf []byte, id string) error { mp3filename, err := saveVoice(buf, id) if err != nil { log4go.Error(&quot;live %s %q&quot;, id, err) return err } // 执行系统命令 cmd := exec.Command(ffmpeg, &quot;-i&quot;, mp3filename, &quot;-acodec&quot;, &quot;aac&quot;, &quot;-f&quot;, &quot;flv&quot;, rtmp+&quot;/&quot;+id) log4go.Trace(&quot;live %s execute %s&quot;, id, strings.Join(cmd.Args, &quot; &quot;)) cmd.Stderr = os.Stderr cmd.Stdout = os.Stdout if err := cmd.Run(); err != nil { log4go.Error(&quot;live %s execute %q&quot;, id, err) return err } return nil} github地址https://github.com/xialeistudio/go-rtmp-http-publisher","link":"/2017/11/23/2017-11-23-go-rtmp-http-publisher.html"},{"title":"从零开始打造自己的直播服务器-Nginx安装","text":"直播行业火了很长一段时间了，抛开那些复杂的实现，本系列将从零开始实现一个直播服务器。 功能 RTMP拉流(基于HLS) RTMP推流(基于ffmpeg) RTMP推流(基于HTTP) 安装Nginx本文使用docker的ubuntu镜像作为种子机，非常干净! 文章最后会放出我写的Dockerfile，不想折腾的朋友可以直接拿过去build一个自己的镜像 以下操作在物理机ubuntu也可以进行。 更新软件仓库 1apt-get update 安装必要软件 1apt-get install git gcc make wget libpcre3 libpcre3-dev openssl libssl-dev -y -q 下载并解压nginx源码 123cd /usr/local/srcwget http://nginx.org/download/nginx-1.12.2.tar.gztar xf nginx-1.12.2.tar.gz 下载nginx-rtmp-module源码 1git clone https://github.com/arut/nginx-rtmp-module.git 开始编译安装(其他参数不是必须的，故本文略去，只添加以下参数对于一个RTMP服务器已足够) 1234cd /usr/local/src/nginx-1.12.2./configure --add-module=../nginx-rtmp-module --with-http_flv_module --with-http_mp4_modulemakemake install 修改配置文件 /usr/local/nginx/nginx.conf 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374worker_processes auto;daemon off;error_log logs/error.log;pid logs/nginx.pid;events { multi_accept on; worker_connections 65535; use epoll;}http { include mime.types; log_format main '$remote_addr - $remote_user [$time_local] &quot;$request&quot; ' '$status $body_bytes_sent &quot;$http_referer&quot; ' '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;'; access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 30; gzip on; server { listen 80; server_name localhost; location /stat { rtmp_stat all; rtmp_stat_stylesheet stat.xsl; } location /stat.xsl { root /usr/local/src/nginx-rtmp-module; } location /control { rtmp_control all; } location /hls { types { application/vnd.apple.mpegurl m3u8; video/mp2t ts; } root html; expires -1; } location ~\\.flv { flv; } location ~\\.mp4 { mp4; } } }rtmp { server { listen 1935; chunk_size 4096; application hls { allow publish 127.0.0.1; live on; hls on; hls_path /usr/local/nginx/html/hls; hls_fragment 5s; } }} nginx在docker运行需要关闭daemon选项. rtmp-&gt;server-&gt;application为具体的直播应用,hls是我的直播应用名称，可以根据实际情况修改。 启动服务器 1/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf 安装ffmpeg1apt-get install ffmpeg 推流测试推流地址1rtmp://localhost:1935/hls/demo hls为上面配置的application名称，demo是直播名称，客户端使用http://localhost/hls/demo.m3u8进行播放 视频推流1ffmpeg -re -i a.mp4 -vcodec copy -f flv rtmp://localhost:1935/hls/demo web中播放 1&lt;video src=&quot;http://localhost/hls/demo.m3u8&quot; controls&gt;&lt;/video&gt; 音频推流1ffmpeg -re -i a.mp3 -acodec aac -f flv rtmp://localhost:1935/hls/demo web中播放 1&lt;audio src=&quot;http://localhost/hls/demo.m3u8&quot; controls&gt;&lt;/audio&gt; 推流与播放地址说明 假设nginx配置http端口为80,http目录为hls,rtmp端口为1935,application名称为hls,需要播放的直播名称为demo 推流地址rtmp://localhost:1935/hls/demo 播放地址http://localhost/hls/demo.m3u8 重要说明如果没有直播推流，nginx是不会产生m3u8文件的，这点需要注意! Docker镜像地址https://github.com/xialeistudio/docker-nginx-rtmp","link":"/2017/11/23/2017-11-23-nginx-rtmp-server.html"},{"title":"微信H5点击跳转到关注页","text":"背景微信诱导关注接口在早两年已经被微信关停，但是一般的H5目的都是要关注公众号。目前用的多的方法是用公众号发表一篇文章，文章里面一般是一个GIF的箭头图片指向公众号关注。这种方法有点取巧。 今天要介绍的是另一种方法，感觉应该不会被微信封号。 起因有个朋友在segmentfault上发了一个链接出来，微信打开可以直接到关注页 1https://mp.weixin.qq.com/mp/profile_ext?action=home&amp;__biz=MzUzMDM3MjMyNQ==#wechat_redirect 条件反射发现MzUzMDM3MjMyNQ==是Base64编码后的参数，解码后是一段数字，然后我改了下数字，重新编码，再发送到微信，发现可以打开另外一个公众号的关注页 1https://mp.weixin.qq.com/mp/profile_ext?action=home&amp;__biz=MzUzMDM3MjMyNA==#wechat_redirect 所以只要知道那个公众号数字就可以构造链接进行关注，想着这种ID一般在公众平台有，果然被我找到了。 步骤 登录公众平台后台 点击右上角的公众号，来到公众号信息页面 查看公众号信息页面的源代码，在顶上找到以下代码 123window.wx={uin:&quot;xxxx&quot;||&quot;0&quot;}; xxxx 就是你的公众号数字ID 将第4步找到的ID进行base64编码 构造如下链接 1https://mp.weixin.qq.com/mp/profile_ext?action=home&amp;__biz=第5步的结果#wechat_redirect 发送到微信之后即可。 反思从打开的链接看页面还是蛮正式的，可能不是私有接口，但是微信文档中没说过这种方式，故使用本方式带来的后果请自行负责！","link":"/2017/11/25/2017-11-25-wechat-web-subscribe.html"},{"title":"golang可能导致内存泄漏的地方","text":"核心golang能够GC是程序声明的变量，而一些外部资源是不可以GC掉的，比如os.OpenFile打开的文件句柄，sql.Open打开的数据库连接句柄等资源。 开发中常用场景 http请求时resp.Body，刚开始写golang的时候，如果会用ioutil.readAll去读取resp.Body时会加上defer resp.Body.Close(),后来有json.NewDecoder().decode()时没有加，以为会自动关闭，没想到还是太天真了。不管什么情况都需要defer resp.Body.Close() sql查询时DB.Prepare，数据库查询操作会得到一个rows的资源，这个一般都关闭了，但是运行一段时间之后发现有内存泄漏，因为只用到了sql查询，所以只有数据库操作代码可以排查，尽快调试发现stmt也有Close方法，加上defer stmt.Close之后，内存稳定了。","link":"/2018/01/20/2018-01-20-golang-memory-leak.html"},{"title":"PHP实现“异步”","text":"众所周知，PHP不使用多线程扩展的情况下是不支持异步的(不算curl之类)。今天无意中看到一个函数fastcgi_finish_request;这个方法是PHP5.3+开始提供。注释写的很清楚，有耗时操作的时候使用该函数可以尽早结束fastcgi处理过程，提高页面响应速度。 代码说明12345&lt;?phpecho 1;fastcgi_finish_request();sleep(3);?&gt; 此时打开浏览器发现响应速度并没有受到sleep函数的影响，基于此点，可以在适当的时候使用该函数以提升用户体验! 注意事项PHP需要运行在fpm模式下才可以使用本函数。","link":"/2018/01/19/2018-01-20-php-async.html"},{"title":"头脑王者辅助","text":"头脑王者本项目仅作为学习anyproxy之用，请勿用于非法用途，否则后果自负 功能 题目爬取 答题匹配(如果题库不存在，请自行答题，系统会在答题后把正确答案自动录入数据库) 开始 安装mysql，新建数据库tnwz，建表语句 123456789101112CREATE TABLE tnwz.question( id int(11) PRIMARY KEY NOT NULL AUTO_INCREMENT, question varchar(100), a varchar(20), b varchar(20), c varchar(20), d varchar(20), answer int(11), createdAt datetime NOT NULL, updatedAt datetime NOT NULL); config.json为数据库配置 安装anyproxy =&gt; npm install anyproxy -g 生成证书anyproxy -i 手机接入代理，代理地址电脑IP:8001 题库获取 登录两个微信号获取到uid和token之后填入auth.json node question-fetcher.js,如果出现401，请重新登录 排位系统 npm run fight开启代理 手机接入代理 开始排位，终端会提示开始匹配，系统会将正确答案添加上### 适用系统 Android &amp;&amp; iOS iOS11.3 已通过测试 项目地址https://github.com/xialeistudio/tnwz","link":"/2018/01/30/2018-01-30-tnwz.html"},{"title":"golang限制协程数量","text":"为什么要限制协程数量golang的go关键字并发实在是太简单，但是带来的问题是由于硬件和网络状况的限制，不受控制的增加协程是非常危险的做法，甚至有可能搞垮数据库之类的应用! 而并发控制在go中是非常常用的技巧，以此文来记录一下学习历程。 原理由于channel的阻塞机制，通过设置缓冲channel的缓冲大小来控制同时执行的协程数量。 demo代码1234567891011121314151617181920212223package mainimport ( &quot;log&quot; &quot;time&quot;)func main() { start := time.Now() ch := make(chan int, 2) for i := 0; i &lt;= 10; i++ { ch &lt;- 1 go worker(i, ch) } close(ch) log.Println(&quot;complete&quot;, time.Since(start).Seconds())}// 模拟耗时操作func worker(i int, ch chan int) { log.Println(&quot;worker&quot;, i) time.Sleep(time.Second) &lt;-ch 运行1go run demo.ho 输出1234567891011122018/01/31 22:24:49 worker 12018/01/31 22:24:49 worker 02018/01/31 22:24:50 worker 22018/01/31 22:24:50 worker 32018/01/31 22:24:51 worker 42018/01/31 22:24:51 worker 52018/01/31 22:24:52 worker 62018/01/31 22:24:52 worker 72018/01/31 22:24:53 worker 82018/01/31 22:24:53 worker 92018/01/31 22:24:54 worker 102018/01/31 22:24:54 complete 5.01140112 结论可以看到日志的输出时间，每秒出现两个，正好等于我们make函数的大小，而总时间也是为10/2左右，证明限制起到了作用。 虽然本文写起来很简单，但是包含的技巧可以说大型程序仍然会用到。正所谓“万丈高楼平地起”。","link":"/2018/01/31/2018-01-31-goroutine-limit-demo.html"},{"title":"golang通用连接池的实现","text":"golang的channel除了goroutine通信之外还有很多其他的功能，本文将实现一种基于channel的通用连接池。 何为通用？连接池的实现不依赖具体的实例，而依赖某个接口，本文的连接池选用的是io.Closer接口，只要是实现了该接口的对象都可以被池管理。当然，你可以实现基于interface{}的连接池，这样任何对象都可以被管理。 实现原理将连接句柄存入channel中，由于缓存channel的特性，获取连接时如果池中有连接，将直接返回，如果池中没有连接，将阻塞或者新建连接（没超过最大限制的情况下）。由于面向接口编程，所有创建连接的逻辑是不清楚的，这里需要传入一个函数，该函数返回一个io.Closer对象。 实现由于并发问题，在需要操作池中互斥数据的时候需要加锁。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129package poolimport ( &quot;errors&quot; &quot;io&quot; &quot;sync&quot; &quot;time&quot;)var ( ErrInvalidConfig = errors.New(&quot;invalid pool config&quot;) ErrPoolClosed = errors.New(&quot;pool closed&quot;))type factory func() (io.Closer, error)type Pool interface { Acquire() (io.Closer, error) // 获取资源 Release(io.Closer) error // 释放资源 Close(io.Closer) error // 关闭资源 Shutdown() error // 关闭池}type GenericPool struct { sync.Mutex pool chan io.Closer maxOpen int // 池中最大资源数 numOpen int // 当前池中资源数 minOpen int // 池中最少资源数 closed bool // 池是否已关闭 maxLifetime time.Duration factory factory // 创建连接的方法}func NewGenericPool(minOpen, maxOpen int, maxLifetime time.Duration, factory factory) (*GenericPool, error) { if maxOpen &lt;= 0 || minOpen &gt; maxOpen { return nil, ErrInvalidConfig } p := &amp;GenericPool{ maxOpen: maxOpen, minOpen: minOpen, maxLifetime: maxLifetime, factory: factory, pool: make(chan io.Closer, maxOpen), } for i := 0; i &lt; minOpen; i++ { closer, err := factory() if err != nil { continue } p.numOpen++ p.pool &lt;- closer } return p, nil}func (p *GenericPool) Acquire() (io.Closer, error) { if p.closed { return nil, ErrPoolClosed } for { closer, err := p.getOrCreate() if err != nil { return nil, err } // todo maxLifttime处理 return closer, nil }}func (p *GenericPool) getOrCreate() (io.Closer, error) { select { case closer := &lt;-p.pool: return closer, nil default: } p.Lock() if p.numOpen &gt;= p.maxOpen { closer := &lt;-p.pool p.Unlock() return closer, nil } // 新建连接 closer, err := p.factory() if err != nil { p.Unlock() return nil, err } p.numOpen++ p.Unlock() return closer, nil}// 释放单个资源到连接池func (p *GenericPool) Release(closer io.Closer) error { if p.closed { return ErrPoolClosed } p.Lock() p.pool &lt;- closer p.Unlock() return nil}// 关闭单个资源func (p *GenericPool) Close(closer io.Closer) error { p.Lock() closer.Close() p.numOpen-- p.Unlock() return nil}// 关闭连接池，释放所有资源func (p *GenericPool) Shutdown() error { if p.closed { return ErrPoolClosed } p.Lock() close(p.pool) for closer := range p.pool { closer.Close() p.numOpen-- } p.closed = true p.Unlock() return nil} 结论基于该连接池，可以管理所有io.Closer对象。比如memcached,redis等等，非常方便！","link":"/2018/02/01/2018-02-01-golang-generic-pool.html"},{"title":"nodejs thrift多路复用客户端","text":"官网nodejs示例中只实现了服务端是单一service的情形，而对于服务端属于多个服务复用一个连接地址的例子却未实现。 查看thrift的nodejs库源码发现实际上还是支持的。以下来展示调用单一服务和多个服务的区别。 单一服务1234567891011121314var thrift = require('thrift');var Calculator = require('./gen-nodejs/Calculator');var ttypes = require('./gen-nodejs/tutorial_types');const assert = require('assert');var transport = thrift.TBufferedTransport;var protocol = thrift.TBinaryProtocol;var connection = thrift.createConnection(&quot;localhost&quot;, 9090, { transport : transport, protocol : protocol});var client = thrift.createClient(Calculator, connection);// 已经可以调用client方法 复用服务123456789101112131415var thrift = require('thrift');var Calculator = require('./gen-nodejs/Calculator');var ttypes = require('./gen-nodejs/tutorial_types');const assert = require('assert');var transport = thrift.TBufferedTransport;var protocol = thrift.TBinaryProtocol;var connection = thrift.createConnection(&quot;localhost&quot;, 9090, { transport : transport, protocol : protocol});const m = new thrift.Multiplexer(); // 关键const client = m.createClient('calculator', Calculator, connection); // calculator为服务端声明的服务名称// 已经可以调用client方法 经过测试，以上代码能与golang实现的服务端正常通信。","link":"/2018/02/08/2018-02-08-nodejs-thrift-multiple-client.html"},{"title":"golang使用CSV导出大量数据","text":"最近在做一个导出功能，最初是使用https://github.com/tealeg/xlsx做的，但是发现导出有个30W行的excel时，这玩意内存彪到700M+，后来发现只是导出数据为表格，并没有其他东西，于是打算使用CSV导出。 CSV格式简介CSV本质上是个文本文件，该文件有以下要求： 列之间用逗号分隔，行之间用换行分隔 单元格如果有逗号，引号之类的字符，该单元格需要使用双引号括起来 如果包含中文，需要使用GBK编码，否则会乱码 golang实现 UTF8转GBK函数(需要 go get golang.org/x/text/) 12345678func UTF82GBK(src string) (string, error) { reader := transform.NewReader(strings.NewReader(src), simplifiedchinese.GBK.NewEncoder()) if buf, err := ioutil.ReadAll(reader); err != nil { return &quot;&quot;, err } else { return string(buf), nil }} 导出代码 12345678910filename := &quot;test.csv&quot;fp, err := os.Create(filename) // 创建文件句柄if err != nil { return nil, err}defer fp.Close()columns := []string{&quot;姓名&quot;, &quot;电话&quot;, &quot;公司&quot;, &quot;职位&quot;, &quot;加入时间&quot;}if line, err := util.UTF82GBK(strings.Join(columns, &quot;,&quot;)); err == nil { // 写入一行 fp.WriteString(line + &quot;\\n&quot;)} \b其他语言也可以使用类似方法导出数据，只要满足CSV的几个条件即可。","link":"/2018/02/28/2018-02-28-golang-export-csv.html"},{"title":"Docker部署golang应用时时区问题","text":"目前golang用的基础镜像是busybox，由于golang交叉编译之后只有一个二进制文件，可以直接部署到容器中运行，容器镜像大小几乎等于二进制文件大小。 带来的问题由于基础镜像太过精简，目前遇到的问题是将时间戳格式化为时间字符串时发现差了8个小时。 尝试过的解决办法刚开始使用了Location时区相关API，但是部署到容器中发现直接报错了，因为容器中缺少相关的系统调用函数。代码如下： 12loc, _ := time.LoadLocation(&quot;Asia/Shanghai&quot;)time.Now().In(loc).Format(&quot;2006-01-02 15:04:05&quot;) 目前应用会部署到docker容器中，故处理办法比较原始，直接在Time对象上添加8个小时来解决时差问题。代码如下: 1time.Now().Add(time.Hour * 8).Format(&quot;2006年01月02日 15:04&quot;), 暂时解决了这个问题。","link":"/2018/03/01/2018-03-01-golang-docker-timezone.html"},{"title":"golang JSON编码时保留HTML标签","text":"golang默认编码JSON时会将HTML标签中的尖括号编码为\\u003c这种unicode字符。而最近在开发的微信客服消息推送就会出现以下结果 1\\u003ca href='https://www.example.com'\\u003e点击进入\\u003c/a\\u003e 查看golang的json包发现json编码器有个方法SetEscapeHTML方法，接收一个bool值来设置是否保留HTML标签。 问题json的Encoder只能编码到实现了io.Writer接口的对象中去，而本例中需要编码到一个[]byte切片中。 解决查找资料发现bytes.Buffer对象实现了io.Writer接口。所以最终代码如下： 12345678910func BuildJson(data map[string]interface{}) ([]byte, error) { buf := bytes.NewBufferString(&quot;&quot;) encoder := json.NewEncoder(buf) encoder.SetEscapeHTML(false) if err := encoder.Encode(&amp;data); err != nil { return nil, err } else { return buf.Bytes(), nil }} 经过测试，输出接口符合要求。","link":"/2018/03/01/2018-03-01-golang-json-no-escape-html.html"},{"title":"golang multipart上传文件到远端（如上传微信临时素材）","text":"最近在开发一个关注之后通过客服消息推送一张海报给用户的功能，海报图片是本地生成好的，需要上传到微信临时素材之后通过客服消息推送给用户。上传文件需要multipart/form-data格式的表单，所以golang默认的http.POST方法是实现不了的。需要自行实现body参数逻辑。 上传请求初始化12345678910111213141516171819202122232425262728// 新建上传请求func NewUploadRequest(link string, params map[string]string, name, path string) (*http.Request, error) { fp, err := os.Open(path) // 打开文件句柄 if err != nil { return nil, err } defer fp.Close() body := &amp;bytes.Buffer{} // 初始化body参数 writer := multipart.NewWriter(body) // 实例化multipart part, err := writer.CreateFormFile(name, filepath.Base(path)) // 创建multipart 文件字段 if err != nil { return nil, err } _, err = io.Copy(part, fp) // 写入文件数据到multipart for key, val := range params { _ = writer.WriteField(key, val) // 写入body中额外参数，比如七牛上传时需要提供token } err = writer.Close() if err != nil { return nil, err } req, err := http.NewRequest(&quot;POST&quot;, link, body) // 新建请求 if err != nil { return nil, err } req.Header.Set(&quot;Content-Type&quot;, &quot;multipart/form-data&quot;) // 设置请求头,!!!非常重要，否则远端无法识别请求 return req, nil} 上传流程1234567891011121314151617181920212223242526272829303132333435func (m *Task) upload(appid string) (string, error) { filename, err := m.download() // 下载远端海报文件到本地路径 if err != nil { return &quot;&quot;, err } // 获取accessToken accessToken, err := m.passport.GetAccessToken(appid) if err != nil { return &quot;&quot;, err } params := &amp;url.Values{ &quot;access_token&quot;: []string{accessToken}, &quot;type&quot;: []string{&quot;image&quot;}, } req, err := util.NewUploadRequest(&quot;https://api.weixin.qq.com/cgi-bin/media/upload?&quot;+params.Encode(), nil, &quot;media&quot;, filename) // 上传到微信 if err != nil { return &quot;&quot;, err } resp, err := http.DefaultClient.Do(req) if err != nil { return &quot;&quot;, err } defer resp.Body.Close() ret := make(map[string]interface{}) if err := json.NewDecoder(resp.Body).Decode(&amp;ret); err != nil { return &quot;&quot;, err } if mediaId, ok := ret[&quot;media_id&quot;]; ok { return mediaId.(string), nil } else if errmsg, ok := ret[&quot;errmsg&quot;]; ok { return &quot;&quot;, errors.New(errmsg.(string)) } else { return &quot;&quot;, errors.New(&quot;上传失败&quot;) }}","link":"/2018/03/01/2018-03-01-golang-upload.html"},{"title":"golang解决TCP粘包问题","text":"什么是TCP粘包问题以及为什么会产生TCP粘包，本文不加讨论。本文使用golang的bufio.Scanner来实现自定义协议解包。 协议数据包定义本文模拟一个日志服务器，该服务器接收客户端传到的数据包并显示出来 12345678910type Package struct { Version [2]byte // 协议版本，暂定V1 Length int16 // 数据部分长度 Timestamp int64 // 时间戳 HostnameLength int16 // 主机名长度 Hostname []byte // 主机名 TagLength int16 // 标签长度 Tag []byte // 标签 Msg []byte // 日志数据} 协议定义部分没有什么好讲的，根据具体的业务逻辑定义即可。 数据打包由于TCP协议是语言无关的协议，所以直接把协议数据包结构体发送到TCP连接中也是不可能的，只能发送字节流数据，所以需要自己实现数据编码。所幸golang提供了binary来帮助我们实现网络字节编码。 123456789101112func (p *Package) Pack(writer io.Writer) error { var err error err = binary.Write(writer, binary.BigEndian, &amp;p.Version) err = binary.Write(writer, binary.BigEndian, &amp;p.Length) err = binary.Write(writer, binary.BigEndian, &amp;p.Timestamp) err = binary.Write(writer, binary.BigEndian, &amp;p.HostnameLength) err = binary.Write(writer, binary.BigEndian, &amp;p.Hostname) err = binary.Write(writer, binary.BigEndian, &amp;p.TagLength) err = binary.Write(writer, binary.BigEndian, &amp;p.Tag) err = binary.Write(writer, binary.BigEndian, &amp;p.Msg) return err} Pack方法的输出目标为io.Writer，有利于接口扩展，只要实现了该接口即可编码数据写入。binary.BigEndian是字节序，本文暂时不讨论，有需要的读者可以自行查找资料研究。 数据解包解包需要将TCP数据包解析到结构体中，接下来会讲为什么需要添加几个数据无关的长度字段。 123456789101112131415func (p *Package) Unpack(reader io.Reader) error { var err error err = binary.Read(reader, binary.BigEndian, &amp;p.Version) err = binary.Read(reader, binary.BigEndian, &amp;p.Length) err = binary.Read(reader, binary.BigEndian, &amp;p.Timestamp) err = binary.Read(reader, binary.BigEndian, &amp;p.HostnameLength) p.Hostname = make([]byte, p.HostnameLength) err = binary.Read(reader, binary.BigEndian, &amp;p.Hostname) err = binary.Read(reader, binary.BigEndian, &amp;p.TagLength) p.Tag = make([]byte, p.TagLength) err = binary.Read(reader, binary.BigEndian, &amp;p.Tag) p.Msg = make([]byte, p.Length-8-2-p.HostnameLength-2-p.TagLength) err = binary.Read(reader, binary.BigEndian, &amp;p.Msg) return err} 由于主机名、标签这种数据是不固定长度的，所以需要两个字节来标识数据长度，否则读取的时候只知道一个总的数据长度是无法区分主机名、标签名、日志数据的。 数据包的粘包问题解决上文只是解决了编码/解码问题，前提是收到的数据包没有产生粘包问题，解决粘包就是要正确分割字节流中的数据。一般有以下做法： 定长分隔(每个数据包最大为该长度) 缺点是数据不足时会浪费传输资源 特定字符分隔(如\\r\\n) 缺点是如果正文中有\\r\\n就会导致问题 在数据包中添加长度字段(本文采用的) golang提供了bufio.Scanner来解决粘包问题。 12345678910111213141516171819scanner := bufio.NewScanner(reader) // reader为实现了io.Reader接口的对象，如net.Connscanner.Split(func(data []byte, atEOF bool) (advance int, token []byte, err error) { if !atEOF &amp;&amp; data[0] == 'V' { // 由于我们定义的数据包头最开始为两个字节的版本号，所以只有以V开头的数据包才处理 if len(data) &gt; 4 { // 如果收到的数据&gt;4个字节(2字节版本号+2字节数据包长度) length := int16(0) binary.Read(bytes.NewReader(data[2:4]), binary.BigEndian, &amp;length) // 读取数据包第3-4字节(int16)=&gt;数据部分长度 if int(length)+4 &lt;= len(data) { // 如果读取到的数据正文长度+2字节版本号+2字节数据长度不超过读到的数据(实际上就是成功完整的解析出了一个包) return int(length) + 4, data[:int(length)+4], nil } } } return})// 打印接收到的数据包for scanner.Scan() { scannedPack := new(Package) scannedPack.Unpack(bytes.NewReader(scanner.Bytes())) log.Println(scannedPack)} 本文的核心就在于scanner.Split方法，该方法用来解析TCP数据包 完整源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109package mainimport ( &quot;bufio&quot; &quot;bytes&quot; &quot;encoding/binary&quot; &quot;fmt&quot; &quot;io&quot; &quot;log&quot; &quot;os&quot; &quot;time&quot;)type Package struct { Version [2]byte // 协议版本 Length int16 // 数据部分长度 Timestamp int64 // 时间戳 HostnameLength int16 // 主机名长度 Hostname []byte // 主机名 TagLength int16 // Tag长度 Tag []byte // Tag Msg []byte // 数据部分长度}func (p *Package) Pack(writer io.Writer) error { var err error err = binary.Write(writer, binary.BigEndian, &amp;p.Version) err = binary.Write(writer, binary.BigEndian, &amp;p.Length) err = binary.Write(writer, binary.BigEndian, &amp;p.Timestamp) err = binary.Write(writer, binary.BigEndian, &amp;p.HostnameLength) err = binary.Write(writer, binary.BigEndian, &amp;p.Hostname) err = binary.Write(writer, binary.BigEndian, &amp;p.TagLength) err = binary.Write(writer, binary.BigEndian, &amp;p.Tag) err = binary.Write(writer, binary.BigEndian, &amp;p.Msg) return err}func (p *Package) Unpack(reader io.Reader) error { var err error err = binary.Read(reader, binary.BigEndian, &amp;p.Version) err = binary.Read(reader, binary.BigEndian, &amp;p.Length) err = binary.Read(reader, binary.BigEndian, &amp;p.Timestamp) err = binary.Read(reader, binary.BigEndian, &amp;p.HostnameLength) p.Hostname = make([]byte, p.HostnameLength) err = binary.Read(reader, binary.BigEndian, &amp;p.Hostname) err = binary.Read(reader, binary.BigEndian, &amp;p.TagLength) p.Tag = make([]byte, p.TagLength) err = binary.Read(reader, binary.BigEndian, &amp;p.Tag) p.Msg = make([]byte, p.Length-8-2-p.HostnameLength-2-p.TagLength) err = binary.Read(reader, binary.BigEndian, &amp;p.Msg) return err}func (p *Package) String() string { return fmt.Sprintf(&quot;version:%s length:%d timestamp:%d hostname:%s tag:%s msg:%s&quot;, p.Version, p.Length, p.Timestamp, p.Hostname, p.Tag, p.Msg, )}func main() { hostname, err := os.Hostname() if err != nil { log.Fatal(err) } pack := &amp;Package{ Version: [2]byte{'V', '1'}, Timestamp: time.Now().Unix(), HostnameLength: int16(len(hostname)), Hostname: []byte(hostname), TagLength: 4, Tag: []byte(&quot;demo&quot;), Msg: []byte((&quot;现在时间是:&quot; + time.Now().Format(&quot;2006-01-02 15:04:05&quot;))), } pack.Length = 8 + 2 + pack.HostnameLength + 2 + pack.TagLength + int16(len(pack.Msg)) buf := new(bytes.Buffer) // 写入四次，模拟TCP粘包效果 pack.Pack(buf) pack.Pack(buf) pack.Pack(buf) pack.Pack(buf) // scanner scanner := bufio.NewScanner(buf) scanner.Split(func(data []byte, atEOF bool) (advance int, token []byte, err error) { if !atEOF &amp;&amp; data[0] == 'V' { if len(data) &gt; 4 { length := int16(0) binary.Read(bytes.NewReader(data[2:4]), binary.BigEndian, &amp;length) if int(length)+4 &lt;= len(data) { return int(length) + 4, data[:int(length)+4], nil } } } return }) for scanner.Scan() { scannedPack := new(Package) scannedPack.Unpack(bytes.NewReader(scanner.Bytes())) log.Println(scannedPack) } if err := scanner.Err(); err != nil { log.Fatal(&quot;无效数据包&quot;) }} 写在最后golang作为一门强大的网络编程语言，实现自定义协议是非常重要的，实际上实现自定义协议也不是很难，以下几个步骤： 数据包编码 数据包解码 处理TCP粘包问题 断线重连(可以使用心跳实现)(非必须)","link":"/2018/03/02/2018-03-02-golang-tcp-stick-package.html"},{"title":"golang for遍历channel时需要注意的问题","text":"最近在做一个基于RabbitMQ的应用，由于官方的qos没有golang的版本，所以出了一点问题。问题代码如下： 1234567891011121314151617_, ch, err := component.NewRabbitMQ()if err != nil { panic(err)}if err := ch.Qos(10, 0, true); err != nil { panic(err)}msgs, err := ch.Consume(&quot;push&quot;, &quot;&quot;, false, false, false, false, nil)if err != nil { panic(err)}for m := range msgs { go func(d *amqp.Delivery) { defer func() { d.Ack(false) } // 处理消息 }(&amp;m) } 发现消费到10条消息，进程就退出了，但是exit code为0，表示系统是正常退出，由于做了日志记录可以确定消费了10条，所以初步确定是qos相关问题。 排查过程 首先是把d的tag打印出来，发现全部是一样的，可以确定是重复的一条消息 一开始想到可能是经典的go协程执行在for循环结束以后导致的，但是看我的代码不属于这种情况，有使用&amp;m保证每一条消息都是不同循环传入的。所以判断可能是for循环的传递问题。 确定方向之后开始写了一个测试项目用来验证我的想法是否正确。 测试代码1234567891011121314package mainimport &quot;fmt&quot;func main() { ch := make(chan int, 10) for i := 0; i &lt; 10; i++ { ch &lt;- i } close(ch) for v := range ch { fmt.Println(&amp;v) }} 执行输出 123456789100xc4200860080xc4200860080xc4200860080xc4200860080xc4200860080xc4200860080xc4200860080xc4200860080xc4200860080xc420086008 到这里才焕然大悟，for循环中，如果循环变量不是指针，那么每次的变量是同一个，不过值变了。，所以上例中的RabbitMQ go协程消费消息那里，需要直接传递值而不是指针，经过测试之后发现，问题确实解决了。 题外话测试代码那里，如果不close掉channel是会发生死锁的，原因是 当for循环读完channel的10个值之后会继续尝试读取下一个，而由于channel为空又没关闭，会一直阻塞形成死锁 TOOD研究RabbitMQ Consumer部分的源码来看看消费channel被关闭的问题。","link":"/2018/04/05/2018-04-05-golang-for-over-channels.html"},{"title":"golang使用travis进行持续集成","text":"虽然golang的工程工具已经非常完善了，比如测试、代码格式化等等。但是如果开发library开源到github的话，这些东西是可以使用自动化工具完成的，那就是 travis 使用步骤 开发好需要集成的library以及测试用例 在项目根目录新建.travis.yml文件 12345678language: gogo:- 1.x- '1.8'- '1.9'- 1.10.xscript:- go test -v ./... 提交到github 打开https://www.travis-ci.org/并使用github账号登录 登录之后点击左边 “My Repositories” 旁边的 “+” 号添加项目（点击项目前面的滑块即可） 更改项目文件，push一次到github，此时travis会自动运行测试脚本 敏感数据加密如果你的测试用例需要使用到敏感数据（如一些密钥等等），那需要用travis将你的敏感数据加密(以Mac为例) 终端执行sudo gem install travis 在项目根目录打开终端执行travis encrypt AMAP_KEY=&quot;xxxx&quot; --add AMAP_KEY是环境变量名称，程序读取环境变量可以得到真实的key，xxxx是敏感数据 执行完毕后，**.travis.yml** 会发生更改, 会添加如下内容(secure可能不一致) 123env:global: secure: kr5JHNTYsh/jezvk88qP91arb+UD/op/5CyOFY7uNYpJ6ZSsJY5fDKyZHjf0VSFmaYqJFMPl6uCASE9baiepeGvBFcy8aI9CNsbLzj2uBNjqqYPmvYGnBjpzp8yknVJKRTitF/kkWtzZcWImHnpvNGHuzXxp/EIBeJtNwjcCRoP/qfGhlZKbLsYFvlWkmRYb0dr8RM5mlmGXPZi8q7m+soVRO8Zjr4QQccybgmhonxlcUrHr6ro+yjjQefoJXRufqoRX0sGyecGYucC4nUpWl5hkDPkQE+Mekhz+rF657SwNsn8nXOFnnUuwsPXE26ak5xF1roEcFk2CpwGZuT7smJZPtw1inXFdIaW+4qllbyxMJkylvFZa5IcvLT3+/eKaQc8Fg6PoxJH0PF3RdtoQVB31cQiPWNm1SecQ6wC64WA/5qN4T5OoRfpt60BFDAITdS62dQGu5LSepcXMWXhxCdQPeDm5Qce6wjJXURubJMpBm0mPWwCNZhJyRw1G5TTyO25NckXQRlObrjltvwAd+7OEUcsYXqhdPtUTIVy6w3XOwT2eC/hP0Yi7qqUMMlJTHUW7Lb9zsEc4UB5BVwgeZ5Y9bVbknJfpt3ygcXAJeeDYxwV9g16KoS7HMFPzwrqlHbiBytIahqarBd4enwqR5RYQPEyetiIDLaJA4SyQ0cE= 上传到github 接收测试结果通知如果你需要获取travis执行结果通知的话，可以添加邮箱配置，travis执行完毕后会通知到该邮箱。 打开 .travis.yml 添加以下内容：123456notifications: email: recipients: - 邮箱地址 on_success: change on_failure: always 提交到github","link":"/2018/04/08/2018-04-08-golang-travis-ci.html"},{"title":"使用yii2依赖注入规范业务开发","text":"本文代码https://github.com/xialeistudio/yii2-di-demo 什么是依赖注入(DI)?对象由框架来创建而不是程序员通过 new 创建。跟IoC差不多一个意思。 为什么要有依赖注入? 解耦。调用方不再通过 new 运算符实例化被调用对象，而通过框架(IoC容器)创建之后注入进来。解除了调用者与被调用者之间的依赖。 有利于面向接口编程。个人认为OOP程序设计最重要的就是面向接口(面向抽象)编程。因为有了第1步的关系，调用者只需要依赖接口类型而不用依赖实现类型，提高了程序的扩展性。 Yii2的依赖注入Yii2通过 yii\\di\\Container 提供DI容器特性。目前支持一下4种方式注入： 构造方法注入 方法注入 Setter和属性注入 PHP回调注入 注册依赖关系 通过容器的 set 方法注入 通过配置文件注入(推荐) 依赖注入实战 打开终端，执行以下命令初始化项目： 1composer create-project --prefer-dist yiisoft/yii2-app-basic basic 声明接口业务类 app\\services\\UserService 123456789101112131415161718192021222324252627282930&lt;?php/*** Created by PhpStorm.* User: xialei* Date: 2018/4/24* Time: 下午10:55*/namespace app\\services;/*** 用户业务类* Interface UserService* @package app\\services*/interface UserService{ /** * 根据ID查询用户 * @param integer $id * @return array|null */ public function show($id); /** * 查看所有用户 * @return array */ public function all();} 接口实现文件 app\\services\\impl\\UserServiceImpl 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?php/*** Created by PhpStorm.* User: xialei* Date: 2018/4/24* Time: 下午10:56*/namespace app\\services\\impl;use app\\services\\UserService;class UserServiceImpl implements UserService{ private $users = [ ['id' =&gt; 1, 'name' =&gt; 'xialei'], ['id' =&gt; 2, 'name' =&gt; 'zhangsan'], ]; /** * 根据ID查询用户 * @param integer $id * @return array */ public function show($id) { foreach ($this-&gt;users as $user) { if ($user['id'] == $id) { return $user; } } return null; } /** * 查看所有用户 * @return array */ public function all() { return $this-&gt;users; }} 注册依赖关系 config/web.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?phpuse app\\services\\UserService;use app\\services\\impl\\UserServiceImpl;$params = require __DIR__ . '/params.php';$db = require __DIR__ . '/db.php';$config = [ 'id' =&gt; 'basic', 'basePath' =&gt; dirname(__DIR__), 'bootstrap' =&gt; ['log'], 'aliases' =&gt; [ '@bower' =&gt; '@vendor/bower-asset', '@npm' =&gt; '@vendor/npm-asset', ], 'container' =&gt; [ 'definitions' =&gt; [ UserService::class =&gt; UserServiceImpl::class ] ], 'components' =&gt; [ 'request' =&gt; [ // !!! insert a secret key in the following (if it is empty) - this is required by cookie validation 'cookieValidationKey' =&gt; '0xGrStOOZE2oXxNNiu-o2eYovJ_Ia1Dk', ], 'response' =&gt; [ 'format' =&gt; 'json' ], 'errorHandler' =&gt; [ 'errorAction' =&gt; 'site/error', ], 'urlManager' =&gt; [ 'enablePrettyUrl' =&gt; true, 'showScriptName' =&gt; false, 'rules' =&gt; [ ], ], ],];if (YII_ENV_DEV) { // configuration adjustments for 'dev' environment $config['bootstrap'][] = 'debug'; $config['modules']['debug'] = [ 'class' =&gt; 'yii\\debug\\Module', // uncomment the following to add your IP if you are not connecting from localhost. //'allowedIPs' =&gt; ['127.0.0.1', '::1'], ]; $config['bootstrap'][] = 'gii'; $config['modules']['gii'] = [ 'class' =&gt; 'yii\\gii\\Module', // uncomment the following to add your IP if you are not connecting from localhost. //'allowedIPs' =&gt; ['127.0.0.1', '::1'], ];}return $config; 添加控制器 app\\controllers\\UserController 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?php/*** Created by PhpStorm.* User: xialei* Date: 2018/4/24* Time: 下午10:57*/namespace app\\controllers;use app\\services\\UserService;use yii\\base\\Module;use yii\\web\\Controller;use yii\\web\\NotFoundHttpException;class UserController extends Controller{ private $userService; public function __construct(string $id, Module $module, UserService $userService, array $config = []) { $this-&gt;userService = $userService; parent::__construct($id, $module, $config); } /** * 查看用户 * @param $id * @return array|null * @throws NotFoundHttpException */ public function actionShow($id) { $user = $this-&gt;userService-&gt;show($id); if (empty($user)) { throw new NotFoundHttpException('用户不存在'); } return $user; } /** * 查看所有用户 * @return array */ public function actionAll() { return $this-&gt;userService-&gt;all(); }} 运行测试服务器 1./yii serve/index 访问用户列表接口 http://localhost:8080/user/all 1234567[{ &quot;id&quot;: 1, &quot;name&quot;: &quot;xialei&quot;}, { &quot;id&quot;: 2, &quot;name&quot;: &quot;zhangsan&quot;}] 访问查看用户接口 http://localhost:8080/user/show?id=1 1234{ &quot;id&quot;: 1, &quot;name&quot;: &quot;xialei&quot;} 写在最后如你所见，Yii2自带的IoC容器使用起来还是挺方便的，观测了Yii 配置优于编码 的思想，Yii的组件基本上都可以在配置文件中进行配置而不需要手动编码。 灵活使用DI可以使我们从依赖关系中解脱出来，专注于业务逻辑。 当然，业务逻辑的组织也是一个很大的研究课题，\b有兴趣的可以去看看 DDD\b(\b领域驱动设计)","link":"/2018/04/24/2018-04-24-yii2-dependency-inject.html"},{"title":"PermissionScope Swift4 兼容问题","text":"PermissionScope是iOS非常好用的权限处理库，界面效果也非常精美。不幸的是作者已经停止维护。 PermissionScope is no longer supported. Please use an alternative if you need updates for newer iOS 10 and 11 APIs! 问题的来源因为作者是基于Swift3开发的，而4.0的@selector语法有一点调整，所以是不能通过编译的，处理办法是根据Xcode的提示一个个修正。 可是事情真的这么简单吗？Xcode处理过后虽然编译通过了，但是会触发运行时错误。错误内容大致是调用了不存在的方法。 解决方案由于我们根据Xcode的提示给相关代码加了@objc，但是有些方法是没有加的，而这些方法类似下面的代码： 123func requestCamera() {} 由于没有@objc修饰，@selector指令找不到方法，所以就报错了。解决方案如下： 1234@objcfunc requestCamera() {}","link":"/2018/06/14/2018-06-14-PermissionScope-With-Swift-4.html"},{"title":"redis常用实践","text":"Redis相信大家都不陌生，而如果只是用来取代memcached做缓存的话，实在是大材小用了。一起来看看生产环境下的常用用法。 分布式锁1234$canLock = $redis-&gt;set('k', 1, 'NX', 'EX', 2);if($canLock) { // 获得锁成功} 锁定键名为k的数据两秒钟，两秒后该方法才能重新获取锁 1$redis-&gt;del('k'); 删除键名为k的数据，其他方法可以重新获取锁 Hash这是redis特有的数据结构，memcached没有。使用场景很多，列举一种常用的，假设有一个需求 加密后的用户id和真实用户id的映射关系保存 这种情况我们可以使用hash，而不是使用多个kv缓存, 需要清空所有的时候比较难处理。代码如下： 123456$realId = $redis-&gt;hget('user_id_map', 'userId1');if(!empty($realId)) { return $realId;}$realId = getFromDatabase('userId1'); // 从数据库读取$redis-&gt;hset('user_id_map','userId1',$realId); 如果需要清空，则直接删除hash即可。 setset就是数据项不重复的集合，使用场景也很多。例子要说的是使用set存储一个聊天室中的所有用户id: 123$redis-&gt;sadd('chat_room', 'user1', 'user2'); // 添加成员到集合$redis-&gt;srem('chat_room', 'user1'); // 删除指定成员$redis-&gt;smembers('chat_room'); // 获取集合所有元素 结论 大致就是这样了，基于这些简单数据结构可以根据业务需求构造更合理的数据结构。","link":"/2018/06/14/2018-06-14-redis-common-practice.html"},{"title":"不到20行代码实现golang路由调度","text":"项目地址go-dispatcher 本项目依赖使用标准库实现，无额外依赖 为什么需要路由调度层 golang http标准库只能精确匹配请求的URI，然后执行handler。现在一般web项目都至少有个Controller层，以struct实现，根据不同的请求路径派发到不同的方法中去。 路由调度器定义由于golang暂时还不可以动态创建对象(比如java的Class.forName(&quot;xxx&quot;).newInstance(),xxx是任意存在的class名称)。所以需要手动注册一下controller关系。 定义routes保存controller指针 解析请求过来的URL查询参数，暂定a为action名称,c为controller名称，本文偷了下懒，没对PATH_INFO做处理，也没有对actionName的首字母自动大写，这个不影响本文要传达的核心内容，有兴趣的读者可以自行实现。 根据URL中的controllerName找到对应的controller 使用反射将当前请求对象的*http.Request和http.ResponseWriter设置到该Controller 使用反射以及actionName对应该controller的方法 由于golang的继承不是一般的OOP，所以也没有父子类这种说法，路由注册那里只能使用interface{} 代码实现app/app.go该文件为核心调度文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package appimport ( &quot;net/http&quot; &quot;reflect&quot; &quot;fmt&quot;)type application struct { routes map[string]interface{}}func New() *application { return &amp;application{ routes: make(map[string]interface{}), }}func (p *application) ServeHTTP(w http.ResponseWriter, r *http.Request) { controllerName := r.URL.Query().Get(&quot;c&quot;) actionName := r.URL.Query().Get(&quot;a&quot;) if controllerName == &quot;&quot; || actionName == &quot;&quot; { http.Error(w, http.StatusText(http.StatusBadRequest), http.StatusBadRequest) return } route, ok := p.routes[controllerName] if !ok { http.Error(w, &quot;Controller Not Found&quot;, http.StatusNotFound) return } ele := reflect.ValueOf(route).Elem() ele.FieldByName(&quot;Request&quot;).Set(reflect.ValueOf(r)) ele.FieldByName(&quot;Response&quot;).Set(reflect.ValueOf(w)) ele.MethodByName(actionName).Call([]reflect.Value{})}func (p *application) printRoutes() { for route, controller := range p.routes { ele := reflect.ValueOf(controller).Type().String() fmt.Printf(&quot;%s %s\\n&quot;, route, ele) }}func (p *application) Get(route string, controller interface{}) { p.routes[route] = controller}func (p *application) Run(addr string) error { p.printRoutes() fmt.Printf(&quot;listen on %s\\n&quot;, addr) return http.ListenAndServe(addr, p)} app/controller.go控制器”基类” 12345678package appimport &quot;net/http&quot;type Controller struct { Response http.ResponseWriter Request *http.Request} controller/site.go具体业务逻辑类 1234567891011121314package controllersimport ( &quot;fmt&quot; &quot;app&quot;)type SiteController struct { app.Controller}func (p SiteController) Index() { fmt.Fprint(p.Response, p.Request.RequestURI)} main.go入口文件 12345678910111213package mainimport ( _ &quot;github.com/go-sql-driver/mysql&quot; &quot;app&quot; &quot;controllers&quot;)func main() { application := app.New() application.Get(&quot;site&quot;, &amp;controllers.SiteController{}) application.Run(&quot;:8080&quot;)} 运行项目 启动进程 访问http://localhost:8080?c=site&amp;a=Index会输出/?c=site&amp;a=Index 写在最后希望这个小小的项目能启发到各位读者，早日开发出适合自己的Web框架!","link":"/2018/07/23/2018-07-23-golang-route-dispatcher.html"},{"title":"golang不到30行代码实现依赖注入","text":"项目地址go-di-demo 本项目依赖使用标准库实现，无额外依赖 依赖注入的优势用java的人对于spring框架一定不会陌生，spring核心就是一个IoC(控制反转/依赖注入)容器，带来一个很大的优势是解耦。一般只依赖容器，而不依赖具体的类，当你的类有修改时，最多需要改动一下容器相关代码，业务代码并不受影响。 golang的依赖注入原理总的来说和java的差不多，步骤如下：(golang不支持动态创建对象，所以需要先手动创建对象然后注入，java可以直接动态创建对象) 通过反射读取对象的依赖(golang是通过tag实现) 在容器中查找有无该对象实例 如果有该对象实例或者创建对象的工厂方法，则注入对象或使用工厂创建对象并注入 如果无该对象实例，则报错 代码实现一个典型的容器实现如下，依赖类型参考了spring的singleton/prototype，分别对象单例对象和实例对象: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135package diimport ( &quot;sync&quot; &quot;reflect&quot; &quot;fmt&quot; &quot;strings&quot; &quot;errors&quot;)var ( ErrFactoryNotFound = errors.New(&quot;factory not found&quot;))type factory = func() (interface{}, error)// 容器type Container struct { sync.Mutex singletons map[string]interface{} factories map[string]factory}// 容器实例化func NewContainer() *Container { return &amp;Container{ singletons: make(map[string]interface{}), factories: make(map[string]factory), }}// 注册单例对象func (p *Container) SetSingleton(name string, singleton interface{}) { p.Lock() p.singletons[name] = singleton p.Unlock()}// 获取单例对象func (p *Container) GetSingleton(name string) interface{} { return p.singletons[name]}// 获取实例对象func (p *Container) GetPrototype(name string) (interface{}, error) { factory, ok := p.factories[name] if !ok { return nil, ErrFactoryNotFound } return factory()}// 设置实例对象工厂func (p *Container) SetPrototype(name string, factory factory) { p.Lock() p.factories[name] = factory p.Unlock()}// 注入依赖func (p *Container) Ensure(instance interface{}) error { elemType := reflect.TypeOf(instance).Elem() ele := reflect.ValueOf(instance).Elem() for i := 0; i &lt; elemType.NumField(); i++ { // 遍历字段 fieldType := elemType.Field(i) tag := fieldType.Tag.Get(&quot;di&quot;) // 获取tag diName := p.injectName(tag) if diName == &quot;&quot; { continue } var ( diInstance interface{} err error ) if p.isSingleton(tag) { diInstance = p.GetSingleton(diName) } if p.isPrototype(tag) { diInstance, err = p.GetPrototype(diName) } if err != nil { return err } if diInstance == nil { return errors.New(diName + &quot; dependency not found&quot;) } ele.Field(i).Set(reflect.ValueOf(diInstance)) } return nil}// 获取需要注入的依赖名称func (p *Container) injectName(tag string) string { tags := strings.Split(tag, &quot;,&quot;) if len(tags) == 0 { return &quot;&quot; } return tags[0]}// 检测是否单例依赖func (p *Container) isSingleton(tag string) bool { tags := strings.Split(tag, &quot;,&quot;) for _, name := range tags { if name == &quot;prototype&quot; { return false } } return true}// 检测是否实例依赖func (p *Container) isPrototype(tag string) bool { tags := strings.Split(tag, &quot;,&quot;) for _, name := range tags { if name == &quot;prototype&quot; { return true } } return false}// 打印容器内部实例func (p *Container) String() string { lines := make([]string, 0, len(p.singletons)+len(p.factories)+2) lines = append(lines, &quot;singletons:&quot;) for name, item := range p.singletons { line := fmt.Sprintf(&quot; %s: %x %s&quot;, name, &amp;item, reflect.TypeOf(item).String()) lines = append(lines, line) } lines = append(lines, &quot;factories:&quot;) for name, item := range p.factories { line := fmt.Sprintf(&quot; %s: %x %s&quot;, name, &amp;item, reflect.TypeOf(item).String()) lines = append(lines, line) } return strings.Join(lines, &quot;\\n&quot;)} 最重要的是Ensure方法，该方法扫描实例的所有export字段，并读取di标签，如果有该标签则启动注入。 判断di标签的类型来确定注入singleton或者prototype对象 测试 单例对象在整个容器中只有一个实例，所以不管在何处注入，获取到的指针一定是一样的。 实例对象是通过同一个工厂方法创建的，所以每个实例的指针不可以相同。 下面是测试入口代码，完整代码在github仓库，有兴趣的可以翻阅： 12345678910111213141516171819202122232425262728293031package mainimport ( &quot;di&quot; &quot;database/sql&quot; &quot;fmt&quot; &quot;os&quot; _ &quot;github.com/go-sql-driver/mysql&quot; &quot;demo&quot;)func main() { container := di.NewContainer() db, err := sql.Open(&quot;mysql&quot;, &quot;root:root@tcp(localhost)/sampledb&quot;) if err != nil { fmt.Printf(&quot;error: %s\\n&quot;, err.Error()) os.Exit(1) } container.SetSingleton(&quot;db&quot;, db) container.SetPrototype(&quot;b&quot;, func() (interface{}, error) { return demo.NewB(), nil }) a := demo.NewA() if err := container.Ensure(a); err != nil { fmt.Println(err) return } // 打印指针，确保单例和实例的指针地址 fmt.Printf(&quot;db: %p\\ndb1: %p\\nb: %p\\nb1: %p\\n&quot;, a.Db, a.Db1, &amp;a.B, &amp;a.B1)} 执行之后打印出来的结果为： 1234db: 0xc4200b6140db1: 0xc4200b6140b: 0xc4200a0330b1: 0xc4200a0338 可以看到两个db实例的指针一样，说明是同一个实例，而两个b的指针不同，说明不是一个实例。 写在最后通过依赖注入可以很好的管理多个对象之间的实例化以及依赖关系，配合配置文件在应用初始化阶段将需要注入的实例注册到容器中，在应用的任何地方只需要在实例化时注入容器即可。没有额外依赖。","link":"/2018/07/24/2018-07-24-golang-dependency-inject-container.html"},{"title":"golang40行代码实现通用协程池","text":"代码仓库goroutine-pool golang 的协程管理golang 协程机制很方便的解决了并发编程的问题，但是协程并不是没有开销的，所以也需要适当限制一下数量。 不使用协程池的代码(示例代码使用 chan 实现，代码略啰嗦)123456789101112131415161718192021222324252627func (p *converter) upload(bytes [][]byte) ([]string, error) { ch := make(chan struct{}, 4) wg := &amp;sync.WaitGroup{} wg.Add(len(bytes)) ret := make([]string, len(bytes)) // 上传 for index, item := range bytes { ch &lt;- struct{}{} go func(index int, imageData []byte) { defer func() { wg.Done() &lt;-ch }() link, err := qiniu.UploadBinary(imageData, fmt.Sprintf(&quot;%d.png&quot;, time.Now().UnixNano())) if err != nil { log.Println(&quot;上传图片失败&quot;, err.Error()) return } ret[index] = link }(index, item) } wg.Wait() return ret, nil} 需要实现的需求有两个: 限制最大协程数，本例为 4 等待所有协程完成，本例为bytes切片长度 使用协程池的代码1234567891011121314151617181920func (p *converter) upload(bytes [][]byte) ([]string, error) { ret := make([]string, len(bytes)) pool := goroutine_pool.New(4, len(bytes)) for index, item := range bytes { index := index item := item pool.Submit(func() { link, err := qiniu.UploadBinary(item, fmt.Sprintf(&quot;%d.png&quot;, time.Now().UnixNano())) if err != nil { log.Println(&quot;上传图片失败&quot;, err.Error()) return } ret[index] = link }) } pool.Wait() return ret, nil} 可以看到最大的区别是只需要关注业务逻辑即可，并发控制和等待都已经被协程池接管 写在最后希望本文能减轻你控制协程的负担","link":"/2018/08/08/2018-08-08-golang-general-goroutine-pool.html"},{"title":"io.Reader游标引发的血案","text":"#背景线上运行了一个图片合成程序，默认的小程序二维码中奖是小程序LOGO，不满足需求，所以将微信小程序二维码和用户头像合成在一张图片。由于微信图片有时候返回的Content-Type不对应（比如内容是PNG的，头确是image/jpeg）所以使用jpeg/png/gif的顺序进行图片数据解析，哪个成功就返回解析结果。#问题总是出现诸如invalid JPEG format: missing SOI marker#解决过程我去查看jpeg.Decode的源码，如下： 1234567891011func (d *decoder) decode(r io.Reader, configOnly bool) (image.Image, error) { d.r = r // Check for the Start Of Image marker. if err := d.readFull(d.tmp[:2]); err != nil { return nil, err } if d.tmp[0] != 0xff || d.tmp[1] != soiMarker { return nil, FormatError(&quot;missing SOI marker&quot;) }... soiMarker常量 1soiMarker = 0xd8 // Start Of Image. 可以看到判断了第1个字节如果不是0xff或者第2个字节不是0xd8就报错。打印图片的bytes前几个字节如下： 1[]byte{0xff, 0xd8, 0xff, 0xe0, 0x0, 0x10} 可以看到第1个字节和第2个字节满足要求，按理说不会出现这个问题，无奈只能求助于Google,搜索了invalid JPEG format: missing SOI marker关键字出现一篇Covert base64 string to JPG引起了我的注意。打开看到答案 You need to create a new reader for each decoder: 12345pngI, errPng := png.Decode(bytes.NewReader(unbased))// ...jpgI, errJpg := jpeg.Decode(bytes.NewReader(unbased)) 原来需要重新创建读取器，重新创建读取器后问题解决。#后续抱着打破砂锅问到底的心态，查看了一下bytes.Reader的源码，发现游标读取完后并未重置 12345678910// Read implements the io.Reader interface.func (r *Reader) Read(b []byte) (n int, err error) { if r.i &gt;= int64(len(r.s)) { return 0, io.EOF } r.prevRune = -1 n = copy(b, r.s[r.i:]) r.i += int64(n) return} Reader定义 12345type Reader struct { s []byte i int64 // current reading index prevRune int // index of previous rune; or &lt; 0} 可以看到r.i就是游标了。问题圆满解决","link":"/2018/10/17/2018-10-17-go-io-reader-panic.html"},{"title":"一起学context（一）——上下文值传递","text":"系列开篇本文开始将针对context的用法进行系统化讨论，在这里你将能够在工作中合理使用context解决一些比较棘手的问题。 context处理超时处理之外还可以用来保存数据，当你需要在多个上下文传递时传递数据，那么本文提到的知识可以排上用场。 示例代码示例代码为一个简单的http服务，流程是登录之后会跳转首页，首页通过guard中间件进行鉴权。当然，示例代码未做其他诸如连接数据库之类的处理，这不是本文的重点。守卫函数读取cookie之后将cookie值写入context并向下传递，在整个请求中可以说是“透明”的。当访问到需要保护的接口时检测到没有提供cookie，则直接终端请求，否则通过r.WithContext将username的值存入cookie，避免的业务接口直接读取cookie的弊端。因为如果后期更改鉴权算法的话，业务代码可以不用更改，直接更改中间件即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package mainimport ( &quot;context&quot; &quot;fmt&quot; &quot;log&quot; &quot;net/http&quot; &quot;time&quot;)func main() { mux := http.NewServeMux() mux.HandleFunc(&quot;/&quot;, guard(home)) mux.HandleFunc(&quot;/login&quot;, login) log.Fatal(http.ListenAndServe(&quot;:8080&quot;, mux))}// 登录func login(w http.ResponseWriter, r *http.Request) { if r.URL.Query().Get(&quot;username&quot;) != &quot;root&quot; { http.Error(w, http.StatusText(401), 401) return } cookie := &amp;http.Cookie{Name: &quot;username&quot;, Value: &quot;root&quot;, Expires: time.Now().Add(time.Hour)} http.SetCookie(w, cookie) http.Redirect(w, r, &quot;/&quot;, 302)}func home(w http.ResponseWriter, r *http.Request) { username := r.Context().Value(&quot;username&quot;) fmt.Fprintf(w, &quot;welcome login: %s&quot;, username.(string))}// 守卫func guard(handleFunc http.HandlerFunc) http.HandlerFunc { return func(w http.ResponseWriter, r *http.Request) { // check username log.Printf(&quot;%s - %s\\n&quot;, r.Method, r.RequestURI) cookie, err := r.Cookie(&quot;username&quot;) if err != nil || cookie == nil { // 如果username为空直接拦截 http.Error(w, http.StatusText(401), 401) return } handleFunc(w, r.WithContext(context.WithValue(r.Context(), &quot;username&quot;, cookie.Value))) }} 本文的代码就这么多，内容也很少，希望大家能好好用上这个利器。关于context与协程超时控制将在下一篇文章中讲到。","link":"/2018/10/17/2018-10-17-golang-context-with-value.html"},{"title":"一起学context（二）——超时控制","text":"上一篇文章讲到如何使用context来传值，实际上context还有另外一个重要功能——goroutine的超时控制。很多时候goroutine如果不设超时，一旦发生阻塞将无限等待，协程数会越来越多，导致耗尽服务器内存。 分类拥有超时控制的context有以下几种： context.WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) 指定时长超时结束 context.WithCancel(parent Context) (ctx Context, cancel CancelFunc) 手动结束 context.WithDeadline(parent Context, d time.Time) (Context, CancelFunc) 指定时间结束 一般常用的话就context.WithTimeout 示例代码所有超时控制结束的代码结构都是类似的，示例代码如下： 1234567891011121314151617181920212223242526272829303132package mainimport ( &quot;context&quot; &quot;time&quot; &quot;fmt&quot;)func main() { ctx, cancel := context.WithTimeout(context.TODO(), time.Second*3) defer cancel() // 防止任务比超时时间短导致资源未释放 // 启动协程 go task(ctx) // 主协程需要等待，否则直接退出 time.Sleep(time.Second * 4)}func task(ctx context.Context) { ch := make(chan struct{}, 0) // 真正的任务协程 go func() { // 模拟两秒耗时任务 time.Sleep(time.Second * 2) ch &lt;- struct{}{} }() select { case &lt;-ch: fmt.Println(&quot;done&quot;) case &lt;-ctx.Done(): fmt.Println(&quot;timeout&quot;) }} task函数是一般情况下ctx的处理代码，很多第三方框架会声明具体函数的第一个参数为context.Context来允许设定代码超时时间。","link":"/2019/01/02/2019-01-02-golang-timeout-context.html"},{"title":"无需编程导出微信表情包","text":"微信前两天推送了年度报告，其中的表情统计很有意思，的确，表情包这两年是越来越火了。但是有个问题是微信不支持导出表情包，有的小伙伴又需要导出来保存到其他地方。 本文分享一个比较简单的方式导出表情包，条件只有一个：谷歌浏览器。 打开 https://wx.qq.com 并登陆，这是网页版微信登录入口 手机选择表情发送给文件传输助手 打开网页版微信，可以查看到图片 接下来打开谷歌浏览器的开发者工具（不同电脑不太一样，但是都是右上角打开） 然后按照图片顺序点击如下图所示的图标 这时候鼠标处于选择元素的状态，直接悬浮在表情图片上即可 下方的窗口会出现图片链接，而且会有背景色（本图片的背景色是淡蓝色） 鼠标悬浮到刚才的淡蓝色窗口的链接上面，会出现表情的原图 在链接上面点击右键，选择如图名字的菜单（菜单顺序不同系统不同） 在新窗口打开的图片就是表情原始图片了，可以保存","link":"/2019/01/11/2019-01-11-export-wechat-emotion.html"},{"title":"c语言实现简单版的php z_val结构体","text":"源码学习过PHP的人都知道PHP是基于C语言开发的，但是C语言是强类型的，PHP如何实现弱类型呢？答案在于这个 12345678910111213141516171819typedef union _zvalue_value { long lval; /* long value */ double dval; /* double value */ struct { char *val; int len; } str; HashTable *ht; /* hash table value */ zend_object_value obj; zend_ast *ast;} zvalue_value;struct _zval_struct { /* Variable information */ zvalue_value value; /* value */ zend_uint refcount__gc; zend_uchar type; /* active type */ zend_uchar is_ref__gc;}; type保存了实际的类型，而value这个共用体保存了具体的值，我们使用到变量的时候需要根据变量类型来取出**_zvalue_value中保存的具体值。采用union能够避免内存浪费，同一时刻，一个_zval_struct中的共用体zvalue_value**只有一个成员会分配内存，避免了无谓的内存分配。 编码阅读源码之前，可能觉得是一个很复杂的实现，阅读源码之后，其实也能自己实现，关键是type和value的组合。源码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;strings.h&gt;enum z_val_type{ DOUBLE, LONG, STRING};struct z_val{ union { double dval; long lval; struct { char *val; int len; } str; } value; enum z_val_type type;};void z_val_print(struct z_val *);int main(void){ // double struct z_val *doubleVal = malloc(sizeof(struct z_val)); doubleVal-&gt;type = DOUBLE; doubleVal-&gt;value.dval = 1.0; // long struct z_val *longVal = malloc(sizeof(struct z_val)); longVal-&gt;type = LONG; longVal-&gt;value.lval = 1; // string struct z_val *strVal = malloc(sizeof(struct z_val)); strVal-&gt;type = STRING; strVal-&gt;value.str.val = &quot;Hello World!&quot;; strVal-&gt;value.str.len = strlen(strVal-&gt;value.str.val); z_val_print(doubleVal); z_val_print(longVal); z_val_print(strVal); free(strVal); free(longVal); free(doubleVal); return 0;}void z_val_print(struct z_val *val){ switch (val-&gt;type) { case LONG: printf(&quot;type: long, val: %ld\\n&quot;, val-&gt;value.lval); break; case DOUBLE: printf(&quot;type: double, val: %f\\n&quot;, val-&gt;value.dval); break; case STRING: printf(&quot;type: string, val: %s, len: %d\\n&quot;, val-&gt;value.str.val, val-&gt;value.str.len); break; }} 编译采用gcc编译 1gcc -o union union.c 执行1./union 输出 123type: double, val: 1.000000type: long, val: 1type: string, val: Hello World!, len: 12 可以看到输出跟预期一样，我们也实现了一个“弱类型”的变量，是不是很有成就感呢？实现上，多阅读源码可以多多参考别人的思维方式和编码习惯，所谓“站在巨人的肩膀上，才能看得更远”","link":"/2019/02/26/2019-02-26-c-php-simple-z-val-example.html"},{"title":"使用systemd来构建你的服务","text":"systemd是什么Systemd 服务是一种以 .service 结尾的单元（unit）配置文件，用于控制由Systemd 控制或监视的进程。简单说，用于后台以守护精灵（daemon）的形式运行程序。 为什么要使用systemd service文件编写简单易用 可以自动维持进程存活（强大的功能，可以取代PM2） 自动收集进程输出的输出 systemd主要命令可以看到systemd以字母d结尾，根据linux惯用规则，可以判断该进程为守护进程，可以通过systemctl与之交互。 1234systemctl start redis.service #启动服务systemctl stop redis.service #停止服务systemctl restart redis.service #重启服务systemctl enable redis.service #将redis设置为开机启动 编写systemdsystmd service文件一般放在/etc/systemd/system/文件夹中。 systemd service文件是结构化的，以下给出一份笔者常用的清单。 12345678910[Unit]Description=Git Auto Update Hook ServiceAfter=network.target[Service]Type=simpleExecStart=/root/src/git-hookd/git-hookdRestart=always[Install]WantedBy=multi-user.target 拿之前写过的init.d的脚本对比一下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#!/bin/bash### BEGIN INIT INFO# Provides: xialeistudio# Required-Start: $network# Required-Stop: $local_fs# Default-Start: 2 3 4 5# Default-Stop: 0 1 6# Short-Description: test service# Description: test service### END INIT INFOPROG=&quot;testd&quot;PROG_PATH=&quot;/root/apps/testd&quot;PROG_ARGS=&quot;-u xialei&quot;PID_PATH=&quot;/var/run/&quot;start() { if [ -e &quot;$PID_PATH/$PROG.pid&quot; ]; then echo &quot;Error! $PROG is running!&quot; 2&gt;&amp;1 exit 1 else $PROG_PATH/$PROG $PROG_ARGS 2&gt;&amp;1 &gt; &quot;/var/log/$PROG.log&quot; &amp; pid=`ps ax|grep testd|awk '{print $2}'|head -n 1` echo &quot;$PROG started&quot; echo $pid &gt; &quot;$PID_PATH/$PROG.pid&quot; fi }stop() { if [ -e &quot;$PID_PATH/$PROG.pid&quot; ]; then pid=`ps ax|grep testd|awk '{print $2}'|head -n 1` kill $pid rm -rf &quot;$PID_PATH/$PROG.pid&quot; echo &quot;$PROG $pid killed&quot; else echo &quot;Error! $PROG not running!&quot; 2&gt;&amp;1 exit 1 fi}if [ &quot;$(id -u)&quot; != &quot;0&quot; ]; then echo &quot;Please run as root!&quot; 2&gt;&amp;1 exit 1ficase &quot;$1&quot; in start) start exit 0 ;; stop) stop exit 0 ;; reload|restart) stop start exit 0 ;; **) echo &quot;Usage: $0 {start|stop|reload}&quot; 2&gt;&amp;1 exit 1 ;;esac 可以看到init.d脚本实在是太原始了，systemd取代init.d指日可待 systemd service文件说明service文件由 Unit, Service, Install 三部分组成 Unit所有引导过程中systemd要控制的文件/设备/程序等等都称为一个单元。 Description: 服务描述 Wants: 本单元启动成功，则会启动此字段定义的单元，如果Wants定义的单元启动失败，对本单元无影响 Requires：本单元启动成功，则会启动此字段定义的单元，如果Requires定义的单元启动失败，本单元也失败。该字段无法控制先后顺序，如果Requires定义的单元未启动完成就启动本单元，那么一个都启动不了，不建议用这个字段 OnFailure： 本单元如果启动失败，则启动该字段定义的单元 Before/After：指定本单元的启动顺序 本例中只需要依赖网络单元即可 Service服务本体定义： Type 启动类型 ExecStart 启动服务的命令 ExecStop 停止服务的命令（一般不写） Restart 重启规则 RemainAfterExit 即使没有进程，也任务服务启动成功 Type 启动类型有以下几种： + simple： 默认类型，启动的进程将成为服务进程。 + forking：标准Unix Daemon进程。本进程启动后会通过系统调用fork，把必要的通信频道都设置好之后父进程退出，留下守护精灵的子进程。（也就是说你自己来将进程变成daemon进程） + oneshot：一次性命令。该服务运行完毕后没有进程，所以需要配合RemainAfterExit。 Restart 重启规则有以下几种： + no（默认值）：退出后不会重启 + always：不管是什么退出原因，总是重启 + on-success：只有正常退出时（退出状态码为0），才会重启 + on-failure：非正常退出时（退出状态码非0），包括被信号终止和超时，才会重启 + on-abnormal：只有被信号终止和超时，才会重启 + on-abort：只有在收到没有捕捉到的信号终止时，才会重启 + on-watchdog：超时退出，才会重启 Installsystemd装载规则定义 WantedBy 将被谁装载，本例中使用multi-user.target，最终服务将通过软链接到/etc/systemd/system/multi-user.target.wants目录 Alias 服务别名，可以通过 systemctl 服务别名 restart 之类的来操作 写在最后是时候通过systemd改写init.d的服务了，有必要的话可以连pm2守护的进程都交给systemd来处理。","link":"/2019/02/28/2019-02-28-build-service-by-systemd.html"},{"title":"在缓存中使用闭包函数","text":"闭包函数PHP官方文档对于闭包函数的定义： 匿名函数（Anonymous functions），也叫闭包函数（closures），允许 临时创建一个没有指定名称的函数。最经常用作回调函数（callback）参数的值。当然，也有其它应用的情况。 简单来说，闭包函数也是一种数据类型，可以直接使用变量来存储、传参、调用等等。 传统缓存操作操作缓存的时候一般步骤如下： 读取缓存 如果缓存不为空则返回缓存数据 读取数据库，然后设置到缓存 返回数据 PHP示例代码如下： 123456789function loadUser($userId) { $data = $cache-&gt;get('user-'. $userId); if(!empty($data)) { return $data; } $data = $db-&gt;findOne(['user_id' =&gt; $userId]); $cache-&gt;set('user-'. $userId, $data, 7200); return $data;} 其实查找缓存，如果不存在则查找数据库之后写入缓存这个操作也可以用闭包来实现： 123456789101112131415function getOrSet($key, callable $callable, $expire = 0) { $data = $cache-&gt;get($key); if(!empty($data)) { return $data; } $data = call_user_func($callable); $cache-&gt;set($key, $data, $expire); return $data;}function loadUser($userId) { return $cache-&gt;getOrSet('user-'. $userId, function() use($db, $userId) { return $db-&gt;findOne(['user_id' =&gt; $userId]); }, 7200);} 可以看到通过闭包省去了手动get和set的过程，而查询数据库那一步是只有在缓存读取不到才会执行。","link":"/2019/05/14/2019-05-14-use-closure-in-cache.html"},{"title":"在事务中使用闭包函数简化开发","text":"闭包函数PHP官方文档对于闭包函数的定义： 匿名函数（Anonymous functions），也叫闭包函数（closures），允许 临时创建一个没有指定名称的函数。最经常用作回调函数（callback）参数的值。当然，也有其它应用的情况。 简单来说，闭包函数也是一种数据类型，可以直接使用变量来存储、传参、调用等等。 事务事务简单来说就是一个核心: 事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。 一般情况下，每一条SQL的执行情况都需要进行判断，如果执行成功则继续，否则回滚事务。以下是PDO事务代码： 123456789$pdo = new PDO('mysql:host=localhost;dbname=demo', 'root', 'root');try { $pdo-&gt;beginTransaction(); //todo 业务代码 $pdo-&gt;commit();} catch (\\Exception $e) { $pdo-&gt;rollBack(); throw $e;} PHP实现几乎所有事务都需要如此处理，但是这样重复代码太多，实际上只需要关心的部分是 业务代码 部分，使用闭包函数可以很好的解决这个问题。 闭包函数可以理解为具体的业务逻辑，不带任何事务相关操作，如果出现异常，会自动回滚事务。 PHP的简单实现代码如下: 123456789101112function transaction(PDO $pdo, callable $callable){ try { $pdo-&gt;beginTransaction(); $result = call_user_func($callable, $pdo); $pdo-&gt;commit(); return $result; } catch (\\Exception $e) { $pdo-&gt;rollBack(); throw $e; }} PHP调用方法代码如下： 123transaction($pdo, function (PDO $pdo) { return $pdo-&gt;query('INSERT INTO `test` VALUES (1)');}); 结语使用闭包函数去简化样板代码在生产中是很常见的，具体的设计模式应该是类似“模板方法模式”。","link":"/2019/05/14/2019-05-14-use-closure-in-transaction.html"},{"title":"使用swoole来运行thrift应用","text":"Swoole扩展简介 Swoole：面向生产环境的 PHP 异步网络通信引擎 使 PHP 开发人员可以编写高性能的异步并发 TCP、UDP、Unix Socket、HTTP，WebSocket 服务。Swoole 可以广泛应用于互联网、移动通信、企业软件、云计算、网络游戏、物联网（IOT）、车联网、智能家居等领域。 使用 PHP + Swoole 作为网络通信框架，可以使企业 IT 研发团队的效率大大提升，更加专注于开发创新产品。 thrift Thrift是一种接口描述语言和二进制通讯协议，它被用来定义和创建跨语言的服务。它被当作一个远程过程调用（RPC）框架来使用，是由Facebook为“大规模跨语言服务开发”而开发的。 swoole实现thrift官方提供的PHP服务端是运行在php原生阻塞IO模式的，性能比较差。笔者使用Swoole的异步服务端+thrift提供的接口实现一个了异步协程化的thrift应用。 此项目已经在github上开源： https://github.com/xialeistudio/swoole-thrift.git","link":"/2019/05/16/2019-05-16-running-thrift-on-swoole.html"},{"title":"在Swoole环境下运行注入Yii2框架的thrift应用","text":"前两天发布了使用swoole来运行thrift应用，项目虽然可以运行起来，但是周边的生态（如缓存，ORM，日志等等）并没有跟上，实际上开发体验比较差。周末研究了一下，把Yii2框架集成到了thrift应用上。 项目地址：https://github.com/swoole-foundation/yii2-swoole-thrift Yii2优势： 完美的OOP设计 大量开箱即用的组件(DB/Cache/Logger/RBAC等等) 组件化开发 扩展性 这些支持是提高thrift应用开发效率的保证，毕竟没有人会直接在生产环境下手写SQL不是?","link":"/2019/05/19/2019-05-19-running-thrift-on-swoole-with-yii2.html"},{"title":"在swoole上运行Yii2应用","text":"Yii2：业界著名的开发框架，完美的OOP设计以及组件化开发思想保证了框架的扩展性。Swoole：面向生产环境的 PHP 异步网络通信引擎。使 PHP 开发人员可以编写高性能的异步并发 TCP、UDP、Unix Socket、HTTP，WebSocket 服务。 Yii2优点 完美的OOP设计 大量开箱即用的组件(DB/Cache/Logger/RBAC等等) 组件化开发 扩展性 Swoole优点 高性能/异步/事件驱动 使用PHP语言开发 单文件容器化(传统的php-fpm容器化有点麻烦，一般使用apache的镜像，但是性能不行) 如果这两者结合将会擦出什么样的火花呢? Yii2-Swoole-ExtensionYii2-Swoole-Extension 基于swoole运行环境的Yii2扩展，基于标准Yii2组件化思想开发，对应用无侵入性，可以随时从 PHP-FPM &lt;-&gt; swoole 互相迁移。 通过简单的几行代码即可完成传统PHP-FPM应用到Swoole的升级，给应用带来实打实的性能提升!","link":"/2019/05/19/2019-05-19-running-yii2-on-swoole.html"},{"title":"解决数据库N+1查询问题","text":"需求数据表如下： department表 id name 1 测试部门 user表 id name department_id 1 test 1 需求是得到以下结构的数据: 1234567891011[ { &quot;id&quot;:1, &quot;name&quot;:&quot;test&quot;, &quot;department_id&quot;:1, &quot;department&quot;:{ &quot;id&quot;:1, &quot;name&quot;:&quot;测试部门&quot; } }] 方法一:循环查询 查询用户列表 循环用户列表查询对应的部门信息 1234$users = $db-&gt;query('SELECT * FROM `user`');foreach($users as &amp;$user) { $users['department'] = $db-&gt;query('SELECT * FROM `department` WHERE `id` = '.$user['department_id']);} 该方法查询次数为：1+N(1次查询列表，N次查询部门)，性能最低，不可取。 方法二：连表 通过连表查询用户和部门数据 处理返回数据 12$users = $db-&gt;query('SELECT * FROM `user` INNER JOIN `department` ON `department`.`id` = `user`.`department_id`');// 手动处理返回结果为需求结构 该方法其实也有局限性，如果 user 和 department 不在同一个服务器是不可以连表的。 方法三：1+1查询 该方法先查询1次用户列表 取出列表中的部门ID组成数组 查询步骤2中的部门 合并最终数据 代码大致如下： 12345678910111213141516$users = $db-&gt;query('SELECT * FROM `user`');$departmentIds =[ ];foreach($users as $user) { if(!in_array($user['department_id'], $departmentIds)) { $departmentIds[] = $user['department_id']; }}$departments = $db-&gt;query('SELECT * FROM `department` WHERE id in ('.join(',',$department_id).')');$map = []; // [部门ID =&gt; 部门item]foreach($departments as $department) { $map[$department['id']] = $department;}foreach($users as $user) { $user['department'] = $map[$user['department_id']] ?? null; } 该方法对两个表没有限制，在目前微服务盛行的情况下是比较好的一种做法。","link":"/2019/06/18/2019-06-18-database-n-1-solution.html"},{"title":"druid SQL监控不显示问题","text":"新版druid数据源驱动的SQL监控如果用以前的老版本配置是无法监控到SQL的： application.yml 1234567spring: datasource: druid: filters: - stat - wall - log4j 启动应用之后访问druid监控页面，除了SQL相关的页面都正常工作，但是访问SQL监控页面时没有看到SQL记录。查看监控页面 数据源 菜单发现 filter类名 显示的是空，估计是filter配置有问题导致。 查阅官方文档发现filter配置有变更，改成以下形式即可统计SQL，同时在数据源页面 filter类名 会显示正常。 application.yml 1234567891011121314151617181920212223242526272829303132spring: datasource: druid: initial-size: 5 min-idle: 5 max-active: 20 max-wait: 5000 # 状态监控 filter: stat: enabled: true db-type: mysql log-slow-sql: true slow-sql-millis: 2000 # 监控过滤器 web-stat-filter: enabled: true exclusions: - &quot;*.js&quot; - &quot;*.gif&quot; - &quot;*.jpg&quot; - &quot;*.png&quot; - &quot;*.css&quot; - &quot;*.ico&quot; - &quot;/druid/*&quot; # druid 监控页面 stat-view-servlet: enabled: true url-pattern: /druid/* reset-enable: false login-username: root login-password: root 数据源filter类名：com.alibaba.druid.filter.stat.StatFilter","link":"/2019/07/08/2019-07-08-druid-sql-monitor.html"},{"title":"vue webpack重写cookie路径","text":"webpack提供的反向代理服务器在开发阶段非常方便，几行简单的代码配置就可以使用反向代理功能，包括路径重写、cookie处理等。 项目开发阶段使用的API路径是 /admin，部署到线上是/，所以在开发过程中需要在proxyTable进行反向代理配置，将路径重写掉，路径重写代码如下(config/index.js): 123456789proxyTable: { '/admin': { target: 'http://127.0.0.1:8080', changeOrigin: true, pathRewrite: { '^/admin': '/admin2' }, }} 启动项目之后进行登录，此时API请求成功，但是获取登录用户信息时发现cookie没有带过去。查看请求发现登录请求的Set-Cookie响应头中的Path是/admin2。但是咱们请求的路径是/admin，cookie当然不会生效。 查阅文档发现，proxyTable支持onProxyRes回调函数来自定义响应，流程是通过替换后端服务器设置的cookie-path来进行处理，代码如下： 12345678910111213141516171819proxyTable: { '/admin': { target: 'http://127.0.0.1:8080', changeOrigin: true, pathRewrite: { '^/admin': '/lesson/admin' }, onProxyRes: function (proxyRes, req, res) { const cookies = proxyRes.headers['set-cookie'] if (cookies) { const newCookies = cookies.map(cookie =&gt; { return cookie.replace(/Path=\\/admin2/, 'Path=/') }) delete proxyRes.headers['set-cookie'] proxyRes.headers['set-cookie'] = newCookies } } },}, 重启webpack之后重新登录，发现cookie的路径已经被重写到/了。","link":"/2019/07/08/2019-07-08-vue-webpack-rewrite-cookie-path.html"},{"title":"PHP和JS加解密","text":"最近遇到的几个网站在提交密码时提交的已经是密文，也就是说在网络上传输的密码是密文，这样提升了密码在网络传输中的安全性。 \b后端语言加解密已经有很成熟的方案了，前端的话Google之前出过一个crypto-js，为浏览器的js提供了加解密方案。今天一起来了解一下基于AES的前后端加解密流程。 Javascript 安装npm包 npm install crypto-js \b加密代码 123456789const CryptoJS = require(&quot;crypto-js&quot;);const key = CryptoJS.enc.Latin1.parse('1234567812345678');const iv = CryptoJS.enc.Latin1.parse('1234567812345678');const encoded = CryptoJS.AES.encrypt('hahaha', key, { iv: iv, mode: CryptoJS.mode.CBC, adding: CryptoJS.pad.ZeroPadding}).toString()console.log('encoded', encoded) 解密代码 12345678const key = CryptoJS.enc.Latin1.parse('123456781234567812345678');const iv = CryptoJS.enc.Latin1.parse('1234567812345678');const decoded = CryptoJS.AES.decrypt(encoded, key, { iv: iv, mode: CryptoJS.mode.CBC, adding: CryptoJS.pad.ZeroPadding}).toString(CryptoJS.enc.Utf8)console.log('decoded', decoded); 输出如下 12encoded 6bcgYd4f4ZgNOQH/3tqMpg==decoded hahaha PHP直接使用openssl解密即可，代码如下： 1234$encoded = '6bcgYd4f4ZgNOQH/3tqMpg==';$key = '123456781234567812345678';$iv = '1234567812345678';var_dump(openssl_decrypt($encoded, 'AES-192-CBC', $key, 0,$iv)); 输出结果： 1string(6) &quot;hahaha&quot; 注意事项 AES加密位数跟密钥key有关, 以下是密钥位数和加密对应关系 16 =&gt; AES-128 24 =&gt; AES-192 32 =&gt; AES-256 iv是初始化向量. 超过16字节或者不足16字节都会被补足16字节或者截断到16字节。由于AES是块加密，铭文被分割成固定长度的块（一般是16字节长度），所以iv也是16字节。 CBC是加密模式","link":"/2019/07/11/2019-07-11-js-encrypt-php-decrypt.html"},{"title":"百度分享不支持HTTPS解决办法","text":"这两天接入文章页百度分享时发现本地可以显示分享按钮，但是发布到线上之后发现分享按钮不会展示。打开浏览器调试工具发现，HTTPS下的百度分享资源未加载，起初以为是HTTPS站点下面使用的是HTTP协议的链接，但是查看源代码发现是自适应协议的， 所以问题应该是处在百度这里。 打开https://bdimg.share.baidu.com/static/api/js/share.js发现浏览器提示NET::ERR_CERT_COMMON_NAME_INVALID，也就是访问的域名和证书配置的域名不匹配，证书的域名是*.baidu.com，访问的域名是bdimg.share.baidu.com，泛域名是不可以跨级使用的。 虽然是百度的问题，但是咱也不可能要他去改这个分享，所以只能自己来处理了。 可能的处理方案 全站使用HTTP，放弃该方案（现在都9012年了，免费证书一大把，基本都是HTTPS站点了） 将百度分享的资源打包下来进行部署 部署到自己的服务器（成本低，易迁移，但是服务器带宽是个问题） 部署到CDN，本文以七牛为例 资源路径百度分享相关JS我已经分享到github了，一键直达仓库 处理过程 将百度分享的资源解压到本地 使用PHP遍历目录上传到七牛(本文用的SPL进行文件夹遍历) 替换使用的百度分享JS路径 使用PHP变量目录上传到七牛文件目录如下： 1234|--static(百度分享资源目录)|--DirectorySync.php|--FilterScanner.php|--index.php DirectorySync.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * 目录同步器 * Class DirectorySync * @package sync * @author xialeistudio * @date 2019-07-11 */class DirectorySync{ private $accessKey; private $secretKey; private $bucket; /** * @var Auth */ private $auth; /** * DirectorySync constructor. * @param $accessKey * @param $secretKey * @param $bucket */ public function __construct($accessKey, $secretKey, $bucket) { $this-&gt;accessKey = $accessKey; $this-&gt;secretKey = $secretKey; $this-&gt;bucket = $bucket; $this-&gt;auth = new Auth($accessKey, $secretKey); } /** * 同步目录 * @param array $list * @throws \\Exception * @author xialeistudio * @date 2019-07-11 */ public function sync(array $list) { $uploader = new UploadManager(); $token = $this-&gt;auth-&gt;uploadToken($this-&gt;bucket); foreach ($list as $path =&gt; $keyPrefix) { $scanner = new FilterScanner($path); foreach ($scanner as $filename) { printf(&quot;uploading %s \\n&quot;, $filename); /** @var Error $error */ list($ret, $error) = $uploader-&gt;putFile($token, $keyPrefix . $filename, $filename); if (!empty($error)) { printf(&quot;uploading %s error: %s\\n&quot;, $filename, $error-&gt;message()); } } } }} FilterScanner.php 1234567891011121314151617181920212223242526272829/** * 文件扫描器 * Class FilterScanner * @package sync * @author xialeistudio * @date 2019-07-11 */class FilterScanner extends FilterIterator{ /** * FilterScanner constructor. * @param $path */ public function __construct($path) { parent::__construct(new RecursiveIteratorIterator(new RecursiveDirectoryIterator($path))); } /** * Check whether the current element of the iterator is acceptable * @link https://php.net/manual/en/filteriterator.accept.php * @return bool true if the current element is acceptable, otherwise false. * @since 5.1.0 */ public function accept() { return substr($this-&gt;current(), -1, 1) != '.' &amp;&amp; substr($this-&gt;current(), -2, 2) != '..'; }} index.php 1234$sync = new DirectorySync(ACCESS_KEY, SECRET_KEY, BUCKET);$sync-&gt;sync([ 'static' =&gt; '']); 上传之前需要修改一下百度分享js相关的域名。打开static/api/js/share.js，搜索到如下代码： 1jscfg: {domain: {staticUrl: &quot;/&quot;}} 将staticUrl改成七牛的域名，本站使用的是static.ddhigh.com，所以改完之后的代码如下： 1jscfg: {domain: {staticUrl: &quot;//static.ddhigh.com/&quot;}} 完事之后执行php index.php上传到七牛，此时就可以随意部署了~。 部署到应用将以往使用bdimg.share.baidu.com/static/api/js/share.js的地方换成//static.ddhigh.com/static/api/js/share.js即可，其他资源会自动加载。 本站的CDN域名做了防盗链处理，各位如果直接用我的share.js链接是会有问题的 hexo Next百度分享的额外处理上传到七牛这个步骤完成之后，搜索文件baidushare.swig，找到最下面的如下代码： 1with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)]; 将链接替换为自己的CDN链接，我这边替换后的结果如下： 1with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//static.ddhigh.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];","link":"/2019/07/12/2019-07-12-baidu-share-support-https.html"},{"title":"实现一个JS深拷贝函数","text":"JS深拷贝概念并不新鲜，但是真正要真正理解原理还是有点难度的。这也是JS语言精粹之一吧。 例子12345678910let a = { name: 'demo', age: 18};let b = a;b.name = 'demo1';console.log(a); // 输出 {name: &quot;demo1&quot;, age: 18}console.log(b); // 输出 {name: &quot;demo1&quot;, age: 18} 因为JS对于对象的赋值使用的是浅拷贝，其中一个实例变量的赋值会影响到所有指向该对象的变量 解决方案 粗暴好使的 JSON.parse(JSON.stringify)，缺点: 丢失成员函数 Object.assign，缺点：只有第一级深拷贝，子级对象依旧是浅拷贝，例子如下： 1234567let a = {name:{demo:'1'}};let b = Object.assign({}, a);console.log(a); // 输出 {name:{demo:'1'}}console.log(b); // 输出 {name:{demo:'1'}}b.name.demo = '2';console.log(a); // 输出 {name:{demo:'2'}}console.log(b); // 输出 {name:{demo:'2'}} 手动实现原理 遍历待拷贝对象 判断当前值类型，如果是object类型且不是null(null也是object)，则递归调用拷贝函数 如果当前值类型时null或者非object类型，直接return，退出本次递归 编码实现12345678910function deepCopy(obj) { let result = obj; if(typeof obj === 'object' &amp;&amp; obj !== null) { result = Object.prototype.toString.call(obj) === '[object Array]' ? []: {}; for(let prop in obj) { result[prop] = deepCopy(obj[prop]); } } return result;} 验证一下： 1234567let a = {name:{demo:'1'}};let b = deepCopy(a);console.log(a); // 输出 {name:{demo:'1'}}console.log(b); // 输出 {name:{demo:'1'}}b.name.demo = '2';console.log(a); // 输出 {name:{demo:'1'}}console.log(b); // 输出 {name:{demo:'2'}}","link":"/2019/07/16/2019-07-16-make-a-deep-copy-function.html"},{"title":"微信小程序数据字段大小写问题","text":"这两天在开发微信小程序登录以及加解密的时候，因为数据大小写的问题被坑了一把。 场景 小程序调用wx.login时会获得code，传输给服务端可以得到openid,unionid(绑定了开放平台),session_key 小程序调用getUserInfo会获得encrypted_data,iv,解密后得到unionId,openId unionid和openid这两个场景键名大小写是不同的 例子 服务端根据code获取session_key返回结果如下： 12345{ &quot;session_key&quot;: &quot;我是session_key&quot;, &quot;openid&quot;: &quot;我是openid&quot;, &quot;unionid&quot;: &quot;我是unionid&quot;} 服务端根据session_key解密encrypted_data和iv返回结果如下： 123456789101112131415{ &quot;openId&quot;: &quot;OPENID&quot;, &quot;nickName&quot;: &quot;NICKNAME&quot;, &quot;gender&quot;: GENDER, &quot;city&quot;: &quot;CITY&quot;, &quot;province&quot;: &quot;PROVINCE&quot;, &quot;country&quot;: &quot;COUNTRY&quot;, &quot;avatarUrl&quot;: &quot;AVATARURL&quot;, &quot;unionId&quot;: &quot;UNIONID&quot;, &quot;watermark&quot;: { &quot;appid&quot;:&quot;APPID&quot;, &quot;timestamp&quot;:TIMESTAMP }} 可以看到两次同样的字段openid和unionid大小写是不同的，此处容易踩坑。 结论 服务端根据code换session_key/openid/unionid是小写 服务端根据encrypted_data和iv解密得到的openId/unionId是大写 最后，祝大家在开发过程中少踩坑。","link":"/2019/07/16/2019-07-16-wechat-mini-program-data-column-case.html"},{"title":"NodeJs简明教程(1)","text":"本文是NodeJs简明教程的第一篇，将介绍NodeJs整体架构以及重点概念。 NodeJs究竟是什么来看一段官方的说法[1]： As an asynchronous event driven JavaScript runtime, Node is designed to build scalable network applications. In the following “hello world” example, many connections can be handled concurrently. Upon each connection the callback is fired, but if there is no work to be done, Node will sleep. Google翻译版本： 作为异步事件驱动的JavaScript运行时，Node旨在构建可伸缩的网络应用程序。 在下面的“hello world”示例中，可以同时处理许多连接。 在每次连接时都会触发回调，但是如果没有工作要做，Node将会休眠。 结合上面的介绍，我们可以得出一个结论： NodeJs的本质是一个Javascript运行时。该运行时基于异步事件驱动进行运作。 异步本文中的异步指异步IO。维基百科对异步IO的定义[2]： 异步IO是计算机操作系统对输入输出的一种处理方式：发起IO请求的线程不等IO操作完成，就继续执行随后的代码，IO结果用其他方式通知发起IO请求的程序。与异步IO相对的是更为常见的“同步（阻塞）IO”：发起IO请求的线程不从正在调用的IO操作函数返回（即被阻塞），直至IO操作完成。 一言以蔽之就是： 执行IO请求后，调用方不等执行结果就继续执行下面的代码，IO操作完成后执行者会告诉调用者“我执行完了”。在NodeJs中通知方式是“回调”。 事件驱动事件驱动是相对 线程驱动 而言的。线程驱动 下服务器为每个请求新建一个线程去处理。维基百科对事件驱动的定义[3]： 事件驱动程序模型下的系统，基本上的架构是预先设计一个事件循环所形成的程序，这个事件循环程序不断地检查当前要处理的信息，根据要处理的信息运行一个触发函数进行必要的处理。其中这个外部信息可能来自一个目录夹中的文件，可能来自键盘或鼠标的动作，或者是一个时间事件。 以NodeJs的HTTP服务器为例，当调用server.listen函数时，NodeJs就会创建一个事件循环，当有客户端请求过来时，NodeJs将该请求入队列进行后续处理，主线程以及轮询客户端请求并入队列，队列中的请求执行完毕后会通过回调函数的形式通知主线程，如此循环。 Javascript运行时Javascript运行时是个比较复杂的概念，本文在介绍 Javascript运行时 之前介绍一下 Javascript引擎。 Javascript引擎维基百科的定义[4]： JavaScript引擎是一个专门处理JavaScript脚本的虚拟机，一般会附带在网页浏览器之中。 个人理解： Javascript引擎主要是对Javascript代码进行词法、语法等分析，通过解释器转化为字节码，虚拟机执行该字节码，带有JIT(Just-In-Time，即时编译技术)的虚拟机会将热点代码编译为机器码，从而加速执行过程。感谢luckymore的热心指正！ 目前业内出名的Javascript引擎非V8莫属了。 运行时的组成Javascript可以运行在浏览器，也可以运行在服务器(NodeJs)中，有些API或者对象只有浏览器有(比如DOM,BOM等)，而有些API或者对象只有服务器中有(如文件操作，HTTP服务器等)。 Javascript运行时包括了Javascript引擎、特定环境API、事件循环和事件队列。 NodeJs架构图NodeJs由C++语言基于libuv开发，分层设计，Javascript只是其基于V8提供的上层接口，换句话说，如果把上层接口换成其他语言实现，比如换成PHP实现，那么PHP就可以实现异步事件驱动的服务器，运行时名称就成为 NODE-PHP。 Node standard library NodeJs标准库，也是直接提供给开发者调用的顶层代码 Node bindings Javascript和libuv在该层进行通信，基于V8打通语言壁垒 V8 执行JS代码 libuv 高性能异步I/O、事件驱动、线程池的库，也是NodeJs高性能的保证 C-ares 提供异步DNS http_parser、OpenSSL、Zlib 提供HTTP解析、openssl加解密、数据压缩等接口 NodeJs到底是不是单线程 不是，主线程Javascript线程是单线程，libuv提供线程池，NodeJs不仅仅是一个Javascript引擎，而是一套运行时，不能将Javascript线程孤立出来。 NodeJs为什么这么快 单线程解决了多线程环境下线程切换开销以及可能的线程同步开销 异步+事件驱动保证了NodeJs主线程不会阻塞，会一直接受请求(这也是受人诟病的地方，其他语言实现的服务器，请求过大会排队处理，NodeJs会将请求全部入队，导致内存暴涨) NodeJs优缺点以及适合的场景 由于主线程Javascript线程是单线程，所以主线程不能做CPU密集操作（比如什么加解密之类的，这种操作只能有Javascript线程运行，会阻塞事件循环），所以NodeJs适合I/O密集场景，比如常见的（TCP/HTTP服务器） 对于前端开发者来说，几乎没有语言门槛 跨平台，NodeJs在主流操作系统都有对应的二进制程序 标准库强大，第三方库也很多，降低了造轮子成本 易于部署，服务器安装一个NodeJs程序配合NPM包管理器即可运行，不用像PHP那样还要安装扩展，配置前端HTTP服务器 结语欢迎继续关注本系列文章。 参考文献 About NodeJs 异步IO 事件驱动 Javascript引擎","link":"/2019/07/18/2019-07-18-nodejs-guide-about.html"},{"title":"NodeJs简明教程(3)","text":"本文是NodeJs简明教程的第三篇，将介绍NodeJs自带HTTP模块服务器相关的基本操作。 HTTP模块介绍以下是官方原文[1]： The HTTP interfaces in Node.js are designed to support many features of the protocol which have been traditionally difficult to use. In particular, large, possibly chunk-encoded, messages. The interface is careful to never buffer entire requests or responses — the user is able to stream data. 大致意思就是： NodeJs的HTTP模块旨在支持传统上HTTP协议难以使用的许多功能，让这些功能或者特性能够使用简单的API进行调用。 HTTP模块服务器开发代码示例以下是NodeJs最简单的HTTP服务器示例: 新建index.js 编码 12345678const http = require('http');const server = http.createServer((req, res) =&gt; { console.log('%s %s', req.method, req.url) res.end(JSON.stringify(req.headers))})server.listen(8080, () =&gt; console.log('listen on 8080')) 打开终端或者控制台，执行 node index.js，终端或控制台会输出listen on 8080，此时HTTP服务器已经启动，如果启动失败，可以在下方留言 打开浏览器访问 http://localhost:8080，笔者输出如下： 1234567891011{ &quot;host&quot;: &quot;localhost:8080&quot;, &quot;connection&quot;: &quot;keep-alive&quot;, &quot;cache-control&quot;: &quot;max-age=0&quot;, &quot;upgrade-insecure-requests&quot;: &quot;1&quot;, &quot;user-agent&quot;: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36&quot;, &quot;dnt&quot;: &quot;1&quot;, &quot;accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3&quot;, &quot;accept-encoding&quot;: &quot;gzip, deflate, br&quot;, &quot;accept-language&quot;: &quot;zh-CN,zh;q=0.9,en;q=0.8,zh-TW;q=0.7&quot;,} 代码说明 NodeJs采用 CommonJs模块系统，require 用来加载模块，本例中加载了NodeJs自带的http模块以使用其中的功能 http.createServer函数创建了一个 HTTP服务器，并配置了请求回调函数，在本系列的第一篇文章中说到事件驱动是需要回调函数进行监听的。 server.listen是监听系统端口，第二个参数是监听成功的回调函数 req对象服务器收到的HTTP请求对象，以下是常用的属性或方法： req.url 本次请求的路径(不包含域名) req.headers 本次请求的请求头 req.httpVersion 本次请求的HTTP协议版本号 req.method 本次请求的请求方法,有GET/POST/PUT等等 on() 监听请求体数据 POST/PUT/PATCH方法会有请求体 res对象res对象是req请求对象相应的响应对象，HTTP协议设计是请求-应答模型，一次请求对应一次应答。 以下是常用的属性或方法： res.writeHead 输出响应状态码，状态码说明以及多个HTTP响应头 res.end 输出数据并结束本次响应 res.write 输出部分内容(chunk) res.setHeader 输出单个响应头 请求路由NodeJs自带的HTTP服务器是没有路由功能的，也是就说，根据请求的URI来执行不同的逻辑需要开发者手动去做 1234567891011121314const http = require('http');const server = http.createServer((req, res) =&gt; { if (req.url === '/') { res.end('index'); return; } if (req.url === '/user') { res.end('user'); return; }})server.listen(8080, () =&gt; console.log('listen on 8080')); 执行node index.js 浏览器访问 http://localhost:8080/ 会输出index 浏览器访问 http://localhost:8080/user 会输出user 读取请求参数读取GET请求参数1234567891011const http = require('http');const url = require('url');const qs = require('querystring');const server = http.createServer((req, res) =&gt; { const parsed = url.parse(req.url); const query = qs.parse(parsed.query); res.end(JSON.stringify(query));})server.listen(8080, () =&gt; console.log('listen on 8080')); 执行node index.js 浏览器访问 http://localhost:8080/?a=x&b=2&c[]=1&amp;c[]=2 显示 12345{ &quot;a&quot;: &quot;x&quot;, &quot;b&quot;: &quot;2&quot;, &quot;c[]&quot;: [&quot;1&quot;, &quot;2&quot;] } 读取请求体参数HTTP协议规范中POST/PUT/PATCH都可以携带请求体，NodeJs HTTP服务器接收请求体代码如下： 123456789101112131415const http = require('http');const url = require('url');const qs = require('querystring');const server = http.createServer((req, res) =&gt; { let data = Buffer.alloc(0); req.on('data', (buffer) =&gt; { data = Buffer.concat([data, buffer]); }) req.on('end', () =&gt; { res.end(data.toString()) })})server.listen(8080, () =&gt; console.log('listen on 8080')); 执行node index.js 使用 postman 发出POST请求http://localhost:8080，本例POST请求体为 a=1&amp;b=2 postman会返回 a=1&amp;b=2 结语一个简单的HTTP服务器就到此结束了，当然，实际生产中该方法用的比较少，几乎都是使用框架进行开发，提高开发效率。","link":"/2019/07/19/2019-07-19-nodejs-guide-http-server.html"},{"title":"NodeJs简明教程(2)","text":"本文是NodeJs简明教程的第二篇，将介绍NodeJs在不同操作系统下的安装操作。 官网https://nodejs.org 由于国内的网络原因，官网可能访问速度有点慢，推荐直接使用淘宝镜像源下载 淘宝镜像源https://npm.taobao.org/mirrors/node，这里是所有版本/所有操作系统的NodeJs安装包。 本系列文章使用 latest-v10.x，也就是 10.x 的NodeJs版本 进入https://npm.taobao.org/mirrors/node/latest-v10.x/ 可以看到最新的版本号为 node-v10.16.0 Windows安装 64位 系统选择node-v10.16.0-x64.msi 32位 系统选择node-v10.16.0-x86.msi 双击即可完成安装 安装完毕之后打开cmd执行node -v，显示版本号即为安装成功，安装失败的读者可以在下方留言 Mac安装PKG安装包安装 选择node-v10.16.0.pkg 双击即可完成安装 安装完毕之后打开终端执行node -v，显示版本号即为安装成功，安装失败的读者可以在下方留言 Homebrew安装 brew install node 安装完毕之后打开终端执行node -v，显示版本号即为安装成功，安装失败的读者可以在下方留言 Linux安装 选择node-v10.16.0-linux-x64.tar.gz下载文件 执行wget https://npm.taobao.org/mirrors/node/latest-v10.x/node-v10.16.0-linux-x64.tar.gz 执行tar xf node-v10.16.0-linux-x64.tar.gz解压 执行mv node-v10.16.0-linux-x64 /opt/node移动到/opt目录 执行echo &quot;export PATH=/opt/node/bin:$PATH&quot; &gt;&gt; ~/.bashrc编辑PATH环境变量 执行source ~/.bashrc更新环境变量 执行node -v，显示版本号即为安装成功，安装失败的读者可以在下方留言","link":"/2019/07/19/2019-07-19-nodejs-guide-installation.html"},{"title":"NodeJs简明教程(4)","text":"本文是NodeJs简明教程的第四篇，将介绍NodeJs文件系统模块相关的基本操作。 fs 模块提供了一个 API，用于以模仿标准 POSIX 函数的方式与文件系统进行交互。 读取文件文件系统的大部分函数都存在 异步调用 和 同步调用 两种形式。 异步异步模式下，回调函数的第一个参数总为 Error 对象，且函数一般无返回值。 如果为null，则本次调用未出错 如果不为null，证明本次调用出错 新建 index.js 文件： 123456789const fs = require('fs');fs.readFile('./index.js', { encoding: 'utf8' }, (err, data) =&gt; { if (err) { console.error('读取文件失败', err); return; } console.log(data);}) readFile的第二个参数如果不指定编码，回调函数取到的data对象是Buffer，需要手动转字符串。读取文本文件可以指定编码，但是读取二进制文件(比如读取图片文件)就不能指定编码了，有一些字符时不可见字符，编码之后会出问题。 在当前目录执行 node index.js 输出如下： 123456789const fs = require('fs');fs.readFile('./index.js', (err, data) =&gt; { if (err) { console.error('读取文件失败', err); return; } console.log(data);}) 同步模式同步模式下，返回值为调用函数的结果，如果调用失败，将抛出Error对象： 12345678const fs = require('fs');try { const data = fs.readFileSync('./index.js', { encoding: 'utf8' }); console.log(data);} catch (e) { console.log('读取失败', e)} 输出数据和同步模式一致。 可以看到同步模式和异步模式下处理错误的方式是不同的。 各位读者在生产中尽量不要使用同步函数，否则会阻塞事件循环。当然，有一种情况例外，需要同步读取配置文件然后才启动服务器的这种情况是可以的。 写入文件新建index.js，代码如下： 1234567891011const fs = require('fs');const data = 'Hello World';fs.writeFile('./a.txt', data, (error) =&gt; { if (error) { console.error('保存失败', error); return; } console.log('保存成功');}) 执行node index.js 输出保存成功，同时当前目录会多出内容为Hello World的文本文件。 常用API fs.copyFile(src,dest[,flags],callback) 复制文件 fs.stat(path[,options],callback) 读取文件状态 fs.unlink(path,callback) 删除文件 fs.rename(oldPath,newPath,callback) 重命名文件 fs.mkdir(path[,options],callback) 新建目录 fs.rmdir(path,callback) 删除目录 结语文件系统的学习暂时到此为止，用到的时候大家可以详细查看文件，文件系统的函数调用方式和本文的示例都是类似的，各位读者可以举一反三。","link":"/2019/07/20/2019-07-20-nodejs-guide-filesystem.html"},{"title":"NodeJs简明教程(5)","text":"本文是NodeJs简明教程的第五篇，将介绍NodeJs path模块相关的基本操作。 path 模块提供用于处理文件路径和目录路径的实用工具。 注意：path模块只是处理文件路径，说白了就是字符串处理，跟文件系统无关 读取路径的文件名 path.basename() 方法返回 path 的最后一部分，类似于 Unix 的 basename 命令。 尾部的目录分隔符将被忽略。 返回带扩展名 12345const path = require('path');console.log(path.basename('/usr/local/a.txt'))// 输出 a.txt 返回不带扩展名 12345const path = require('path');console.log(path.basename('/usr/local/a.txt','.txt'))// 输出 a 读取文件路径的目录名 path.dirname() 方法返回 path 的目录名，类似于 Unix 的 dirname 命令。 尾部的目录分隔符将被忽略。path.extname() 方法返回 path 的扩展名，从最后一次出现 .（句点）字符到 path 最后一部分的字符串结束。 如果在 path 的最后一部分中没有 . ，或者如果 path 的基本名称（参阅 path.basename()）除了第一个字符以外没有 .，则返回空字符串。 12345const path = require('path');console.log(path.dirname('/usr/local/a.txt'))// 输出 /usr/local 获取文件扩展名 path.extname() 方法返回 path 的扩展名，从最后一次出现 .（句点）字符到 path 最后一部分的字符串结束。 12345const path = require('path');console.log(path.extname('/usr/local/a.txt'));// 输出 .txt 检测路径是否为绝对路径 path.isAbsolute() 方法检测 path 是否为绝对路径。 123456789const path = require('path');// linux || macosxconsole.log(path.isAbsolute('/usr/local')); // 输出 trueconsole.log(path.isAbsolute('usr/local')); // 输出 false// windowsconsole.log(path.isAbsolute('//server')); // 输出 trueconsole.log(path.isAbsolute('\\\\\\\\server')); // 输出 trueconsole.log(path.isAbsolute('c:\\windows')); // 输出 trueconsole.log(path.isAbsolute('foo/bar')); // 输出 false 生成规范化的路径 path.join() 方法使用平台特定的分隔符作为定界符将所有给定的 path 片段连接在一起，然后规范化生成的路径。零长度的 path 片段会被忽略。 如果连接的路径字符串是零长度的字符串，则返回 ‘.’，表示当前工作目录。 12345const path = require('path');console.log(path.join('/a','b','c','..')); // 输出 /a/bconsole.log(path.join('.','a','b','..','c')); // 输出 a/c 解析路径 path.parse() 方法返回一个对象，其属性表示 path 的重要元素。 尾部的目录分隔符将被忽略。返回对象属性如下：dir 目录root 根目录base 带扩展名的文件名或者目录名(最后一级是目录的情况下)name 文件名(不带扩展名)或目录名ext 文件扩展名(如果是目录则为空字符串) 123456789const path = require('path');path.parse('/home/user/dir/file.txt');// 返回:// { root: '/',// dir: '/home/user/dir',// base: 'file.txt',// ext: '.txt',// name: 'file' } 获取两个路径的相对路径 path.relative() 方法根据当前工作目录返回 from 到 to 的相对路径。 1234const path = require('path');console.log(path.relative('/data/orandea/test/aaa', '/data/orandea/impl/bbb')); // 输出 ../../impl/bbb 获取规范化的绝对路径 path.resolve() 方法将路径或路径片段的序列解析为绝对路径。 12345678const path = require('path');console.log(path.resolve('/foo/bar', './baz')); // 输出 /for/bar/bazconsole.log(path.resolve('/foo/bar', '/tmp/file/');); // 输出 /tmp/fileconsole.log(path.resolve('a','b','../c/img.gif'));// 假设当前工作目录 /home/wwwroot，上述语句输出 /home/wwwroot/a/c/img.gifconsole.log(path.resolve()); // 假设当前工作目录 /home/wwwroot 输出 /home/wwwroot 结语path模块的主要就是处理路径相关，经常和fs模块共同使用。","link":"/2019/07/20/2019-07-20-nodejs-guide-path.html"},{"title":"NodeJs简明教程(6)","text":"本文是NodeJs简明教程的第六篇，将介绍NodeJs crypto模块相关的基本操作。 crypto 模块提供了加密功能，包括对 OpenSSL 的哈希、HMAC、加密、解密、签名、以及验证功能的一整套封装。 Hash Hash类是用于创建数据哈希值的工具类。 哈希算法严格来说并不属于加密算法，传统意义上的 加密 是与 解密 相配对的。哈希算法能够保证被哈希的内容不被篡改。针对任意长度的输入数据都可以产生固定位数的哈希值。 crypto模块对hash的操作是一致的，除了算法名不一致之外，本文以 md5 和 sha1 作为示例。 MD5123456const crypto = require('crypto');const hash = crypto.createHash('md5'); // 创建MD5 hash示例hash.update('111111'); // 待计算hash的数据console.log(hash.digest('hex')); 以上例程输出 96e79218965eb72c92a549dd5a330112 SHA1123456const crypto = require('crypto');const hash = crypto.createHash('sha1'); // 创建MD5 hash示例hash.update('111111'); // 待计算hash的数据console.log(hash.digest('hex')); 以上例程输出 3d4f2bf07dc1be38b20cd6e46949a1071f9d0e3d Base64Base64并不是crypto模块的成员，但是跟本节内容比较相近，所以放过来了。Base64是一套编码算法，常用在二进制数据编码上。 Base64编码123const data = '111111';const encodedData = Buffer.from(data, 'utf8').toString('base64'); // 输入编码为utf8,输出为base64console.log(encodedData); 以上例程输出 MTExMTEx Base64解码123const data = 'MTExMTEx';const decodedData = Buffer.from(data, 'base64').toString('utf8'); // 输入编码为base64,输出编码为utf8console.log(decodedData); 以上例程输出111111 Hmac Hmac类是用于创建加密Hmac摘要的工具。 Hmac算法也是一种hash算法，但是它需要一个密钥，针对同样的输入，传统的hash算法输出是固定的。但是Hmac的输出会随着密钥的不同而不同。 1234567const crypto = require('crypto');const hmac = crypto.createHmac('sha256', 'secret-key');hmac.update('Hello, world!');console.log(hmac.digest('hex')); 以上例程输出 f4d850b1017eb4e20e0c58443919033c90cc9f4fe889b4d6b4572a4a0ec2d08a AES AES是一种常用的对称加密算法，加解密都用同一个密钥。 AES加密123456const crypto = require('crypto');const cipher = crypto.createCipheriv('aes192', '111111111111111111111111', '1111111111111111')var crypted = cipher.update('1', 'utf8', 'hex'); crypted += cipher.final('hex');console.log(crypted); 以上例程输出 5bb3e6eb39e502b5fa74d93796087efa 说明： createCipheriv原型如下： crypto.createCipheriv（algorithm，key，iv [，options]） iv是初始化向量，可以 为空 或者 16 字节的字符串 key是加密密钥，根据选用的算法不同，密钥长度也不同，对应关系如下： aes128对应16位长度密钥 aes192对应24位长度秘钥 aes256对应32位长度密钥 AES解密123456const crypto = require('crypto');const cipher = crypto.createDecipheriv('aes192', '111111111111111111111111', '1111111111111111')var data = cipher.update('5bb3e6eb39e502b5fa74d93796087efa', 'hex', 'utf8'); // 输入数据编码为hex(16进制)，输出为utf8data += cipher.final('utf8');console.log(data); 以上例程输出1 crypto.createDecipheriv方法原型与crypto.createCipher一致，这里不在赘述。 RSA RSA算法是一种非对称加密算法，即由一个私钥和一个公钥构成的密钥对，通过私钥加密，公钥解密，或者通过公钥加密，私钥解密。其中，公钥可以公开，私钥必须保密。 生成密钥对使用RSA算法前必须提供密钥对，本文使用openssl命令进行生成。 openssl genrsa -out private.pem 2048 生成2048位长度的私钥 openssl rsa -in private.pem -pubout -out public.pem 导出公钥 这样在当前目录我们就得到了private.pem和public.pem RSA加密1234567const crypto = require('crypto');const fs = require('fs');const privateKey = fs.readFileSync('./private.pem', { encoding: 'utf8' });const encodedData = crypto.privateEncrypt(privateKey, Buffer.from('111111','utf8')); // 传入utf8编码的数据console.log(encodedData.toString('hex')); 以上例程输出 144a1b50b9639e4cbe17d55ca57dcb041387acadae3d3721fd9803a3a33091a36d59977feaa6caad990e58b9542c26297de6014e20819f0a71eadd0793bfe0fac834f30d2a05f8b329a3b2409e9f8b7fbd7de3734ada00228b84027568be58a2a34ccf0c4a8b2d02c58eef510931423ed5f40c696361b606df11609248b271aebcd17f9a113f98a8fa86c9c45bd609256f4779ce01ea3027171fffb35e695f1c38553aecafb72a2f46a9012246fde0f2934eacba8932bca38e228f4f4294873ed75d9acf79ab854897ebaab2375384b2da682c1b2e2b49b0592929067b3d5a11971d912629a178691345f7f88137343588b5c51d60643e5c00998484727b8c4a8 RSA解密123456789const crypto = require('crypto');const fs = require('fs');const publicKey = fs.readFileSync('./public.pem', { encoding: 'utf8' });const encodedData = '44a1b50b9639e4cbe17d55ca57dcb041387acadae3d3721fd9803a3a33091a36d59977feaa6caad990e58b9542c26297de6014e20819f0a71eadd0793bfe0fac834f30d2a05f8b329a3b2409e9f8b7fbd7de3734ada00228b84027568be58a2a34ccf0c4a8b2d02c58eef510931423ed5f40c696361b606df11609248b271aebcd17f9a113f98a8fa86c9c45bd609256f4779ce01ea3027171fffb35e695f1c38553aecafb72a2f46a9012246fde0f2934eacba8932bca38e228f4f4294873ed75d9acf79ab854897ebaab2375384b2da682c1b2e2b49b0592929067b3d5a11971d912629a178691345f7f88137343588b5c51d60643e5c00998484727b8c4a8';const rawData = crypto.publicDecrypt(publicKey, Buffer.from(encodedData, 'hex')); // 传入hex(16进制)数据console.log(rawData.toString('utf8')); 以上例程输出 1111111 结语常用的加解密、哈希、编解码用法已经介绍完毕。","link":"/2019/07/21/2019-07-21-nodejs-guide-crypto.html"},{"title":"NodeJs简明教程(7)","text":"本文是NodeJs简明教程的第七篇，将介绍NodeJs events模块相关的基本操作。 大多数 Node.js 核心 API 构建于惯用的异步事件驱动架构，其中某些类型的对象（又称触发器，Emitter）会触发命名事件来调用函数（又称监听器，Listener）。 快速开始使用事件监听器一般包含以下操作： 新建事件监听器实例 设置监听函数 触发事件 1234567891011const EventEmitter = require('events'); // 引用模块class MyEmitter extends EventEmitter {} // 初始化监听器const myEmitter = new MyEmitter();myEmitter.on('event', () =&gt; { // 设置监听函数 console.log('an event occurred!');});myEmitter.emit('event'); // 触发事件 以上例程会输出an event occurred! 一次性事件监听上文中的监听方式事件触发几次就会输出几次an event occurred!，有些事件可能是一次性的。这时候可以使用once监听。 123456789101112const EventEmitter = require('events'); // 引用模块class MyEmitter extends EventEmitter {} // 初始化监听器const myEmitter = new MyEmitter();myEmitter.once('event', () =&gt; { // 设置监听函数 console.log('an event occurred!');});myEmitter.emit('event'); // 触发事件myEmitter.emit('event'); // 触发事件 以上例程会输出1次 an event occurred!; 同一事件多次监听上文中的监听方式都是只有1个监听函数，通过多次调用on可以设置多个监听函数。 123456789101112131415const EventEmitter = require('events');class MyEmitter extends EventEmitter {}const myEmitter = new MyEmitter();myEmitter.once('event', () =&gt; { // 监听器1 console.log('监听器1收到事件');});myEmitter.on('event', () =&gt; { // 监听器2 console.log('监听器2收到事件');})myEmitter.emit('event'); // 触发事件 以上例程会输出 12监听器1收到事件监听器2收到事件 接收事件参数 emit函数的第一个值为事件名,后续参数为事件值 on和once等监听器设置函数的回调函数收到的值为emit传入的事件参数 1234567891011const EventEmitter = require('events');class MyEmitter extends EventEmitter {}const myEmitter = new MyEmitter();myEmitter.once('event', (param1,param2,param3) =&gt; { // 接收事件参数 console.log('收到事件',param1,param2,param3);});myEmitter.emit('event','参数1','参数2',{name:'参数3'}); // 发送事件参数 以上例程会输出 1收到事件 参数1 参数2 { name: '参数3' } 获取事件监听器上所有事件使用eventNames()实例方法获取监听器上所有事件 123456789101112131415const EventEmitter = require('events');class MyEmitter extends EventEmitter {}const myEmitter = new MyEmitter();myEmitter.once('event', (param1,param2,param3) =&gt; { console.log('收到事件',param1,param2,param3);});myEmitter.once('event2',() =&gt; { console.log('收到事件2');});console.log(myEmitter.eventNames()); 以上例程输出[ 'event', 'event2' ] 移除事件监听器使用off实例方法移除单个监听器 123456789101112131415const EventEmitter = require('events');class MyEmitter extends EventEmitter {}const myEmitter = new MyEmitter();const callback = (param1) =&gt; { console.log(param1);};myEmitter.on('event', callback); // 添加监听器myEmitter.off('event', callback); // 移除监听器myEmitter.emit('event'); // 触发事件 以上例程没有输出，因为先添加监听器，随后移除，触发事件时已经没有可用的监听器了 移除所有监听器使用removeAllListeners([eventName])实例方法移除所有监听器。 removeAllListener不传参数时移除该emitter实例上所有事件监听器 removeAllListener传入字符串参数时移除该emitter实例上所有该事件的监听器 结语事件系统是NodeJs的灵魂，在几乎所有的I/O模块都有使用，希望各位读者好好掌握。","link":"/2019/07/22/2019-07-22-nodejs-guide-events.html"},{"title":"NodeJs简明教程(8)","text":"本文是NodeJs简明教程的第八篇，将介绍NodeJs 子进程 模块相关的基本操作。 child_process 模块提供了衍生子进程的能力（以一种与 popen(3) 类似但不相同的方式）。 NodeJs的JS线程虽然是单线程，不能利用多核CPU，也不能执行CPU密集型的任务，但是通过派生子进程的形式加上**IPC(进程间通信)**，可以充分利用多核CPU。 spawn spawn可以执行指定的命令，spawn的函数原型如下： 1child_process.spawn(command[,args][,options]) command &lt;string&gt; 要执行的命令 args &lt;string[]&gt; 传给命令的参数列表 options &lt;Object&gt; 额外选项 cwd &lt;string&gt; 子进程workdir env &lt;Object&gt; 子进程环境变量 1234567891011121314const { spawn } = require('child_process');const ls = spawn('ls', ['-lh', '/usr']); // 命令配置ls.stdout.on('data', (data) =&gt; { // 监听命令执行的标准输出 console.log(`stdout: ${data}`);});ls.stderr.on('data', (data) =&gt; { // 监听命令执行的标准错误输出 console.log(`stderr: ${data}`);});ls.on('close', (code) =&gt; { // 监听子进程退出 console.log(`子进程退出，使用退出码 ${code}`);}); 以上例程输出(不同机器输出可能不一样) 12345678910stdout: total 0drwxr-xr-x 970 root wheel 30K 7 19 23:00 bindrwxr-xr-x 306 root wheel 9.6K 7 12 22:35 libdrwxr-xr-x 249 root wheel 7.8K 7 19 23:00 libexecdrwxr-xr-x 15 root wheel 480B 4 1 14:15 localdrwxr-xr-x 239 root wheel 7.5K 7 12 22:35 sbindrwxr-xr-x 46 root wheel 1.4K 9 21 2018 sharedrwxr-xr-x 5 root wheel 160B 9 21 2018 standalone子进程退出，使用退出码 0 execexec也可以执行指定的命令，与spawn区别是执行结果通过回调通知，spawn是通过事件，exec函数原型如下： 1exec(command[,options][,callback]) command &lt;string&gt; 要执行的命令，命令参数使用空格分隔 options &lt;Object&gt; 额外选项 cwd &lt;string&gt; 子进程workdir env &lt;Object&gt; 子进程环境变量 timeout &lt;number&gt; 子进程执行超时 callback &lt;Function&gt; 执行结果回调 error &lt;Error&gt; 执行错误(不是子进程的错误输出) stdout &lt;string|Buffer&gt; 子进程标准输出 stderr &lt;string|Buffer&gt; 子进程标准错误输出 123456789const exec = require('child_process').exec;exec('ls -lh /usr',function(err,stdout,stderr) { if(err) { console.log('执行错误', err); } console.log('stdout', stdout); console.log('stderr', stderr);}); 以上例程输出 12345678910stdout: total 0drwxr-xr-x 970 root wheel 30K 7 19 23:00 bindrwxr-xr-x 306 root wheel 9.6K 7 12 22:35 libdrwxr-xr-x 249 root wheel 7.8K 7 19 23:00 libexecdrwxr-xr-x 15 root wheel 480B 4 1 14:15 localdrwxr-xr-x 239 root wheel 7.5K 7 12 22:35 sbindrwxr-xr-x 46 root wheel 1.4K 9 21 2018 sharedrwxr-xr-x 5 root wheel 160B 9 21 2018 standalone子进程退出，使用退出码 0 execFileexecFile类似于exec，但默认情况下不会派生shell， 相反，指定的可执行文件 file 会作为新进程直接地衍生，使其比 exec稍微更高效。 支持与exec相同的选项。 由于没有衍生 shell，因此不支持 I/O 重定向和文件通配等行为。execFile原型： 1execFile(file[,args][,options][,callback]) file &lt;string&gt; 要执行的命令或可执行文件路径 args &lt;string[]&gt; 字符串数组形式的参数列表 options &lt;Object&gt; 额外选项 cwd &lt;string&gt; 子进程workdir env &lt;Object&gt; 子进程环境变量 timeout &lt;number&gt; 子进程执行超时 callback &lt;Function&gt; 执行结果回调 error &lt;Error&gt; 执行错误(不是子进程的错误输出) stdout &lt;string|Buffer&gt; 子进程标准输出 stderr &lt;string|Buffer&gt; 子进程标准错误输出 12345678const execFile = require('child_process').execFile;execFile('ls', ['--version'], function(error, stdout, stderr) { if(err) { console.log('执行错误', err); } console.log('stdout', stdout); console.log('stderr', stderr);}); 以上例程输出同exec forkfork是spawn的一个特例，专门用于派生新的NodeJs进程。spawn可以派生任何进程。fork方法原型如下： 1fork(modulePath[,args][,options]) modulePath &lt;string&gt; 要执行的JS路径 args &lt;string[]&gt; 字符串数组形式的参数列表 options &lt;Object&gt; 额外选项 cwd &lt;string&gt; 子进程的workdir env &lt;Object&gt; 环境变量 silent &lt;boolean&gt; 如果为 true，则子进程的 stdin、stdout 和 stderr 将会被输送到父进程，否则它们将会继承自父进程。默认false b.js 123456789101112const fork = require('child_process').fork;const child = fork('./a.js',{silent:true}); // silent为true时可以监听子进程标准输出和标准错误输出child.stdout.on('data',function(data){ // 监听子进程标准输出 console.log('child stdout', data.toString('utf8'));});child.stderr.on('data', function(data){ // 监听子进程标准错误输出 console.log('child stderr', data.toString('utf8'));});child.on('close', function(){ console.log('child exit');}); a.js 1console.log('我是子进程`); 终端执行node b.js，以上例程输出： 123child stdout 我是子进程child exit 结语子进程模块的介绍到此就告一段落了，一般情况下使用spawn和execFile即可。","link":"/2019/07/23/2019-07-23-nodejs-guide-child-process.html"},{"title":"NodeJs简明教程(9)","text":"本文是NodeJs简明教程的第九篇，将介绍NodeJs net 模块(TCP服务端/客户端)相关的基本操作。 啥是TCP 传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793 定义。 NodeJs使用net模块实现TCP服务端/客户端相关功能。 Echo服务器开发 Echo服务器就是客户端发送什么，服务端就显示什么的一种服务端程序。主要为了调试网络和协议是否正常工作。 net.createServer用来创建一个服务端，该方法原型如下： net.createServer([options][, connectionlistener]): net.Server options &lt;Object&gt; allowHalfOpen &lt;boolean&gt; 表明是否允许半开的 TCP 连接。默认值: false。 pauseOnConnect &lt;boolean&gt; 表明是否应在传入连接上暂停套接字。默认值: false。 connectionListener &lt;Function&gt; 客户端连接事件监听器。回调参数为Socket(可以视为一个客户端连接) 返回值为net.Server，net.Server主要方法如下： server.listen([port[, host[, backlog]]][, callback]) port &lt;number&gt; 监听端口 host &lt;string&gt; 监听主机 backlog &lt;number&gt; 待连接队列的最大长度 callback &lt;Function&gt; 监听成功回调函数 server.js 1234567891011121314151617181920212223242526const net = require('net');const server = net.createServer(function (client) { // 创建服务端 console.log(client.address().address, '连接成功'); // 客户端连接成功时打印客户端地址 client.on('error', function (e) { console.log(client.address().address, ' error &gt;&gt; ', e.message); // 连接错误时（如客户端异常断开） }); client.on('data', function (data) { // 收到客户端数据 console.log(client.address().address, ' &gt;&gt; ', data.toString()); client.write(data); // 往客户端写数据 }); client.on('end', function () { // 客户端正常断开 console.log(client.address().address, '断开连接'); });});server.on('error', function (e) { // 服务器错误（如启动失败，端口占用） console.log('服务器启动失败', e);});server.listen(10000, function () { console.log('启动成功，地址', server.address().address);}); 执行node server.js可以看到输出启动成功，地址xxx 打开终端，执行telnet localhost 10000，可以看到输出如下（如果不一样，请加群讨论）： 123Trying ::1...Connected to localhost.Escape character is '^]'. 终端继续输入以下字符： 1helloworld 服务端会回复 1hello world 该Echo服务器就开发已经测试通过了。虽然代码量不多，但是演示了从零开始开发一个TCP服务器的流程，相比于C语言开发TCP服务器还是方便很多的。 TCP客户端net.connect可以连接目标TCP服务器，该方法原型如下： net.connect(port[,host][,connectionListener]) port &lt;number&gt; 连接端口 host &lt;string&gt; 连接主机 connectionListener &lt;Function&gt; 连接成功的回调 还是以刚才监听10000端口的服务端为例来开发客户端 client.js 12345678910111213141516const net = require('net');const client = net.connect(10000, 'localhost', function () { // 连接服务器 console.log('连接服务器成功'); client.write('我是客户端'); // 往服务端发送数据 client.on('data', function (data) { // 接收到服务端数据 console.log('服务端消息', data.toString()); client.end(); // 断开连接 }); client.on('end', function () { // 连接断开事件 console.log('服务端连接断开'); });}); 保证服务端开启的情况下，执行该js，输出如下： 123连接服务器成功服务端消息 我是客户端服务端连接断开 结语NodeJs TCP服务端与客户端开发到此结束，但是TCP协议的学习远远不止于此，包括自定义协议开发、TCP粘包问题等等。","link":"/2019/07/24/2019-07-24-nodejs-guide-net.html"},{"title":"NodeJs简明教程(10)","text":"本文是NodeJs简明教程的第十篇，将介绍NodeJs dgram 模块(UDP服务端/客户端)相关的基本操作。 啥是UDP Internet 协议集支持一个无连接的传输协议，该协议称为用户数据报协议（UDP，User Datagram Protocol）。UDP 为应用程序提供了一种无需建立连接就可以发送封装的 IP 数据报的方法。RFC 768描述了 UDP。 NodeJs使用dgram模块实现UDP服务端/客户端相关功能。 dgram.createSocket用来创建一个Socket对象，可以基于该套接口接收或发送数据。该方法原型如下： dgram.createSocket(type[, callback]) type &lt;string&gt; socket类型。udp4或udp6，对应ipv4和ipv6 callback &lt;Function&gt; 接收到消息时的回调函数 Echo服务端开发server.js 123456789101112131415161718192021const dgram = require('dgram');const socket = dgram.createSocket('udp4');socket.on('error', function(err) { // 监听socket错误 console.log('服务器错误', err); socket.close();});socket.on('message',function(msg,sender) { // 监听收到数据 console.log('%s:%d =&gt; %s', sender.address,sender.port,msg.toString()); // 打印该数据包详情 socket.send('socket: '+msg.toString(),sender.port,sender.address,function(err) { // 发送数据给来源地址 if(err) { console.log('回复%s:%d失败: %s',sender.address,sender.port,err.message); return; } });});socket.bind(10000, function() { // 监听UDP端口 console.log('服务器正在监听 %s:%d', socket.address().address, socket.address().port);}); Echo客户端开发由于telnet连接服务器使用的是TCP协议，所以本文对应的客户端需要使用NodeJs开发。 client.js 12345678910111213141516const dgram = require('dgram');const socket = dgram.createSocket('udp4'); // 创建socket实例socket.on('message', function(msg,sender) { // 监听收到数据 console.log('接收到%s:%d的消息:%s',sender.address,sender.port,msg.toString()); socket.close();});socket.send('hello',10000,function(err) { // 向目标端口发送数据 if(err) { console.log('发送错误', err); return; } console.log('发送成功');}); 执行 终端执行node server.js，输出 1服务器正在监听 0.0.0.0:10000 终端执行node client.js，输出 12发送成功接收到127.0.0.1:10000的消息:server: hello 服务端输出: 1127.0.0.1:50577 =&gt; hello 结语NodeJs UDP服务端与客户端开发到此结束，但是使用UDP的情况下，数据包确认、流量控制等等操作都需要程序员手动完成，这一方面确实挺复杂的，没有什么特殊的要求的话使用TCP即可。","link":"/2019/07/25/2019-07-25-nodejs-guide-dgram.html"},{"title":"NodeJs简明教程(11) - 完结篇","text":"本文是NodeJs简明教程的完结篇，将对以往文章进行归档。 系列文章 NodeJs简明教程(1)——简介 NodeJs简明教程(2)——安装 NodeJs简明教程(3)——HTTP服务器 NodeJs简明教程(4)——文件系统 NodeJs简明教程(5)——路径 NodeJs简明教程(6)——加解密 NodeJs简明教程(7)——事件 NodeJs简明教程(8)——子进程 NodeJs简明教程(9)——TCP开发 NodeJs简明教程(10)——UDP开发 接下来的内容 Typescript语言基础 NodeJs常用第三方模块(缓存、数据库、通用连接池、消息队列等等) koa 专题 express 专题 nestjs 专题 欢迎持续关注~","link":"/2019/07/25/2019-07-25-nodejs-guide-next-step.html"},{"title":"TS简明教程(1)","text":"本文是TS简明教程的第一篇，对TS做简要介绍、基础知识以及后续内容规划。 TypeScript是JavaScript的一个超集，支持 ECMAScript 6 标准。TypeScript可以在任何浏览器、任何计算机和任何操作系统上运行，并且是开源的。Typescript由微软开发，与C#出自同一人之手! TS与JS的区别 TS是JS的超集，扩展了TS的语法，因此现有的JS代码可直接与TS一起工作无需任何修改，TS通过类型注解提供编译时的静态类型检查。 由于TS与JS语法大部分一致，本文只对有差异的部分进行讲解。 目录有些知识点可能是交叉的\b建议通读完本文再开始真正的开发，这样疑惑会比较少一点 数据类型与类型断言 函数 接口和类 泛型 枚举 命名空间和模块 装饰器(注解) 高级类型 声明文件 tsconfig.json 示例 React示例(前端) Koa示例(后端) 数据类型与类型声明TS使用:语法对类型进行声明。基础类型如下： 布尔类型TS使用boolean来声明布尔类型。 1let succeed: boolean = false; // 声明succeed为boolean类型 数字TS对数字的支持与JS一致，所有数字都是浮点数，所以TS并不存在int,float之类的数字类型声明，只有number。除了支持十进制和十六进制，TS还支持ES6的二进制和八进制数字。 12const age: number = 16; // 声明年龄为数字类型const price: number = 99.99; // 声明价格为数字类型 字符串TS使用string声明字符串，和JS一样，支持单引号和双引号。 12345let name: string = &quot;demo&quot;;name = &quot;demo1&quot;;const description = `我是${name}`; // ES6语法 数组TS使用类型[]声明数组的元素类型，与JS不一样的地方在于，TS中一旦指明一个类型，所有元素必须是该类型。JS则可以往数组放任意类型的元素。 1234const numbers: number[] = [];numbers.push(1);numbers.push(2);numbers.push('3'); // 错误，'3'不是数字类型 对象与JS一样，TS的对象也是由键值对构成，类型声明可以分别作用与键类型以及值类型。 声明语法：{[key名称: key类型]: 值类型}key名称可以自定义，如key,index都是合法的。 12345const config: {[key: string]: string} = {}; // 声明键和值都只能是字符串类型config.version = '1.0.0';const ages: {[key: number]: number} = {}; // 声明键值对都是数字类型ages[10] = '1.0.0'; // 赋值 上例中赋值语法虽然和数组一致，但是ages对象的长度为1，如果ages是数组的话，长度为11。(0-9个元素为undefined) 任意类型TS用any用来声明任意类型，被any修饰的变量(或常量以及返回值等等)在编译阶段会直接通过，但是运行阶段可能会抛出undefined或null相关错误。 any的出现使得现有的JS代码能够很快速的切换到TS。 12let age:any = 10;age = 'name'; // 编译通过 空类型TS使用void声明空类型。与any相反，表示没有任何类型，常用在函数返回值中。void类型只能被赋值为null和undefined。 12345function test(name: string): void { // 声明函数无返回值，编译成JS之后取返回值会取到undefined，与JS一致 console.log(name);}let v: void = null; null和undefinedTS中默认情况下，null和undefined是所有类型的子类型，换句话说，你可以把null和undefined直接赋值给number/string/boolean等类型。但是不能反过来干，你不能把number/string/boolean类型赋值给null或者undefined 12let u: undefined = undefined;let n: null = null; nevernever是100%不存在的值的类型。比如函数中直接抛出异常或者有死循环。 1234567891011function error(message: string): never { throw new Error(message);}function fail() { // TS自动类型推断返回值类型为never，类型推断在下文中会提到 return error('failed');}function loop(): never { // 死循环，肯定不会返回 while(true) {} } never和void区别 被void修饰的函数能正常终止，只不过没有返回值 被never修饰的函数不能正常终止，如抛出异常或死循环 枚举枚举是对JS的一个扩展。TS使用enum关键字定义枚举类型。 123456enum Color { Red, Green, Yellow}let c: Color = Color.Red; ObjectTS使用object类修饰对象类型，TS中表示非原始类型。原始类型如下： number string boolean null undefined symbol(ES6新出类型) 123let a: object = {}; // oklet a: object = 1; // errorlet a: object = Symbol(); / error 虽然Symbol长得像对象类型，不过在ES6规范中，人家就是原始类型。 函数声明TS中可以对函数的形参以及返回值进行类型声明。 123function a(name: string, age: number): string { return `name:${name},age:${age}`;} 类型断言类型断言说白了就是告诉编译器，你按照我指定的类型进行处理。 12let value: any = 'a string';const length: number = (&lt;string&gt;value).length; 编译结果(正常编译且正常运行) 12let value = 'a string';const length = value.length; 类型推断当没有手动指定类型时，TS编译器利用类型推断来推断类型。如果由于缺乏声明而不能推断出类型，那么它的类型被视作默认的动态 any 类型。 1let num = 2; // 推断为number类型 函数TS函数与JS函数没有大的区别，多了一个类型系统。 123function test(name: string) { // 自动推断返回类型为string return name;} 可选参数TS中函数每个形参都是必须的，当然你可以传递null和undefined，因为他们是值。但是在JS中，每个形参都是可选的，没传的情况下取值会得到undefined。TS中在参数名后面使用?号指明该参数为可选参数 1234function test(name: string, age?: number) { console.log(`${name}:${age}`);}test('a'); // 输出 a:undefined 默认参数与ES6一致，TS也的函数也支持默认参数。需要注意的是可选参数和默认参数是互斥的。因为如果使用了默认参数，不管外部传不传值，取值的时候都是有值的，和可选参数矛盾。 1234function test(name: string, age: number = 10) { console.log(`${name}:${age}`)}test('a'); // 输出 a:10 剩余参数剩余参数和ES6表现一致，但是多了类型声明： 1234function test(name1: string, ...names: string[]) { console.log(name1, names);}test('1','2','3');// 输出 1 ['2', '3'] this执行TS中this指向和JS一致，这里不做赘述。 结语未完待续~","link":"/2019/07/25/2019-07-25-typescript-quick-guide.html"},{"title":"使用Typescript装饰器来劫持React组件","text":"最近在捣鼓Typescript的装饰器，NodeJs项目的装饰器比较好理解，但是React项目的装饰器由于有JSX，走了一点弯路，但是总之来说是新技能get typescript对装饰器的说明 装饰器是一种特殊类型的声明，它能够被附加到类声明，方法， 访问符，属性或参数上。 装饰器使用 @expression这种形式，expression求值后必须为一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入。 装饰器为我们提供了运行时修改数据的能力。 React例子Parent.tsx 1234567891011@Componentexport default class App extends PureComponent { handleClick() { console.log('parent click'); } render() { return ( &lt;div className=&quot;App&quot; onClick={this.handleClick}&gt;parent&lt;/div&gt; ); }} Component装饰器 12345678910111213function Component&lt;T extends { new(...args: any[]): any }&gt;(component: T) { // 泛型限定 return class extends component { handleClick() { // 劫持onClick super.handleClick() console.log('child clicked'); } render() { const parent = super.render() // 劫持onClick return React.cloneElement(parent, { onClick: this.handleClick }) } }} 点击渲染之后的parent字符，可以看到劫持成功 项目地址react-decorator-example 结论本文写的只是比较简单的装饰器用法，但是可以基于此文的原来来开发如登录后才能访问的组件之类的装饰器，将业务逻辑更好的组织起来。 对TS有兴趣的伙伴可以加我微信交流~","link":"/2019/07/26/2019-07-26-react-decorator-example.html"},{"title":"手把手从零开始小程序单元测试(附避坑指南以及源码跟踪)","text":"单元测试是一个老生常谈的话题，基于Web/NodeJs环境的测试框架、测试教程数不胜数，也趋于成熟了。但是对于微信小程序的单元测试，目前还是处于起步状态，这两天在研究微信小程序的测试，也遇到了一些坑，在这里记录一下，希望给看到本文的小伙伴带来一点帮助，少走一些弯路。 demo地址https://github.com/xialeistudio/miniprogram-unit-test-demo 关键依赖版本本文写作时相关依赖版本如下(版本不同，源码行数可能不同)： miniprogram-simulate: 1.0.7 j-component: 1.1.6 miniprogram-exparser: 0.0.6 测试流程 初始化小程序项目，编写待测试组件 安装jest,miniprogram-simulate测试环境 编写测试用例 执行测试 初始化小程序项目 使用小程序开发者工具初始化新项目，APPID选择测试号即可，语言选择Javascript。 使用小程序开发者工具新建/components/user组件 components/user.js 1234567891011// components/user.jsComponent({ data: { nickname: '' }, methods: { handleUserInfo: function(e) { this.setData({ nickname: e.detail.userInfo.nickName }) } }}) components/user.wxml12&lt;text class=&quot;nickname&quot;&gt;{{nickname}}&lt;/text&gt;&lt;button class=&quot;button&quot; open-type=&quot;getUserInfo&quot; bindgetuserinfo=&quot;handleUserInfo&quot;&gt;Oauth&lt;/button&gt; pages/index/index.js123Page({ data:{}}) pages/index/index.wxml 123&lt;view class=&quot;container&quot;&gt; &lt;user&gt;&lt;/user&gt;&lt;/view&gt; 打开小程序开发者工具，可以看到有一个Oauth按钮，点击之后会在上面显示昵称。 由此可以得到测试用例点击授权按钮时上方显示为授权用户的昵称 安装jest/miniprogram-simulate测试环境 由于JS项目的小程序根目录没有package.json，需要手动生成一下 打开终端，在项目根目录执行npm init -y生成package.json 安装测试工具集npm install jest miniprogram-simulate --save-dev 编辑package.json，在scripts新建test命令 12345678910111213141516{ &quot;name&quot;: &quot;unit-test-demo&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;app.js&quot;, &quot;scripts&quot;: { &quot;test&quot;: &quot;jest&quot; }, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: { &quot;jest&quot;: &quot;^24.8.0&quot;, &quot;miniprogram-simulate&quot;: &quot;^1.0.7&quot; }} 编写测试用例 在项目根目录新建tests/components/user.spec.js文件(目录需要手动创建) 代码如下(参考微信官方单元测试文档编写): 123456789101112131415161718192021const simulate = require('miniprogram-simulate');const path = require('path');test('components/user', (done) =&gt; { // 定义测试名称,传入done表示当前测试是异步测试，需要回调函数来告诉jest，我测试执行完毕const id = simulate.load(path.join(__dirname, '../../components/user')); // 加载组件const component = simulate.render(id); // 渲染组件const text = component.querySelector('.nickname'); // 获取nickname节点const button = component.querySelector('.button'); // 获取button节点button.dispatchEvent('getuserinfo', { // 模拟触发事件 detail: { // 传递事件参数 userInfo: { nickName: 'hello', }, },});setTimeout(() =&gt; { // 异步断言 expect(text.dom.innerHTML).toBe('hello'); // 检测text节点的innerHTML等于模拟授权获取的昵称 done();}, 1000);}); 执行测试 npm run test，等待一秒后发现，不出意外的话，测试肯定过不去 部分出错日志：123456Expected: &quot;hello&quot;Received: &quot;&quot; at toBe (/Users/xialeistudio/WeChatProjects/unit-test-demo/tests/components/user.spec.js:18:32) at Timeout.callback [as _onTimeout] (/Users/xialeistudio/WeChatProjects/unit-test-demo/node_modules/jsdom/lib/jsdom/browser/Window.js:678:19) at listOnTimeout (internal/timers.js:535:17) at processTimers (internal/timers.js:479:7) 可以推测一下原因： dispatchEvent的事件触发有问题，导致handleUserInfo未触发[1] dispatchEvent的事件触发成功，但是触发参数有问题[2] 错误分析(源码跟踪过程) 针对第1点原因，可以写一下测试代码(components/user.js)12345678910Component({ data: { nickname: '' }, methods: { handleUserInfo: function(e) { console.log(e); } }}) npm run test，可以看到事件还是成功触发了，不过detail是{}12345678 console.log components/user.js:21{ type: 'getuserinfo', timeStamp: 948, target: { id: '', offsetLeft: 0, offsetTop: 0, dataset: {} }, currentTarget: { id: '', offsetLeft: 0, offsetTop: 0, dataset: {} }, detail: {}, touches: {}, changedTouches: {} } 原因1排除，查原因2 dispatchEvent方法是被测试组件的子组件，被测试组件由simulate.render函数返回 浏览node_modules/miniprogram-simulate/src/index.js，看到render函数(152行)，可以看到返回的组件由jComponent.create提供 浏览node_modules/j-component/src/index.js的create函数，可以看到其返回了RootComponent实例，而RootComponent是由./render/component.js提供 浏览node_modules/j-component/src/render/component.js的dispatchEvent函数，在这里可以打下日志测试(本文就不打了，结果是这里的options就是user.spec.js dispatchEvent函数的第二个参数，detail是有值的) 继续跟踪源码，由于咱们的是自定义事件，所以会走到91行的代码，该代码块如下： 123456789101112131415161718// 自定义事件 const customEvent = new CustomEvent(eventName, options); // 模拟异步情况 setTimeout(() =&gt; { dom.dispatchEvent(customEvent); exparser.Event.dispatchEvent(customEvent.target, exparser.Event.create(eventName, {}, { originalEvent: customEvent, bubbles: true, capturePhase: true, composed: true, extraFields: { touches: options.touches || {}, changedTouches: options.changedTouches || {}, }, })); }, 0); 可以看到调用了exparser.Event.dispatchEvent函数，该函数的第二个参数调用了exparser.Event.create对自定义事件进行了包装，这里还没到最底层，需要继续跟踪 exparser对象是miniprogram-exparser模块提供的，浏览node_modules/miniprogram-exparser/exparser.min.js，发现该文件被混淆了，不过没关系混淆后的代码逻辑是不变的，只不过变量名变得无意义，可读性变差 使用webstorm格式化该文件，这里我传了一份格式化好的到github wxparser.js，可在线观看 需要在源码中搜索三个参数的create函数(Object.create不算)，需要有耐心，经过排查后发现168行代码应该是目标代码1234567i.create = function(e, t, r) { r = r || {}; var n = r.originalEvent, o = r.extraFields || {}, a = Date.now() - l, s = new i; s.currentTarget = null, s.type = e, s.timeStamp = a, s.mark = null, s.detail = t, s.bubbles = !!r.bubbles, s.composed = !!r.composed, s.__originalEvent = n, s.__hasCapture = !!r.capturePhase, s.__stopped = !1, s.__dispatched = !1; for (var u in o) s[u] = o[u]; return s;} 可以看到s.detail = t这个赋值，t是create的第二个参数，由node_modules/j-component/render/component.js的wxparser.Event.create传入，但是传入的第二个参数写死了{}，所以咱们的组件获取detail的时候永远为{}，将其修改为options.detail||{}即可，修改后代码如下：1exparser.Event.dispatchEvent(customEvent.target, exparser.Event.create(eventName, options.detail||{}, xxxxxx 重新测试12345678 PASS tests/components/user.spec.js✓ components/user (1099ms)Test Suites: 1 passed, 1 totalTests: 1 passed, 1 totalSnapshots: 0 totalTime: 3.622sRan all test suites. 避坑指南 querySelector用法同HTML，但是需要在组件执行，而不是组件.dom，HTML中实在DOMNode执行的 dispatchEvent是触发事件，需要在组件执行，上述代码中是触发button组件的自定义事件 dispatchEvent事件名规范: 去掉前导bind剩余的字符串为事件名，示例代码中bindgetuserinfo，触发时就是getuserinfo，如果是bindtap，那触发时就是tap dispatchEvent底层是j-component这个npm模块实现的，跟踪源码发现执行是异步的(代码文件node_modules/j-component/src/render/component.js，函数名dispatchEvent) 123456789101112131415161718// 自定义事件 const customEvent = new CustomEvent(eventName, options); // 模拟异步情况 setTimeout(() =&gt; { dom.dispatchEvent(customEvent); exparser.Event.dispatchEvent(customEvent.target, exparser.Event.create(eventName, {}, { originalEvent: customEvent, bubbles: true, capturePhase: true, composed: true, extraFields: { touches: options.touches || {}, changedTouches: options.changedTouches || {}, }, })); }, 0); 由于setTimeout的存在，触发事件为异步，所以写断言时需要加定时器 结语小程序单元测试基本是没什么经验扩借鉴，但是基于官网提供的工具，以及开源，咱们遇到问题时细心排查然后修改一下，还是可以解决问题的。","link":"/2019/07/27/2019-07-27-miniprogram-unit-test.html"},{"title":"TS简明教程(2)","text":"本文是TS简明教程的第二篇，讲解面向对象相关的知识。 类传统JS使用函数和原型链进行集成，在ES6出现了class关键，JS也能使用传统OOP的方式进行继承，但是还是存在一定的局限性，在TS中，OOP已经和传统语言差不多。 12345678910111213141516class Parent { name: string; age: number; constructor(name: string, age: number) { this.name = name; this.age = age; } say() { return `name: ${this.name}, age: ${this.age}`; }}const parent = new Parent();parent.say(); 可以看到TS的OOP写法和Java还是有点类似的。但是他两的构造方法名不同，TS构造方法名为constructor，Java是类名。 继承继承用来扩展现有的类，TS中这一点和传统语言一样使用extends语法。 1234567891011121314151617181920212223class Parent { name: string; constructor(name: string) { this.name = name; } say() { console.log(`Parent say: ${this.name}`); }}class Child extends Parent { age: number; constructor(name: string, age: number) { // 覆盖父类构造方法 super(name); // 调用父类构造方法 this.age = age; } say() { console.log(`Child say: ${this.name} ${this.age}`); }}const child: Parent = new Child(&quot;haha&quot; ,1);child.say(); // 输出 Child say haha 1 子类存在构造方法时，必须显示调用父类构造方法先有父亲，后有儿子 TS方法调用是基于值而不是基于类型声明，比如child声明为Parent类型，但是值是子类型，所以调用方法时会调用子类的say 访问限定符publicTS中方法和属性默认的访问限定符为public，所有外部或内部成员都可访问。 123456789class Parent { public name: string; // public可以不加 say() { console.log(`say ${this.name}`); }}const p = new Parent();p.name = 'hello';p.say(); // 输出 say hello private私有访问，只能在本类访问,子类和其他类都不行。 12345678910class Parent { private name: string; private say() { console.log(`say ${this.name}`); }}const p = new Parent();p.name = 'hello'; // 错误，private限定的属性不能被外部访问p.say(); // 错误，private限定的访问不能被外部访问 protected保护性访问，只能被本类或本类的子类(子类的子类也可以访问)。 12345678910111213141516171819class Parent { protected name: string; constructor(name: string) { this.name = name; } protected say() { console.log(`say ${this.name}`); }}class Child extends Parent { public say() { // 提升访问性 console.log(`say ${this.name}`); // 访问父类属性 }}const c = new Child('hello');c.say(); // 输出 say hello 访问限定符只能提升，不能降低，如下例子是无法通过编译的： 1234567class Parent { protected name: string;}class Child extends Parent { private name: string; // 错误，子类访问性必须&gt;=父类的访问性} 只读限定TS使用readonly声明只读属性(方法不能使用)，必须在声明时或者构造时进行赋值,其他地方不能赋值 1234567class Parent { private readonly name = 'hello'; private readonly age: number; constructor(age: number) { this.age = age; }} 参数属性在上例中我们在构造方法中使用this.age = age对已存在的私有只读属性age进行了赋值。由于该操作时常用操作，所以TS有了更加便捷的写法： 12345678class Parent { constructor(readonly name: string, private readonly age: number) { } say() { console.log(`say ${this.name} ${this.age}`); }} 上例中声明了公有只读的name属性，私有只读的age属性 getter &amp;&amp; setter在传统语言中，几乎不会直接声明公有属性，然后对其进行操作，都会先定义私有属性，然后提供getter和setter方法对其操作(Java中很多类都是这种情况) 123456789101112131415class Parent { private _name: string; get name(): string { return this._name; } set name(name: string) { console.log(`name设置前: ${this._name} 设置后: ${name}`); this._name = name; }}const parent = new Parent();parent.name = 'ok'; // 可以直接使用赋值语句，但是会自动调用set name(name: string)方法 getter和setter方法提高了开发者对属性的控制，一起对属性的访问都是可控的，为以后的扩展性打下了基础（比如如果需要加缓存，我们可以在set时设置缓存,get时读取缓存，如果是直接操作属性的话，该功能实现起来很麻烦 静态属性 &amp;&amp; 静态方法以上讨论的都是实例属性和梳理方法，需要有实例才能调用，如果有些属性或方法并不是存在于实例上时可以使用静态方法或静态属性 12345678class Parent { static name: string; static say() { console.log(`name ${this.name}`); // 方法是静态，属性是静态时可以使用this }}Parent.say();// 使用类名调用静态方法 需要注意的是实例可以直接调用静态，静态不能直接调用实例，因为实例需要实例化后调用 抽象类传统语言中接口只包含实现，不包含细节。而抽象类可以包含细节。一般来说，有些公有方法可以放到抽象类做，不同的子类完成不同功能的代码可以放到抽象类做。 12345678910111213141516171819abstract class Animal { abstract say(): void; // 声明抽象方法，子类必须实现 eat() { console.log(`animal eat`); }}class Human extends Animal { // 使用extends关键字 say() { console.log('human say words'); }}class Dog extends Animal { say() { console.log('dog say wangwang'); }} 接口接口用来限定子类的行为，不关心具体实现。与传统语言不同的是,TS接口还可以限定变量或常量的属性 限定子类行文： 12345678910111213interface Animal { say(): void; eat(): void;}class Human implements Animal { say() { console.log('human say'); } eat() { console.log('human eat'); }} 限定变量属性： 12345678interface A { name?: string; age: number;}const obj: A = { age: 10, // name是可选的}; 可索引类型使用可索引类型来描述可以通过索引访问得到的类型。如person[&quot;name&quot;],list[0] 1234567interface HashMap { [key: string]: any; // 冒号左边为属性名类型，右边为值类型}const map: HashMap = {};map[&quot;name&quot;] = &quot;1&quot;;map.a = &quot;2&quot;; 接口继承与类继承类似，接口也可以通过继承来扩展现有的功能： 123456interface Animal { eat(): void; // 动物会吃，但是怎么吃的不管}interface Human extends Animal { say(): void; // 人会说话，但是怎么说，说什么不管} 混合类型JS中，函数可以直接调用也可以通过对象方式调用，TS中可以通过接口声明被修饰的函数支持的调用方式： 123456789101112131415interface Counter { (start: number): string; step: number; reset(): void;}function getCounter(): Counter { const counter = &lt;Counter&gt; function(start: number) {}; counter.step = 1; counter.reset = function() {};}const c = getCounter();c(1);c.reset();c.step = 2; 结语面向对象中的类和接口内容实在是太多了，本文只选择了开发中常用到的用法进行说明，不足之处，敬请包涵。","link":"/2019/07/29/2019-07-29-typescript-quick-guide2.html"},{"title":"TS简明教程(3)","text":"本文是TS简明教程的第三篇，讲解泛型。 泛型 泛型程序设计（generic programming）是程序设计语言的一种风格或范式。泛型允许程序员在强类型程序设计语言中编写代码时使用一些以后才指定的类型，在实例化时作为参数指明这些类型。 泛型的出现有效的降低了代码重复率，同时也能很好的保留类型信息，降低运行期崩溃的概率。 HelloWorld\b假设有个函数，你给他啥类型，他就返回啥类型，代码如下： 123function getValue(arg: number):number { return arg;} 如果需要支持字符串的话，有以下做法： 复制一份代码，然后更改number为string 把number改为any 但是以上做法有弊端，方法1会导致代码重复比较多，而且难以扩展（只能通过复制代码来扩展）；方法2的话会丢失变量类型信息，运行期可能会抛出异常。 因此，我们需要一种方法使返回值的类型与传入参数的类型是相同的。这里，我们使用了 类型变量，它是一种特殊的变量，只用于表示类型而不是值。 123function getValue&lt;T&gt;(arg: T): T { return arg;} 调用 12const n = getValue&lt;number&gt;(2);const s = getValue&lt;string&gt;('s'); 说明，如果arg:T中arg是可自动推导类型（一般不是any就能推导），那么&lt;&gt;之间的类型可以省略，如果&lt;&gt;指定了类型，但是arg类型不匹配的话，编译失败。 T是随便取的，你叫ABCD都没人管你 泛型函数原型如下： 1function 函数名&lt;泛型类型，有几个写几个，逗号分隔&gt;(参数名: 参数类型，参数名:参数类型):返回值类型 传统风格 123function makeMap&lt;K,V&gt;(key: K, value: V):map&lt;K,V&gt; { return map&lt;K,V&gt;(key,value);} 箭头函数风格 123const makeMap: &lt;K,V&gt;(key:K,value:V) =&gt; map&lt;K,V&gt; = { // &lt;K,V&gt;(key:K,value:V) =&gt; map&lt;K,V&gt; 类型声明 return map&lt;K,V&gt;(key,value);} 泛型接口原型如下: 123interface 接口名称&lt;泛型类型，有几个写几个，逗号分隔&gt; { // 使用泛型约束} 例子 123456789101112131415161718192021interface GenericFunction&lt;T&gt; { getValue(arg:T):T;}// 字符串类型class Test implements GenericFunction&lt;string&gt; { getValue(arg:string):string { returna arg; }}// 数字类型class Test2 implements GenericFunction&lt;number&gt; { getValue(arg:number):number { returna arg; }}const test = new Test();console.log(test.getValue('111'));const test2 = new Test2();console.log(test.getValue(111)); 泛型类泛型类的使用和泛型接口差不多 123456789class GenericClass&lt;T&gt; { add(a: T, b: T):T;}const n = new GenericClass&lt;number&gt;();console.log(n.add(1,1));const s = new GenericClass&lt;string&gt;();console.log(s.add('1','2')); 使用继承约束Java中经常看到如下代码 1234567891011public class Generic&lt;T extends Number&gt;{ private T key; public Generic(T key) { this.key = key; } public T getKey(){ return key; }} 上例中，T只能为Number子类。避免过大范围的泛型导致问题 TS也可以使用以上方法： 1234567891011121314151617181920212223242526class BeeKeeper { hasMask: boolean;}class ZooKeeper { nametag: string;}class Animal { numLegs: number;}class Bee extends Animal { keeper: BeeKeeper;}class Lion extends Animal { keeper: ZooKeeper;}function createInstance&lt;A extends Animal&gt;(c: new () =&gt; A): A { return new c();}createInstance(Lion).keeper.nametag; // 编译OKcreateInstance(Bee).keeper.hasMask; // 编辑OK 以下代码可能难以理解 1function createInstance&lt;A extends Animal&gt;(c: new () =&gt; A): A 拆开来看: 泛型约束，A必须是Animal子类 new () =&gt; A 箭头函数，约束了传入的值必须是构造方法 :A createInstance必须返回传入的构造函数的实例 结语泛型有效减少了重复代码，同时也解决了类型强制转换的问题，在开发中要尽量使用泛型而不是any。TS的泛型用法大部分都比这复杂，但是原理是一样的，不足之处，敬请包涵。对TS有兴趣的小伙伴可以扫码加我进行交流","link":"/2019/07/30/2019-07-30-typescript-quick-guide3.html"},{"title":"TS简明教程(4)","text":"本文是TS简明教程的第四篇，讲解装饰器。 装饰器装饰器是一种特殊类型的声明，它能够被附加到类声明，方法，访问符，属性或参数上。 装饰器使用@expression这种形式，expression必须是一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入。 Typescript中的装饰器是一项实验性功能，需要在tsconfig.json中开启该特性 12345{ &quot;compilerOptions&quot;: { &quot;experimentalDecorators&quot;: true }} 例如，有一个@sealed装饰器，我们这样定义sealed: 123function sealed(target: any) { // 操作被装饰对象} 装饰器工厂如果需要给装饰器添加一些动态行为，比如开发一个监控统计的装饰器，需要传入当前统计的事件名称，有多个事件名称时只需要变更传入的事件名而不用重复定义装饰器。 这时候需要使用到装饰器工厂。装饰器工厂也是一个函数，只不过它的返回值是一个装饰器。例如如下的事件监控装饰器： 12345function event(eventName: string) { return function(target: any) { // 获取到当前eventName和被装饰对象进行操作 }} 装饰器组合多个装饰器可以同时应用到被装饰对象上，例如下面的例子： 12345@sealed@test('test')class Demo {} 装饰器执行顺序： 装饰器工厂需要先求值，再装饰，求值顺序是由上到下 装饰器可以直接求值，装饰顺序是由下到上 上面的说明可以难以理解，下面举一个实际的例子： 12345678910111213141516171819function f() { console.log('f求值'); return function(target: any) { console.log('f装饰'); }}function g() { console.log('g求值'); return function(target: any) { console.log('g装饰'); }}@f()@g()class Demo {} 上例的执行顺序为 1234f求值g求值g装饰f装饰 因为先求值，所以在上面的f会比g先求值。因为装饰器是由下到上装饰，所以求值后的g比f先执行。 装饰器类型根据被装饰的对象不同，装饰器分为以下几类： 类装饰器 方法装饰器 属性装饰器 函数参数装饰器 类装饰器类装饰器在定义类的地方。类装饰器可以监视、修改或替换类定义。类的构造函数将作为唯一参数传递给装饰器。如果类装饰器返回一个值，它会使用返回的构造函数替换原来的类声明。 12345678function sealed(target: Function) { Object.seal(target); Object.seal(target.prototype);}@sealedclass Demo {} 下面来一个替换构造函数的示例： 12345678910111213141516function replace&lt;T extends {new(...args: any[]):{}}&gt;(target: T) { return class extends target { newname = &quot;newName&quot;; age = 18 }}@replaceclass Demo { oldname = &quot;oldname&quot;; constructor(oldname: string) { this.oldname = oldname; }}console.log(new Demo(&quot;oldname&quot;)); 以上例程会输出 1class_1 { oldname: 'oldname', newname: 'newName', age: 18 } 可以看到通过装饰器新增的newname和age属性已经成功注入了。 方法装饰器方法装饰器用来装饰类的方法（静态方法和实例方法都可以）。方法装饰器可以监视、修改或替换方法定义。方法装饰器接收3个参数： 类的原型对象，如果是静态方法则为类的构造函数 方法名称 方法的属性描述符 下面是一个修改方法行为的装饰器： 123456789101112131415161718function hack(target: any, propertyKey: string, descriptor: PropertyDescriptor) { const oldFunction = target[propertyKey]; // 获取方法引用 const newFunction = function(...args: any[]) { console.log('call function ', propertyKey); oldFunction.call(target, ...args); } descriptor.value = newFunction; // 替换原声明}class Demo { @hack demo() { console.log('call demo'); }}const demo = new Demo();demo.demo(); 以上例程输出如下： 12call function democall demo 属性装饰器属性装饰器用来装饰类的成员属性。属性装饰器接收两个参数： 类的原型对象，如果是静态方法则为类的构造函数 属性名 1234567891011function demo(value: string) { return function(target: any, propertyKey: string) { target[propertyKey] = value; }}class Demo { @demo('haha') name?: string;}const d = new Demo();console.log(d.name); 属性装饰器多用在属性依赖注入上面 函数参数装饰器参数装饰器表达式会在运行时当作函数被调用，传入下列3个参数： 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。 参数的名字。 参数在函数参数列表中的索引。 12345678910111213function PathParam(paramDesc: string) { return function (target: any, paramName: string, paramIndex: number) { !target.$meta &amp;&amp; (target.$meta = {}); target.$meta[paramIndex] = paramDesc; }}class Demo { constructor() { } getUser( @PathParam(&quot;userId&quot;) userId: string) { }}console.log((&lt;any&gt;Demo).prototype.$meta); 以上例程输出 1{ '0': 'userId' } 函数参数装饰器可以用在开发Web框架时自动注入请求参数。 结语装饰器的介绍到这里就暂时结束了，\b装饰器的存在让Typescript有了与Java和C#等语言的注解相同的功能。当然，基于装饰器能做的工作是相当多的，注明的Angular2就大量使用了装饰器来分离业务逻辑。对装饰器有想法的小伙伴可以扫码加我进行交流","link":"/2019/08/06/2019-08-06-typescript-quick-guide4.html"},{"title":"NestJs学习之旅(1)——快速开始","text":"本文是NestJs学习之旅的第一篇，简要介绍一下NestJs框架，搭建一个Hello World应用。 介绍Nest（或NestJS）是一个用于构建高效，可扩展的Node.js服务器端应用程序的框架。它使用渐进式JavaScript，内置并完全支持TypeScript（但仍然允许开发人员使用纯JavaScript编写代码）并结合了OOP（面向对象编程），FP（功能编程）和FRP（功能反应编程）的元素。 123456789import { Controller, Get } from '@nestjs/common';@Controller('cats')export class CatsController { @Get() findAll(): string { return 'This action returns all cats'; }} 熟悉Java的同学应该有似曾相识的感觉，SpringBoot中大量使用注解来简化开发。现在，使用基于ES6装饰器构建的NestJs框架，你也可以做到! 优缺点先说说优点吧： 完美支持Typescript，因此可以使用日益繁荣的TS生态资源 兼容express中间件，降低造轮子成本 完美支持响应式编程框架rxjs 完美支持依赖注入 模块化思想，方便开发以及后期维护 使用装饰器简化开发，减少样板代码 组件化设计，解决Node.js无全栈框架约束的现存问题 当然，”缺点”也是有点的，不过熟练之后这些都不是缺点： 基于TS导致的语言门槛 代码设计上对模块化/组件化思想有一定要求 第一个NestJs应用使用NestJs的命令行工具，可以简化项目的创建以及项目文件的创建。 npm install -g @nestjs/cli安装命令行工具 nest new 项目名称初始化项目 初始化完毕后可以看到一个完整的项目结果，目录如下(忽略node_modules)： 12345678910111213141516├── README.md 自述文件├── nest-cli.json NestJs项目配置├── package.json npm文件├── src 项目源码│ ├── app.controller.spec.ts 控制器测试文件│ ├── app.controller.ts 控制器类│ ├── app.module.ts 模块类│ ├── app.service.ts 服务类│ └── main.ts 项目入口文件├── test 测试目录│ ├── app.e2e-spec.ts 应用e2e测试│ └── jest-e2e.json jest e2e测试配置├── tsconfig.build.json 生产环境Typescript所用├── tsconfig.json 开发环境Typescript配置├── tslint.json tslint配置└── yarn.lock yarn锁文件 NestJs有几大类文件是主要的是下面几种，其他类型的文件在后续课程会讲解； module 模块声明(这是NestJs的一个亮点，有点DDD的思想) controller 控制器(负责接收数据，返回响应) service 服务(主要业务逻辑) 使用npm run start来运行项目。终端输出如下: 12345[Nest] 2986 - 08/19/2019, 10:29 AM [NestFactory] Starting Nest application...[Nest] 2986 - 08/19/2019, 10:29 AM [InstanceLoader] AppModule dependencies initialized +22ms[Nest] 2986 - 08/19/2019, 10:29 AM [RoutesResolver] AppController {/}: +12ms[Nest] 2986 - 08/19/2019, 10:29 AM [RouterExplorer] Mapped {/, GET} route +9ms[Nest] 2986 - 08/19/2019, 10:29 AM [NestApplication] Nest application successfully started +6ms 一般来说，看到successfully就可以认为启动成功了。启动失败的话可以根据错误提示进行处理，比较多的情况可能是端口占用导致的错误。 打开浏览器访问http://localhost:3000即可看到输出Hello World!。 To Be Continued下一期将介绍Controller，欢迎持续关注!","link":"/2019/08/19/2019-08-19-nestjs-get-started.html"},{"title":"NestJs学习之旅(2)——控制器","text":"本文是NestJs学习之旅的第二篇，主要讲解控制器。 MVC说到控制器就不得不说经典的MVC架构。 MVC模式（Model–view–controller）是软件工程中的一种软件架构模式，把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）。 控制器（Controller）- 负责转发请求，对请求进行处理，处理完毕后输出响应。 视图 （View） - 界面设计人员进行图形界面设计 模型 （Model）- 数据库查询和业务逻辑 可以看到控制器起着承上启下的作用，是Web开发中必备的一环，视图和模型倒不是必须的，理由如下： API项目直接输出JSON数据，无需渲染页面 无数据库或者复杂业务逻辑的项目时可以把请求处理直接在控制器完成 路由控制器的目的是接收应用程序的特定请求。基于路由机制来实现请求的分发。通常，每个控制器具有多个路由，并且不同的路由可以执行不同的动作。 为了创建一个基本的控制器，我们使用类和装饰器。装饰器将类与所需的元数据相关联，并使Nest能够创建路由映射（将请求绑定到相应的控制器）。 控制器定义使用@Controller装饰器来定义控制器，传入一个可选的路由前缀可以将该控制器绑定到该前缀。 12345678910111213141516171819import { Controller, Get } from '@nestjs/common';@Controller('cats')export class CatsController { @Get('list') findAll(): string { return 'This action returns all cats'; } @Get('show') fineOne(): string { return 'one cat'; } @Get() index():string { return 'index'; }} 以上例程会生成以下路由： GET /cats/list CatsController::findAll方法处理 GET /cats/show CatsController::show方法处理 GET /cats CatsController::index方法处理 上述例程使用的是@Get装饰器，所以只能处理GET请求，以下是支持的请求方法与对应的装饰器 请求方法 装饰器名称 说明 GET @Get 匹配GET请求 POST @Post 匹配POST请求 PUT @Put 匹配PUT请求 HEAD @Head 匹配HEAD请求 DELETE @Delete 匹配DELETE请求 OPTIONS @Options 匹配OPTIONS请求 - @All 匹配所有请求方法 动态路由上文中的路由方法接收的参数是固定的，所以只能匹配固定的请求，如果路由地址是动态变化的(路由地址指请求的path，不包括QueryString)，则上述路由定义方式无法正常工作。 NestJs支持基于路径的路由定义，使用如下： 12345678910import {@Controller, Get} from '@nestjs/common';@Controller('cats')class CatsController { @Get(':id') findOne(@Param() params): string { console.log(params.id); return `This action returns a #${params.id} cat`; }} 当请求/cats/猫ID这种动态路由时(因为猫ID是path的一部分，所以path是变化的)，params.id就是猫ID，做过Vue或者React开发的读者应该熟悉以下写法： 路由定义 /user/:userId/orders/:orderId页面地址 /user/1/orders/2 访问以上页面将产生以下参数: userId =&gt; 1 orderId =&gt; 2 NestJs在这方面是一致的。 请求参数上述例子中，我们使用@Params读取了请求路径上的动态参数。NestJs还支持以下的装饰器来获取不同的请求参数 装饰器名称 底层对象 说明 @Request() req 原始请求对象 @Response() res 原始响应对象 @Param(key?:string) req.params或req.params[key] 路径参数 @Body(key?:string) req.body或req.body[key] 请求体，支持表单或JSON @Query(key?:string) req.query或req.query[key] 请求链接的查询字符串 @Headers(name?:string) req.headers或req.headers[key] 请求头 请求体在POST/PUT/PATCH请求中，会包含请求体，NestJs通过@Body装饰器可以自动获取该数据。比如如下代码: 123456789@Controller('user')export class AppController { constructor(private readonly appService: AppService) {} @Post() findAll(@Body() data: any) { return data; }} 以上例程会原样输出请求内容。 请求体绑定SpringBoot中@RequestBody注解可以直接绑定到给定的POJO对象实现请求参数自动注入，在NestJs中，该特性也得到了支持。 定义DTO对象 1234export class UserLoginDTO { readonly username: string; readonly password: string;} 定义控制器 1234567@Controller('users')class UserController() { @Post('login') login(@Body() userLoginDTO: UserLoginDTO) { console.log(userLoginDTO.username, userLoginDTO.password); }} 可以看到与SpringBoot的开发体验几乎一致。 响应头如果需要输出响应头，可以使用@Header(name:string,value:string)装饰器来进行处理。 请注意：响应头使用@Header()装饰器，请求头使用@Headers()装饰器，末尾有个s的区别! 123456@Controller('users')class UserController { @Head(':id') @Header('x-version', '1.0.0') function head(@Param('id') id:number) { } 响应状态码从响应体的设计可以发现一个问题，由于不推荐直接操纵response对象，如果需要输出响应状态码怎么办?NestJs也为我们提供了解决方案。 使用@HttpCode(statusCode:number)装饰器可以设定响应状态码。 在Restful API设计中，DELETE请求应当返回204 No Content状态码，如下代码所示： 12345678@Controller('users')class UserController { @DELETE(&quot;:id&quot;) @HttpCode(204) delete(@Param('id') id:number) { // 删除成功不需要返回数据 }} 响应体在express或者开发中，响应内容都是我们手动赋值或者输出的，但是在NestJs，可以直接根据路由函数的返回值类型自动识别响应体类型。NestJs支持以下格式的响应： TS类型 响应类型 响应格式 string 字符串 text/html object JSON application/json array JSON application/json null 无(响应体长度为0) 无 undefined 无(响应体长度为0) 无 Promise&lt;*&gt; 根据Promise返回的结果类型确定(规则如上) - 异步路由函数在前面的例子中，我们所有的路由处理函数都是同步的，但是在实际开发中基本不可能，一旦涉及到数据库访问、缓存访问就会存在IO，有IO就会有异步。 NestJs天生完美支持异步，有以下两种方法进行异步编程： Promise1234@Get()async findAll(): Promise&lt;any[]&gt; { return Promise.resolve([]);} RxJsRxJs中提供了Observable对象，NestJs可以自动订阅并获取最后一次产生的值。 1234@Get()findAll: Observable&lt;any[]&gt; { return of([]); // of为RxJs操作符} 实现一个Restful API以下是基于Restful API规范开发的API，本文的主要内容为控制器，所以DTO对象的创建省略。 12345678910111213141516171819202122232425262728293031323334353637import { Controller, Get, Query, Post, Body, Put, Param, Delete } from '@nestjs/common';import { CreateCatDto, UpdateCatDto, ListAllEntities } from './dto';@Controller('users')export class UsersController { // 创建用户，POST请求会自动返回201状态码，响应体为空 @Post() create(@Body() dto: CreateUserDto) { } // 用户列表 @Get() findAll() { return [ {id:1,username:'a',password:'a'}, {id:2,username:'b',password:'b'} ]; } // 查看用户 @Get(':id') findOne(@Param('id') id: number) { return {id,username:'mock username', password: 'mock password'}; } // 更新用户，需要返回编辑后的用户资源 @Put(':id') update(@Param('id') id: number, @Body() updateUserDto: UpdateUserDto) { return {id,username:'updated username',password: 'updated password'}; } // 删除用户，返回204状态码 @Delete(':id') @HttpCode(204) remove(@Param('id') id: number) { }}","link":"/2019/08/20/2019-08-20-nestjs-controller.html"},{"title":"NestJs学习之旅(3)——服务提供者","text":"本文是NestJs学习之旅的第三篇，讲解服务提供者。 简介服务提供者是NestJs一个非常重要的概念，一般来说，被装饰器@Injectable()修饰的类都可以视为服务提供者。服务提供者一般包含以下几种： Services(业务逻辑) Factory(用来创建提供者) Repository(数据库访问使用) Utils(工具函数) 使用下文中将以Services来说明服务提供者的具体使用。 典型的MVC架构中其实有一个问题，业务逻辑到底放哪里？ 放在控制器，代码复用成了问题，不可能去New一个控制器然后调用方法，控制器方法都是根据路由地址绑定的 放在Model，导致Model层臃肿，Model应该是直接和数据库打交道的，业务逻辑跟数据库的关系并不是强制绑定的，只有业务逻辑涉及到数据查询/存储才会使用到Model层 现阶段比较流行的架构是多添加一个Services层来写业务逻辑，分离Model层不应该做的事情。 12345678910111213// 业务类 user.service.ts@Injectable()export class UserServices { private readonly users: User[] = []; create(user: User) { this.users.push(user); } findAll(): User[] { return this.users; }} 123456789101112131415// 用户控制器@Controller('users')export class UserController { constructor(private readonly userService: UserService) {} // 注入UserService @Post() async create(@Body() createUserDTO:CreateUserDTO) { this.userService.create(createUserDTO); } @Get() async findAll() { return this.userService.findAll(); }} 服务提供者的ScopeSpringBoot中提供了Scope注解来指明Bean的作用域，NestJs也提供了类似的@Scope()装饰器： scope名称 说明 SINGLETON 单例模式，整个应用内只存在一份实例 REQUEST 每个请求初始化一次 TRANSIENT 每次注入都会实例化 1234@Injectable({scope: Scope.REQUEST})export class UserService {} 可选的依赖项默认情况下，如果依赖注入的对象不存在会提示错误，中断应用运行，此时可以使用@Optional()来指明选择性注入，但依赖注入的对象不存在时不会发生错误。 1234@Controller('users')export class UserController { constructor(@Optional() private readonly userService:UserService){}} 基于属性的注入上文中的注入都是基于构造函数的，这样做有一个缺陷，如果涉及到继承的话，子类必须显示调用super来实例化父类。如果父类的构造函数参数过多的话反而成了子类的负担。 针对这个问题，NestJs建议的方式是基于属性进行注入。 12345@Controller('users')export class UserController { @Inject() private readonly userService:UserService;} 服务提供者注册只有被注册过的服务提供者才能被NestJs进行自动注入。 1234567@Module({ controllers:[UserController], // 注册控制器 providers: [UserServices], // 注册服务提供者，可以是services,factory等等})export class UserModule {} 自定义服务提供者使用值上文中提供的Services一般用在编写业务逻辑，结构基本是固定的，如果需要集成其他库作为注入对象的话，需要使用的自定义的服务提供者。 比如我们使用sequelize创建了数据库连接，想把他注入到我们的Services中进行数据库操作。可以使用以下方式进行处理： 1234// sequelize.ts 数据库访问export const sequelize = new Sequelize({ ///}); 1234567// sequelize.provider.tsimport {sequelize} from './sequelize';export const sequelizeProvider = { provide: 'SEQUELIZE', // 服务提供者标识 useValue: sequelize, // 直接使用值} 12345// user.module.ts@Module({ providers:[UserService, sequelizeProvider]})export class UserModule {} 12345// user.service.ts@Injectable()export class UserService { constructor(@Inject('SEQUELIZE') private readonly sequelize: Sequelize) {}} 使用类OOP的一个重要思想就是面向接口化设计，比如我们开发了一个日志接口，有写入本地文件的实现，也有写入syslog的实现。依赖注入到时候我们希望使用接口进行注入，而不是具体的实现。 1234// logger.tsexport interface Logger { log(log:string);} 123456// file.logger.tsexport class FileLogger implements Logger { log(log:string) { // 写入本地文件 }} 123456// syslog.logger.tsexport class SyslogLogger implements Logger { log(log:string) { // 写入Syslog }} 12345// logger.provider.tsexport const loggerProvider = { provide: Logger, // 使用接口标识 useClass: process.env.NODE_ENV==='development'?FileLogger:SyslogLogger, // 开发日志写入本地，生产日志写入syslog} 1234567// user.module.ts@Module({ providers:[UserService,loggerProvider]})export class UserModule {} 12345// user.service.ts@Injectable()export class UserService { constructor(@Inject(Logger) private readonly logger: Logger) {}} 使用工厂工厂模式相信大家都不陌生，工厂模式本质上是一个函数或者方法，返回我们需要的产品。 传统的第三方库都是提供callback形式或者事件形式的进行连接，比如redis，如果需要使用该类型的注入对象，工厂模式是最佳方式。 以下是使用工厂模式创建数据库连接的例子： 123456789101112// database.provider.tsexport const databaseProvider = { provide:'DATABASE', useFactory: async(optionsProvider: OptionsProvider) { // 使用依赖，注入顺序和下面定义的顺序一致 return new Promise((resolve, reject) =&gt; { const connection = createConnection(optionsProvider.getDatabaseConfig()) connection.on('ready',()=&gt;resolve(connection)); connection.on('error',(e)=&gt;reject(e)); }); }, inject:[OptionsProvider], // 注入依赖} 1234567// user.module.ts@Module({ providers:[OptionsProvider, databaseProvider]})export class UserModule {} 12345// user.service.ts@Injectable()export class UserService { constructor(@Inject('DATABASE') private readonly connection: Connection) {}} 别名方式别名方式可以基于现有的提供者进行创建。 1234const loggerAliasProvider = { provide: 'AliasedLoggerService', useExisting: Logger,}; 导出服务提供者到其他模块模块的详细知识将在后文提到，但是有一点需要提前知道，只有被模块导出的服务提供者才能被其他模块导入 基于类型的导出上文中的UserService是基于类型而不是进入名称进行注入的。 12345@Module({ providers: [UserService], exports: [UserService], // 重要})export class UserModule {} 基于名称的导出上文中DATABASE和SEQUELIZE这种服务提供者都是自定义的，而且指定的标识符。 1234@Module({ providers: [sequelizeProvider], exports: ['SEQUELIZE'], // 其他模块的组件直接使用@Inject('SEQUELIZE')即可}) 结尾服务提供者是NestJs的精华之一，提供了几种方式方便我们在各种环境下的服务提供者创建。","link":"/2019/08/21/2019-08-21-nestjs-provider.html"},{"title":"NestJs学习之旅(4)——模块系统","text":"本文是NestJs学习之旅的第四篇，讲解模块系统。 模块NestJs中模块是构建和组织业务单元的基本元素。使用@Module()装饰模块来声明该模块的元信息： 本模块导出哪些服务提供者 本模块导入了哪些依赖模块 本模块提供了哪些控制器 每个NestJs至少有一个跟模块，这个就是app.module.ts定义的。根模块一般不放具体的业务逻辑，具体业务逻辑应该下沉到各个子业务模块去做。 比如我们开发一个商城系统，该系统有以下业务模块： 订单中心 用户中心 支付中心 商品中心 物流中心 那我们可以定义以下的模块结构: 12345678910111213141516171819202122|-- app.module.ts|-- order |-- order.module.ts |-- services |-- order.service.ts |-- controllers |-- order.controller.ts|-- user |-- user.module.ts |-- services |-- user.service.ts |-- controllers |-- user.controller.ts|-- pay |-- pay.module.ts |-- services |-- wepay.service.ts |-- alipay.service.ts |-- pay.service.ts |-- controller |-- pay.controller.ts... 模块化有以下优点： 业务低耦合 边界清晰 便于排查错误 便于维护 模块声明与配置@Module()装饰的类为模块类，该装饰器的典型用法如下： 123456789@Module({ providers: [UserService], controllers: [UserController], imports: [OrderModule], exports: [UserService]})export class UserModule {} 参数名称 说明 proviers 服务提供者列表，本模块可用，可以自动注入 controllers 控制器列表，本模块可用，用来绑定路由访问 imports 本模块导入的模块，如果需要使用到其他模块的服务提供者，此处必须导入其他模块 exports 本模块导出的服务提供者，只有在此处定义的服务提供者才能在其他模块使用 模块重导出ts中有以下用法： 1234// a.tsexport interface A {} 12// index.tsexport * from './a'; 我们在使用的时候直接使用以下代码即可，方面封装 1import {A} from './index' NestJs中的模块也有类似用法，比如我们定义了两个基本模块，这两个基本模块用的时候基本都是一起导入的，此时我们通过模块重导出将其封装到一个叫CoreModule，其他地方直接导入CoreModule即可。 12345@Module({ providers: [CommonService], exports: [CommonService]})export class CommonModule {} 12345@Module({ providers: [Util], exports: [Util]})export class UtilModule {} 12345@Module({ imports: [CommonModule, UtilModule], exports: [CommonModule, UtilModule]})export class CoreModule {} 模块初始化与依赖注入如果需要在模块实例化的时候运行一些逻辑，而且该逻辑有外部依赖的时候，可以通过以下方式处理 12345678910111213import { Module } from '@nestjs/common';import { UserController } from './user.controller';import { UserService } from './user.service';@Module({ controllers: [UserController], providers: [UserService],})export class catsModule { constructor(private readonly userService: UserService) { // 没有@Inject // 调用userService }} 全局模块上面定义的模块都是需要手动imports进来的，如果有些模块是使用率很高的，比如工具模块，此时可以声明为全局模块。 使用@Global()即可声明全局模块。 123456789101112import { Module } from '@nestjs/common';import { UserController } from './user.controller';import { UserService } from './user.service';@Global()@Module({ controllers: [UserController], providers: [UserService],})export class catsModule { } 动态模块上面定义的都是静态模块，如果我们需要动态声明我们的模块，比如数据库模块，连接成功我才返回模块，此时需要使用动态模块来处理。 使用模块名.forRoot()方法来返回模块定义，通过该方式定义的即为动态模块。 12345678910111213@Module({ providers: [DatabaseProvider]})export class DatabaseModule { static async forRoot(env: string) { const provider = createDatabaseProvider(env); // 根据环境变量连接不同的数据库 return { module: DatabaseModule, providers: [provider], exports: [provider] } }} 12345// user.module.ts@Module({ imports: [DatabaseModule.forRoot('production')]})export class UserModule {} 生产环境下的姿势上面有一个商城系统的模块例子，当我们的业务模块开发完毕之后，需要将其注册到AppModule，这样才能生效，这个也有个好处，有点像插拔的例子，当需要下掉一个业务时，业务代码不动，在AppModule取消注册即可。 1234@Module({ imports:[UserModule,GoodsModule,OrderModule,PayModule]})export class AppModule {} 结尾模块系统是NestJs另一个重要的特性，个人认为是基于DDD思想的，每个模块就是一个单独的领域业务，可以由一个小组去独立开发。多个模块时可以同时开发，如果有依赖问题的话，可以先把模块和响应的interface公开出去，别人正常调用你的interface，当实现类开发完毕之后NestJs会自动注入该实现类，调用方的代码不用更改。","link":"/2019/08/22/2019-08-22-nestjs-module.html"},{"title":"NestJs学习之旅(5)——中间件","text":"本文是NestJs学习之旅的第五篇，讲解中间件。 中间件中间件是在路由处理程序之前调用的函数。中间件函数可以访问请求和响应对象。 使用过koa和express的朋友应该知道，中间件是一个很核心的功能，尤其是koa，核心就是中间件，连路由功能都是由中间件提供的。 中间件可以提供以下功能： 运行过程中执行任意代码 对请求和响应进行更改 结束本次请求的响应 继续调用下一个中间件 示例NestJs使用@Injectable()来装饰中间件，被装饰的对象应该实现NestMiddleware接口。 以下是一个日志中间件的实现： 1234567891011// log.middleware.tsimport {Injectable, NestMiddleware} from '@nestjs/common';import {Request, Response} from 'express';@Injectable()export class LogMiddleware implements NestMiddleware { use(req: Request, resp: Response, next: Function) { console.log(`${req.method} ${req.path}`) next(); }} 123456789101112131415// app.module.tsimport { Module, NestModule, MiddlewareConsumer } from '@nestjs/common';import { LogMiddleware } from './common/middleware/log.middleware';import { UserModule } from './user/user.module';@Module({ imports: [UserModule],})export class AppModule implements NestModule { configure(consumer: MiddlewareConsumer) { consumer .apply(LogMiddleware) .forRoutes('users'); }} 针对请求方法应用中间件上面的简单示例中会对所有的users路由应用中间件，如果需要只对特定的请求方法，比如GET请求才应用中间件，可以使用以下方式： 1234567891011121314import { Module, NestModule, MiddlewareConsumer } from '@nestjs/common';import { LogMiddleware } from './common/middleware/log.middleware';import { UserModule } from './user/user.module';@Module({ imports: [UserModule],})export class AppModule implements NestModule { configure(consumer: MiddlewareConsumer) { consumer .apply(LogMiddleware) .forRoutes({ path: 'users', method: RequestMethod.GET }); }} 应用多个中间件1234567891011121314import { Module, NestModule, MiddlewareConsumer } from '@nestjs/common';import { LogMiddleware } from './common/middleware/log.middleware';import { UserModule } from './user/user.module';@Module({ imports: [UserModule],})export class AppModule implements NestModule { configure(consumer: MiddlewareConsumer) { consumer .apply(LogMiddleware, OtherMiddleware) .forRoutes({ path: 'users', method: RequestMethod.GET }); }} 基于控制器名称应用中间件上述代码都是针对固定的路由地址应用中间件，在NestJs中路由地址是通过装饰器定义的，如果控制器的路由地址有变化，而中间件这里没有跟着改掉，就会导致问题。 NestJs在使用中间件的时候提供了基于控制器来注册的方式： 1234567891011121314import { Module, NestModule, MiddlewareConsumer } from '@nestjs/common';import { LogMiddleware } from './common/middleware/log.middleware';import { UserModule } from './user/user.module';@Module({ imports: [UserModule],})export class AppModule implements NestModule { configure(consumer: MiddlewareConsumer) { consumer .apply(LogMiddleware) .forRoutes(UserController); }} 排除指定路由有些场景下对控制器应用了中间件之后需要绕过其中几个方法，比如登录验证中间件应该放行登录路由，否则没有人能够登录成功。 1234567891011121314151617import { Module, NestModule, MiddlewareConsumer } from '@nestjs/common';import { LogMiddleware } from './common/middleware/log.middleware';import { UserModule } from './user/user.module';@Module({ imports: [UserModule],})export class AppModule implements NestModule { configure(consumer: MiddlewareConsumer) { consumer .apply(LogMiddleware) .exclude( {path:'users/login',method:RequestMethod.GET} ) .forRoutes(UserController); }} 全局中间件类似于全局模块，中间件也可以全局注册，对每一个路由都生效。 1234// main.tsconst app = await NestFactory.create(AppModule);app.use(LogMiddleware);await app.listen(3000); 结尾中间件给框架赋予了极大的灵活性，可以根据功能抽象为中间件，达到”可插拔“的目的。","link":"/2019/08/23/2019-08-23-nestjs-middlware.html"},{"title":"socks5协议详解","text":"Socks5代理协议或许你没听说过socks5，但你一定听说过SS，SS内部使用的正是socks5协议。 socks5是一种网络传输协议，主要用于客户端与目标服务器之间通讯的透明传递。 该协议设计之初是为了让有权限的用户可以穿过防火墙的限制，访问外部资源。 1. RFC地址 socks5协议规范rfc1928 socks5账号密码鉴权规范rfc1929 2. 协议过程 客户端连接上代理服务器之后需要发送请求告知服务器目前的socks协议版本以及支持的认证方式 代理服务器收到请求后根据其设定的认证方式返回给客户端 如果代理服务器不需要认证，客户端将直接向代理服务器发起真实请求 代理服务器收到该请求之后连接客户端请求的目标服务器 代理服务器开始转发客户端与目标服务器之间的流量 3. 认证过程3.1 客户端发出请求 客户端连接服务器之后将直接发出该数据包给代理服务器 VERSION METHODS_COUNT METHODS… 1字节 1字节 1到255字节，长度由METHODS_COUNT值决定 0x05 0x03 0x00 0x01 0x02 VERSION SOCKS协议版本，目前固定0x05 METHODS_COUNT 客户端支持的认证方法数量 METHODS… 客户端支持的认证方法，每个方法占用1个字节 METHOD定义 0x00 不需要认证（常用） 0x01 GSSAPI认证 0x02 账号密码认证（常用） 0x03 - 0x7F IANA分配 0x80 - 0xFE 私有方法保留 0xFF 无支持的认证方法 3.2 服务端返回选择的认证方法 接收完客户端支持的认证方法列表后，代理服务器从中选择一个受支持的方法返回给客户端 3.2.1 无需认证 VERSION METHOD 1字节 1字节 0x05 0x00 VERSION SOCKS协议版本，目前固定0x05 METHOD 本次连接所用的认证方法，上例中为无需认证 3.2.2 账号密码认证 VERSION METHOD 1字节 1字节 0x05 0x02 3.2.3 客户端发送账号密码 服务端返回的认证方法为0x02(账号密码认证)时，客户端会发送账号密码数据给代理服务器 VERSION USERNAME_LENGTH USERNAME PASSWORD_LENGTH PASSWORD 1字节 1字节 1-255字节 1字节 1-255字节 0x01 0x01 0x0a 0x01 0x0a VERSION 认证子协商版本（与SOCKS协议版本的0x05无关系） USERNAME_LENGTH 用户名长度 USERNAME 用户名字节数组，长度为USERNAME_LENGTH PASSWORD_LENGTH 密码长度 PASSWORD 密码字节数组，长度为PASSWORD_LENGTH 3.2.4 服务端响应账号密码认证结果 收到客户端发来的账号密码后，代理服务器加以校验，并返回校验结果 VERSION STATUS 1字节 1字节 VERSION 认证子协商版本，与客户端VERSION字段一致 STATUS 认证结果 0x00 认证成功 大于0x00 认证失败 4. 命令过程 认证成功后，客户端会发送连接命令给代理服务器，代理服务器会连接目标服务器，并返回连接结果 4.1 客户端请求 VERSION COMMAND RSV ADDRESS_TYPE DST.ADDR DST.PORT 1字节 1字节 1字节 1字节 1-255字节 2字节 VERSION SOCKS协议版本，固定0x05 COMMAND 命令 0x01 CONNECT 连接上游服务器 0x02 BIND 绑定，客户端会接收来自代理服务器的链接，著名的FTP被动模式 0x03 UDP ASSOCIATE UDP中继 RSV 保留字段 ADDRESS_TYPE 目标服务器地址类型 0x01 IP V4地址 0x03 域名地址(没有打错，就是没有0x02)，域名地址的第1个字节为域名长度，剩下字节为域名名称字节数组 0x04 IP V6地址 DST.ADDR 目标服务器地址 DST.PORT 目标服务器端口 4.2 代理服务器响应 VERSION RESPONSE RSV ADDRESS_TYPE BND.ADDR BND.PORT 1字节 1字节 1字节 1字节 1-255字节 2字节 VERSION SOCKS协议版本，固定0x05 RESPONSE 响应命令 0x00 代理服务器连接目标服务器成功 0x01 代理服务器故障 0x02 代理服务器规则集不允许连接 0x03 网络无法访问 0x04 目标服务器无法访问（主机名无效） 0x05 连接目标服务器被拒绝 0x06 TTL已过期 0x07 不支持的命令 0x08 不支持的目标服务器地址类型 0x09 - 0xFF 未分配 RSV 保留字段 BND.ADDR 代理服务器连接目标服务器成功后的代理服务器IP BND.PORT 代理服务器连接目标服务器成功后的代理服务器端口 5. 通信过程 经过认证与命令过程后，客户端与代理服务器进入正常通信，客户端发送需要请求到目标服务器的数据给代理服务器，代理服务器转发这些数据，并把目标服务器的响应转发给客户端，起到一个“透明代理”的功能。 6. 实际例子上文详细讲解了协议规范，下面来一个实例的通信过程范例。 6.2中无需认证和需要账号密码认证是互斥的，同一请求只会采取一种，本文都列在下面。 6.1 客户端发送受支持的认证方法10x05 0x02 0x00 0x02 0x05 SOCKS5协议版本 0x02 支持的认证方法数量 0x00 免认证 0x02 账号密码认证 6.2 服务端响应选择的认证方法6.2.1 无需认证 以下是无需认证，客户端收到该响应后直接发送需要发送给目标服务器的数据给到代理服务器，此时进入通信错过程 10x05 0x00 0x05 SOCKS5协议版本 0x00 免认证 6.2.2 需要账号密码认证10x05 0x02 0x05 SOCKS5协议版本 0x02 账号密码认证 6.2.3 客户端发送账号密码10x01 0x04 0x61 0x61 0x61 0x61 0x04 0x61 0x61 0x61 0x61 0x01 子协商版本 0x04 用户名长度 0x61 0x61 0x61 0x61 转换为ascii字符之后为”aaaa” 0x04 密码长度 0x61 0x61 0x61 0x61 转换为ascii字符之后”aaaa” 6.2.4 代理服务器响应认证结果10x01 0x00 0x01 子协商版本 0x00 认证成功（也就是代理服务器允许aaaa账号以aaaa密码登录） 6.3 客户端请求代理服务器连接目标服务器以127.0.0.1和80端口为例 10x05 0x01 0x01 0x01 0x7f 0x00 0x00 0x01 0x00 0x50 0x05 SOCKS协议版本 0x01 CONNECT命令 0x01 RSV保留字段 0x01 地址类型为IPV4 0x7f 0x00 0x00 0x01 目标服务器IP为127.0.0.1 0x00 0x50 目标服务器端口为80 6.4 代理服务器连接目标主机，并返回结果给客户端10x05 0x00 0x01 0x01 0x7f 0x00 0x00 0x01 0x00 0xaa 0xaa 0x05 SOCKS5协议版本 0x00 连接成功 0x01 RSV保留字段 0x01 地址类型为IPV4 0x7f 0x00 0x00 0x01 代理服务器连接目标服务器成功后的代理服务器IP, 127.0.0.1 0xaa 0xaa 代理服务器连接目标服务器成功后的代理服务器端口（代理服务器使用该端口与目标服务器通信），本例端口号为43690 6.5 客户端发送请求数据给代理服务器如果客户端需要请求目标服务器的HTTP服务,就会发送HTTP协议报文给代理服务器,代理服务器将这些报文原样转发给目标服务器,并将目标服务器的响应发送给客户端,代理服务器不会对客户端或者目标服务器的报文做任何解析。 7. 结尾SOCKS5协议的讲解到此结束，后续会使用GOLANG实现一个SOCKS5服务器来讲述TCP协议服务器的开发。","link":"/2019/08/24/2019-08-24-socks5-protocol.html"},{"title":"NestJs学习之旅(6)——异常处理","text":"本文是NestJs的第六篇，讲解异常处理。 传统的异常处理在前面的内容中我们介绍了NestJs的几大常用组件，但是有一点没有做出说明，当我们的应用需要中断此次请求且输出错误信息时，我们需要怎么做？ 这个问题有两种解决办法： services层直接返回中断请求的响应对象，controller直接输出该对象即可 123if(!this.allowLogin()) { return {errcode: 403, errmsg: '不允许登录'};} services层抛出异常，controller捕获该异常，然后输出响应对象 以上两种方法都有一定的缺点： controller调用多个services时，需要依据services层的返回值来进行错误判断，要是漏了判断的话会导致原本需要中断的请求处理继续运行，导致不可预料的后果 如果每个controller都需要try/catch掉services层抛出的异常的话，会多了很多“重复”代码 那有没有一个像SpringBoot的ExceptionHandler相似的解决办法呢? NestJs的异常处理NestJs提供了统一的异常处理器，来集中处理运行过程中未捕获的异常，可以自定义响应参数，非常灵活。 默认响应NestJs内置了默认的全局异常过滤器，该过滤器处理HttpException(及其子类)的异常。如果抛出的异常不是上述异常，则会响应以下默认JSON： 1234{ &quot;statusCode&quot;: 500, &quot;message&quot;: &quot;Interval server error&quot;} 内置异常过滤器由于NestJs内置了默认的异常过滤器，如果在应用内抛出HttpException，是可以被NestJs自动捕获的。 比如在services层抛出一个HttpException： 123456789@Injectable()export class UserService { login(username: string, password: string) { if(!this.allowLogin()) { throw new HttpException('您无权登录', HttpStatus.FORBIDDEN); } return {user_id:1, token: 'fake token'} }} controller正常调用该services即可: 123456789@Controller('users')export class UserController { constructor(private readonly userService: UserService) {} @Post('login') login(@Body('username') username: string, @Body('password') password: string) { return this.userService.login(username, password); }} 客户端访问/user/login时，如果不允许登录，会收到以下响应： 1234{ &quot;statusCode&quot;: 403, &quot;message&quot;: &quot;您无权登录&quot;} 一般情况下，上述JSON的返回的信息是不够的，比如有些业务自定义的错误码没地方可以自定义。 如果你有这种需求，可以传递object给HttpException的第一个参数来实现： 1throw new HttpException({errcode: 40010, errmsg: '您无权登录'}, HttpStatus.FORBIDDEN); 客户端访问时，如果不允许登录，会收到以下响应： 1234{ &quot;errcode&quot;: 40010, &quot;errmsg&quot;: &quot;您无权登录&quot;} 自定义异常企业级应用开发过程中，使用HttpException进行处理对开发是不太友好的，一个比较常用的做法是自定义一个UserException来承载业务异常（系统运行正常，只不过当前请求不满足业务上的要求而中断，比如注册的时候用户名重复的时候打回去，此时数据库查询是正常的，这就是业务异常和系统异常的区别）。 12345export class UserException extends HttpException { constructor(errcode: number, errmsg: string, statusCode: number) { super({ errcode, errmsg }, statusCode); }} 业务层在使用该异常时直接使用以下代码即可，将原来传递对象的代码扁平化了： 12throw new UserException(40010, '您无权登录', HttpStatus.FORBIDDEN); 语义化业务异常使用自定义异常时HTTP协议层是正常的，抛出403错误有点不符合语义化的需求。对上例改造一下： 123456export class UserException extends HttpException { constructor(errcode: number, errmsg: string) { super({ errcode, errmsg }, HttpStatus.OK); }} 12throw new UserException(40010, '您无权登录'); 此时客户端收到的HttpStatus为200，意味着此次请求在协议层面是成功的，只不过业务层返回了错误。前端在处理响应时可以直接对errcode是否为0来确定此次请求是否成功。 自定义异常过滤器虽然内置的异常过滤器可以自动处理很多情况，但是不是“可编程”的，也就是说我们无法完全控制异常处理过程，如果我们需要记录日志的话，使用内置的异常过滤器办不到，这时候可以使用**@Catch**注解来自定义异常处理器，添加日志记录什么的。 1234567891011121314151617181920212223import { ExceptionFilter, Catch, ArgumentsHost, HttpException } from '@nestjs/common';import { Request, Response } from 'express';@Catch(HttpException)export class HttpExceptionFilter implements ExceptionFilter&lt;HttpException&gt; { catch(exception: HttpException, host: ArgumentsHost) { const ctx = host.switchToHttp(); const response = ctx.getResponse&lt;Response&gt;(); const request = ctx.getRequest&lt;Request&gt;(); const status = exception.getStatus(); // @todo 记录日志 console.log('%s %s error: %s', request.method, request.url, exception.message); // 发送响应 response .status(status) .json({ statusCode: status, message: exception.message path: request.url, }); }} ArgumentHostArgumentHost是原始请求的包装器，由于NestJs支持HTTP/GRPC/WebSocket，这三种请求的原始请求对象是有差异的，为了异常过滤器能够统一处理这三种异常，NestJs做了包装。最终在使用时处理那种异常由开发者来决定。 ArgumentHost接口定义如下： 12345678export interface ArgumentsHost { getArgs&lt;T extends Array&lt;any&gt; = any[]&gt;(): T; getArgByIndex&lt;T = any&gt;(index: number): T; switchToRpc(): RpcArgumentsHost; switchToHttp(): HttpArgumentsHost; switchToWs(): WsArgumentsHost;} 如果需要处理的是WebSocket异常，就使用**host.switchToWs()**，其他异常以此类推。 使用自定义异常过滤器如果定义完自定义异常过滤器之后，直接去访问会抛出异常的接口，此时可以发现并没有走自定义异常过滤器。 因为我们只是定义，并没有注册。 使用**@UseFilters**注册自定义异常过滤器。 异常过滤器有以下三种作用范围： 方法级别 控制器级别 全局级别 方法级别只会处理该方法上抛出的异常，其他方法抛出的异常不会处理。 123456@Post('login')@UseFilters(UserExceptionFilter)login(@Body('username') username:string, password: string) { throw new UserException(40010, '您无权登录');} 控制器级别只会处理该控制器方法上抛出的异常，其他控制器抛出的异常不处理。 123456@Controller('user')@UseFilters(UserExceptionFilter)export class UserController { } 全局级别在应用入口注册，不会对Websocket或者混合应用（同时支持两种应用，如HTTP/GRPC或者HTTP/WebSocket）生效。一般Web开发中全局异常过滤器已经够用了。 在main.ts中注册全局异常过滤器 1234567async function bootstrap() { const app = await NestFactory.create(AppModule); app.useGlobalFilters(new UserExceptionFilter()); await app.listen(3000);}bootstrap(); 依赖注入由于异常过滤器并不是任何模块上下文的一部分，所以NestJs无法对其进行依赖注入管理，如果有此种需求，比如在异常过滤器中注入service，需要定义服务提供者。服务提供者名称为NestJs规定的常量APP_FILTER 12345678910111213import { Module } from '@nestjs/common';import { APP_FILTER } from '@nestjs/core';@Module({ providers: [ { provide: APP_FILTER, useClass: UserExceptionFilter, }, ],})export class AppModule {} 捕获多种异常或者所有异常上例中提到的自定义异常处理器只会捕获UserException异常，如果有系统异常，会使用内置的异常处理器。通过传入异常类型给**@Catch**装饰器来捕获多种异常。如果不传任何异常类型的话，NestJs会捕获所有异常（也就是Error及其子类）。 1234567891011121314151617181920212223import { ExceptionFilter, Catch, ArgumentsHost, HttpException } from '@nestjs/common';import { Request, Response } from 'express';@Catch() // 捕获所有异常export class HttpExceptionFilter implements ExceptionFilter&lt;Error&gt; { catch(exception: Error, host: ArgumentsHost) { const ctx = host.switchToHttp(); const response = ctx.getResponse&lt;Response&gt;(); const request = ctx.getRequest&lt;Request&gt;(); const status = exception.getStatus(); // @todo 记录日志 console.log('%s %s error: %s', request.method, request.url, exception.message); // 发送响应 response .status(status) .json({ statusCode: status, message: exception.message path: request.url, }); }} 结尾异常过滤器让应用异常有了统一的处理渠道，同时也解决文章开头提出的两个问题。通过自定义异常过滤器，开发者可以进行统一响应格式，统一记录日志等等操作。","link":"/2019/08/26/2019-08-26-nestjs-exception-filter.html"},{"title":"NestJs学习之旅(7)——路由守卫","text":"本文是NestJs的第七篇，讲解路由守卫。 传统的Web应用中去检测用户登录、权限判断等等都是在控制器层或者中间件层做的，而在目前比较推荐的模块化与组件化架构中，不同职责的功能建议拆分到不同的类文件中去。 通过前几篇的学习可以发现NestJs在这方面做的很好，传统的express/koa应用中，需要开发者去思考项目结构以及代码组织，而NestJs不需要你这样做，降低了开发成本，另外也统一了开发风格。 路由守卫熟悉Vue,React的伙伴应该比较熟悉这个概念，通俗的说就是在访问指定的路由之前回调一个处理函数，如果该函数返回true或者**调用了next()**就会放行当前访问，否则阻断当前访问。 NestJs中路由守卫也是如此，通过继承CanActive接口即可定义一个路由守卫。 123456789import { CanActivate, ExecutionContext, Injectable } from '@nestjs/common';import { Observable } from 'rxjs';@Injectable()class AppGuard implements CanActivate { canActivate(context: ExecutionContext): boolean | Promise&lt;boolean&gt; | Observable&lt;boolean&gt; { return true; }} 路由守卫与中间件区别路由守卫本质上也是中间件的一种，koa或者express开发中接口鉴权就是基于中间件开发的，如果当前请求是不被允许的，当前中间件将不会调用后续中间件，达到阻断请求的目的。 但是中间件的职责是不明确的，中间件可以干任何事（数据校验，格式转化，响应体压缩等等），这导致只能通过名称来识别中间件，项目迭代比较久以后，有比较高的维护成本。 联系由于单一职责的关系，路由守卫只能返回true和false来决定放行/阻断当前请求，不可以修改request/response对象，因为一旦破坏单一职责的原则，排查问题比较麻烦。 如果需要修改request对象，可以结合中间件一起使用。 路由守卫在所有中间件执行完毕之后开始执行。 以下是一个结合路由守卫和中间件的例子。 12345678910111213141516171819202122232425// auth.middleware.ts// 中间件职责：读取请求头Authorization，如果存在且有效的话，设置user对象到request中import { Injectable, NestMiddleware } from '@nestjs/common';import { Request, Response } from 'express';@Injectable()export class AuthMiddleware implements NestMiddleware&lt;Request|any, Response&gt; { constructor(private readonly userService: UserService) {} async use(req: Request|any, res: Response, next: Function) { const token = req.header('authorization'); if(!token) { next(); return; } const user = await this.userService.getUserByToken(token); if(!user) { next(); return; } request.user = user; next(); }} 12345678910111213// user.guard.tsimport { CanActivate, ExecutionContext, Injectable } from '@nestjs/common';import { Observable } from 'rxjs';import { Request } from 'express';@Injectable()export class UserGuard implements CanActivate { canActivate(context: ExecutionContext): boolean | Promise&lt;boolean&gt; | Observable&lt;boolean&gt; { const request = context.switchToHttp().getRequest&lt;Request | any&gt;(); // 直接检测是否有user对象，因为无user对象证明无token或者token无效 return !!request.user; }} 以上例子是笔者常用的一种方法，这样职责比较清晰，而且user对象可以在其他中间件中读取。 使用路由守卫来保护我们的应用NestJs使用**@UseGuards()**装饰器来注入路由守卫。支持全局守卫、控制器级别守卫、方法级别守卫。 下面以一个实际的例子来演示路由守卫的工作过程。 登录流程 用户输入账号密码后进行登录，如果登录成功下发Token 客户端在请求头Authorization中加入第1步下发的Token进行请求 路由守卫读取当前请求的Authorization信息并与数据库的进行比对，如果成功则放行，否则阻断请求 定义token校验业务类12345678// user.service.ts@Injetable()export class UserService { // 模拟校验，这里直接返回true，实际开发中自行实现即可 validateToken(token: string) { return true; }} 定义路由守卫123456789101112131415// user.guard.ts@Injetable()export class UserGuard implements CanActive { constructor(private readonly userService: UserService) {} canActivate(context: ExecutionContext): boolean | Promise&lt;boolean&gt; | Observable&lt;boolean&gt; { const request = context.switchToHttp().getRequest&lt;Request&gt;(); // 读取token const authorization = request.header('authorization'); if (!authorization) { return false; } return this.userService.validateToken(authorization); }} 定义控制器123456789101112131415@Controller('user')export class UserController { // 请求登录 @Post('login') login() { return {token:'fake_token'}; // 直接下发token，真实场景下需要验证账号密码 } // 查看当前用户信息 @Get('info') @UseGuards(UserGuard) // 方法级路由守卫 info() { return {username: 'fake_user'}; }} 一个完整的路由守卫应用实例就已经出来了，虽然咱们的路由守卫没啥逻辑都是直接放行的，但是实际开发中也是基于这种思路去开发的，只不过校验的逻辑不一样罢了。 路由守卫级别控制器级别该级别会对被装饰控制器的所有路由方法生效。 123456789@Controller('user')@UseGuards(UserGuard)export class UserController { // 查看当前用户信息 @Get('info') info() { return {username: 'fake_user'}; }} 方法级别该级别只对被装饰的方法生效。 12345@Get('info')@UseGuards(UserGuard)info() { return {username: 'fake_user'};} 全局级别与全局异常过滤器类似，该级别对所有控制器的所有路由方法生效。该方法与全局异常过滤器一样不会对WebSocket和GRPC生效。 12345678async function bootstrap() { const app = await NestFactory.create(AppModule); // 由于main.ts启动时并未初始化依赖注入容器，所以依赖必须手动传入，一般情况下不建议使用全局守卫，因为依赖注入得自己解决。 app.useGlobalGuards(new UserGuard(new UserService())); await app.listen(3000);}bootstrap(); 执行上下文CanActive接口的方法中有一个ExecutionContext对象，该对象为请求上下文对象，该对象定义如下： 1234export interface ExecutionContext extends ArgumentsHost { getClass&lt;T = any&gt;(): Type&lt;T&gt;; getHandler(): Function;} 可以看到继承了ArgumentHost，ArgumentHost在之前的异常处理文章中已经提到过了，这里不再赘述。 getClass() 获取当前访问的Controller对象（不是实例），T为调用时传入的具体控制器对象泛型参数 getHandler() 获取当前访问路由的方法 例如访问 /user/info 时，getClass()将返回UserController对象（不是实例），getHandler()将返回info()函数的引用。 这个特性有什么作用呢？ NestJs中可以使用反射来获取定义在方法、属性、类等等上面的自定义属性，这一点和Java的注解有点类似。 反射示例——基于角色的权限验证(RBAC)定义角色装饰器被角色装饰器装饰的控制器或者方法在访问时，路由守卫会读取当前用户的角色，与装饰器传入的角色相匹配，如果匹配失败，将阻断请求，否则将放行请求。 1234// roles.decorator.tsimport { SetMetadata } from '@nestjs/common';export const Roles = (...roles: string[]) =&gt; SetMetadata('roles', roles); 定义控制器假设我们有一个只允许管理员访问的创建用户的接口： 12345@Post('create')@Roles('admin')async create(@Body() createUserDTO: CreateUserDTO) { this.userService.create(createUserDTO);} 定义路由守卫123456789101112131415161718192021// role.guard.tsimport { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';import { Observable } from 'rxjs';import { Reflector } from '@nestjs/core';@Injectable()export class RolesGuard implements CanActivate { constructor(private readonly reflector: Reflector) {} canActivate(context: ExecutionContext): boolean { // 获取roles元数据，roles与roles.decorator.ts中SetMetadata()第一个参数一致 const roles = this.reflector.get&lt;string[]&gt;('roles', context.getHandler()); if (!roles) { // 未被装饰器装饰，直接放行 return true; } const request = context.switchToHttp().getRequest(); const user = request.user; // 读取请求对象的user，该user对象可以通过中间件来设置（本文前面有例子） const hasRole = () =&gt; user.roles.some((role) =&gt; roles.includes(role)); return user &amp;&amp; user.roles &amp;&amp; hasRole(); }} 以上就是读取自定义装饰器数据开发RBAC的例子，写的比较简陋，但是原理是一样的，代码量少的话便于理解核心。 异常处理路由守卫返回false时框架会抛出ForbiddenException，客户端收到的默认响应如下： 1234{ &quot;statusCode&quot;: 403, &quot;message&quot;: &quot;Forbidden resource&quot;} 如果需要抛出其他异常，比如UnauthorizedException，可以直接在路由守卫的canActive()方法中抛出。 另外，在这里抛出的异常时可以被异常过滤器捕获并且处理的，所以我们可以自定义异常类型以及输出自定义响应数据。 结尾本文除了路由守卫之外另一个重要的知识是【自定义元数据装饰器】的使用，基于该装饰器可以开发很多令人惊艳的功能，这个就看各位看官的实现了。","link":"/2019/08/27/2019-08-27-nestjs-guard.html"},{"title":"NestJs学习之旅(8)——管道","text":"本文是NestJs学习之旅的第八篇，讲解管道。 管道熟悉Linux命令的伙伴应该对“管道运算符”不陌生。 1ls -la | grep demo “|” 就是管道运算符，它把左边命令的输出作为输入传递给右边的命令，支持级联，如此一来，便可以通过管道运算符进行复杂命令的交替运算。 NestJs中的管道有着类似的功能，也可以级联处理数据。NestJs管道通过**@Injectable()装饰器装饰，需要实现PipeTransform**接口。 NestJs中管道的主要职责如下： 数据转换 将输入数据转换为所需的输出 数据验证 接收客户端提交的参数，如果通过验证则继续传递，如果验证未通过则提示错误 执行顺序在前面的文章中我们讨论了中间件、控制器、路由守卫，结合本问讨论的管道，可能有些读者会对这些组件的执行顺序提出疑问：这些东西执行的顺序到底是怎样的？ 执行顺序也不用找资料，自己在这些组件执行时加上日志即可，我得出的结论如下： 客户端请求 -&gt; 中间件 -&gt; 路由守卫 -&gt; 管道 -&gt; 控制器方法 开发管道数据转换类的管道就不详细解释了： 给你一个value和元数据，你的return值就是转换后的值。 NestJs内置了ValidationPipe、ParseIntPipe和ParseUUIDPipe。为了更好地理解它们的工作原理，我们以ValidationPipe（验证器管道）为例来演示管道的使用。 PipeTransform这是管道必须实现的接口，该接口定义如下： 123export interface PipeTransform&lt;T = any, R = any&gt; { transform(value: T, metadata: ArgumentMetadata): R;} value 输入参数，T为输入参数类型 metadata \u0010 value的元数据，包括参数来源，参数类型等等 输出参数，R为输出参数类型 ArgumentMetadata用来描述当前处理value的元数据接口，接口定义如下： 12345export interface ArgumentMetadata { readonly type: 'body' | 'query' | 'param' | 'custom'; readonly metatype?: Type&lt;any&gt;; readonly data?: string;} 这个接口大家可能看不明白，没关系，等下会有具体示例来进行解读。 type 输入数据的来源 metatype &lt;Type&gt; 注入数据的类型 data &lt;string|undefined&gt;传递给装饰器的数据类型 例如如下控制器方法： 1234@Post()login(@Query('type') type: number) { // type 为登录类型参数，类似手机号登录为1，账号登录为2的例子 } 上述例子的元数据如下： type query @Query装饰器是读取GET参数 metatype Number type的类型符号 data type 传递给@Query装饰器的参数为“type” 验证器示例下面以用户登录时校验账号密码来说明验证器管道的使用，规则如下： 账号必须是字符串，长度6-20 密码不能为空 DTO定义DTO在Java中是Data Transfer Object，简单来说就是对数据的一层包装。咱们NestJs中用这个东西一般是为了防止非法字段的提交和IDE自动提示（偷笑）。 使用规则装饰器需要安装class-validator和class-transformer： 1npm i --save class-validator class-transformer 登录表单定义如下： 12345678// userLogin.dto.tsexport class UserLoginDto { @IsString() @Length(6, 20, { message: '长度不合法' }) readonly username: string; @Length(1) readonly password: string;} 管道定义由于咱们的管道是通用的，也就是验证什么内容是由外部决定的，管道只负责“你给我数据和规则，我来校验”。所以咱们需要使用到装饰器元数据。 1234567891011121314151617181920212223242526272829303132// validate.pipe.tsimport { ArgumentMetadata, BadRequestException, Injectable, PipeTransform } from '@nestjs/common';import { plainToClass } from 'class-transformer';import { validate } from 'class-validator';@Injectable()export class ValidatePipe implements PipeTransform { async transform(value: any, { metatype }: ArgumentMetadata): Promise&lt;any&gt; { if (!metatype || !this.toValidate(metatype)) { // 如果不是注入的数据且不需要验证，直接跳过处理 return value; } // 数据格式转换 const object = plainToClass(metatype, value); // 调用验证 const errors = await validate(object); // 如果错误长度大于0，证明出错，需要抛出400错误 if (errors.length &gt; 0) { throw new BadRequestException(errors); } return value; } /** * 需要验证的数据类型 * @param metatype */ private toValidate(metatype: any): boolean { const types = [String, Boolean, Number, Array, Object]; return !types.includes(metatype); }} 控制器定义今天的主角是管道，所以控制器层就不写逻辑了 123456// user.controller.ts@Post('login')@UsePipes(ValidatePipe)login(@Body() userLoginDto: UserLoginDTO) { return {errcode:0, errmsg: 'ok'};} 运行项目项目根目录执行以下命令即可运行NestJs项目： 1npm run start 项目运行后可以使用Postman来验证一下： 请求数据1 123{ } 响应数据1 1234567891011121314151617181920212223{ &quot;statusCode&quot;: 400, &quot;error&quot;: &quot;Bad Request&quot;, &quot;message&quot;: [ { &quot;target&quot;: {}, &quot;property&quot;: &quot;username&quot;, &quot;children&quot;: [], &quot;constraints&quot;: { &quot;length&quot;: &quot;长度不合法&quot;, &quot;isString&quot;: &quot;username must be a string&quot; } }, { &quot;target&quot;: {}, &quot;property&quot;: &quot;password&quot;, &quot;children&quot;: [], &quot;constraints&quot;: { &quot;length&quot;: &quot;password must be longer than or equal to 1 characters&quot; } } ]} 请求数据2 123{ &quot;username&quot;:&quot;xialeistudio&quot;} 响应数据2 12345678910111213141516{ &quot;statusCode&quot;: 400, &quot;error&quot;: &quot;Bad Request&quot;, &quot;message&quot;: [ { &quot;target&quot;: { &quot;username&quot;: &quot;xialeistudio&quot; }, &quot;property&quot;: &quot;password&quot;, &quot;children&quot;: [], &quot;constraints&quot;: { &quot;length&quot;: &quot;password must be longer than or equal to 1 characters&quot; } } ]} 请求数据3 1234{ &quot;username&quot;:&quot;xialeistudio&quot;, &quot;password&quot;:&quot;111111&quot;} 响应数据3 1[] 注意事项上文演示了ValidatePipe的实现，生产环境直接使用NestJs提供的ValidationPipe即可。我们可以在main.ts中使用全局管道。 123456async function bootstrap() { const app = await NestFactory.create(AppModule); app.useGlobalPipes(new ValidationPipe()); await app.listen(3000);}bootstrap(); 结尾和笔者使用的SpringBoot中验证框架对比一下之后发现，NestJs验证管道所实现的功能还真不比SpringBoot差，看来官方说的“下一代Node.js全栈开发框架”确实不是盖的！ 如果您想交流关于NestJs更多的知识，欢迎加群讨论！","link":"/2019/08/28/2019-08-28-nestjs-pipe.html"},{"title":"NestJs学习之旅(9)——拦截器","text":"本文是NestJs的第九篇，讲解拦截器。 拦截器是一个实现了NestInterceptor接口且被**@Injectable**装饰器修饰的类。 拦截器是基于AOP编程思想的一种应用，以下是常用的功能： 在方法执行之前或之后执行额外的逻辑，这些逻辑一般不属于业务的一部分 转换函数执行结果 转换函数执行时抛出的异常 扩展函数基本行为 特定场景下完全重写函数的行为（比如缓存拦截器，一旦有可用的缓存则直接返回，不执行真正的业务逻辑，即业务逻辑处理函数行为已经被重写） 拦截器接口每个拦截器都需要实现NestInterceptor接口的**intercept()**方法，该方法接收两个参数。方法原型如下： 1function intercept(context: ExecutionContext, next: CallHandler): Observable&lt;any&gt; ExecutionContext 执行上下文，与NestJs学习之旅(7)——路由守卫中的执行上下文相同 CallHandler 路由处理函数 CallHandler该接口是对路由处理函数的抽象，接口定义如下： 123export interface CallHandler&lt;T = any&gt; { handle(): Observable&lt;T&gt;;} handle()函数的返回值也就是对应路由函数的返回值。 以获取用户列表为例： 12345678// user.controller.ts@Controller('user')export class UserController { @Get() list() { return []; }} 当访问 /user/list 时，路由处理函数返回**[]**，如果在应用拦截器的情况下，调用CallHandler接口的handle()方法得到的也是Observable&lt;[]&gt;(RxJs包装对象)。 所以，如果在拦截器中调用了next.handle()方法就会执行对应的路由处理函数，如果不调用的话就不会执行。 一个请求链路日志记录拦截器随着微服务的兴起，原来的单一项目被拆分成多个比较小的子模块，这些子模块可以独立开发、独立部署、独立运行，大大提高了开发、执行效率，但是带来的问题也比较多，一个经常遇到的问题是接口调用出错不好查找日志。 如果在业务逻辑中硬编码这种链路调用日志是非常不可取的，严重违反了单一职责的原则，这在微服务开发中是相当不好的一种行为，会让微服务变得臃肿，这些逻辑完全可以通过拦截器来实现。 123456789101112131415161718192021222324252627282930// app.interceptor.tsimport { CallHandler, ExecutionContext, Injectable, Logger, NestInterceptor } from '@nestjs/common';import { Observable } from 'rxjs';import { tap } from 'rxjs/operators';import { Request } from 'express';import { format } from 'util';@Injectable()export class AppInterceptor implements NestInterceptor { private readonly logger = new Logger(); // 实例化日志记录器 intercept(context: ExecutionContext, next: CallHandler): Observable&lt;any&gt; { const start = Date.now(); // 请求开始时间 return next.handle().pipe(tap((response) =&gt; { // 调用完handle()后得到RxJs响应对象，使用tap可以得到路由函数的返回值 const host = context.switchToHttp(); const request = host.getRequest&lt;Request&gt;(); // 打印请求方法，请求链接，处理时间和响应数据 this.logger.log(format( '%s %s %dms %s', request.method, request.url, Date.now() - start, JSON.stringify(response), )); })); }} 12345678// user.controller.ts@UseInterceptors(AppInterceptor)export class UserController { @Get() list() { return []; }} 当访问 /user时控制台想输出 1[Nest] 96310 - 09/10/2019, 2:44 PM GET /user 1ms [] 拦截器作用域拦截器可以在以下作用域进行绑定： 全局拦截器 控制器拦截器 路由方法拦截器 全局拦截器在main.ts中使用以下代码即可： 12const app = await NestFactory.create(AppModule);app.useGlobalInterceptors(new AppInterceptor()); 控制器拦截器将对该控制器所有路由方法生效： 1234@Controller('user')@UseInterceptors(AppInterceptor)export class UserController {} 路由方法拦截器只对当前被装饰的路由方法进行拦截： 123456789@Controller('user')export class UserController { @UseInterceptors(AppInterceptor) @Get() list() { return []; }} 响应处理CallHandler接口的handle()返回值实际上是RxJs的Observable对象，利用RxJs操作符可以对该对象进行操作，比如有一个API接口，之前返回的数据结构如下，如果正常响应，响应体就是数据，没有包装结构： 12345{ &quot;id&quot;:1, &quot;name&quot;:&quot;xialei&quot;} 新的需求是要把之前的纯数据响应包装为一个data属性，结构如下： 1234567{ &quot;data&quot;: { &quot;id&quot;: 1, &quot;name&quot;:&quot;xialei&quot; }} 接到这个需求时有的小伙伴可能已经在梳理响应接口的数量然后评估工时准备进行开发了，而使用NestJs的拦截器，不到一炷香的时间即可实现该需求。 1234567891011121314import { CallHandler, ExecutionContext, Injectable, Logger, NestInterceptor } from '@nestjs/common';import { Observable } from 'rxjs';import { map } from 'rxjs/operators';@Injectable()export class AppInterceptor implements NestInterceptor { intercept(context: ExecutionContext, next: CallHandler): Observable&lt;any&gt; { return next.handle(). pipe(map(data =&gt; ({ data }))); // map操作符与Array.prototype.map类似 }} 应用上述拦截器后响应数据就会被包上一层data属性。 异常映射另外一个有趣的例子是利用RxJs的catchError来覆盖路由处理函数抛出的异常。 123456789101112131415161718192021import { Injectable, NestInterceptor, ExecutionContext, BadGatewayException, CallHandler,} from '@nestjs/common';import { Observable, throwError } from 'rxjs';import { catchError } from 'rxjs/operators';@Injectable()export class ErrorsInterceptor implements NestInterceptor { intercept(context: ExecutionContext, next: CallHandler): Observable&lt;any&gt; { return next .handle() .pipe( catchError(err =&gt; throwError(new BadGatewayException())) // catchError用来捕获异常 ); }} 重写路由函数逻辑在文章开始部分提到了拦截器可以重写路由处理函数逻辑。如下是一个缓存拦截器的例子 1234567891011121314151617181920212223242526import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common';import { Observable, of } from 'rxjs';@Injectable()export class CacheInterceptor implements NestInterceptor { constructor(private readonly cacheService: CacheService) {} async intercept(context: ExecutionContext, next: CallHandler): Observable&lt;any&gt; { const host = context.switchToHttp(); const request = host.getRequest(); if(request.method !== 'GET') { // 非GET请求放行 return next.handle(); } const cachedData = await this.cacheService.get(request.url); if(cachedData) { // 命中缓存，直接放行 return of(cachedData); } return next.handle().pipe(tap(response) =&gt; { // 响应数据写入缓存，此处可以等待缓存写入完成，也可以不等待 this.cacheService.set(request.method, response); }); }} 结尾本文是NestJs基础知识的最后一篇，接下将针对特定模块进行更新，比如数据库、上传、鉴权等等。","link":"/2019/09/10/2019-09-10-nestjs-interceptor.html"},{"title":"leetcode(2) —— 两数相加","text":"本文是力扣算法的第二篇，讲解两数相加问题。 Question 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例： 123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 分析遍历两个链表把值加起来好之后插入链表，如果有进位的话需要把进位的值保存到后面的节点上，如果遍历完毕之后还剩下需要进位的值，那么需要插入末尾新节点。 边界情况遇到链表相关的题目时一定要处理好边界情况，因为有些为空的链表或者只有1个节点的链表没有处理的必要，及时返回可以降低算法复杂度。 链表1和链表2同时为空，直接返回undefined即可 链表1为空，返回链表2 链表2为空，返回链表1 解题方法123456789101112131415161718192021222324252627282930313233343536373839404142434445// 链表节点定义function ListNode(val) { this.val = val; this.next = null;}function addTwoNumbers(l1, l2) { if(!l1 &amp;&amp; !l2) { // 链表1和链表2同时为空，无需任何处理 return; } if(!l1) { // 链表1为空，直接返回链表2 return l2; } if(!l2) { // 链表2为空，直接返回链表1 return l1; } let carry = 0; // 进位值 let head = new ListNode(0); // 链表头节点 let p = head; // 链表移动指针 while(l1 || l2 || carry &gt; 0) { // l1和l2虽然不会同时为空，但是存在l1和l2长度不一致的情况， 这种也需要处理 let sum = carry; // sum为本节点的值，需要加上前一个节点的进位值 if(l1) { sum += l1.val; // 把链表1当前节点的值加上 l1 = l1.next; // 移动链表1指针 } if(l2) { sum += l2.val; l2 = l2.next; } if(sum &gt;= 10) { // 两个个位数相加最大值为18，所以到下一个节点进位的最大值为1 carry = 1; sum -= 10; // 去掉十位，保留个位为节点最终值 } else { carry = 0; // 相加之后和小于10，不需要进位，清除进位数据，否则死循环 } p.next = new ListNode(sum); // 插入新节点 p = p.next; // 新链表指针后移 } return head.next; // 头结点的值不是相加得到的，所以需要后移一个节点返回由两个链表加起来的结果} 进位的处理搞清楚之后这道题就清楚了。 时间复杂度O(max(l1.length, l2.length)) 循环次数的根据链表1和链表2中长的那个链表来的，因为要保证两个链表的所有节点都被便利到 空间复杂度O(max(l1,l2)) 最终链表的节点数也是根据链表1和链表2中长的那个链表来的，因为要保证两个链表的所有节点都被便利到，如果最后有进位的话，结果链表的长度会比链表1和链表2中长的链表大小+1。 结尾这道题的难度是中等，但是摸清楚链表的基本操作之后，应该没什么问题就能解决。","link":"/2019/09/12/2019-09-12-leetcode-add-two-sum.html"},{"title":"leetcode(1) —— 两数之和","text":"本文是力扣算法的第一篇，讲解两数之和问题。 问题 给定一个整数数组 nums 和一个目标值 *target*，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 12345给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 嵌套循环解题法 通过第1遍循环可以拿到当前值和剩余值，然后嵌套循环一次，检查剩余值是不是在数组中。 123456789101112function twoSum(nums, target) { for(let i = 0;i&lt;nums.length;i++) { const current = nums[i]; // 拿到当前值 const remain = target - current; // 拿到剩余值 for(let j = 1;j&lt;nums.length;j++) { if(nums[j] === remain) { return [i, j]; } } }} 时间复杂度是O(n^2) nums的长度为n,嵌套循环的总执行次数是 n*(n-1)，当n趋向于无穷大时n-1和n没什么区别，忽略 空间复杂度为O(1) 增加的临时变量有 current, remain, i, j，不会随着nums的长度而增加，所以是常量O(1) 嵌套循环的效率是最低的, 面试的时候就算回答出来被送走的几率也是很大的。 两遍HashTable解题法 核心思想是使用一个HashTable保存每个值和每个值的位置。 第1次循环时构造出HashTable，键为nums数组的元素，值为元素对应的下标 第2次循环时获取当前循环的值以及剩余值，如果剩余值的索引不等于当前值的索引，且剩余值也在HashTable中，直接从HashTable读取出当前值和剩余值的index返回。 123456789101112131415function twoSum(nums, target) { const hashTable = {}; // 第1次循环 for(let i = 0;i&lt;nums.length;i++) { hashTable[nums[i]] = i; } // 第2次循环 for(let i = 0;i&lt;nums.length;i++) { const current = nums[i]; const remain = target - current; if(map[remain] !== undefined &amp;&amp; map[remain] !== i) { return [i, map[remain]]; } }} 时间复杂度为O(2n) = O(n) 进行了两次循环，理论上是2*n的时间复杂度，但是当n趋向于无穷大时，n和2n的差距可以忽略，所以结果是O(n) 空间复杂度为O(n) 增加了HashTable，大小是nums的长度n，所以空间复杂度是O(n) 该算法利用了HashTable的O(1)的时间复杂度巧妙地减少了嵌套循环，算法效率提升很大！ 一般回答到这里基本就没啥问题了，但是还有一种基于HashTable一次循环就能解决问题的方案。 一遍HashTable解题法 循环nums数组，得到当前值和剩余值，判断剩余值在不在HashTable，如果在的话，直接返回剩余值的位置和当前值的位置。如果不在则把剩余值插入HashTable，继续循环。 Q: 为什么先返回的是剩余值的位置而不是当前值的位置？ A: 因为当前值的位置是确定的，所以当前值的位置不在HashTable中，但是剩余值可能在前面的循环中插入了HashTable，是老值，所以先返回。 123456789101112function twoSum(nums, target) { const hashTable = {}; for(let i = 0;i&lt;nums.length;i++) { const current = nums[i]; const remain = target - remain; if(hashTable[remain] !== undefined) { // 为什么不需要判断位置?因为当前值的位置根本没插入HashTable中，索引不可能重复 return [hashTable[remain], i]; } hashTable[current] = i; // 插入当前值到HashTable，下一次循环时这里就成了&quot;老值&quot; }} 时间复杂度O(n) 正宗的O(n),一次循环解决问题 空间复杂度O(n) 增加了HashTable，大小随着nums的增大而增大 结尾合理使用HashTable能够将算法的时间复杂度降低很多，一般会有一个指数级的提升！","link":"/2019/09/12/2019-09-12-leetcode-two-sum.html"},{"title":"leetcode(3)——无重复字符的最长子串","text":"本文是力扣算法的第三篇，讲解无重复字符的最长子串问题。 Question 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例1： 123输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例2： 123输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例3： 1234输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 遍历法 最容易想到的一种算法，也是效率最低的一种算法 通过两次遍历得到所有可能的 子字符串 列表 将每个字符串传入一个函数检测是否包含重复字符，如果不包含则更新最长子串的长度 12345678910111213141516171819202122232425// 判断给定的子串是否包含重复字符function isUnique(str, start, end) { const chars = []; for(let i = start; i &lt; end; i++) { const char = str[i]; if(chars.indexOf(char) !== -1) { // 字符已存在，本字符串不符合条件 return false; } chars.push(char); // 添加字符 } return true;}// 获取字符串最长子串长度function lengthOfLongestSubstring(s) { let max = 0; for(let i = 0; i &lt; s.length; i++) { for(let j = i+1; j &lt;= s.length; j++) { if(isUnique(s, i, j)) { // 判断子串是否唯一 max = Math.max(max, j - i); // j - i 为当前子串长度 } } } return max;} 时间复杂度$O(n^3)$ i循环，j循环，isUnquie中的循环，3次循还嵌套 空间复杂度$O(min(n,m))$ isUnique函数中定义了一个数组来存储不重复的子串字符，长度为$k$,$k$的长度取决于字符串$s$的大小$n$以及 字符串$s$包含的不重复字符数大小$m$ 滑动窗口法 暴力法中我们会重复检查一个子串是否包含重复的字符，如果从$i$ ~ $j-1$ 之间的子串已经被检查过没有重复字符了，那么只需要检查$s[j]$是否在这个子串就行了。 子串使用js自带的数据结构Set存储 如果不在该子串，那么子串长度+1，$j+1$，继续往后走 如果在这个子串，证明出现了重复，我们需要将$s[i]$移出来之后$i+1$，继续往后走 123456789101112131415161718function lengthOfLongestSubstring(s) { const set = new Set(); const max = 0; let i = 0; let j = 0; while(i &lt; s.length &amp;&amp; j &lt; s.length) { if(!set.has(s[j])) { // j 不在set中，set中添加s[j],j后移，同时更新最大子串长度 set.add(s[j]); j++; max = Math.max(max, j - i); } else { set.delete(s[i]); // 移除set左边的数据，i后移一位 i++; } } return max;} 时间复杂度 $O(2n) \\approx O(n)$ 最好的情况是j一次走完没有出现重复，最坏的情况是i和j都走到了末尾 空间复杂度 $O(min(n,m))$ 与暴力法相似，也需要一个Set存储不重复字符，$n$ 是字符串$s$长度，$m$是字符串$s$中不重复的字母个数 优化的滑动窗口 在滑动窗口解法中，$i$的后移可以优化一下，如果 s$[j]$ 在 s[$i$] ~ s[$j$] 内与字符 $c$ (随便取的名字)重复，$i$ 不需要一步一步$i$++，直接把 $i$ 定位到 $c$ + 1的位置即可。这样可以将算法时间复杂度稳定在 $O(n)$ 1234567891011121314function lengthOfLongestSubstring(s) { const map = {}; // 保存 字符和下标的映射关系，如果字符重复，从map拿到位置，i直接跳到这个位置 let max = 0; for(let i = 0, j = 0;j &lt; s.length;j++) { const char = s[j]; if(map[char] !== undefined) { // 当前字符存在重复，需要将i更新 i = Math.max(i, map[char]); // 如果i的当前位置大于map[char]，不能更新为map[char] } max = Math.max(max, j - i + 1); // 由于j最大是s.length-1，所以最大子串长度需要+1 map[char] = j + 1; // 保存映射关系 } return max;} 时间复杂度 $O(n)$ 只遍历了j 空间复杂度 $O(min(n,m))$ 与之前的方法相同 Q: 为什么第8行的 i = Math.max(i, map[char]) 不能直接是 i = map[char]? A: $i$ 的位置比map[char]大的情况下如果直接赋值会导致 $i$ 往前面走，会导致返回的子串长度大于实际的子串长度 错误例子 abba i j s[j] s[i] ~ s[j] Max 0 0 a a 1 0 1 b ab 2 2(map中没有s[j]，所以这里的位置直接是当前j的值) 2 b b 2 1(map中有s[j]，第1个字符就是a，直接拿来用) 3 a bba 3 可以看到第4次循环中 i 的位置已经出现了问题，把位置1的a拿过来进行计算了，窗口的起始左边也从2变成了1，往回走了。 结尾本问题主要是考察对滑动窗口算法的实际应用，掌握之后解题问题不大。","link":"/2019/09/16/2019-09-16-leetcode-longest-substring-without-repeating-characters%20(copy).html"},{"title":"搞懂JS变量提升","text":"本文讲解Javascript变量提升引起的问题以及如何规避。 问题今天看到一道有意思的面试题，考察的还真是JS的基本功，题目如下： 12345678910var name = &quot;world&quot;;(function(){ if(typeof name === &quot;undefined&quot;) { var name = &quot;Jack&quot;; console.log(&quot;Hello &quot; + name); } else { console.log(&quot;Hello &quot; + name); }}()); 根据if条件可以得出可能的答案： Hello world Hello Jack 正确答案答案是Hello Jack，但是答案怎么来的，回答不好可能还是只能打50分，有以下两种理解： 理解1： 立即执行函数有独立的作用域，访问不到外部name，所以if判断成立，输出 Hello Jack 这个理解是不正确的。虽然函数隔离了作用域，但是由于作用域链的关系，JS会从当前作用域一直往上级查找，直到顶级作用域（浏览器环境为window）。 如下代码输出Hello world 12345var name = &quot;world&quot;;(function(){ console.log(&quot;Hello &quot; + name);}()); 理解2： var存在变量提升，所以if在判断的时候name确实为undefined，走了if分支，输出 Hello Jack 变量提升MDN对变量提升的解释： “变量提升”意味着变量和函数的声明会在物理层面移动到代码的最前面，但这么说并不准确。实际上变量和函数声明在代码里的位置是不会动的，而是在编译阶段被放入内存中。 JavaScript 仅提升声明，而不提升初始化 函数和变量相比，会被优先提升 根据变量提升理论我们可以“模拟”JS实际执行代码的过程： 1234567891011var name = &quot;world&quot;;(function(){ var name; // 变量提升，仅提升声明，不提升初始化 if(typeof name === &quot;undefined&quot;) { name = &quot;Jack&quot;; console.log(&quot;Hello &quot; + name); } else { console.log(&quot;Hello &quot; + name); }}()); 函数内部作用域顶级的name初始化时为undefined，所以会走if分支，输出Hello Jack。这才是100分答案！ 规避变量提升问题 在作用域的顶部定义变量 使用ES6新语法let或const定义变量 技术参考 变量提升 - 术语表 | MDN","link":"/2019/09/17/2019-09-18-javascript-var-scope.html"},{"title":"leetcode(4)——寻找两个有序数组的中位数","text":"本文是力扣算法的第四篇，讲解寻找两个有序数组的中位数。 Question 给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。 请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。 示例 1: 1234nums1 = [1, 3]nums2 = [2]则中位数是 2.0 示例 2: 1234nums1 = [1, 2]nums2 = [3, 4]则中位数是 (2 + 3)/2 = 2.5 中位数 中位数是按顺序排列的一组数据中居于中间位置的数，即在这组数据中，有一半的数据比他大，有一半的数据比他小。 暴力法 将两个有序数组合并成一个有序数组 如果长度是奇数则返回中间的值，如果是否则则返回中间两个数的平均值。 12345678910111213141516171819202122232425262728var findMedianSortedArrays = function (nums1, nums2) { const nums = []; let p1 = p2 = 0; while (p1 &lt; nums1.length &amp;&amp; p2 &lt; nums2.length) { if (nums1[p1] &lt; nums2[p2]) { nums.push(nums1[p1++]); } else if (nums1[p1] &gt; nums2[p2]) { nums.push(nums2[p2++]); } else { nums.push(nums1[p1++]); nums.push(nums2[p2++]); } } if (p1 !== nums1.length) { // nums2比nums1长度要短，导致nums1没有走到末尾 for (; p1 &lt; nums1.length; p1++) { nums.push(nums1[p1]); } } if (p2 !== nums2.length) { // nums1比nums2长度要短，导致nums2没有走到末尾 for (; p2 &lt; nums2.length; p2++) { nums.push(nums2[p2]); } } if (nums.length % 2 === 0) { // 长度为偶数 return (nums[nums.length / 2] + nums[nums.length / 2 - 1]) / 2 } return nums[Math.floor(nums.length / 2)];} 时间复杂度 $O(m+n)$ 同时遍历了数组1和数组2 空间复杂度$O(m+n)$ 声明了新数组，长度为数组1的长度加数组2的长度 提交完通过了，这道题定义为Hard是不是搞错了，明明是个Easy题。 如果你这么想那你可能漏了一个时间复杂度的要求：$O(log(m+n))$ 思考 &amp;&amp; 规律 一般来说看到$O(log)$ 级别的时间复杂度一般是跟二分有关的算法才会产生这个时间复杂度，所以我们不妨以二分的思想来重新考虑一下这个问题。 有序数组求中位数，一般化为就两个有序数组的第$k$个数，本问题中$k = (m+n)/2$时就是我们的答案。 怎么求第$k$个数？ 我们可以现在数组1和数组2中求出$k/2$个数$a$和$b$，如果$a &lt; b$，那说明$k$个数位于数组1的后半段或和数组2的前半段之间。我们把不符合规则的数组1前半段和数组2后判断给舍弃即可，这就只处理了一般的数据，达到的二分的目的。之后按照这个原则递归处理即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364var findMedianSortedArrays = function (nums1, nums2) { const m = nums1.length; const n = nums2.length; // 如果第1个数组为空，直接返回第2个数组的数据即可 if (m === 0) { // 第2个数组长度为偶数，返回中间两个数字的平均值 if (n % 2 === 0) { return (nums2[nums2.length / 2] + nums2[nums2.length / 2 - 1]) / 2; } // 第2个数组长度为奇数，返回中间两个数字的平均值 return nums2[Math.floor(nums2.length / 2)]; } if (n === 0) { if (m % 2 === 0) { return (nums1[nums1.length / 2] + nums1[nums1.length / 2 - 1]) / 2; } return nums1[Math.floor(nums1.length / 2)]; } // 总长度 const total = m + n; // 总数为奇数，找到第total/2+1个数（下标从1开始） if (total % 2 === 1) { return findKth(nums1, 0, nums2, 0, Math.floor(total / 2) + 1); } // 下标为偶数，找到中间的两个数 return ( findKth(nums1, 0, nums2, 0, Math.floor(total / 2)) + findKth(nums1, 0, nums2, 0, Math.floor(total / 2) + 1) ) / 2}// 找到两个有序数组的第k大的值function findKth(nums1, aBegin, nums2, bBegin, k) { // 如果数组1的下标或者数组2的下标超过各自的数组长度，k就是另一个数组的第k个数 if (aBegin &gt;= nums1.length) { return nums2[bBegin + k - 1]; } if (bBegin &gt;= nums2.length) { return nums1[aBegin + k - 1]; } if (k === 1) { return Math.min(nums1[aBegin], nums2[bBegin]); } let midA = Number.MAX_VALUE; let midB = Number.MAX_VALUE; // 如果数组1的第k/2个数没有越界 if (aBegin + Math.floor(k / 2) - 1 &lt; nums1.length) { midA = nums1[aBegin + Math.floor(k / 2) - 1]; } if (bBegin + Math.floor(k / 2) - 1 &lt; nums2.length) { midB = nums2[bBegin + Math.floor(k / 2) - 1]; } // 如果数组1的第k/2个数小于数组2的k/2个数，表示总的第k个数在数组1后判断和数组2的前半段 // 所以数组1的下标需要往后走k/2个位置，响应的数组b的下标往前走k/2个位置 if (midA &lt; midB) { return findKth(nums1, aBegin + Math.floor(k / 2), nums2, bBegin, k - Math.floor(k / 2)); } return findKth(nums1, aBegin, nums2, bBegin + Math.floor(k / 2), k - Math.floor(k / 2));} 时间复杂度$O(log(m+n))$ 每次递归都舍弃了一半数据，二分的复杂度是$log$ 空间复杂度$O(1)$ 只使用了固定的几个临时变量 结尾本问题考察的是对二分法的基本功，面试中后期遇到的可能性比较大，可以多加熟悉。","link":"/2019/09/20/2019-09-20-leetcode-median-of-two-sorted-arrays.html"},{"title":"Javavscript基础——原型和原型链","text":"本文研究一下Javascript的核心基础——原型链和继承。 对于使用过基于类的语言(如Java或C#)的人来说，Javascript的继承有点难以搞懂，因为它本身没有class这种东西。(ES6中引入了class关键字，看上去也像传统的OOP语言，但是那只是语法糖，底层还是基于原型)。 原型链MDN上对于原型链的解释： 当谈到继承时，JavaScript 只有一种结构：对象。每个实例对象（ object ）都有一个私有属性（称之为 __proto__ ）指向它的构造函数的原型对象（prototype ）。该原型对象也有一个自己的原型对象( __proto__ ) ，层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节。 几乎所有 JavaScript 中的对象都是位于原型链顶端的 Object 的实例。 这段话可能难以理解，我们来举个例子： 123456const list = []; // 定义数组list.__proto__ === Array.prototype; // truelist.__proto__.__proto__ === Object.prototype; // truelist.__proto__.__proto__.__proto__===null; // true// 继承关系为// list -&gt; Array.prototype -&gt; Object.prototype -&gt; null 结合MDN的解释，我们来解释一下上述例子： list是Array的实例对象，使用了字面量的方式创建了对象实例。 每个实例对象（ object ）都有一个私有属性（称之为 __proto__ ）指向它的构造函数的原型对象（prototype ）。 12// list的构造函数是Array，所以list.__proto__指向构造函数Array的原型对象。list.__proto__ === Array.prototype; // true 该原型对象也有一个自己的原型对象( __proto__ ) 12345// Array.prototype也是对象，也有自己的原型对象，原型是Object.prototype// 下面是数学运算(等量代换)// list.__proto__ = Array.prototype// Array.prototype.__proto__ = Object.prototypelist.__proto__.__proto__ === Object.prototype; // true 层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节。 12345// 目前我们来到了Object.prototype，根据规范，Object.prototype的原型对象为null// list.__proto__ = Array.prototype// Array.prototype.__proto__ = Object.prototype// Object.prototype.__proto__ = null;list.__proto__.__proto__.__proto__ === null; // true 原型链查找 当我们访问对象的属性或者方法时，会先从对象本身开始查找，如果查找不到，则查找对象的__proto__，层层向上查找，直到查找到属性，否则抛出错误。 12const list = [];list.toString(); 属性查找过程如下： 查找list.toString()方法，没找到 继续查找list.__proto__，也就是Array.prototype，找到了 调用Array.prototype.toString 原型链结论 对象实例.__proto__ = 对象构造函数.prototype 几乎所有对象的原型都是Object.prototype null是对象，但是null没有原型 属性/方法查找采用优先返回机制。 函数经过原型链的简单介绍，相信大家对原型和原型链有了一个比较直观的了解了，现在要说到的是函数。 我们知道，Javascript中函数也是对象，所以Function.__proto__指向Object.prototype。 上面的结论在Javascript中是有问题的。我们来聊一聊函数。 先看看简单一点的例子，大家知道,Object是对象的构造函数，构造函数也是函数，所有的函数的原型都是Function.prototype，所以Object.__proto__是等于Function.prototype的。 事实证明，也是如此。 那么Function.__proto__为什么不等于Object.prototype呢?Function不是对象吗? Function确实是对象，同时还是构造函数，可以通过new Function()来得到函数实例。 上面我们说到所有函数的原型是Function.prototype，所以Function这个构造函数的原型__proto__等于Function.prototype。 基于以上原理，还有以下相等关系： Object.__proto__ === Function.prototype Array.__proto__ === Function.prototype 引申的问题我们知道Function.__proto__是指向Function.prototype，那个Function.prototype这个Function哪里来的?Function自己创造自己?那不是会死循环吗? 这个问题不是纯JS层面能解决的，牵涉到底层实现，下面是网络上别人整理的结论，有需要的可以研究一下V8的源码，这样可以彻底解决这个问题。 用C/C++ 构造内部数据结构创建一个 OP 即(Object.prototype)以及初始化其内部属性但不包括行为。 用 C/C++ 构造内部数据结构创建一个 FP 即(Function.prototype)以及初始化其内部属性但不包括行为。 将 FP 的[[Prototype]]指向 OP。 用 C/C++ 构造内部数据结构创建各种内置引用类型。 将各内置引用类型的[[Prototype]]指向 FP。 将 Function 的 prototype 指向 FP。 将 Object 的 prototype 指向 OP。 用 Function 实例化出 OP，FP，以及 Object 的行为并挂载。 用 Object 实例化出除 Object 以及 Function 的其他内置引用类型的 prototype 属性对象。 用 Function 实例化出除Object 以及 Function 的其他内置引用类型的 prototype 属性对象的行为并挂载。 实例化内置对象 Math 以及 Grobal 至此，所有 内置类型构建完成。 函数结论 函数的原型都是Function.protype,构造函数也是函数，所以构造函数的原型也是Function.prototype 来自灵魂的拷问1下面是一道有点难度的JS基础题，可以感受一下： 1234567891011121314151617181920function A() { }function B(a) { this.a = a;}function C(a) { if(a) { this.a = a; }}A.prototype.a = 1;B.prototype.a = 1;C.prototype.a = 1;console.log(new A().a);console.log(new B().a);console.log(new C().a); 输出是 1231undefined1 解释 为什么输出1? 因为new A()这个对象上没有属性a，所以去查找原型链，查到了F.prototype.a 为什么输出undefined? 因为new B时没有传递a，所以a是undefined，new B()这个对象是有a属性的，只不过值是undefined,所以不查原型链 为什么输出1? 因为new C()未传递a，所以a是undefined，由于if(a)的判断，new C()这个对象内部没有a属性，所以去查原型链 来自灵魂的拷问212345678function F() { this.a = 1;}F.prototype.b = 2;var f = new F();console.log(f.hasOwnProperty('a'));console.log(f.hasOwnProperty('b')); 输出是 12truefalse 解释 为什么输出true`? 输出true比较好理解，因为构造函数F声明了属性a，所以F的实例有a属性 为什么输出false? b是f的原型对象F.prototype的属性，不是b自己的，不能拿别人的说成自己的。 结尾本文研究了原型和原型链之间的关系以及常见对象的原型和原型链，对于特殊对象Function也研究了一下，如果能搞懂后面两个问题，那本文对你来说没什么问题了。","link":"/2019/09/23/2019-09-23-javascript-prototype.html"},{"title":"Javavscript基础——this指向","text":"本文研究一下Javascript的this指向。 Javascript的this指向问题，有些人可能觉得很简单，有些人却觉得扑朔迷离，看完本文之后相应会对this的掌握有一个直观的判断，而不是”开局全靠猜”。 敲黑板 function函数this指向由调用方式确定，跟定义环境无关。 箭头函数this指向由定义环境决定，与调用方式无关，也不可以bind(this)。 严格模式 非严格模式下，全局作用域下的this指向window 严格模式下，全局作用域下的this指向undefined 以下讨论均为非严格模式，这个不影响今天的讨论。 实践说结论往往是让人难以理解的，下面通过不同的调用场景对this做一个说明。 1. 直接调用1234function test() { console.log(this);}test(); // 输出undefined 直接调用是最简单的， 大部分人在这里都能回答的很好。 总结 直接调用时this指向全局作用域。 非严格模式this指向window 严格模式this指向undefined 2. 对象调用123456789101112'use strict'var n = 1;var a = { n: 2, b: function() { console.log(this.n); }};a.b(); // 输出2var b = a.b;b(); // 输出1 面试题：请问上述例子输出什么? 非严格模式下，输出2和1，严格模式下输出2和一个报错(this指向undefined，访问undefined的n属性肯定报错) 那如果你这么回答，满分! 分析知其然还要知其所以然，我们分析一下： 为什么输出2? 因为a.b()是对象调用方式，所以b()中的this指向a 为什么输出1? 这个非常有意思，而且也很有迷惑性，面试的时候经常问到，也经常有人被问倒。 1var b = a.b 把a.b赋值给变量b，b就是一个函数，请注意: 这里只是赋值，没有调用，所以b中的this指向还不确定。 1b(); 调用函数b，这是什么调用方式? **普通调用**，所以this指向全局作用域。 总结对象调用方式下this指向调用对象。 是否GET? 如果没有GET，请关注公众号NodeJs之路，我在线给你答疑。 开胃菜已经吃了，下面来点”有难度的(实际上也没啥难度)”。 3. 嵌套对象调用12345678910var n = 1;var a = { n: 2, b: { n: 3, c: function() { console.log(this.n) } }}; 面试题：请问上述例子中function中的this指向哪里? 正确答案：未确定调用环境的情况下，this的指向不确定。 错误答案：指向a.b对象，Too young too simple! 123456789101112131415161718var n = 1;var a = { n: 2, b: { n: 3, c: function() { console.log(this.n) } }};a.b.c(); // 输出3a.c = a.b.c;a.c(); // 输出2var c = a.b.c; c(); // 输出1 这道题跟之前那道对象调用很像。 为什么输出3? 对象调用方式下指向调用对象，a.b.c()中c()是通过a.b对象调用，指向对象a.b 为什么输出? a.c = a.b.c 给a对象定义一个函数c，注意，此时没有调用！this指向不确定 a.c() 通过a对象来调用c()，所以this指向对象a 为什么输出1？ var c = a.b.c 函数赋值给普通变量，注意，此时没有调用! c(); 普通方式调用，指向window 总结嵌套对象调用方式下，this指向最终调用函数的对象。 a.b.c.d.e.f.g.h() h函数中的this指向a.b.c.d.e.f.g 4. 构造函数方式调用1234567891011var name = 1;function Person() { this.name = 2;}var p1= Person(); // p1为undefinedconsole.log(p1.name); // 报错var p2 = new Person();console.log(p2.name); // 输出2 p1为什么是undefined? 这道题比较坑，跟调用方式和this指向无关，因为Person函数没有返回值，js中，默认会返回undefined. p2.name为什么是2? 使用new操作符时，构造函数的返回值默认指向对象实例，所以p2.name就是Person()中的this.name 如果在Person()函数中加上return this的话，Person()返回值还是this，因为这是普通调用。 5. 构造函数中指明返回值原则上构造函数不应该有返回值，但是如果真的写了会怎么样？我们来探讨一下。 返回复杂对象123456function Person() { this.name = 2; return {};}var p1 = new Person();console.log(p1.name)// 输出undefined 返回简单对象虽然Js只有对象，但是有一些如string,number这种一般叫做简单对象,date,regex,array,object等等叫复杂对象。 123456function Person() { this.name = 2; return 1;}var p1 = new Person();console.log(p1.name)// 输出2 返回null使用typeof null返回的是[object]，证明null是个对象，不过咱们来看看构造函数返回null的表现。 123456function Person() { this.name = 2; return null;}var p1 = new Person();console.log(p1.name)// 输出2 总结构造函数中this指向对象实例本身，如果构造函数指明了返回值，那么表现如下： 返回普通值，this指向不变，还是对象实例本身 返回复杂对象，this指向新对象，也就是你new Person()返回的是那个新对象 6. bind1234567891011121314var a = { n: 1};var b = { n: 2}function f() { console.log(this.n);}var fa = f.bind(a);var fb = fa.bind(b);fa(); // 输出1fb(); // 输出1 第1个输出1应该不难理解，bind可以更改function内部的this指向。多次bind已经bind过的函数，this指向不变。 bind的实现原理有点复杂，将在下一篇文章进行详细解读。 总结bind可以手动绑定function的this，this指向第1次bind时的this。 7. apply/call这两个函数在this指向上表现一致，放到一起讲 1234567891011var a = { n: 1};var b = { n: 2}function f() { console.log(this.n);}f.call(a); // 输出1f.apply(b); // 输出2 call和apply的第1个参数为function执行时的this，这个this是确定的，对未使用过bind的函数进行多次apply/call，this指向都会改变。 8. 箭头函数123456789var n = 1;var b = { n: 2, a: () =&gt; { console.log(this.n); }}b.a(); // 输出1b.a.call({n:3}); // 输出1 b.a定义时的this和n,b所在的this一致，默认情况下为全局作用域 箭头函数的this指向定义时所在的this，这个是明确的，但是如果定义时所在的是1个function，那么this指向同上面7点。 说下我之前学JS遇到过的问题: ES5下function才会有作用域隔离, {}这种玩意不会隔离作用域。 结尾 直接调用this指向全局作用域window，严格模式指向undefined 对象调用方式指向调用对象 嵌套对象调用方式指向最终调用对象(离function最近的那个) 构造函数方式调用指向对象实例 构造函数返回String/Number等简单类型时this指向不变，返回null指向也不变 构造函数返回Object/Array等复杂对象时，new Person()的返回值为return的对象 bind可以更改function的this,一经绑定，永不改变。但是并不执行函数 apply/call可以更改没有被bind过的this 箭头函数的this指向为定义箭头函数的this","link":"/2019/09/27/2019-09-27-javascript-this.html"},{"title":"HTTPS协议是如何保证安全的?","text":"相信大家对于HTTPS协议都不陌生，但是应该存在以下疑问： HTTPS协议到底是如何运作的? HTTPS是如何解决HTTP协议的不安全特性的? HTTPS网站抓包为什么要信任证书? HTTP协议HTTP协议是一个应用层协议，通常运行在TCP协议之上。它是一个明文协议，客户端发起请求，服务端给出响应的响应。 由于网络并不是可信任的，HTTP协议的明文特性会存在以下风险： 通信数据有被窃听和被篡改的风险 目标网站有被冒充的风险 一般的网站可能没什么影响，但是如果是银行这种网站呢? 好在国内的银行在HTTP协议时代针对IE开发了ActiveX插件来保证安全性，这一点算是值得点赞了。 解决方案既然HTTP协议是明文协议，如果对数据进行加密之后是否就能保证安全性了呢? 在回答这个问题之前，我们先看看比较常见的两种加密算法。 加密算法常见的有对称加密算法和非对称加密算法。 对称加密 加密和解密使用同一个密钥。加解密效率比非对称加密高。但是密钥一旦泄露，通信就不安全了 非对称加密 存在密钥对，公钥加密私钥解密或者私钥加密公钥解密，无法通过公钥反推私钥，也无法通过私钥反推公钥。 一般情况下，使用非对称加密来传输通信所用的密钥，通信过程中采用对称加密，可以解决对称加密的安全问题以及非对称加密的性能问题。 HTTP加密通信过程 浏览器生成随机串A作为通信密钥 浏览器使用公钥将随机串A加密后得到密文B发送给服务器，这一步是安全的，因为黑客没有服务端私钥无法解密 服务端利用私钥解密出随机串A得到通信密钥 服务端和客户端用随机串A以及对称加密算法进行通信 这么一看似乎没有问题，毕竟黑客无法破解非对称加密的的内容，但是浏览器是如何得到公钥的? 有以下两种办法： 浏览器内置(不太可能，网站域名这么多，浏览器内置这么多公钥不现实) 服务器给浏览器下发(由于是明文下发，存在被窃听和篡改风险，也就是著名的中间人攻击) 中间人攻击 浏览器请求服务器获取公钥 中间人劫持了服务器的公钥，保存在自己手里 中间人生成一对密钥对，把伪造的公钥下发给浏览器 浏览器使用伪造的公钥和中间人通信 中间人和服务器进行通信 由于浏览器使用了伪造的公钥进行通信，所以通信过程是不可靠的 需要解决的问题只要保证浏览器得到的公钥是目标网站的公钥即可保证通信安全，那么问题来了，如何在不可靠的网络上安全的传输公钥呢? 这就是HTTPS协议需要解决的问题 HTTPS协议HTTPS协议涉及到的知识很多，本文只关注密钥安全交换部分，这也是HTTPS协议的精华。 HTTPS协议引入了CA和数字证书的概念。 数字证书包含签发机构、有效期、申请人公钥、证书所有者、证书签名算法、证书指纹以及指纹算法等信息。 CA数字证书签发机构，权威CA是受操作系统信任的，安装操作系统就会内置。 数字签名用Hash算法对数据进行计算得到Hash值，利用私钥对该Hash加密得到签名。 只有匹配的公钥才能解密出签名，来保证签名是本人私钥签发的 证书签发过程 网站生成密钥对，将私钥自己保存，公钥和网站域名等信息提交给CA CA把证书签发机构(也就是自己)、证书有效期、网站的公钥、网站域名等信息以明文形式写入到一个文本文件 CA选择一个指纹算法(一般为hash算法)计算文本文件的内容得到指纹，用CA的私钥对指纹和指纹算法进行加密得到数字签名，签名算法包含在证书的明文部分 CA把明文证书、指纹、指纹算法、数字签名等信息打包在一起得到证书下发给服务器 此时服务器拥有了权威CA颁发的数字证书以及自己的私钥 证书验证过程浏览器是如何验证网站的有效性的呢? 浏览器以HTTPS协议请求服务器的443端口 服务器下发自己的数字证书给浏览器(明文) 浏览器先校验CA、有效期、域名是否有效，如果无效，则终止连接(服务器此时不可信任) 如果有效，则从操作系统取出证书颁发机构的公钥，根据签名算法对数字签名解密得到证书指纹和指纹算法 浏览器用解密得到的指纹算法计算证书的指纹，与解密得到的指纹进行比对，如果一致，证书有效，公钥也安全拿到了 浏览器此时已经和真实的服务器进行通信了，中间人无法得知通信内容，因为中间人没有网站私钥 问题是如何解决的 黑客冒充CA给了一个假证书给浏览器 浏览器通过CA名称从操作系统取出CA公钥时对数字签名进行解密，发现解密失败，证明这个CA签名用的私钥和操作系统内置的不是一对，就发现了伪造 黑客篡改了证书中的网站公钥 证书中的网站公钥可以被篡改，但是数字签名是CA私钥计算出来的，黑客无法计算数字签名，浏览器用内置的CA公钥对数字签名解密时就会发现指纹不匹配了，这也发现了伪造 黑客也能正常获取网站公钥 的确，黑客自己通过浏览器访问网站时也能得到公钥，这个公钥跟正常用户的公钥是一致的。 但是每个客户端和服务器通信使用的对称密钥都是临时生成且随机的，黑客只能知道自己的随机密钥，但是不知道其他的随机密钥 综上，浏览器通过操作系统内置权威CA公钥的方式解决了网站公钥下发问题。 HTTPS中间人攻击HTTPS从协议上解决了HTTP时代的中间人攻击问题，但是HTTPS在用户主动信任了伪造证书的时候也会发生中间人攻击(比如早期的12306需要手动信任证书)，HTTPS中间人攻击流程如下： 客户端用HTTPS连接服务器的443端口 服务器下发自己的数字证书给客户端 黑客劫持了服务器的真实证书，并伪造了一个假的证书给浏览器 浏览器可以发现得到的网站证书是假的，但是浏览器选择信任 浏览器生成随机对称密钥A，用伪造的证书中的公钥加密发往服务器 黑客同样可以劫持这个请求，得到浏览器的对称密钥A，从而能够窃听或者篡改通信数据 黑客利用服务器的真实公钥将客户端的对称密钥A加密发往服务器 服务器利用私钥解密这个对称密钥A之后与黑客通信 黑客利用对称密钥A解密服务器的数据，篡改之后利用对称密钥A加密发给客户端 客户端收到的数据已经是不安全的了 以上就是HTTPS中间人攻击的原理，这也就是HTTPS抓包为什么要信任证书的原因。 总结 操作系统内置权威CA公钥来保证数字签名以及数字证书的安全性 实施HTTPS中间人攻击需要手动信任攻击者的假证书","link":"/2019/10/11/2019-10-11-https-protocol.html"},{"title":"搞懂JS闭包","text":"闭包(Closure)是JS比较难懂的一个东西，或者说别人说的难以理解， 本文将以简洁的语言+面试题来深入浅出地介绍一下。 作用域和作用域链在将闭包之前，需要先讲一下作用域。 JS中有全局作用域和局部作用域两种。 全局作用域任何地方都能访问，而局部作用于只有内部能访问。 1234function a() { var num = 1;}console.log(num); 在上面的例子中会报错，num不存在。 总结：函数外部无法访问函数内部的值 当代码在一个作用域中执行时，JS引擎会默认创建一个作用域链(从当前作用域一直链接到全局作用域)。 在访问变量或者函数时，如果当前作用域查找不到，则向上级作用域查找，找到就返回，如果查找到全局作用域还没找到的话就报错。 123456function a() { var num = 1; function b() { console.log(num); }} 在上面的例子中，num是在a函数作用域下的局部变量，我们在b函数访问num时会有以下过程： 在b的作用域查找num，发现找不到 往上一级作用域查找，发现num在a作用域，查找成功 总结：函数可以访问同级或上级作用域的值 闭包当我们需要在函数外部访问函数内部的值时，闭包就产生了。 123456789function a() { var num = 1; function b () { console.log(num); } return b;}var bb = a();bb(); // 1 在函数a的内部声明一个函数b，然后把return b，这个时候的b()函数就可以在外部访问，最终能够访问到num。 简单来说： 闭包就是函数内部的函数，上面的那个b就是闭包，可以在外面访问到内部的num 面试题1234567// 每隔1秒输出0-10的数字for(var i = 0;i&lt;10;i++) { setTimeout(function() { console.log(i); },1000);}// 上面这段代码输出什么?如果需要修改为正确的情况，怎么修改？ 1秒后输出10，因为setTimeout是到下一轮tick中执行，而for循环在当前这轮循环完毕后i的值已经是最后一个值了。需要使用闭包来保留现场 1234567for (var i = 0; i &lt; 10; i++) { (function (i) { setTimeout(function () { console.log(i); }, 1000); }(i))} 这样就是正常的输出了。 123456789101112131415var name = &quot;Window&quot;;var object = { name: &quot;Object&quot;, f: function () { return function () { return this.name; }; }};alert(object.f()()); 答案是Window。 object.getNameFunc()()可以分开两部分来看。 object.f()得到了一个这样的函数 123function() { return this.name} object.f()()相当于执行上面那个函数，也就是普通函数调用方式，this指向全局环境，this指向搞不清楚的同学可以看看我之前发的Javavscript基础——this指向 所以this.name也就是var name = &quot;Window&quot; 还是那道题，不过我们把this保存一下，变成下面这种形式 12345678910111213141516var name = &quot;Window&quot;;var object = { name: &quot;Object&quot;, f: function () { var that = this; return function () { return that.name; }; }};alert(object.f()()); 答案是Object。 object.f()中调用时这个this指向object，当用变量保存时，这个that相当于object object.f()()调用时，由于that相当于object，所以that.name就是object中的Object 总结 闭包可以在外部访问函数内部的变量 闭包可以保留现场 结尾来道面试题给大家看看吧 123456const buttons = document.querySelectorAll('.btn');for(var i = 0; i &lt; buttons.length; i++) { buttons[i].onclick = function() { console.log(i); }} 以上例子显示什么?如果需要正常显示需要怎么修改?","link":"/2019/10/14/2019-10-14-js-Closure.html"},{"title":"聊一聊valueOf和toString","text":"valueOf和toString是Object.prototype的方法。一般很少直接调用，但是在使用对象参与运算的时候就会调用这两个方法了。我想大部分人都存在以下疑问： valueOf和toString哪个优先级较高? 是不是所有场景都会调用valueOf和toString 概念解释 valueOf: 返回对象的原始值表示 toString: 返回对象的字符串表示 在介绍下面的内容之前先了解一下转换规则，下面的内容解释都是基于这个规则表来的： valueOf转换规则valueOf是Object.prototype的方法，由Object来的对象都会有该方法，但是很多内置对象会重写这个方法，以适合实际需要。 说到原始值就必须说到原始类型，JS规范中 原始类型 如下： Boolean Null Undefined Number String 非原始值(也就是对象)重写规则如下： 对象 valueOf返回值 Array 数组本身 Boolean 布尔值 Date 返回毫秒形式的时间戳 Function 函数本身 Number 数字值 Object 对象本身 String 字符串值 以下规则是经过验证的，如果对验证过程不关心，可以只看转换规则。 建议看一下验证过程，这样可以加深理解 对象转换为布尔值 直接转换为true（包装类型也一样），不调用valueOf和toString 对象转换为数字在预期会将对象用作数字使用时，比如参与算术运算等等操作，对象转换为数字会依次调用valueOf和toString方法，具体规则如下： 如果对象具有valueOf方法且返回原始值(string、number、boolean、undefined、null)，则将该原始值转换为数字(转换失败会返回NaN)，并返回这个数字 如果对象具有toString方法且返回原始值(string、number、boolean、undefined、null)，则将该原始值转换为数字(转换失败会返回NaN)，并返回这个数字 转换失败，抛出TypeError 对象转换为字符串 如果对象具有toString方法且返回原始值(string、number、boolean、undefined、null)，则将该原始值转换为字符串，并返回该字符串 如果对象具有valueOf方法且返回原始值(string、number、boolean、undefined、null)，则将该原始值转换为字符串，并返回该字符串 转换失败，抛出TypeError toString转换规则 对象 toString返回值 Array 以逗号分割的字符串，如[1,2]的toString返回值为”1,2” Boolean “True” Date 可读的时间字符串，如”Tue Oct 15 2019 12:20:56 GMT+0800 (中国标准时间)” Function 声明函数的JS源代码字符串 Number “数字值” Object “[object Object]” String “字符串” 验证对象到原始值的转换光看valueOf和toString没啥东西可说，日常开发中也很少直接调用，但是当我们将对象当做原始值来使用时会发生转换，而且转换过程还略微有点迷糊。 对象转换为Boolean为了能够直观的看到JS内部的转换过程，我把valueOf和toString都简单重写了，加了日志。 1234567891011121314151617181920212223// 保存原始的valueOfvar valueOf = Object.prototype.valueOf;var toString = Object.prototype.toString;// 添加valueOf日志Object.prototype.valueOf = function () { console.log('valueOf'); return valueOf.call(this);};// 添加toString日志Object.prototype.toString = function () { console.log('toString'); return toString.call(this);};var a = {};var b = new Boolean(false);if (a) { console.log(1);}if(b) { console.log(2);} 以上例子的输出如下： 1212 未调用valueOf和toString，符合[对象到布尔值]的转换规则 对象转换为Number例子112345678910111213141516// 保存原始的valueOfvar valueOf = Object.prototype.valueOf;var toString = Object.prototype.toString;// 添加valueOf日志Object.prototype.valueOf = function() { console.log('valueOf'); return valueOf.call(this);};// 添加toString日志Object.prototype.toString = function() { console.log('toString'); return toString.call(this);};var a = {};console.log(++a); 输出如下： 123valueOftoStringNaN 分析 valueOf方法返回的是对象本身，不是原始值，继续执行 toString方法返回的是”[object Object]”，是原始值(字符串)，将字符串转换为数字NaN 例子212345678910111213141516// 保存原始的valueOfvar valueOf = Object.prototype.valueOf;var toString = Object.prototype.toString;// 添加valueOf日志Object.prototype.valueOf = function () { console.log('valueOf'); return &quot;1&quot;; // 强制返回原始值};// 添加toString日志Object.prototype.toString = function () { console.log('toString'); return toString.call(this);};var a = {};console.log(++a); 输出如下： 12valueOf2 分析 valueOf返回原始值(字符串)，直接将该字符串转换为数字，得到1 对象转换为字符串在预期会将对象用作字符串时，比如一个字符串拼接了字符串，传入了一个对象，此时会发生转换。 12345678910111213141516// 保存原始的valueOfvar valueOf = Object.prototype.valueOf;var toString = Object.prototype.toString;// 添加valueOf日志Object.prototype.valueOf = function () { console.log('valueOf'); return valueOf.call(this);};// 添加toString日志Object.prototype.toString = function () { console.log('toString'); return toString.call(this);};var a = {};alert(a); 输出如下： 12toString// 弹出[object Object] 分析 调用toString方法，返回了字符串”[object Object]”，对象最终转换为该字符串 例子212345678910111213141516// 保存原始的valueOfvar valueOf = Object.prototype.valueOf;var toString = Object.prototype.toString;// 添加valueOf日志Object.prototype.valueOf = function () { console.log('valueOf'); return valueOf.call(this);};// 添加toString日志Object.prototype.toString = function () { console.log('toString'); return this;};var a = {};alert(a); 输出如下： 1234toStringvalueOfUncaught TypeError: Cannot convert object to primitive value at 1.js:16 分析 调用toString方法，返回的不是原始值，继续执行 调用valueOf方法，返回的不是原始值，继续执行 抛出TypeError ##【番外】使用加号运算符连接字符串和对象时的处理 在测试对象到字符串转换时发现如下代码的表现和预期并不一致： 12345678910111213141516// 保存原始的valueOfvar valueOf = Object.prototype.valueOf;var toString = Object.prototype.toString;// 添加valueOf日志Object.prototype.valueOf = function () { console.log('valueOf'); return valueOf.call(this);};// 添加toString日志Object.prototype.toString = function () { console.log('toString'); return toString.call(this);};console.log(&quot;a&quot; + {}); 输出如下： 123valueOftoStringa[object Object] 疑问&quot;a&quot;+ {} 应该是预期把{}当做字符串使用，应该先调用toString方法的，实际情况却不是这样。 结论通过查找资料得到的结论如下： 如果有一个是对象，则遵循对象对原始值的转换过程(Date对象直接调用toString完成转换，其他对象通过valueOf转化，如果转换不成功则调用toString) 如果两个都是对象，两个对象都遵循步骤1转换到字符串 两个数字，进行算数运算 两个字符串，直接拼接 一个字符串一个数字，直接拼接为字符串 面试题12345678var a = {};var b = {};var c = {};c[a] = 1;c[b] = 2;console.log(c[a]);console.log(c[b]); 题解由于对象的key是字符串，所以c[a]和c[b]中的a和b会执行[对象到字符串]的转换。 根据转换规则, a和b都转换为了[object Object]，所以c[a]和c[b]操作的是同一个键。 答案是输出两个2，c对象的最终结构如下： 123{ '[object Object]':2}","link":"/2019/10/15/2019-10-15-valueof-and-tostring.html"},{"title":"不只是块级作用域，你不知道的let和const","text":"ES6新增了两个重要的关键字let和const，相信大家都不陌生，但是包括我在内，在系统学习ES6之前也只使用到了【不存在变量提升】这个特性。 let声明一个块级作用域的本地变量 const语句声明一个块级作用域的本地常量，不可以重新赋值 支持块级作用域var定义的变量会提升到整个函数作用域内，let/const则支持块级作用域。 块级作用域: 由{}包裹的作用域（函数那种{}不算） 来看一个var的例子: 1234{ var a = 1;}console.log(a); 此时输出1，因为var没有块级作用域。 来看一个let的例子(const效果一样): 1234{ let a = 1;}console.log(a); 此时会报错ReferenceError，因为let/const支持块级作用域，所以let定义的a只在{}可以访问 不存在变量提升与var不同的是，let/const声明的变量不存在变量提升，也就是说{}对于let/const是有效的。 来看一个var的例子: 12console.log(a);var a = 1; 此时会输出undefined，因为var声明的变量会提升到作用域顶部（只提升声明，不提升赋值） 来看一个let的例子(const效果也一样): 123console.log(a);let a = 1; 此时会报错ReferenceError，因为let不存在变量提升 同一作用域内不可以重复声明同一作用域内let/const不可以重复声明,var可以。 来看一个var的例子: 123var a = 1;var a = 2;console.log(a); 此时会输出2，var是支持重复声明的，后面声明的值会覆盖前面声明的值。 来看一个let的例子(const效果也一样): 123let a = 1;let a = 2;console.log(a); 此时会报错SyntaxError，因为同一作用域内let/const不可以重复声明。 再来看一个不同作用域的例子： 12345let a = 1;{ let a = 2;}console.log(a); 此时输出1，因为两者作用域不同 暂存死区**暂存死区TDZ(Temporal Dead Zone)**是ES6中对作用域新的语义。 通过let/const定义的变量直到执行他们的初始化代码时才被初始化。在初始化之前访问该变量会导致ReferenceError。该变量处于一个自作用域顶部到初始化代码之间的“暂存死区”中。 来看以下例子： 1234567function do_something() { console.log(bar); // undefined console.log(foo); // ReferenceError var bar = 1; let foo = 2;}do_something(); var定义的变量声明会提升到作用域顶部，所以bar是undefined，而let定义的变量从作用域开始到let foo=2这中间都无法访问，访问会报错ReferenceError 暂存死区与typeoftypeof检测var定义的变量或者检测不存在的变量时会返回undefined，如果检测暂存死区内的变量，会报错ReferenceError. 12345console.log(typeof foo); // undefinedconsole.log(typeof bar); // ReferenceErrorconsole.log(typeof bar2); // undefinedlet bar = 1;var bar2 = 2; 也就是说typeof去检测未初始化的let变量时会报错，var或者未声明的变量不会报错 面试题1234567function test(){ var foo = 33; { let foo = (foo + 55); }}test(); 以上函数执行结果是什么?为什么? 报错 {}内有let定义的foo，所以存在暂存死区，(foo + 55)这个表达式是在let foo之前执行的(赋值时先执行等号右边的，执行完毕把结果赋给等号左边)，表达式执行的时候还没有初始化foo，所以报错ReferenceError 总结 let/const支持函数作用域和块级作用域,var只有函数作用域 let/const不存在变量提升，var存在变量提升 let/const同一作用域内不可以重复声明，var可以重复声明 let/const存在暂存死区，var不存在 面试题1234567let b = 1;function test4() { console.log(b); let b = 2;}test4()","link":"/2019/10/22/2019-10-22-let-and-const.html"},{"title":"深入浅出ES6的Symbol类型","text":"本文内容 JS基本数据类型种类 Symbol的主要用法, 全局Symbol的使用与检测 Symbol与其他基本类型转换时的规则 ES6引入了一种新的原始数据类型，表示独一无二的值，最大的用处是作为对象属性的唯一标识符。 至此，Javascript拥有6种基本数据类型和一种复杂数据类型。 数据类型基本类型 string number boolean undefined null symbol 复杂类型 object 用法基本语法1Symbol([description]) description 可选的描述，一般用在调试的时候作为区分，但是 不能用来访问Symbol。 该方法返回一个symbol值 1234567let s = Symbol('test');let s2 = Symbol('test');let s3 = new Symbol('test'); // TypeErrorconsole.log(s === s2); // falseconsole.log(typeof s); // symbolconsole.log(s.description); // test 每次调用Symbol()返回的值都是独一无二的，不管描述是否一致。 Symbol不支持new调用 通过description属性可以获取到传入Symbol的描述性字符串 全局单例的Symbol使用Symbol.for()可以创建全局单例的symbol值，语法如下： 1Symbol.for([name]) name 可选的描述，建议传入，否则name会作为undefined传入 类似于单例模式，执行环境(一般是浏览器)内部维护了一个全局Symbol注册表，记录name和Symbol(name)关系 尝试通过name在该注册表查找对应symbol值，如果找到，则返回这个symbol值 如果没找到，则使用Symbol(name)创建一个symbol值，并记录该symbol值与name的关联关系，之后返回该symbol 123456const name = Symbol('name');const name2 = Symbol.for('name');const name3 = Symbol.for('name');console.log(name === name2); // falseconsole.log(name2 === name3); // true 全局Symbol映射关系中name是作为字符串来使用的，结构类似下面的代码： 123const globalSymbols = { name: Symbol('name')}; 使用同样的字符串描述调用Symbol()和Symbol.for()获取到的symbol值不相等 查找是否为全局的单例Symbol使用Symbol.keyFor()可以检测给定的symbol值是否是全局单例的symbol(简单来说就是检测是否是Symbol.for()创建的)，语法如下： 1Symbol.keyFor(symbol) symbol 必传， 待检测的symbol值 如果给定的symbol值是通过Symbol.for()得到的，该方法返回传入symbol的字符串描述 如果给定的symbol值不是通过Symbol.for()得到的，该方法返回undefined 12345const s = Symbol('s1');const s2 = Symbol.for('s2');console.log(Symbol.keyFor(s)); // undefinedconsole.log(Symbol.keyFor(s2)); // s2 Symbol与JSON.stringify Symbol类型的属性不会参与JSON的序列化 123456const name = Symbol('name');const obj = { [name]: 'xialei', data: 1};console.log(JSON.stringify(obj)); // {&quot;data&quot;: 1} Symbol与for … in和for … of Symbol类型的属性不会出现在for … in和for … of循环中 123456789101112131415const name = Symbol('name');const user = { [name]: 'xialei', data: 1};for(let i in user) { console.log(i, user[i]);}// 上述循环输出 data 1for(let i of user) { console.log(i, user[i]);}// TypeError: user不是可迭代对象 Symbol与Object.keys()和Object.getOwnPropertyNames() Symbol类型的属性不会出现在Object.keys()和Object.getOwnPropertyNames()返回结果中 1234567const name = Symbol('name');const user = { [name]: 'xialei', data: 1};console.log(Object.keys(user)); // [&quot;data&quot;]console.log(Object.getOwnPropertyNames(user)); // [&quot;data&quot;] Symbol与Object.getOwnPropertySymbols() Symbol类型的属性会出现在Object.Object.getOwnPropertySymbols() 123456const name = Symbol('name');const user = { [name]: 'xialei', data: 1};console.log(Object.Object.getOwnPropertySymbols(user)); // [Symbol(name)] Symbol数据类型转换123456789const name = Symbol('1');console.log(name + 1); // TypeErrorconsole.log(Number(name)); // 创建包装对象console.log(name + '1'); // TypeErrorconsole.log(String(name)); // Symbol(1)console.log(!!name); // trueconsole.log(Boolean(name)); // true symbol值不能转换为数字 symbol不能直接转换为字符串，需要通过String包装才能转化 symbol可以直接转换为boolean，转化后为true 结尾 使用Symbol最大的注意事项应该是使用方括号语法去访问对应的属性，而不是字符串。 Symbol数据类型转换规范比较简单，大部分场景下也没用拿Symbol去做数据转换","link":"/2019/10/28/2019-10-28-symbol.html"},{"title":"Redis优化高并发下的秒杀性能","text":"本文内容 使用Redis优化高并发场景下的接口性能 数据库乐观锁 随着双11的临近，各种促销活动开始变得热门起来，比较主流的有秒杀、抢优惠券、拼团等等。 涉及到高并发争抢同一个资源的主要场景有秒杀和抢优惠券。 前提活动规则 奖品数量有限，比如100个 不限制参与用户数 每个用户只能参与1次秒杀 活动要求 不能多发，也不能少发，100个奖品要全部发出去 1个用户最多抢1个奖品 遵循先到先得原则，先来的用户有奖品 数据库实现悲观锁性能太差，本文不予讨论，讨论一下使用乐观锁解决高并发问题的优缺点。 数据库结构 ID Code UserId CreatedAt RewardAt 奖品ID 奖品码 用户ID 创建时间 中奖时间 未中奖时UserId为0，RewardAt为NULL 中奖时UserId为中奖用户ID，RewardAt为中奖时间 乐观锁实现乐观锁实际上并不存在真正的锁，乐观锁是利用数据的某个字段来做的，比如本文的例子就是以UserId来实现的。 实现流程如下： 查询UserId为0的奖品，如果未找到则提示无奖品 1SELECT * FROM envelope WHERE user_id=0 LIMIT 1 更新奖品的用户ID和中奖时间(假设奖品ID为1，中奖用户ID为100，当前时间为2019-10-29 12:00:00)，这里的user_id=0就是我们的乐观锁了。 1UPDATE envelope SET user_id=100, reward_at='2019-10-29 12:00:00' WHERE user_id=0 AND id=1 检测UPDATE语句的执行返回值，如果返回1证明中奖成功，否则证明该奖品被其他人抢了 为什么要添加乐观锁正常情况下获取奖品、然后把奖品更新给指定用户是没问题的。如果不添加user_id=0时，高并发场景下会出现下面的问题： 两个用户同时查询到了1个未中奖的奖品(发生并发问题) 将奖品的中奖用户更新为用户1，更新条件只有ID=奖品ID 上述SQL执行是成功的，影响行数也是1，此时接口会返回用户1中奖 接下来将中奖用户更新为用户2，更新条件也只有ID=奖品ID 由于是同一个奖品，已经发给用户1的奖品会重新发放给用户2，此时影响行数为1，接口返回用户2也中奖 所以该奖品的最终结果是发放给用户2 用户1就会过来投诉活动方了，因为抽奖接口返回用户1中奖，但他的奖品被抢了，此时活动方只能赔钱了 添加乐观锁之后的抽奖流程 更新用户1时的条件为id=红包ID AND user_id=0 ,由于此时红包未分配给任何人，用户1更新成功，接口返回用户1中奖 当更新用户2时更新条件为id=红包ID AND user_id=0，由于此时该红包已经分配给用户1了，所以该条件不会更新任何记录，接口返回用户2中奖 乐观锁优缺点优点 性能尚可，因为无锁 不会超发 缺点 通常不满足“先到先得”的活动规则，一旦发生并发，就会发生未中奖的情况，此时奖品库还有奖品 压测在MacBook Pro 2018上的压测表现如下(Golang实现的HTTP服务器,MySQL连接池大小100，Jmeter压测)： 500并发 500总请求数 平均响应时间331ms 发放成功数为31 吞吐量458.7/s Redis实现可以看到乐观锁的实现下争抢比太高，不是推荐的实现方法，下面通过Redis来优化这个秒杀业务。 Redis高性能的原因 单线程 省去了线程切换开销 基于内存的操作 虽然持久化操作涉及到硬盘访问，但是那是异步的，不会影响Redis的业务 使用了IO多路复用 实现流程 活动开始前将数据库中奖品的code写入Redis队列中 活动进行时使用lpop弹出队列中的元素 如果获取成功，则使用UPDATE语法发放奖品 1UPDATE reward SET user_id=用户ID,reward_at=当前时间 WHERE code='奖品码' 如果获取失败，则当前无可用奖品，提示未中奖即可 使用Redis的情况下并发访问是通过Redis的lpop()来保证的，该方法是原子方法，可以保证并发情况下也是一个个弹出的。 压测在MacBook Pro 2018上的压测表现如下(Golang实现的HTTP服务器,MySQL连接池大小100，Redis连接池代销100，Jmeter压测)： 500并发 500总请求数 平均响应时间48ms 发放成功数100 吞吐量497.0/s 结论可以看到Redis的表现是稳定的，不会出现超发，且访问延迟少了8倍左右，吞吐量还没达到瓶颈，可以看出Redis对于高并发系统的性能提升是非常大的！接入成本也不算高，值得学习！ 实验代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139// main.gopackage mainimport ( &quot;fmt&quot; &quot;github.com/go-redis/redis&quot; _ &quot;github.com/go-sql-driver/mysql&quot; &quot;github.com/jinzhu/gorm&quot; &quot;log&quot; &quot;net/http&quot; &quot;strconv&quot; &quot;time&quot;)type Envelope struct { Id int `gorm:&quot;primary_key&quot;` Code string UserId int CreatedAt time.Time RewardAt *time.Time}func (Envelope) TableName() string { return &quot;envelope&quot;}func (p *Envelope) BeforeCreate() error { p.CreatedAt = time.Now() return nil}const ( QueueEnvelope = &quot;envelope&quot; QueueUser = &quot;user&quot;)var ( db *gorm.DB redisClient *redis.Client)func init() { var err error db, err = gorm.Open(&quot;mysql&quot;, &quot;root:root@tcp(localhost:3306)/test?charset=utf8&amp;parseTime=True&amp;loc=Local&quot;) if err != nil { log.Fatal(err) } if err = db.DB().Ping(); err != nil { log.Fatal(err) } db.DB().SetMaxOpenConns(100) fmt.Println(&quot;database connected. pool size 10&quot;)}func init() { redisClient = redis.NewClient(&amp;redis.Options{ Addr: &quot;localhost:6379&quot;, DB: 0, PoolSize: 100, }) if _, err := redisClient.Ping().Result(); err != nil { log.Fatal(err) } fmt.Println(&quot;redis connected. pool size 100&quot;)}// 读取Code写入Queuefunc init() { envelopes := make([]Envelope, 0, 100) if err := db.Debug().Where(&quot;user_id=0&quot;).Limit(100).Find(&amp;envelopes).Error; err != nil { log.Fatal(err) } if len(envelopes) != 100 { log.Fatal(&quot;不足100个奖品&quot;) } for i := range envelopes { if err := redisClient.LPush(QueueEnvelope, envelopes[i].Code).Err(); err != nil { log.Fatal(err) } } fmt.Println(&quot;load 100 envelopes&quot;)}func main() { http.HandleFunc(&quot;/envelope&quot;, func(w http.ResponseWriter, r *http.Request) { uid := r.Header.Get(&quot;x-user-id&quot;) if uid == &quot;&quot; { w.WriteHeader(401) _, _ = fmt.Fprint(w, &quot;UnAuthorized&quot;) return } uidValue, err := strconv.Atoi(uid) if err != nil { w.WriteHeader(400) _, _ = fmt.Fprint(w, &quot;Bad Request&quot;) return } // 检测用户是否抢过了 if result, err := redisClient.HIncrBy(QueueUser, uid, 1).Result(); err != nil || result != 1 { w.WriteHeader(429) _, _ = fmt.Fprint(w, &quot;Too Many Request&quot;) return } // 检测是否在队列中 code, err := redisClient.LPop(QueueEnvelope).Result() if err != nil { w.WriteHeader(200) _, _ = fmt.Fprint(w, &quot;No Envelope&quot;) return } // 发放红包 envelope := &amp;Envelope{} err = db.Where(&quot;code=?&quot;, code).Take(&amp;envelope).Error if err == gorm.ErrRecordNotFound { w.WriteHeader(200) _, _ = fmt.Fprint(w, &quot;No Envelope&quot;) return } if err != nil { w.WriteHeader(500) _, _ = fmt.Fprint(w, err) return } now := time.Now() envelope.UserId = uidValue envelope.RewardAt = &amp;now rowsAffected := db.Where(&quot;user_id=0&quot;).Save(&amp;envelope).RowsAffected // 添加user_id=0来验证Redis是否真的解决争抢问题 if rowsAffected == 0 { fmt.Printf(&quot;发生争抢. id=%d\\n&quot;, envelope.Id) w.WriteHeader(500) _, _ = fmt.Fprintf(w, &quot;发生争抢. id=%d\\n&quot;, envelope.Id) return } _, _ = fmt.Fprint(w, envelope.Code) }) fmt.Println(&quot;listen on 8080&quot;) fmt.Println(http.ListenAndServe(&quot;:8080&quot;, nil))}","link":"/2019/10/29/2019-10-29-redis-high-concurrent.html"},{"title":"ES6的Map类型","text":"本文内容 Map的基本使用 Map支持的数据类型 Map的迭代 Map与其他对象的转化 在Map出现之前，要实现类似需求，只能使用Object，但是Object还是存在一些问题的。 如果使用Object作为key存储在{}中，key最终是当做[object Object]来使用的 Object的keys是无序的 无法安全遍历Object 无法直接获取Object大小 Map 对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。 基本操作1new Map([iterator]) iterator 可以是一个数组或者其他iterator对象，其元素为键值对(如['key', 'value'])。 null或undefined不会生效，返回一个空的Map 非iterator会抛出错误 TypeError: object is not iterable 1234567891011121314const map = new Map();// Createmap.set('name','xialei');map.set('site', 'https://www.ddhigh.com');// Updatemap.set('name', 'xialeistudio');// Readmap.get('name');// Deletemap.delete('name');// 清空map.clear();// map大小console.log(map.size); 数据类型测试JS中基本数据类型有string、number、boolean、null、undefined、symbol，复杂数据类型有object(包括object,array,function等)，还有个特殊的NaN(typeof结果是number)，分别对这些类型进行测试 1234567891011121314151617181920212223242526272829303132333435const map = new Map();const sKey = 'key', nKey = 1, bKey = true, nullKey = null, uKey = undefined, symbolKey = Symbol(&quot;key&quot;), oKey = {}, ooKey = oKey, aKey = [], fKey = function () { }, nanKey = NaN;map.set(sKey, &quot;string&quot;) .set(nKey, &quot;number&quot;) .set(bKey, &quot;boolean&quot;) .set(nullKey, &quot;null&quot;) .set(uKey, &quot;undefined&quot;) .set(symbolKey, &quot;symbol&quot;) .set(oKey, &quot;object&quot;) .set(aKey, &quot;array&quot;) .set(fKey, &quot;function&quot;) .set(nanKey, &quot;NaN&quot;);console.log(map);console.log(map.get(sKey) === &quot;string&quot;, map.get(&quot;key&quot;) === &quot;string&quot;);console.log(map.get(nKey) === &quot;number&quot;, map.get(1) === &quot;number&quot;);console.log(map.get(bKey) === &quot;boolean&quot;, map.get(true) === &quot;boolean&quot;);console.log(map.get(nullKey) === &quot;null&quot;, map.get(null) === &quot;null&quot;);console.log(map.get(uKey) === &quot;undefined&quot;, map.get(undefined) === &quot;undefined&quot;);console.log(map.get(symbolKey) === &quot;symbol&quot;);console.log(map.get(oKey) === &quot;object&quot;, map.get({}) === &quot;object&quot;, map.get(oKey) === map.get(ooKey));console.log(map.get(aKey) === &quot;array&quot;, map.get([]) === &quot;array&quot;);console.log(map.get(fKey) === &quot;function&quot;, map.get(function () { }) === &quot;function&quot;);console.log(map.get(nanKey) === &quot;NaN&quot;, map.get(NaN) === &quot;NaN&quot;); 输出如下 12345678910111213141516171819202122Map { 'key' =&gt; 'string', 1 =&gt; 'number', true =&gt; 'boolean', null =&gt; 'null', undefined =&gt; 'undefined', Symbol(key) =&gt; 'symbol', {} =&gt; 'object', [] =&gt; 'array', [Function: fKey] =&gt; 'function', NaN =&gt; 'NaN'}true truetrue truetrue truetrue truetrue truetruetrue false truetrue falsetrue falsetrue true 结论 string/number/boolean/null/undefined/NaN 按值存储，值一致即可访问 symbol必须是同一个Symbol才能访问，详见深入浅出ES6的Symbol类型 object/array/function等Object类型按照引用访问，必须是同一个引用才可以访问 Map是有序的，按照插入顺序 Map.set方法支持链式操作 Map的迭代for…of同时迭代键值 12345678910111213141516// 普通版本const map = new Map();map.set(&quot;1&quot;, 1);map.set(&quot;2&quot;, 2);for (const [k, v] of map) { console.log(k, v);}// 迭代器版本const map = new Map();map.set(&quot;1&quot;, 1);map.set(&quot;2&quot;, 2);for (const [k, v] of map.entries()) { console.log(k, v);} 迭代键 12345678910111213141516// 普通版本const map = new Map();map.set(&quot;1&quot;, 1);map.set(&quot;2&quot;, 2);for (const k of map.keys()) { console.log(k, map.get(k));}// 迭代器版本const map = new Map();map.set(&quot;1&quot;, 1);map.set(&quot;2&quot;, 2);for (const [k] of map.entries()) { // 解构赋值 console.log(k, map.get(k));} 迭代值 12345678910111213141516// 普通版本const map = new Map();map.set(&quot;1&quot;, 1);map.set(&quot;2&quot;, 2);for (const v of map.values()) { console.log(v);}// 迭代器版本const map = new Map();map.set(&quot;1&quot;, 1);map.set(&quot;2&quot;, 2);for (const [,v] of map.entries()) { console.log(v);} forEach() forEach方法的顺序是value, key，不是key, value! 1234567const map = new Map();map.set(&quot;1&quot;, 1);map.set(&quot;2&quot;, 2);map.forEach((value, key) =&gt; { console.log(value, key);}); Map与其他类型的转换Map与Object123456const obj = { name: 'xialei', site: 'https://www.ddhigh.com'};const map = new Map(obj);console.log(map); 执行报错TypeError: object is not iterable，因为Object不是可迭代对象。 可迭代对象：ES6新出的语法，对象或对象的原型链实现了Symbol.iterator方法，关于迭代器的内容将在下一篇文章中详细介绍 我们给Object.prototype添加属性方法来支持迭代： warning: 正式代码请谨慎修改原型链! 12345678910111213141516171819202122const obj = { name: 'xialei', site: 'https://www.ddhigh.com'};Object.prototype[Symbol.iterator] = function () { // Symbol.iterator可以理解为全局唯一的标识 const keys = Object.keys(this); let keyIndex = 0; return { next() { if (keyIndex &lt; keys.length) { const key = keys[keyIndex++]; return { value: [key, obj[key]] }; // 迭代值 } return { done: true }; // 迭代结束 } }};const map = new Map(obj);console.log(map); Map与数组 只支持[[key, value]]这种二维数组。二维数组的每一个元素包含key和value两个子元素 1const map = new Map([['name', 'xialeistudio'], ['site', 'https://www.ddhigh.com']]); Map与Map 由于Map是可迭代对象，因此可以作为参数传给Map构造函数 两个Map的元素是一样的，不是Map不相等，因为不是同一个对象 1234const map = new Map([['name', 'xialeistudio'], ['site', 'https://www.ddhigh.com']]);const map2 = new Map(map);console.log(map === map2); // false Map的合并 多个Map可以合并，相同key会被覆盖，规则为后面的覆盖前面的 12345678910const map = new Map([ [1, 1], [2, 2]]);const map2 = new Map([ [1, 2]]);const map3 = new Map([...map, ...map2]);console.log(map3); // Map { 1 =&gt; 2, 2 =&gt; 2 } 总结Map的出现解决了传统object无法直接解决的问题，更好地向标准编程语言靠近(标准编程语言一般会提供Map集合)，使用的坑也比较少（比如没有object作为key时转换为[object Object]的问题）。","link":"/2019/10/30/2019-10-30-es6-map.html"},{"title":"我是如何发现我的文章被侵权以及如何得到侵权网站的联系方式的?","text":"本文内容 如何发现自己的文章被侵权 如何结合whois信息查询侵权网站的联系方式 声明：本文只做技术研究，请勿用于非法目的，如果恶意使用造成任何法律责任本人概不负责！ 发现侵权我的文章除了发布在博客之外，还会同步到思否平台。自己没事的时候会去看看百度统计，比较关注来源网站(也就是referer)，一般来说通过搜索引擎过来的流量我不太关注，私人网站过来的就比较关注了，昨天查看来源的时候看到了一个新网站。 可以看到这个 www.twblogs.net是一个普通网站，点进去发现这样一篇文章。 可以看到这篇文章的作者是xialeistudio(也就是我常用的网络用户名)，可我压根就没听说过这个网站，我意识到可能被爬虫爬取了。 点击作者进入到作者的文章页，发现我昨天下午刚发布没多久的文章就被爬了。 然后我去查看nginx的访问日志，没有发现异常访问，有个IP虽然是美国的，但是是Google的爬虫。这意味着文章不是直接爬取我的博客来的。 nginx的访问日志过滤使用shell命令即可做到，不过这不是本文的重点，此处略过 那就只剩下思否和掘金，通过文章中的公众号图片二维码，我发现了爬取的文章来源。 可以看到是通过思否爬取到的。 侵权结论 伪造用户名爬取了思否大量的文章，截止发文时大概爬了三四十篇文章 思否应该并不知道这件事，应该早期的文章都爬过来了（包括我在思否已经删除的文章） 获取侵权网站联系方式目前手头只有一个域名https://www.twblogs.net，先去站长工具的whois查询工具http://whois.chinaz.com/查询一下。 whois：用来查询域名注册信息的一种技术 通过查询并没有得到什么有效的信息。看来是whois做了保护处理。 不过没关系，目前得到了twblogs.net的域名提供商是Goddy，我们可以到域名提供商的网站看一下Whois信息 浏览器打开whois.godaddy.com输入www.twblogs.net就可以了，查询到的Whois信息如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960WHOIS 搜索结果Domain Name: twblogs.netRegistry Domain ID: 2330628228_DOMAIN_NET-VRSNRegistrar WHOIS Server: whois.godaddy.comRegistrar URL: http://www.godaddy.comUpdated Date: 2019-10-09T11:09:43ZCreation Date: 2018-11-08T16:30:46ZRegistrar Registration Expiration Date: 2021-11-08T16:30:46ZRegistrar: GoDaddy.com, LLCRegistrar IANA ID: 146Registrar Abuse Contact Email: abuse@godaddy.comRegistrar Abuse Contact Phone: +1.4806242505Domain Status: clientTransferProhibited http://www.icann.org/epp#clientTransferProhibitedDomain Status: clientUpdateProhibited http://www.icann.org/epp#clientUpdateProhibitedDomain Status: clientRenewProhibited http://www.icann.org/epp#clientRenewProhibitedDomain Status: clientDeleteProhibited http://www.icann.org/epp#clientDeleteProhibitedRegistry Registrant ID: Not Available From RegistryRegistrant Name: kiwi robertRegistrant Organization:Registrant Street: americanRegistrant City: austinRegistrant State/Province: AnhuiRegistrant Postal Code: 73344Registrant Country: CNRegistrant Phone: +86.15220288017Registrant Phone Ext:Registrant Fax:Registrant Fax Ext:Registrant Email: 898611548@qq.comRegistry Admin ID: Not Available From RegistryAdmin Name: kiwi robertAdmin Organization:Admin Street: americanAdmin City: austinAdmin State/Province: AnhuiAdmin Postal Code: 73344Admin Country: CNAdmin Phone: +86.15220288017Admin Phone Ext:Admin Fax:Admin Fax Ext:Admin Email: 898611548@qq.comRegistry Tech ID: Not Available From RegistryTech Name: kiwi robertTech Organization:Tech Street: americanTech City: austinTech State/Province: AnhuiTech Postal Code: 73344Tech Country: CNTech Phone: +86.15220288017Tech Phone Ext:Tech Fax:Tech Fax Ext:Tech Email: 898611548@qq.comName Server: JOBS.NS.CLOUDFLARE.COMName Server: LANA.NS.CLOUDFLARE.COMDNSSEC: unsignedURL of the ICANN WHOIS Data Problem Reporting System: http://wdprs.internic.net/&gt;&gt;&gt; Last update of WHOIS database: 2019-10-30T03:00:00Z &lt;&lt;&lt; 可以看到域名注册者有点意思，手机号是深圳的,省份是安徽的，估计是安徽人到深圳上班。 拿到联系信息之后就通知思否小姐姐去发律师函了 总结 通过百度统计发现来源网站 通过访问来源网站发现内容侵权 check博客服务器的nginx访问日志，看看有无明显异常的访问 通过文章中的图片发现文章是通过思否爬取的 检测侵权网站的whois信息，如果做了保护就去域名提供商获取whois 获取到联系方式之后可以联系思否小姐姐帮你处理，给思否点个赞，内容这块的响应速度很快 大家发现侵权不要不作为，可以处理的方法如下： 向国家新闻出版广电总局举报http://www.sapprft.gov.cn/sapprft/channels/6979.shtml 联系平台（思否，知乎，掘金等等），平台会帮你发律师函啥的，毕竟内容使他们的根基 《中华人民共和国刑法》节选如下： 第二百一十七条 【侵犯著作权罪】以营利为目的，有下列侵犯著作权情形之一，违法所得数额较大或者有其他严重情节的，处三年以下有期徒刑或者拘役，并处或者单处罚金;违法所得数额巨大或者有其他特别严重情节的，处三年以上七年以下有期徒刑，并处罚金： (一)未经著作权人许可，复制发行其文字作品、音乐、电影、电视、录像作品、计算机软件及其他作品的; (二)出版他人享有专有出版权的图书的; (三)未经录音录像制作者许可，复制发行其制作的录音录像的; (四)制作、出售假冒他人署名的美术作品的。","link":"/2019/10/30/2019-10-30-twblog.html"},{"title":"ES6的Set类型","text":"本文内容 Set的基本使用 常用用法 Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。 基本使用1new Set([iterator]) iterator 与Map类似，Set接收一个可选的Iterator对象，所有元素将按照顺序不重复地添加到Set中。传递null或者undefined将返回一个空Set 123456789const set = new Set();// 添加元素set.add(1);// 移除元素set.delete(1);// 检测元素是否存在set.has(1);// 清空Setset.clear(); 数据类型的唯一性判定1234567891011121314const set = new Set(undefined);set. add(&quot;string&quot;).add(&quot;string&quot;). add(1).add(1). add(true).add(true). add(null).add(null). add(undefined).add(undefined) .add(NaN).add(NaN) .add({}).add({}) .add([]).add([]) .add(function () { }).add(function () { });console.log(set); 输出如下： 1234567891011121314Set { 'string', 1, true, null, undefined, NaN, {}, {}, [], [], [Function], [Function]} 结论 string/number/boolean/null/undefined/NaN是使用值判重 NaN!==NaN，但是Set也只会存一份，所以值判定应该不完全是用===做的 object/array/function等object类型使用引用判重 Set的迭代for…of 由于Set实现了Symol.iteator方法，所以可以使用for…of迭代 1234567const set = new Set(undefined);set.add(&quot;string&quot;).add(&quot;string&quot;);for (const v of set.entries()) { console.log(v);} forEach 1234567const set = new Set(undefined);set.add(&quot;string&quot;).add(&quot;string&quot;);set.forEach(function(value) { console.log(value);}); 使用场景Set和数组相互转化 123const array = [1,2];const set = new Set(array); // 数组转化为setconst newArray = [...set]; // set转化为数组 去除字符串重复字符 12345const s = 'aabbcc';const set = new Set(s);const newString = [...set].join('');console.log(newString); // abc 数组去重 123const list = [1,2,3,1,2,3];const set = new Set(list);console.log([...set]); // [1,2,3] 并集 123const set = new Set([1,2,3]);const set2 = new Set([1,2,3,4]);const set3 = new Set([...set], [...set2]); // [1, 2, 3] 交集 123const set = new Set([1,2,3]);const set2 = new Set([1,2,3,4]);const set3 = new Set([...set].filter(item =&gt; set2.has(item))); // [1, 2, 3] 差集 123const set = new Set([1,2,3]);const set2 = new Set([1,2,3,4]);const set3 = new Set([...set2].filter(item =&gt; !set.has(item))); // [4], 注意set2和set的顺序 总结在需要唯一性的场景中，Set使用起来比数组要方便许多，比如添加标签，这个肯定是不重复的，用Set去实现就可以省去重复判断之类的操作，可以专注业务逻辑。","link":"/2019/10/31/2019-10-31-es6-set.html"},{"title":"深入浅出ES6的标准内置对象Proxy","text":"Proxy是ES6规范定义的标准内置对象，可以对目标对象的读取、函数调用等操作进行拦截。一般来说，通过Proxy可以让目标对象“可控”，比如是否能调用对象的某个方法，能否往对象添加属性等等。 123456789101112const originalObj = { name: 'xialei'};const publicObj = new Proxy(originalObj, { set(target, prop, value) { // 将属性值转化为大写 target[prop] = value.toString().toUpperCase(); }});publicObj.name = 'xialei';console.log(publicObj.name); // XIALEI 从上例可以看出Proxy不需要更改目标对象(也就是originalObj)，就可以对originalObj的行为进行拦截。 语法 let obj = new Proxy(target, handler); target Object 目标对象。可以是任何类型的对象，甚至包括原生对象（比如数组，函数，另一个Proxy对象） handler Object 代理行为对象。访问目标对象时会自动触发该handler的对应属性。 和大多数开发者一样，刚开始学习Proxy的时候，这个handler不知道是个什么东西，什么时候能触发。 先看一个简单的例子，看看handler到底是什么东西。假设我们开发一个游戏脚本，由于内存修改器的盛行，我们需要对内存中的数据进行安全处理，但是不能影响外部使用，我们使用Proxy完成这个功能。 123456789101112131415const gameObj = { hp: 0 }; const publicGameObj = new Proxy(gameObj, { get(target, prop) { return target[prop]/2; }, set(target, prop, value) { target[prop] = value*2; } }); publicGameObj.hp = 10000; console.log(publicGameObj.hp, gameObj); // 10000 {hp: 20000} gameObj是我们在内存中真实存储数据的地方，可以看到HP是20000，但是publicGameObj.hp是10000，外部使用publicGameObj.hp即可(比如UI层展示HP为10000); 例程handler使用到的属性 get publicGameObj.hp进行了读取操作，因此会自动触发handler的get方法 set publicGameObj.hp=10000进行了赋值操作，因此为自动触发handler的set方法 handler对象handler对象是Proxy的核心基础，所有对目标对象的操作都需要通过handler来处理，虽然内容有点多，但是常用的不多。 说明 目标对象 被代理的对象。外部不能直接访问(当然语法上是可以访问的，你都用上Proxy了，还访问他干嘛?) 代理对象 new Proxy的返回值。外部直接访问。目标对象会作为handler对应函数的参数传入 带*号的是常用属性 所有访问都是对代理对象访问才会触发，直接访问目标对象不会触发(代理对象压根没参与进来，如果触发那一定是出bug了) handler.getPrototypeOf(target)说明：获取目标对象的原型 触发时机：Object.getPrototypeOf(代理对象) 参数： target Object 目标对象 返回值： Object 对象的原型 1234567891011const array = [];const myArray = new Proxy(array, { getPrototypeOf(target) { console.log('读取对象原型'); return Object.getPrototypeOf(array); }});console.log(Object.getPrototypeOf(myArray));// 输出// 读取对象原型// [] handler.setPrototypeOf(target, prototype)说明：设置对象的原型 触发时机：Object.setPrototypeOf(代理对象, 原型)参数： target Object 目标对象 prototype Object 原型对象或null 返回值： boolean 设置成功返回true，否则返回false(比如不让设置) 123456789const array = [];const myArray = new Proxy(array, { setPrototypeOf(target, prototype) { Object.setPrototypeOf(target, prototype); return true; }});Object.setPrototypeOf(myArray, Object.prototype);console.log(Object.getPrototypeOf(myArray)); // {} handler.isExtensible(target)说明：检测对象是否可扩展(个人理解：也就是能否添加属性、函数)触发时机：Object.isExtensible(代理对象)参数： target Object 目标对象 返回参数： boolean handler.preventExtensions(target)说明：设置目标对象为不可扩展触发时机：Object.preventExtensions(代理对象)参数： target Object 目标对象 返回值： boolean 设置目标对象不可扩展后返回true，不管是否设置目标对象不可扩展，返回false都会报错 123456789101112const obj = {};const p = new Proxy(obj, { preventExtensions(target) { Object.preventExtensions(target); return true; }});Object.preventExtensions(p);p.a = 1;console.log(p); // {} 目标对象不可扩展，所以a属性设置不进去 *handler.getOwnPropertyDescriptor(target, prop)说明：获取目标对象属性的描述符 触发时机：Object.getOwnPropertyDescriptor(代理对象) 参数： target Object 目标对象 prop &lt;string|Symbol|number&gt; 属性名 返回参数： Object 属性描述符 12345678910const obj = { a: 1};const p = new Proxy(obj, { getOwnPropertyDescriptor(target, prop) { return target[prop]; }});console.log(Object.getOwnPropertyDescriptor(obj, 'a')); // { value: 1, writable: true, enumerable: true, configurable: true } *handler.defineProperty(target,prop,properties)说明：在对象上定义属性(添加新属性或修改现有属性)触发时机：Object.defineProperty(代理对象，属性名，属性描述对象)参数： target Object 目标对象 prop string|number|Symbol 属性名 properties Object 属性描述对象 返回值： boolean 定义成功返回true，定义失败或不允许定义返回false 123456789101112131415161718192021const obj = { name: 'xialei', name2: 'xx'};const p = new Proxy(obj, { defineProperty(target, prop, properties) { if (prop === 'name') { Object.defineProperty(target, prop, properties); return true; } return false; }});Object.defineProperty(p, 'name', { value: 'aaa',});Object.defineProperty(p, 'name2', { // TypeError value: 'aaa',}); *handler.has(target, prop)说明：判断对象是否有指定属性触发时机：prop in 代理对象参数： target Object 目标对象 prop string|number|Symbol 属性名 返回值： boolean *handler.get(target, prop, receiver)说明: 属性读取器触发时机：读取代理对象的属性时触发 参数： target Object 目标对象 prop string|number|Symbol 属性名 receiver Proxy 代理对象或者原型链上的代理对象 返回值： 任何值 12345678910111213const obj = { name: 'xialei'};const p = new Proxy(obj, { get(target, prop) { if(prop in target) { return target[prop].toUpperCase(); } return undefined; }});console.log(p.name); // XIALEI *handler.set(target, prop, value, receiver)说明：属性写入访问器触发时机：对代理对象的属性进行赋值时触发 参数： target Object 目标对象 prop string|number|Symbol 属性名 value any 属性值 receiver Proxy 代理对象或原型链上的代理对象 返回值： boolean 赋值成功返回true，否则返回false。严格模式下返回false会抛出TypeError *handler.deleteProperty(target, prop)说明：删除对象属性触发时机：对代理对象的属性进行delete时触发 参数： target Object 目标对象 prop string|number|Symbol 属性名 返回值： boolean 删除成功返回true，否则返回false。严格模式下返回false会抛出TypeError *handler.apply(target, thisArg, args)说明：拦截函数调用，被代理对象必须是函数触发时机： 直接调用函数 obj.xxx()或xxx() apply/call 参数： target Object 目标函数 thisArg Object this对象 args Array 参数列表 返回值： any 任何值 123456789101112function sum(a, b) { return a + b;}const absSum = new Proxy(sum, { apply(target, thisArg, args) { const value = target.apply(thisArg, args); return value &lt; 0 ? -value : value; }});console.log(absSum(-1, -2)); // 3，因为被拦截了 *handler.construct(target,args)说明：拦截构造过程触发时机：new 目标构造函数(…args) 参数： target Function 构造函数 args Array 构造函数的参数 返回值： Object 对象 1234567891011121314function Person(name) { this.name = name;}const P = new Proxy(Person, { construct(target, args, newTarget) { console.log(newTarget, newTarget === P, newTarget === Person); // [Function: Person] true false return new target(args[0].toUpperCase()); }});const p = new P('xialei');console.log(p); // Person { name: 'XIALEI' } 使用场景 保护目标对象(通过钩子方法进行拦截) 数据转换(上文有一个内存保护的例子) 数据验证(不符合规则的值不允许设置) 123456789101112131415161718192021const privateUser = { name: 'xialei', phone: '13888888888'};const user = new Proxy(privateUser, { set(target, prop, value) { if (prop === 'phone' &amp;&amp; !/^(\\+86)?1[\\d]{10}$/.test(value)) { return false; } target[prop] = value; return true; }});user.phone = '13666666666';console.log(user.phone); // 13666666666user.phone = '+8613777777777';console.log(user.phone); // +8613777777777user.phone = '1';console.log(user.phone); // +8613777777777 数据修正(也做数据标准化) 1234567891011121314151617const privateUser = { name: 'xialei', phone: '13888888888'};const user = new Proxy(privateUser, { set(target, prop, value) { if (prop === 'phone' &amp;&amp; !/^(\\+86)?1[\\d]{10}$/.test(value)) { return false; } target[prop] = value.replace('+86',''); return true; }});user.phone = '+8613666666666';console.log(user.phone); // 13666666666 添加实用方法 12345678910111213141516171819202122232425const list = [ { name: 'xialei', phone: '13888888888' }, { name: 'xialei1', phone: '13899999999' },];const mList = new Proxy(list, { get(target, prop) { if (prop in target) { return target[prop]; } for (const item of target) { if (item.name === prop) { return item; } } return undefined; }});const firstItem = mList[0];const itemXialei = mList[&quot;xialei&quot;];console.log(firstItem); // { name: 'xialei', phone: '13888888888' }console.log(itemXialei);// { name: 'xialei', phone: '13888888888' } 提供易用API 123456789101112131415161718192021// 本例对localStorage做了封装，可以像普通对象一样操作localStorage,而不需要调用方法const storage = new Proxy(localStorage, { get(target, prop) { return localStorage.getItem(prop); }, set(target, prop, value) { localStorage.setItem(prop, value); return true; }, deleteProperty(target, prop) { localStorage.removeItem(prop); }, has(target, prop) { return localStorage.getItem(prop) !== null; }});storage.aaa = '1';console.log(storage.aaa); // '1'delete storage.aaa;console.log(storage.aaa); // undefined 总结Proxy的语法虽然简单，但是可谓前途无量，比如开了一个Virtual Dom框架也是可以的。","link":"/2019/11/04/2019-11-04-es6-proxy.html"},{"title":"深入浅出ES6的迭代器","text":"迭代器是ES2015中新增的规范，与之相关的for…of也是ES2015新增的。 本文来深入研究一下迭代器是什么，以及迭代器能够干什么？ 或许你对for … of的执行还不了解，比如什么情况下可以使用for … of去遍历对象，什么情况下会报错等等，这篇文章应该能帮到你。 迭代器协议 for … of只能迭代满足【迭代器协议】的对象 可迭代对象的必须存在[Symbol.iterator]方法，该方法一个无参函数，返回迭代器协议的对象。 迭代器对象包含一个next()函数，该函数返回值有两种: 如果迭代未结束，返回如下 1234return { value: 'item', // item是本次迭代值，可以为任意对象 done: false} 如果迭代已结束，返回如下 123return { done: true} 下面是未提供迭代器的示例。 1234567const obj = { name: 'xialei', id: 1};for(let item of obj) { // TypeError: obj is not iterable } 下面是提供迭代器的示例。 123456789101112131415161718192021222324const obj = { name: 'xialei', id: 1, [Symbol.iterator]: function () { // 迭代器属性 const keys = Object.keys(this); // 读取对象键列表 let keyIndex = 0; // 遍历未知 const self = this; // 保存this，next中的function会有自己的this return { // 返回带有next()的对象 next: function () { if (keyIndex &lt; keys.length) { // 防止越界 const key = keys[keyIndex]; keyIndex++; // 移动到下一个位置 return { value: [key, self[key]], // 键值对数组 done: false } } return { // 遍历结束 done: true } } } }}; 通过给obj提供迭代器方法让obj也可以使用for…of遍历。 直接去理解迭代器概念比较困难，用一个简单的例子去简化理解是一件很容易的事情。 其他可迭代对象String,Array,Map,Set,TypedArray是所有内置的可迭代对象，他们的原型对象都有一个[Symbol.iterator]方法。 下面是两种方法迭代String对象的示例。 12345678910111213// for ... ofconst str = 'xialei';for(const char of str) { console.log(char);}// iteratorconst str = 'xialei';const iterator = str[Symbol.iterator](); // 返回一个{next:方法}对象let obj = null;do { obj = iterator.next(); // 返回的是对象，{value:任意对象,done:布尔型} console.log(obj.value);}while(!obj.done); 结尾迭代器协议虽然一般用的比较少，但是了解其原理是非常有必要的，这样才可以才需要的实现定义自己的迭代器来遍历对象。","link":"/2019/11/14/2019-11-13-es6-iterator.html"},{"title":"MySQL中的CHAR和VARCHAR到底支持多长?","text":"最近在研究MySQL的数据类型，我们知道，选择合适的数据类型和数据长度对MySQL的性能影响是不可忽视的，小字段意味着可以MySQL可以读取更多的记录，从而加快查询速度。 网上该问题的答案有很多版本，还是通过实践得出的结论比较靠谱。 先说结论(MySQL版本5.7.27) CHAR最大255字符，字符集对CHAR没有影响，CHAR()括号内填写最大字符数255 VARCHAR最大65535字节，字符集对VARCHAR有影响 UTF8字符集，每个字符大小3字节，所以65535/3 = 21845，最大支持21845字符，因此VARCHAR()括号中最大填写21845字符 GBK字符集，每个字符大小2字节，所以65535/2 = 32767.5，最大支持32767字符，因此VARCHAR()括号中最大填写32767字符 验证过程CHARUTF8字符集(1个字符占用3个字节) 12345CREATE TABLE `test`.`demo` ( `id` int(0) UNSIGNED NULL AUTO_INCREMENT, `title` char(256) NULL, PRIMARY KEY (`id`)) CHARACTER SET = utf8 COLLATE = utf8_general_ci; MySQL提示错误 11074 - Column length too big for column 'title' (max = 255); use BLOB or TEXT instead GBK字符集(1个字符占用2个字节) 12345CREATE TABLE `test`.`demo` ( `id` int(0) UNSIGNED NULL AUTO_INCREMENT, `title` char(256) NULL, PRIMARY KEY (`id`)) CHARACTER SET = gbk COLLATE = gbk_chinese_ci; MySQL提示错误 11074 - Column length too big for column 'title' (max = 255); use BLOB or TEXT instead 结论：CHAR最大长度和字符集没有关系，因此CHAR()括号内填写字符大小，最终数据的字节大小随着字符集不同而不同 VARCHARUTF8字符集(1个字符占用3个字节) 12345CREATE TABLE `test`.`demo` ( `id` int(0) UNSIGNED NULL AUTO_INCREMENT, `title` varchar(65535) NULL, PRIMARY KEY (`id`)) CHARACTER SET = utf8 COLLATE = utf8_general_ci; MySQL提示错误 11074 - Column length too big for column 'title' (max = 21845); use BLOB or TEXT instead MySQL提示的最大长度为21845，通过UTF8字符集的大小可知VARCHAR()括号中指的是字符大小。 UTF8MB4字符集(1个字符占用4个字节) 12345CREATE TABLE `test`.`demo` ( `id` int(0) UNSIGNED NULL AUTO_INCREMENT, `title` varchar(65535) NULL, PRIMARY KEY (`id`)) CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci; MySQL提示错误 11074 - Column length too big for column 'title' (max = 16383); use BLOB or TEXT instead MySQL提示的最大长度为16383，通过UTF8MB4字符集大小可知VARCHAR()括号中指的是字符大小。","link":"/2019/11/14/2019-11-14-mysql-char-varchar-max-length.html"},{"title":"Webpack4不求人系列(1)","text":"Webpack是一个现在Javascript应用程序的模块化打包器，在Webpack中JS/CSS/图片等资源都被视为JS模块，简化了编程。当Webpack构建时，会递归形成一个模块依赖关系图，然后将所有的模块打包为一个或多个bundle。 本文内容 简介 常用loader &amp;&amp; plugin 传统网站的webpack配置 简介要系统地学习Webpack，需要先了解Webpack的四个核心概念: 入口(entry) 输出(output) loader plugin webpack使用Node.js运行，因此所有的Node.js模块都可以使用，比如文件系统、路径等模块。 对Node.js基础不太了解的读者，可以参考我的Node.js系列 配置文件webpack.config.js的一般格式为: 12345678910111213141516171819202122232425262728293031const path = require('path'); // 导入Node.js的path模块module.exports = { mode: 'development', // 工作模式 entry: './src/index', // 入口点 output: { // 输出配置 path: path.resolve(__dirname, 'dist'), // 输出文件的目录 filename: 'scripts/[name].[hash:8].js', // 输出JS模块的配置 chunkFilename:'scripts/[name].[chunkhash:8].js', // 公共JS配置 publicPath:'/' // 资源路径前缀，一般会使用CDN地址，这样图片和CSS就会使用CDN的绝对URL }, module:{ rules: [ { test:/\\.(png|gif|jpg)$/, // 图片文件 use:[ { loader:'file-loader', // 使用file-loader加载 options:{ // file-loader使用的加载选项 name:'images/[name].[hash:8].[ext]' // 图片文件打包后的输出路径配置 } } ] } ] }, plugins:[ // 插件配置 new CleanWebpackPlugin() ]}; Webpack自己只管JS模块的输出，也就是output.filename是JS的配置，CSS、图片这些是通过loader来处理输出的 入口入口指明了Webpack从哪个模块开始进行构建，Webpack会分析入口模块依赖到的模块(直接或间接)，最终输出到一个被称为bundle的文件中。 使用entry来配置项目入口。 单一入口 最终只会生成1个js文件 123module.exports = { entry: './src/index',}; 多个入口 最终会根据入口数量生成对应的js文件 123456module.exports = { entry:{ home:'./src/home/index', // 首页JS about:'./src/about/index' // 关于页JS }}; 多个入口一般会在多页面应用中使用，比如传统的新闻网站。 输出输出指明了Webpack将bundle输出到哪个目录，以及这些bundle如何命名等，默认的目录为./dist。 12345678module.exports = { output:{ path:path.resolve(__dirname, 'dist'), // 输出路径 filename:'scripts/[name].[hash:8].js', // 输出JS模块的文件名规范 chunkFilename:'scripts/[name].[chunkhash:8].js', // 公共JS的配置 publicPath:'/', // 资源路径前缀，一般会使用CDN地址，这样图片和CSS就会使用CDN的绝对URL }}; path path是打包后bundle的输出目录，必须使用绝对路径。所有类型的模块(js/css/图片等)都会输出到该目录中，当然，我们可以通过配置输出模块的名称规则来输出到path下的子目录。比如上例中最终输出的JS目录如下： 123|----dist |---- scripts |---- home.aaaaaaaa.js filename 入口模块输出的命名规则，在Webpack中，只有js是亲儿子，可以直接被Webpack处理，其他类型的文件(css/images等)需要通过loader来进行转换。 filename的常用的命名如下: 1[name].[hash].js [name] 为定义入口模块的名称，比如定义了home的入口点，这里的name最终就是home [hash] 是模块内容的MD5值，一次打包过程中所有模块的hash值是相同的，由于浏览器会按照文件名缓存，因此每次打包都需要指定hash来改变文件名，从而清除缓存。 chunkFilename 非入口模块输出的命名规则，一般是代码中引入其他依赖，同时使用了optimization.splitChunks配置会抽取该类型的chunk hash Webpack中常见的hash有hash,contenthash,chunkhash，很容易弄混淆，这里说明一下。 hash 整个项目公用的hash值，不管修改项目的什么文件，该值都会变化 chunkhash 公共代码模块的hash值，只要不改该chunk下的代码，该值不会变化 contenthash 基于文件内容生成的hash，只要改了文件，对应的hash都会变化 publicPath 资源的路径前缀，打包之后的资源默认情况下都是相对路径，当更改了部署路径或者需要使用CDN地址时，该选项比较常用。 比如我们把本地编译过程中产生的所有资源都放到一个CDN路径中，可以这么定义： 1publicPath: 'https://static.ddhigh.com/blog/' 那么最终编译的js,css,image等路径都是绝对链接。 loaderloader用来在import时预处理文件，一般用来将非JS模块转换为JS能支持的模块，比如我们直接import一个css文件会提示错误，此时就需要loader做转换了。 比如我们使用loader来加载css文件。 12345678910module.exports = { module:{ rules:[ { test: /\\.(css)$/, use: ['css-loader'] } ] }}; 配置方式Webpack中有3种使用loader的方式： 配置式：在webpack.config.js根据文件类型进行配置，这是推荐的配置 内联：在代码中import时指明loader 命令行：通过cli命令行配置 配置式module.rules用来配置loader。test用来对加载的**文件名(包括目录)**进行正则匹配，只有当匹配时才会应用对应loader。 多个loader配置时从右向左进行应用 配置式Webpack的loader也有好几种形式，有些是为了兼容而添加的，主要使用的方式有以下3种。 12345678910111213141516171819202122232425module.exports = { module:{ rules:[ { test: /\\.less$/, loader:'css-loader!less-loader', // 多个loader中用感叹号分隔 }, { test:/\\.css/, use:['css-loader'],//数组形式 }, { test:/\\.(png|gif|jpg)$/, use:[ // loader传递参数时建议该方法 { loader: 'file-loader', options:{ // file-loader自己的参数，跟webpack无关 name: 'images/[name].[hash:8].js' } } ] } ] }}; 每个loader的options参数不一定相同，这个需要查看对应loader的官方文档。 Pluginloader一般用来做模块转换，而插件可以执行更多的任务，包括打包优化、压缩、文件拷贝等等。插件的功能非常强大，可以进行各种各样的任务。 下面是打包之前清空dist目录的插件配置示例。 123456const { CleanWebpackPlugin } = require('clean-webpack-plugin');module.exports = { plugins: [ new CleanWebpackPlugin(), ]}; 插件也可以传入选项，一般在实例化时进行传入。 1234new MiniCssPlugin({ filename: 'styles/[name].[contenthash:8].css', chunkFilename: 'styles/[name].[contenthash:8].css'}) 提取公共代码Webpack4中提取公共代码只需要配置optimization.splitChunks即可。 1234567891011121314151617optimization: { splitChunks: { cacheGroups: { vendor: { // 名为vendor的chunk name: &quot;vendor&quot;, test: /[\\\\/]node_modules[\\\\/]/, chunks: 'all', priority: 10 }, styles: { // 名为styles的chunk name: 'styles', test: /\\.css$/, chunks: 'all' } } }}, cacheGroups 缓存组 name chunk的名称 test 加载的模块符合该正则时被打包到该chunk chunks 模块的范围，有initial(初始模块),async(按需加载模块),all(全部模块) 上面的例子中将node_modules中的js打包为vendor，以css结尾的打包为styles 常用的loader和plugincss-loader 加载css文件 1234{ test:/\\.css$/ loader:['css-loader']} less-loader 加载less文件，一般需要配合css-loader 1234{ test:/\\.less$/, loader:['css-loader','less-loader']} file-loader 将文件拷贝到输出文件夹，并返回相对路径。一般常用在加载图片 1234567891011{ test:/\\.(png|gif|jpg)/, use:[ { loader:'file-loader', options:{ name:'images/[name].[hash:8].[ext]' } } ]} babel-loader 转换ES2015+代码到ES5 123456789101112{ test:/\\.js$/, exclude: /(node_modules|bower_components)/, // 排除指定的模块 use:[ { loader:'babel-loader', options:{ presets:['@babel/preset-env'] } } ]} ts-loader 转换Typescript到Javascript 1234{ test:/\\.ts/, loader:'ts-loader'} html-webpack-plugin 简化HTML的创建，该插件会自动将当前打包的资源(如JS、CSS)自动引用到HTML文件 123456const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = { plugins:[ new HtmlWebpackPlugin() ]}; clean-webpack-plugin 打包之前清理dist目录 123456const { CleanWebpackPlugin } = require('clean-webpack-plugin');module.exports = { plugins:[ new CleanWebpackPlugin() ]}; mini-css-extract-plugin 提取、压缩CSS，需要同时配置loader和plugin 123456789101112131415161718192021const MiniCssPlugin = require('mini-css-extract-plugin');module.exports = { module:{ rules:[ { test: /\\.less$/, use: [MiniCssPlugin.loader, 'css-loader', 'less-loader'] }, { test: /\\.css$/, use: [MiniCssPlugin.loader, 'css-loader'] }, ] }, plugins:[ new MiniCssPlugin({ filename: 'styles/[name].[contenthash:8].css', chunkFilename: 'styles/[name].[contenthash:8].css' }), ]}; 实战下面使用Webpack来配置一个传统多页面网站开发的示例。 目录结构123456789101112131415├── package.json├── src│ ├── about 关于页│ │ ├── index.html│ │ ├── index.js│ │ └── style.less│ ├── common│ │ └── style.less│ └── home 首页│ ├── images│ │ └── logo.png│ ├── index.html│ ├── index.js│ └── style.less├── webpack.config.js 使用到的npm包123456789101112131415161718&quot;clean-webpack-plugin&quot;: &quot;^3.0.0&quot;,&quot;css-loader&quot;: &quot;^3.2.1&quot;,&quot;exports-loader&quot;: &quot;^0.7.0&quot;,&quot;extract-text-webpack-plugin&quot;: &quot;^4.0.0-beta.0&quot;,&quot;file-loader&quot;: &quot;^5.0.2&quot;,&quot;html-webpack-plugin&quot;: &quot;^3.2.0&quot;,&quot;html-withimg-loader&quot;: &quot;^0.1.16&quot;,&quot;less&quot;: &quot;^3.10.3&quot;,&quot;less-loader&quot;: &quot;^5.0.0&quot;,&quot;mini-css-extract-plugin&quot;: &quot;^0.8.0&quot;,&quot;normalize.css&quot;: &quot;^8.0.1&quot;,&quot;script-loader&quot;: &quot;^0.7.2&quot;,&quot;style-loader&quot;: &quot;^1.0.1&quot;,&quot;url-loader&quot;: &quot;^3.0.0&quot;,&quot;webpack&quot;: &quot;^4.41.2&quot;,&quot;webpack-cli&quot;: &quot;^3.3.10&quot;,&quot;webpack-dev-server&quot;: &quot;^3.9.0&quot;,&quot;zepto&quot;: &quot;^1.2.0&quot; 配置入口点由于是传统多页网站，每个页面都需要单独打包一份JS，因此每个页面需要一个入口。 1234entry: { // 入口配置，每个页面一个入口JS home: './src/home/index', // 首页 about: './src/about/index' // 关于页} 配置输出本例我们不进行CDN部署，因此输出点配置比较简单。 123456output: { // 输出配置 path: path.resolve(__dirname, 'dist'), // 输出资源目录 filename: 'scripts/[name].[hash:8].js', // 入口点JS命名规则 chunkFilename: 'scripts/[name]:[chunkhash:8].js', // 公共模块命名规则 publicPath: '/' // 资源路径前缀} 配置开发服务器本地开发时不需要每次都编译完Webpack再访问，通过webpack-dev-server，我们可以边开发变查看效果，文件会实时编译。 1234devServer: { contentBase: './dist', // 开发服务器配置 hot: true // 热加载}, 配置loader本例中没有使用ES6进行编程，但是引用了一个非CommonJS的js模块Zepto，传统用法中在HTML页面引入Zepto就会在window下挂载全局对象Zepto。但是在Webpack开发中不建议使用全局变量，否则模块化的优势将受到影响。 通过使用exports-loader和script-loader，我们可以将Zepto包装为CommonJS模块进入导入。 12345678910111213141516171819202122232425262728293031module: { rules: [ { test: require.resolve('zepto'), loader: 'exports-loader?window.Zepto!script-loader' // 将window.Zepto包装为CommonJS模块 }, { test: /\\.less$/, use: [MiniCssPlugin.loader, 'css-loader', 'less-loader'] }, { test: /\\.css$/, use: [MiniCssPlugin.loader, 'css-loader'] }, { test: /\\.(png|jpg|gif)$/, use: [ { loader: 'file-loader', options: { name: 'images/[name].[hash:8].[ext]' } } ] }, { test: /\\.(htm|html)$/i, loader: 'html-withimg-loader' } ] }, 配置optimization主要进行公共模块的打包配置。 1234567891011121314151617optimization: { splitChunks: { cacheGroups: { vendor: { name: &quot;vendor&quot;, test: /[\\\\/]node_modules[\\\\/]/, chunks: 'all', priority: 10, // 优先级 }, styles: { name: 'styles', test: /\\.css$/, chunks: 'all' } } } }, 配置plugin123456789101112131415161718192021222324252627plugins: [ new CleanWebpackPlugin(), // 清理发布目录 new HtmlWebpackPlugin({ chunks: ['home', 'vendor', 'styles'], // 声明本页面使用到的模块，有主页，公共JS以及公共CSS filename: 'index.html', // 输出路径，这里直接输出到dist的根目录，也就是dist/index.html template: './src/home/index.html', // HTML模板文件路径 minify: { removeComments: true, // 移除注释 collapseWhitespace: true // 合并空格 } }), new HtmlWebpackPlugin({ chunks: ['about', 'vendor', 'styles'], filename: 'about/index.html', // 输出到dist/about/index.html template: './src/about/index.html', minify: { removeComments: true, collapseWhitespace: true } }), new MiniCssPlugin({ filename: 'styles/[name].[contenthash:8].css', chunkFilename: 'styles/[name].[contenthash:8].css' }), new webpack.NamedModulesPlugin(), // 热加载使用 new webpack.HotModuleReplacementPlugin() // 热加载使用 ] 示例代码部分示例代码如下: 123456789// src/about/index.jsconst $ = require('zepto');require('normalize.css');require('../common/style.less');require('./style.less');$('#about').on('click', function () { alert('点击了about按钮');}); 和传统的JS有点不太一样，多了一些css的require，前面说过，webpack把所有资源当做JS模块，因此这是推荐的做法。 123456789101112131415161718192021&lt;!--首页--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;/&quot;&gt;首页&lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/about&quot;&gt;关于&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;logo&quot;&gt;&lt;/div&gt; &lt;button id=&quot;home&quot;&gt;首页按钮&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 页面中不再需要编写JS。 注意：html中使用标签导入图片的编译，目前还没有好的解决办法，可以通过css background的形式进行处理 开发模式开发模式下直接启用webpack-dev-server即可，会自动加载工作目录下的webpack.config.js 12345// package.json&quot;scripts&quot;: { &quot;build&quot;: &quot;webpack&quot;, &quot;dev&quot;: &quot;webpack-dev-server&quot;} 1npm run dev 生产模式生产模式下使用webpack编译，编译完成后输出最终文件。 1npm run build 输出效果12345678910111213├── about│ └── index.html├── images│ └── logo.b15c113a.png├── index.html├── scripts│ ├── about.3fb4aa0f.js│ ├── home.3fb4aa0f.js│ └── vendor:ed5b7d31.js└── styles ├── about.71eb65e9.css ├── home.cd2738e6.css └── vendor.9df34e21.css 项目地址项目已经托管到github，有需要的读者可以自取。 https://github.com/xialeistudio/webpack-multipage-example","link":"/2019/12/19/2019-12-19-webpack-get-started.html"},{"title":"Javascript事件系统","text":"本文内容 事件基础 事件监听方式 事件默认行为 事件冒泡与事件捕获 事件绑定与事件委托 事件基础 注意：本文不会深入探究Javascript的事件循环。 提到事件，相信每位Javascript开发者都不会陌生，由于Javascript是先有实现，后有规范，因此，对于大部分人来说，事件模块可以说是比较模糊的，本文将从不同角度帮助你理清楚事件模块。 事件的本质可以说是一个回调函数，当事件触发时会调用你的监听函数。 事件是一定会触发的，如果没有对应的监听函数，就不会执行回调。 比如下面就是用户点击指定元素打印日志的例子： 123document.querySelector('#button').onclick = function() { console.log('clicked');}; 事件基础相信大家都没什么问题，重点在后面的内容。 事件监听方式由于历史原因，Javascript目前存在三种事件监听方式： HTML代码中监听 DOM0级监听 DOM2级监听 Q: 为啥从DOM0级开始？ 1998年，W3C综合各浏览器厂商的现有API，指定了DOM1标准。在DOM1标准出现之前浏览器已有的事件监听方式叫做DOM0级。 Q：DOM1级监听到哪里去了？ 由于DOM1标准只是对DOM0标准的整理+规范化，并没有增加新的内容，因此DOM0级可以看做DOM1级。 HTML代码监听1&lt;button onclick=&quot;alert('Hello World!')&quot;&gt;点我&lt;/button&gt; 直接将事件处理函数或事件处理代码写到HTML元素对应的属性上的方式就是HTML代码监听方式。 该方式有一个明显的缺点，如果事件逻辑比较复杂时，将大段代码直接写在HTML元素上不利于维护。因此一般会提取到一个专一的函数进行处理。 1&lt;button onclick=&quot;callback()&quot;&gt;点我&lt;/button&gt; 该方式也有一个问题，那就是如果callback()函数还未加载好时点击按钮将报错。而且直接将事件耦合到HTML元素上也不符合单一职责，HTML元素应该只负责展示，不负责事件。 不建议在开发中使用该方式处理事件。 DOM0级事件监听在DOM1级规范出来之前，各浏览器厂商已经提供了一套事件API，也就是DOM0级API，它的写法如下： 123456&lt;button id=&quot;click&quot;&gt;点我&lt;/button&gt;&lt;script&gt; document.querySelector('#click').onclick = function() { console.log('clicked'); };&lt;/script&gt; 这个相信大家在刚开始入行时写的比较多，比如我们的ajax相关API就是DOM0级的。 123var xhr = new XMLHttpRequest();xhr.onload = function() {};xhr.onerror = function() {}; DOM0级事件基本上都是以”on”开头的 DOM0级事件也存在一个问题，那就是不支持添加多个事件处理函数，因此只有在不支持DOM2级事件的情况下才会使用DOM0级来绑定事件。 DOM2级事件监听DOM2级事件是最新的事件处理程序规范（有许多年未更新了）。DOM2级事件通过addEventListener方式给元素添加事件处理程序。 123456&lt;button id=&quot;click&quot;&gt;点我&lt;/button&gt;&lt;script&gt; document.addEventListener('click', function(){ console.log('clicked'); });&lt;/script&gt; 多次调用addEventListener可以绑定多个事件处理程序，但是需要注意： 同样的事件名、同样的事件处理函数和同样的事件流机制(冒泡和捕获，下面会讲到)，只会触发一次。 123456789// 下面的代码只会触发一次&lt;button id=&quot;request&quot;&gt;登录&lt;/button&gt;&lt;script&gt;function onClick() { console.log('clicked');}document.querySelector('#request').addEventListener('click', onClick, false);document.querySelector('#request').addEventListener('click', onClick, false);&lt;/script&gt; onClick是同一个事件处理程序，所以只触发一次 12345678910// 下面的代码只会触发两次&lt;button id=&quot;request&quot;&gt;登录&lt;/button&gt;&lt;script&gt;document.querySelector('#request').addEventListener('click', function() { console.log('clicked');}, false);document.querySelector('#request').addEventListener('click', function() { console.log('clicked');}, false);&lt;/script&gt; 两个匿名函数，所以会触发两次 事件默认行为很多网页元素会有默认行为，比如下面这些： 点击a标签的时候，会有跳转行为 点击右键时会弹出菜单 在表单中点击提交按钮会提交表单 如果我们需要阻止默认行为，比如我们在阻止表单的默认提交事件，进行数据校验，通过校验后再调用表单submit方法提交。 不同的监听方式阻止默认行为的方式也不同。 HTML代码方式 HTML代码方式支持return false和event.preventDefault() return false方式12345678&lt;form action=&quot;&quot; onsubmit=&quot;return handleSubmit()&quot;&gt; &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;&lt;/form&gt;&lt;script&gt;function handleSubmit() { return false;}&lt;/script&gt; 上例中我们监听了表单的onsubmit事件，当点击按钮或者按下回车时，将会触发handleSubmit方法，同时会阻止表单的提交。 表单内如果有type=”submit”的按钮存在，按下回车时就会自动提交。 HTML监听方式阻止默认事件需要满足以下两点： HTML事件监听代码return handler()，return不能少，少了就无法阻止默认行为 handler()函数需要返回false event.preventDefault()123456&lt;a href=&quot;https://www.ddhigh.com&quot; onclick=&quot;handleClick(event)&quot; id=&quot;click&quot;&gt;Href&lt;/a&gt;&lt;script&gt;function handleClick(e) { e.preventDefault();}&lt;/script&gt; DOM0级事件方式 DOM0级事件支持return false和event.preventDefault()两种方式。 event.preventDefault()1234567// event.preventDefault()&lt;a href=&quot;https://www.ddhigh.com&quot; id=&quot;click&quot;&gt;Href&lt;/a&gt;&lt;script&gt; document.querySelector('#click').onclick= function (event) { event.preventDefault(); };&lt;/script&gt; return false1234567// return false&lt;a href=&quot;https://www.ddhigh.com&quot; id=&quot;click&quot;&gt;Href&lt;/a&gt;&lt;script&gt; document.querySelector('#click').onclick= function (event) { return false; };&lt;/script&gt; 两种方式都能工作，不过建议使用event.preventDefault()，原因在下面DOM2级会讲到 DOM2级事件 DOM2级事件事件**只支持event.preventDefault()**方式，这也是事件的标准处理方法。 123456&lt;a href=&quot;https://www.ddhigh.com&quot; id=&quot;click&quot;&gt;Href&lt;/a&gt;&lt;script&gt;document.querySelector('#click').addEventListener('click', function (e) { e.preventDefault();});&lt;/script&gt; 事件冒泡与事件捕获先来看一个HTML结构 12345&lt;div id=&quot;father&quot;&gt; &lt;div id=&quot;child&quot;&gt; &lt;div id=&quot;son&quot;&gt;Click&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 我们知道，一旦绑定了事件处理程序，在事件触发时，事件处理函数都会触发。 如果我们给father/child/son都绑定了事件处理函数，点击了son时，谁被触发呢？ 事实上，三个函数都会被触发，因为son时child的子元素，child又是father的子元素，点击son，同时也点击了father和child。 由此带来一个问题，三个函数谁先触发，谁后触发呢？这就是我们常说的事件流，father-&gt;child-&gt;son这种路径是可以的，但是son-&gt;child-&gt;father这种路径也是可以的。 针对这两种方式，W3C给了我们一个答案，两种方式都支持，即可以从父元素到子元素，又可以从子元素到父元素，前者叫事件捕获，后者叫事件冒泡。 事件捕获事件发生时采取自上而下的方式进行触发，最先触发的是window，其次是document，然后根据DOM层级依次触发，最终进入到真正的事件元素。 addEventListener第三个参数传入true就是捕获方式的标志。 1234567891011121314151617&lt;div id=&quot;father&quot;&gt; &lt;div id=&quot;child&quot;&gt; &lt;div id=&quot;son&quot;&gt;Click&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; document.querySelector('#father').addEventListener('click', function () { console.log('father'); }, true); document.querySelector('#child').addEventListener('click', function () { console.log('child'); }, true); document.querySelector('#son').addEventListener('click', function () { console.log('son'); }, true); &lt;/script&gt; 点击son之后的输出顺序为 123fatherchildson 事件冒泡事件发生时采取自下而上的方式进行触发，最先触发的是发生事件的元素，其次是父元素，依次向上，最终触发到document和window。 addEventListener第三个参数传入false就是捕获冒泡的标志。 1234567891011121314151617&lt;div id=&quot;father&quot;&gt; &lt;div id=&quot;child&quot;&gt; &lt;div id=&quot;son&quot;&gt;Click&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; document.querySelector('#father').addEventListener('click', function () { console.log('father'); }, false); document.querySelector('#child').addEventListener('click', function () { console.log('child'); }, false); document.querySelector('#son').addEventListener('click', function () { console.log('son'); }, false); &lt;/script&gt; 点击son之后的输出顺序为 123sonchildfather 由于事件捕获和事件冒泡机制，我们需要一个标记来标识真正触发事件的元素，这个元素就是event.target，而另外一个相似的属性叫event.currentTarget，这是当前元素。 事件捕获和时间冒泡的顺序 根据浏览器规范，事件捕获会先于事件冒泡发生。因此，总的事件顺序如下 window 捕获阶段 document 捕获阶段 … 依次到真正触发事件的元素 捕获阶段 真正触发事件的元素 冒泡阶段 依次向上的父元素 冒泡阶段 document 冒泡阶段 window 冒泡阶段 1234567891011121314151617181920212223242526&lt;div id=&quot;father&quot;&gt; &lt;div id=&quot;child&quot;&gt; &lt;div id=&quot;son&quot;&gt;Click&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; document.querySelector('#father').addEventListener('click', function () { console.log('father捕获'); }, true); document.querySelector('#child').addEventListener('click', function () { console.log('child捕获'); }, true); document.querySelector('#son').addEventListener('click', function () { console.log('son捕获'); }, true); document.querySelector('#father').addEventListener('click', function () { console.log('father冒泡'); }, false); document.querySelector('#child').addEventListener('click', function () { console.log('child冒泡'); }, false); document.querySelector('#son').addEventListener('click', function () { console.log('son冒泡'); }, false); &lt;/script&gt; 点击son之后的输出为 123456father捕获child捕获son捕获son冒泡child冒泡father冒泡 事件绑定和事件委托弄明白浏览器的事件流机制之后，来讨论事件绑定和事件委托其实是很简单的事情。 事件绑定就是在事件监听方式中直接对具体元素进行事件监听的方式。有个明显的缺点，对于新增加的DOM节点是无法监听到事件的。 12345678910111213&lt;div class=&quot;a&quot;&gt;click1&lt;/div&gt;&lt;div class=&quot;a&quot;&gt;click2&lt;/div&gt;&lt;script&gt; document.querySelectorAll('.a').forEach(ele =&gt; ele.onclick = function () { console.log('clicked ' + this.innerHTML); }); setTimeout(function () { const div3 = document.createElement('div') div3.className = &quot;a&quot;; div3.innerHTML = &quot;click3&quot; document.body.appendChild(div3) }, 500);&lt;/script&gt; 上面的click3点击是没有任何反应的，因为在创建该元素时没有绑定事件处理函数。 事件委托我们利用事件流机制来实现上面的需求。 事件委托就是利用事件流机制，在父元素进行监听，由于事件冒泡机制，父元素可以接受新添加元素的事件。 12345678910111213&lt;div class=&quot;a&quot;&gt;click1&lt;/div&gt;&lt;div class=&quot;a&quot;&gt;click2&lt;/div&gt;&lt;script&gt; document.body.addEventListener('click', function (e) { console.log(e.target.innerHTML) }, false); setTimeout(function () { const div3 = document.createElement('div') div3.className = &quot;a&quot;; div3.innerHTML = &quot;click3&quot; document.body.appendChild(div3) }, 500);&lt;/script&gt; 由于事件冒泡机制，click3元素点击之后会将事件冒泡给父元素，也就是我们的document.body，通过event.target可以拿到真正触发事件的元素。 （完）","link":"/2019/12/30/2019-12-30-javascript-event.html"},{"title":"kafka二进制协议简要分析","text":"最近分享了《应用层私有协议的设计和实战》，对应用层私有协议设计做了一些介绍，同时也对协议设计中常用的数据类型做了比较形象的讲解，今天我们来研究一下kafka的二进制协议。 数据类型kafka二进制协议定义了许多的数据类型，包含常用的数字、字符串，也包含了数组等类型。 本文主要讨论不可变长数据类型，可变长度（如Google Protocol Buffers）不在讨论范围内。 数据类型 字节长度 说明 BOOLEAN 1 布尔值 INT8 1 单字节整型，-2^7 ~ 2^7-1 INT16 2 双字节整型，大端序，范围 -2^15 ~ 2^15 - 1 INT32 4 四字节整型、大端序，范围 -2^31 ~ 2^31 - 1 INT64 8 八字节整型、大端序，范围 -2^63 ~ 2^63 -1 UINT32 4 十字街 UUID 16 16字节，Java UUID类型 STRING 2+N 头部由2字节标识字符串长度N，后续N字节为字符串内容 NULLABLE_STRING 2+N 头部由2字节标识字符串长度N，后续N字节为字符串内容，N为-1时无后续内容 BYTES 4+N 头部4字节标识字节数组长度，后续N字节为字节数组内容 NULLABLE_BYTES 4+N 头部4字节标识字节数组长度，后续N字节为字节数组内容，N为-1时无后续内容 ARRAY 4+N*M 头部4字节标识数组长度N，M为单个数组元素的长度，N为-1时为空数组 错误码 -1 未知错误 0 未出错 大于0， 具体错误 kafka内置的操作类型有点多，有兴趣的可以参阅kafka错误码 Api Keys可以理解为操作码，服务端根据该字段区分当前请求操作。 这里不做展开，有兴趣的可以参阅kafka Api Keys 报文结构接下来我们重点分析一下kafka的报文结构。 本文基于kafka V1版本协议写作，其他版本的研究原理时一致的。 整体结构kafka的协议结构比较简单，请求和响应使用同样的整体结构。 12RequestOrResponse =&gt; Size (RequestMessage | ResponseMessage) Size =&gt; int32 我们转化为表格来看看 Size为INT32类型，正文长度 Message 为请求或响应正文的内容，变长字段，长度由Size给出 请求格式请求数据包有固定的请求包头，我们来看看。 12345Request Header v1 =&gt; request_api_key request_api_version correlation_id client_id request_api_key =&gt; INT16 request_api_version =&gt; INT16 correlation_id =&gt; INT32 client_id =&gt; NULLABLE_STRING 上面给出的是请求头的内容，结合整体结构得出的协议表格如下： Size 4字节正文长度（包含请求头） request_api_key 2字节 api key，用来区分操作 request_api_version 2字节api 版本号 correlation_id 4字节请求ID，服务端会原样响应该请求ID client_id 可空字符串，根据kafka数据类型定义，需要2字节client_id length字段标识client_id长度，如果client_id length为-1，则不需要传具体的client_id，否则需要传递client_id request message* 请求正文，不同的api key请求正文不同 响应格式12Response Header v1 =&gt; correlation_id TAG_BUFFER correlation_id =&gt; INT32 响应头的结构比较简单，返回了请求ID Size 4字节响应正文长度（包含请求ID） correlation_id 4字节请求ID response message* 响应正文 Metadata 示例请求数据Kafka Metadata对应的协议格式如下 123Metadata Request (Version: 1) =&gt; [topics] topics =&gt; name name =&gt; STRING 我们转化为表格看看 Size 4字节请求正文长度 Request_api_key，根据协议文档， 此处为3 Request_api_version，本文基于v1版本写作，因此版本号为1 correlation_id 请求ID client_id length 2字节客户端长度，我们使用test作为客户端标识，此处传入4 client_id 客户端名称，传入test字符串 topic name length 需要查询的topic数组，我们查询test1这个topic，此处传入1 topic name 字符串类型，因此先写入字符串长度5(test1字符串长度为5)，再写入test1字符串（总共写入2+5 = 7个字节） 响应数据1234567891011121314151617Metadata Response (Version: 1) =&gt; [brokers] controller_id [topics] brokers =&gt; node_id host port rack node_id =&gt; INT32 host =&gt; STRING port =&gt; INT32 rack =&gt; NULLABLE_STRING controller_id =&gt; INT32 topics =&gt; error_code name is_internal [partitions] error_code =&gt; INT16 name =&gt; STRING is_internal =&gt; BOOLEAN partitions =&gt; error_code partition_index leader_id [replica_nodes] [isr_nodes] error_code =&gt; INT16 partition_index =&gt; INT32 leader_id =&gt; INT32 replica_nodes =&gt; INT32 isr_nodes =&gt; INT32 Size 4字节响应长度 Correlation_id 4字节请求ID Broker Count，数组类型，4字节整型标识数组长度 node_id 4字节整型，broker的节点ID host 字符串类型，主机名称 port 4字节整型，端口号 rack 可空字符串，如果broker是rack，则需要2+N字节，否则只需要2字节 Controller_id 4字节整型 Topics 数组类型，topic数组 error_code 2字节整型，错误码 name 字符串类型，topic名称 is_internal 布尔类型，是否内部topic partions 数组类型，topic所在partition error_code 2字节整型，错误码 partition_index 4字节整型，partition index leader_id 4字节整型，leader id Replica_nodes 数组类型 Replica_node 4字节整型 isr_nodes 数组类型 Isr_node 4字节整型 其他类型的请求也可以使用同样的方式去分析 PHP客户端实现PHP自带了pack/unpack函数帮助我们操作二进制数据，不过pack/unpack易用性比较低。 对于二进制数据，java有byte[]，golang有[]byte，PHP没有专门的类型，而是使用字符串存储的，不过PHP字符串是二进制安全的。 针对pack/unpack函数易用性问题，这两天参考Java的IO系统开发了一个简单版本的io库来简化二进制数据流的操作（文末有仓库地址）。 接下来使用该库来编写一个kafka的客户端。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;?php/** * 读取kafka broker列表 */require __DIR__ . '/../vendor/autoload.php';use io\\BinaryStringInputStream;use io\\BinaryStringOutputStream;use io\\DataInputStream;use io\\DataOutputStream;use io\\FileInputStream;use io\\FileOutputStream;$client = stream_socket_client('tcp://127.0.0.1:9092', $errno, $errstr, 5);if ($errno) { die($errstr);}$binaryOutputStream = new BinaryStringOutputStream();$binaryPacketOutput = new DataOutputStream($binaryOutputStream);$binaryPacketOutput-&gt;writeUnSignedShortBE(0x03); // METADATA_REQUEST$binaryPacketOutput-&gt;writeUnSignedShortBE(1); // API_VERSION$binaryPacketOutput-&gt;writeUnSignedIntBE(0x01); // 请求ID$binaryPacketOutput-&gt;writeUnSignedShortBE(strlen('test')); // 客户端标识长度$binaryPacketOutput-&gt;writeString('test'); // 客户端标识$binaryPacketOutput-&gt;writeUnSignedIntBE(1); // topic列表数组长度// topic数组元素$binaryPacketOutput-&gt;writeUnSignedShortBE(strlen('test1')); // 写入2字节topic名称长度$binaryPacketOutput-&gt;writeString('test1'); // topic名称$binaryPacketOutput-&gt;flush(); // 输出缓冲$packet = $binaryOutputStream-&gt;toBinaryString(); // 获得构造好的正文数据包// 包装socket链接，获得多数据类型操作能力$out = new DataOutputStream(new FileOutputStream($client));$out-&gt;writeUnSignedIntBE(strlen($packet)); // 4字节包长度$out-&gt;write($packet); // 包体$out-&gt;flush(); // 输出到Socket// 实例化输入流，从socket读取数据$in = new DataInputStream(new FileInputStream($client));$size = $in-&gt;readUnSignedIntBE(); // 4字节包长度// 一次性读取完socket数据后关闭，然后将读取到的响应数据填充到二进制字符串输入流中，释放socket$in = new DataInputStream(new BinaryStringInputStream(fread($client, $size)));fclose($client);$requestId = $in-&gt;readUnSignedIntBE(); // 4字节请求IDprintf(&quot;packet length: %d requestId: %d\\n&quot;, $size, $requestId);$brokerCount = $in-&gt;readUnSignedIntBE(); // broker数量for ($i = 0; $i &lt; $brokerCount; $i++) { // 循环读取broker $nodeId = $in-&gt;readUnSignedIntBE(); // nodeId $hostLength = $in-&gt;readUnSignedShortBE(); // host长度 $host = $in-&gt;readString($hostLength); // 主机名 $port = $in-&gt;readUnSignedIntBE(); // port $rackLength = $in-&gt;readShortBE(); // rack $rack = null; if ($rackLength != -1) { $rack = $in-&gt;readString($rackLength); } printf(&quot;nodeId:%d host:%s port:%d rack: %s\\n&quot;, $nodeId, $host, $port, $rack);}$controllerId = $in-&gt;readUnSignedIntBE();printf(&quot;controllerId: %d\\n&quot;, $controllerId);$topicCount = $in-&gt;readUnSignedIntBE();printf(&quot;topic count %d\\n&quot;, $topicCount);for ($i = 0; $i &lt; $topicCount; $i++) { printf(&quot;----topic list----\\n&quot;); $errCode = $in-&gt;readUnSignedShortBE(); $nameLength = $in-&gt;readUnSignedShortBE(); $name = $in-&gt;readString($nameLength); $isInternal = $in-&gt;readUnSignedChar(); printf(&quot;errcode: %d name: %s interval: %d\\n&quot;, $errCode, $name, $isInternal); $partitionCount = $in-&gt;readUnSignedIntBE(); printf(&quot;----topic [%s] partition list count %d---\\n&quot;, $name, $partitionCount); for ($j = 0; $j &lt; $partitionCount; $j++) { $errCode = $in-&gt;readUnSignedShortBE(); $partitionIndex = $in-&gt;readUnSignedIntBE(); $leaderId = $in-&gt;readUnSignedIntBE(); $replicaNodesCount = $in-&gt;readUnSignedIntBE(); $replicaNodes = []; for ($k = 0; $k &lt; $replicaNodesCount; $k++) { $replicaNodes[] = $in-&gt;readUnSignedIntBE(); } $isrNodeCount = $in-&gt;readUnSignedIntBE(); $isrNodes = []; for ($k = 0; $k &lt; $isrNodeCount; $k++) { $isrNodes[] = $in-&gt;readUnSignedIntBE(); } printf( &quot;errcode: %d partitionIndex: %d leaderId: %d replicaNodes: [%s] isrNodes: [%s]\\n&quot;, $errCode, $partitionIndex, $leaderId, join(',', $replicaNodes), join(',', $isrNodes) ); }} 输出如下： 12345678packet length: 73 requestId: 1nodeId:0 host:bogon port:9092 rack: controllerId: 0topic count 1----topic list----errcode: 0 name: test1 interval: 0----topic [test1] partition list count 1---errcode: 0 partitionIndex: 0 leaderId: 0 replicaNodes: [0] isrNodes: [0] 项目地址 php-io (完)","link":"/2020/01/17/2020-01-17-php-binary-io.html"},{"title":"Java中加载文件的几种方式","text":"在Java程序中加载外部文件有多中方式，每种方式也存在区别，本文将理清这些加载方式之间的区别。 文件IO方式1234567891011package org.xialei.example.resource;import java.io.File;import java.io.IOException;public class Main { public static void main(String[] args) throws IOException { File file = new File(&quot;app.properties&quot;); System.out.println(file.getAbsolutePath()); }} 常见的读取方式，使用该方式读取文件时规则如下： 如果传入的是绝对路径，则以系统根目录作为绝对路径的起点。 如果传入的是相对路径，则以当前工作目录作为起点。 本例中，运行java命令的目录即为工作目录，app.properties从工作目录开始查找。 Class.getResourceAsStream123456789101112131415package org.xialei.example.resource;import java.io.IOException;import java.io.InputStream;import java.util.Properties;public class Main { public static void main(String[] args) throws IOException { try (InputStream is = Main.class.getResourceAsStream(&quot;app.properties&quot;)) { Properties properties = new Properties(); properties.load(is); System.out.println(properties.getProperty(&quot;name&quot;)); } }} 使用该方式读取文件时规则如下： 如果传入的是相对路径，则以当前class所在的包作为起点。 如果传入的是绝对路径，则以classpath的根目录为起点。 Main.class.getResourceAsStream(&quot;app.properties&quot;) 会读取/org/xialei/example/resource/app.properties文件。 Main.class.getResourceAsStream(&quot;/app.properties&quot;)会读取”classpath:/app.properties”文件 ClassLoader.getResourceAsStream123456789101112131415package org.xialei.example.resource;import java.io.IOException;import java.io.InputStream;import java.util.Properties;public class Main { public static void main(String[] args) throws IOException { try (InputStream is = Main.class.getClassLoader().getResourceAsStream(&quot;org/xialei/example/resource/app.properties&quot;)) { Properties properties = new Properties(); properties.load(is); System.out.println(properties.getProperty(&quot;name&quot;)); } }} 使用该方式时规则如下: 使用classpath根目录作为起点。 本例中，org/xialei/example/resource/app.properties就是从classpath根目录进行查找的。","link":"/2020/02/01/2020-02-01-java-resource-load.html"},{"title":"Shell脚本快速入门(1)","text":"Shell 是一个用 C 语言编写的程序，用户可以通过Shell脚本语言来进行程序开发。与其他脚本语言不同，Shell脚本所需的解释器一般是内置在操作系统的，而像Node.js、PHP等脚本语言需要手动安装解释器程序才可以。 接下来将和大家一起来学习Shell脚本编程。 Shell解释器Shell解释器种类众多，笔者的电脑上内置以下Shell: 123456/bin/bash/bin/csh/bin/ksh/bin/sh/bin/tcsh/bin/zsh 其中bash和sh是最常见的Shell解释器，一般情况下，这两种Shell没有区别，本文以bash为例。 Hello World打开文本编辑器(vim或者vscode)，新建文件 hello.sh，扩展名为sh(常用)。 12#!/bin/bashecho &quot;Hello World!&quot; 第1行用来指明本脚本需要使用什么解释器来执行。#!是一个约定的语法。 echo用来输出文本。 执行Shell脚本有两种方法可以执行Shell脚本： 作为可执行程序。给脚本添加可执行权限之后执行即可。 12chmod +x ./hello.sh # 添加可执行权限./hello.sh # 执行脚本 作为解释器脚本。直接运行指定的解释器程序，并将脚本路径传入，本方式不要求脚本有可执行权限。 1/bin/bash hello.sh # 使用/bin/bash来执行hello.sh Shell语法和其他编程语言一样，Shell脚本也有自己的一套语法规则，我们现在来系统学习一下。 变量命名规则定义变量时，变量名不加美元符号$，如： 1name=&quot;xialei&quot; 和其他编程语言不同的时，Shell脚本中变量名和等号之间不能有空格。Shell变量名的命名规则如下： 只能包含英文字母、数字和下划线，且不能以数字开头 不能包含空格 不能使用关键字命名(通过下划线连接关键字是允许的) 不能使用标点符号 以下是合法的示例 1234var1var_2_var3MAX_PAGE 以下是不合法的示例 1$var 赋值Shell有以下两种复制方式。 直接赋值。直接在等号后面指定变量值。 12name=&quot;xialeiadmin=1 使用命名执行结果。可以将其他命令的执行结果赋值给变量。（以下两种方式是等效的） 12file=`ls /etc` # 反引号(键盘Tab上面的键)file1=$(ls /etc) 已经存在的变量，可以被重新赋值。 12345name=&quot;hello&quot;echo $namename=&quot;world&quot;echo $name 使用变量 使用变量时在变量名前添加$符号，定义时不加。 123name=&quot;xialei&quot;echo $nameecho ${name} 变量名两边的花括号是可选的，一般情况下不用加，但是如果涉及到边界识别问题，则需要手动添加花括号。 123name=&quot;xialei&quot;echo &quot;I'm ${name}studio.&quot; # 正确示例echo &quot;I'm $namestudio.&quot; # 错误示例 如果不添加花括号，Shell会将namestudio作为变量，该变量是不存在的，因此代码执行逻辑就不是我们想要的了。 只读变量如果某些变量在定义后就无法更改该变量的值，可以设置使用readonly设置为只读变量，对只读变量赋值会跑出错误。 123name=&quot;xialei&quot;readonly namename=&quot;zhangsan&quot; 上述例子执行结果如下 1./hello.sh: line 5: name: readonly variable 释放变量使用unset可以释放变量。变量被释放后不能使用(使用不会报错,shell中使用未定义变量当做空值处理)，此外unset命令无法释放只读变量。 123name=&quot;xialei&quot;unset name # 不要$echo $name 变量类型Shell脚本运行时，存在以下三种变量： 局部变量。在脚本中定义的变量，只对当前脚本有效 环境变量。所有程序都能访问到环境变量，此外Shell脚本也可以在运行时定义环境变量 Shell变量。Shell变量是由Shell解释器设置的变量。Shell变量中有一部分是局部变量，有一部分是环境变量。 数据类型Shell支持数字、字符串和数组三种数据类型。下面我们分别进行学习。 字符串字符串可以使用单引号、双引号，也可以不使用引号。 单引号 1name='xialei' 单引号内的任何字符都会原样使用，不解析变量，也不解析转义字符。这一点和PHP有点类似 双引号 123name='xialei'msg=&quot;Hello, ${name}&quot;echo $msg 双引号内的字符串会进行变量解析和转义字符解析 字符串拼接字符串拼接有以下两种方式。 引号拼接(支持双引号和单引号) 123name='xialei'msg='Hello '$name', welcome!'echo $msg 内部嵌套(只支持双引号，因为单引号不解析变量) 123name='xialei'msg=&quot;Hello ${name}, welcome!&quot;echo $msg 数组Shell只支持一维数组，不限定数组大小。 数组的索引由0开始，读取元素的索引可以使用整数或表达式。 数组定义数组元素使用小括号括起来，每个元素之间用空格分割。 1users=(xialei zhangsan lisi) 读取数组元素语法如下: 1${数组名称[下标]} 比如上例中读取第2个人 12users=(xialei zhangsan lisi)echo ${users[1]} # 输出zhangsan 使用@作为下标可以获取数组的所有元素。 12users=(xialei zhangsan lisi)echo ${users[@]} # 输出 xialei zhangsan lisi 获取数组长度语法如下 1length=${#数组名[@]} 比如输出users数组的长度 12users=(xialei zhangsan lisi)echo ${#users[@]} 今天的内容主要是让大家对Shell有一个宏观的认识，介绍了Shell的变量以及数据类型，下一篇将重点介绍Shell的运算符和流程控制。 (未完待续)","link":"/2020/02/10/2020-02-10-shell-quickstart.html"},{"title":"Shell脚本快速入门(2)","text":"今天我们来学习Shell的运算符和流程控制。 运算符Shell和其他编程语言一样支持多种运算符，包括： 算术运算符 关系运算符 逻辑运算符 字符串运算符 文件测试运算符 下面我们一起来看看。 算术运算符 原生bash不支持简单的数学运算，需要借助expr命令。 例如，输出两个数的和： 12sum=`expr 1 + 1`echo $sum 注意： 操作数和操作符之间必须用空格分开； 表达式必须使用反引号包裹； 操作符 说明 示例 + 加法 expr 1 + 1 - 减法 expr 1 - 1 * 乘法 expr 1 \\* 1 需要转义*号 / 除法 expr 1 / 1 % 取余 expr 2 % 2 完整示例如下： 123456789101112131415161718192021a=1b=2# 加法val=`expr $a + $b`echo &quot;$a+$b=$val&quot;# 减法val=`expr $a - $b`echo &quot;$a-$b=$val&quot;# 乘法val=`expr $a \\* $b` # 必须转义echo &quot;$a*$b=$val&quot;# 除法val=`expr $a / $b`echo &quot;$a/$b=$val&quot;# 取余val=`expr $a % $b`echo &quot;$a%$b=$val&quot; 关系运算符关系运算符是比较两个操作数的数学大小关系，支持数字和数字字符串(如”1”) 运算符 说明 例子 -eq 检测两数是否相等 [ $a -eq $b ] -ne 检测两数是否不等 [ $a -ne $b ] -gt 检查左边是否大于右边(greater than) [ $a -gt $b ] -lt 检查左边是否小于右边(less than) [ $a -lt $b ] -ge 检查左边是否大于等于右边 [ $a -ge $b ] -le 检查左边是否小于等于右边 [ $a -le $b ] == 判断两数是否相等 [ $a == $b ] != 判断两数是否不想等 [ $a != $b ] 下面是一个if比较的示例，if语法将在本文介绍流程控制的时候进行详细学习。 123456789a=10b=20if [ $a -eq $b ]then echo &quot;$a=$b&quot;else echo &quot;$a!=$b&quot;fi 逻辑运算符逻辑运算符就是与(AND)、或(OR)、非(NOT)。 运算符 说明 示例 ! 逻辑非 [ !false]返回true -o 逻辑或 [ $a -gt 0 -o $b -gt 0] 当a和b有一个大于0时返回true -a 逻辑与 [ $a -gt 0 -a $b -gt 0 ]当a和b都大于0时返回true 下面是结合关系运算符的例子： 1234567891011121314151617181920212223a=1b=2if [ $a != $b ]then echo &quot;1!=2&quot;else echo &quot;1=2&quot;fiif [ $a -gt 0 -o $b -gt 0 ]then echo &quot;a或b大于0&quot;else echo &quot;a和b都不大于0&quot;fiif [ $a -gt 0 -a $b -gt 0 ]then echo &quot;a和b都大于0&quot;else echo &quot;a和b不都大于0&quot;fi 字符串运算符Shell被常用来处理字符串数据，因此有一些专门适用于字符串的运算符。 运算符 说明 示例 = 检查两个字符串是否相等 [ $a = $b ] != 检查两个字符串是否不想等 [ $a != $b ] -z 检查字符串长度是否为0 [ -z $a ] -n 检查字符串长度是否不为0 [ -n $a ] $ 检查字符串是否为空 [ $a ] 下面是一些示例： 123456789101112131415161718192021222324252627282930a=&quot;hello&quot;b=&quot;world&quot;if [ $a = $b ]then echo &quot;$a和$b相同&quot;else echo &quot;$a和$b不同&quot;fiif [ -z $a ]then echo &quot;$a长度为0&quot;else echo &quot;$a长度不为0&quot;fiif [ -n $a ]then echo &quot;$a长度不为0&quot;else echo &quot;$a长度为0&quot;fiif [ $a ]then echo &quot;$a不为空&quot;else echo &quot;$a为空&quot;fi 文件测试运算符文件测试运算符用于检测文件的各种状态。下表列出了常用的文件测试运算符。 操作符 说明 示例 -d file 检查文件是否是目录 [ -d $file ] -f file 检查文件是否是普通文件(不是目录，也不是块设备文件) [ -f $file] -r file 检查文件是否可读 [ -r $file ] -w file 检查文件是否可写 [ -w $file ] -x file 检查文件是否可执行 [ -x $file ] -s file 检查文件大小是否为0 [ -s $file ] -e file 检查文件或文件夹是否存在 [ -e $file ] -S 检查文件是否是Socket文件 [ -S $file ] -L 检查文件是否存在且是一个符号链接 [ -L $file ] 下面是一些示例： 12345678910111213141516171819202122file=&quot;/etc/passwd&quot;if [ -d $file ]then echo &quot;$file是目录&quot;else echo &quot;$file不是目录&quot;fiif [ -f $file ]then echo &quot;$file是普通文件&quot;else echo &quot;$file不是普通文件&quot;fiif [ -e $file ]then echo &quot;$file存在&quot;else echo &quot;$file不存在&quot;fi 流程控制Shell的流程控制也包含判断和循环，我们一起来学习一下。 if/else语法 123456789101112131415161718if conditionthen 语句1 语句2 ... 语句Nelif condition2then 语句1 语句2 ... 语句Nelse 语句1 语句2 ... 语句Nfi elif和else分支是可以省略的 if/fi 需要配对 下面是一些示例： 1234567891011121314a=1b=2if [ $a == $b ]then echo &quot;a = b&quot;elif [ $a -gt $b ]then echo &quot;a &gt; b&quot;elif [ $a -lt $b ]then echo &quot;a &lt; b&quot;else echo &quot;所有条件都不匹配&quot;fi for循环语法如下 1234567for item in item1 item2 ... itemNdo 语句1 语句2 ... 语句Ndone do/done需要配对 in列表支持文件列表、字符串、数字和其他数组数据 下面是循环输出/etc下文件和目录的示例： 1234for dir in `ls /etc`do echo &quot;$dir&quot;done while语法如下 1234567while conditiondo 语句1 语句2 ... 语句Ndone 下面是一个示例 123456c=1while(( $c&lt;=10 ))do echo $c c=`expr $c + 1`done switch语法如下 1234567891011121314151617181920case 值 in模式1) 语句1 语句2 ... 语句N ;;模式2) 语句1 语句2 ... 语句N ;;*) 语句1 语句2 ... 语句N ;;easc 模式匹配之后不会再执行其他模式语句(不需要手动break) case/easc 必须配对 每个模式语句的末尾必须添加两个分号 使用*号捕获其他模式 如下是一个示例 12345678910111213echo '输入星期几'read daycase $day in 1) echo &quot;星期一&quot; ;; 2) echo &quot;星期二&quot; ;; ... *) echo &quot;输入的数字无效&quot; ;; read是从标准输入读取一行赋值给指定变量 breakbreak命令允许跳出循环体。下面是一个示例 1234567891011sum=0while read ndo if [ $n -gt 0 ] then sum=`expr $sum + $n` else break fidone continuecontinue命令允许跳过本次循环，直接进行下一轮循环。下面是一个示例 1234567891011sum=0while read ndo if [ $n -gt 0 ] then sum=`expr $sum + $n` else continue # 本次输入不合法，跳过， fidone 九九乘法表结合今日所学，我们用Shell来打印一个九九乘法表： 12345678910111213141516171819#!/bin/bashi=1while [ $i -le 9 ] # i &lt;= 9do j=1 while [ $j -le 9 ] # j &lt;= 9 do if [ $i -ge $j ] # if($i &gt;= $j) then val=`expr $i \\* $j` echo -n &quot;$j*$i=$val &quot; fi j=`expr $j + 1` # j++ done echo i=`expr $i + 1` # i++done 执行结果如下: 1234567891*1=1 1*2=2 2*2=4 1*3=3 2*3=6 3*3=9 1*4=4 2*4=8 3*4=12 4*4=16 1*5=5 2*5=10 3*5=15 4*5=20 5*5=25 1*6=6 2*6=12 3*6=18 4*6=24 5*6=30 6*6=36 1*7=7 2*7=14 3*7=21 4*7=28 5*7=35 6*7=42 7*7=49 1*8=8 2*8=16 3*8=24 4*8=32 5*8=40 6*8=48 7*8=56 8*8=64 1*9=9 2*9=18 3*9=27 4*9=36 5*9=45 6*9=54 7*9=63 8*9=72 9*9=81 今天的内容是Shell中比较重要的，也是最常用的语法。下一篇将对Shell的输入输出进行学习。 (未完待续)","link":"/2020/02/11/2020-02-11-shell-operator-flow-control.html"},{"title":"Webpack4不求人(2) ——手把手搭建TypeScript+React16+ReactRouter5同构应用脚手架","text":"同构应用使用同一份应用代码，同时提供浏览器环境和服务器环境下的应用，解决传统浏览器单页应用的两个顽固问题： 不利于SEO，浏览器环境代码是在客户端渲染，大部分爬虫都只能爬到一个空白的入口文件 代码在浏览器渲染，低端机可能会卡顿 接下来我们一起从零开始搭建基于Webpack的React同构应用脚手架。 SSR流程 Web应用构建完成后输出CSS、JS和HTML SSR应用构建完成后输出一个CommonJs模块文件，可以将虚拟DOM在服务端渲染为HTML字符串 Node.js新建HTTP服务器，收到请求后调用SSR模块导出的render函数输出HTML到客户端 初始化项目1234567891011mkdir react-ssr-examplecd react-ssr-exampleyarn init -yyarn add webpack webpack-cli webpack-dev-server -D # 安装Webpackyarn add react react-dom react-router-dom # 安装Reactyarn add @types/react @types/react-dom @types/react-router-dom -D # 安装React声明文件yarn add express # 安装expressyarn add css-loader sass-loader node-sass mini-css-extract-plugin # 安装CSS相关模块yarn add ts-loader typescript # 安装TypeScriptyarn add html-webpack-plugin # 安装HTML处理插件 目录结构脚手架的完整目录如下：(这些文件一步步都会有) 12345678910111213141516171819202122|----build # 构建结果目录 |----styles # 样式 |----main.css |----bundle.ssr.js # SSR应用文件 |----bundle.web.js # Web应用文件 |----index.html # Web应用入口HTML|----src # 应用源码 |----home # 首页组件 |----index.scss # 首页SCSS |----index.tsx # 首页组件 |----signin # 登录页组件 |----index.scss # 登录页SCSS |----index.tsx # 登录页组件 |----App.tsx # 应用路由设置 |----index.html # Web应用入口HTML |----main.ssr.tsx # SSR入口文件 |----main.web.tsx # Web入口文件|----index.js # express服务器入口|----package.json|----tsconfig.json # TypeScript配置文件|----webpack.config.js # Web应用webpack配置|----webconfig.ssr.config.js # SSR应用Webpack配置 工具配置1.TypeScript配置，新建tsconfig.json 12345678910111213141516171819{ &quot;compilerOptions&quot;: { &quot;target&quot;: &quot;es5&quot;, &quot;module&quot;: &quot;commonjs&quot;, &quot;jsx&quot;: &quot;react&quot;, &quot;strict&quot;: true, &quot;lib&quot;: [ &quot;DOM&quot; ], &quot;esModuleInterop&quot;: true }, &quot;include&quot;: [ &quot;./src/**/*.ts&quot;, &quot;./src/**/*.tsx&quot; ], &quot;exclude&quot;: [ &quot;node_modules&quot; ] } 主要是添加了jsx设置和include设置 2.Web环境webpack配置，新建webpack.config.js 1234567891011121314151617181920212223242526272829303132333435363738394041const path = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');const MiniCssPlugin = require('mini-css-extract-plugin');module.exports = { entry: './src/main.web', // 入口文件 output: { path: path.resolve(__dirname, 'build'), // 输出目录 filename: 'bundle.web.js' // 输出文件 }, module: { rules: [ { test: /\\.tsx?$/, // ts文件处理 use: 'ts-loader' }, { test: /\\.scss$/, // scss文件处理 use: [MiniCssPlugin.loader, 'css-loader', 'sass-loader'] }, { test: /\\.css$/, // css文件处理 use: [MiniCssPlugin.loader, 'css-loader'] } ] }, plugins: [ new HtmlWebpackPlugin({ chunks: ['main'], // chunk名称，entry是字符串类型，因此chunk为main filename: 'index.html', // 输出到build目录的文件名 template: 'src/index.html' // 模板路径 }), new MiniCssPlugin({ filename: 'styles/[name].[contenthash:8].css', // 输出的CSS文件名 chunkFilename: 'styles/[name].[contenthash:8].css' }) ], resolve: { extensions: ['.ts', '.tsx', '.js', '.json'] // 添加ts和tsx后缀 }}; 3.SSR环境Webpack配置，新建webpack.ssr.config.js 12345678910111213141516171819202122232425262728293031323334353637const path = require('path');const MiniCssPlugin = require('mini-css-extract-plugin');module.exports = { entry: './src/main.ssr', target: 'node', // 必须指定为Node.js，否则会打包Node.js内置模块 output: { path: path.resolve(__dirname, 'build'), filename: 'bundle.ssr.js', libraryTarget: 'commonjs2' // 打包为CommonJs模块才能被Node.js加载 }, module: { rules: [ { test: /\\.tsx?$/, use: 'ts-loader' }, { test: /\\.scss$/, use: [MiniCssPlugin.loader, 'css-loader', 'sass-loader'] }, { test: /\\.css$/, use: [MiniCssPlugin.loader, 'css-loader'] } ] }, plugins: [ new MiniCssPlugin({ filename: 'styles/[name].[contenthash:8].css', chunkFilename: 'styles/[name].[contenthash:8].css' }) ], resolve: { extensions: ['.ts', '.tsx', '.js', '.json'] }}; 4.package.json添加npm命令 1234567{ &quot;scripts&quot;: { &quot;build&quot;: &quot;webpack&quot;, &quot;start&quot;: &quot;webpack-dev-server&quot;, &quot;build-ssr&quot;: &quot;webpack --config webpack.ssr.config.js&quot; }} 应用编码src/home/index.tsx 12345678910import React from 'react';import './index.scss';export default class Home extends React.Component { render() { return ( &lt;div className=&quot;main&quot;&gt;首页&lt;/div&gt; ) }} src/home/index.scss 123.main { color: red;} src/signin/index.tsx 123456789import React from 'react';import { withRouter } from 'react-router-dom';function SignIn(props: any) { return ( &lt;button onClick={() =&gt; props.history.replace('/')}&gt;登录&lt;/button&gt; )}export default withRouter(SignIn); src/App.tsx 1234567891011121314151617import React from 'react';import { Switch, Route, Link } from 'react-router-dom'; // router// 导入页面组件import Home from './home';import SignIn from './signin';// 导出路由组件配置export default function App() { return ( &lt;Switch&gt; &lt;Route path=&quot;/signin&quot; component={SignIn} /&gt; &lt;Route path=&quot;/&quot; component={Home} /&gt; &lt;/Switch&gt; )} index.html 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Hello World&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; src/main.ssr.tsx 12345678910111213141516171819202122import React from 'react';import { StaticRouter, Link } from 'react-router-dom';import { renderToString } from 'react-dom/server';import App from './App'; // 将路由组件导入进来export function render(req: any) { // 导出一个渲染函数，根据请求链接进行分发 const context = {}; const html = renderToString( &lt;StaticRouter location={req.url} context={context}&gt; &lt;header&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to=&quot;/&quot;&gt;首页&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=&quot;/signin&quot;&gt;登录&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;/header&gt; &lt;App /&gt; &lt;/StaticRouter&gt; ); return [html, context]; // 导出context和html渲染结果} src/main.web.tsx 1234567891011121314151617import React from 'react';import ReactDOM from 'react-dom';import { BrowserRouter, Link } from 'react-router-dom';import App from './App';ReactDOM.render( // 渲染路由 &lt;BrowserRouter&gt; &lt;header&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to=&quot;/&quot;&gt;首页&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=&quot;/signin&quot;&gt;登录&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;/header&gt; &lt;App /&gt; &lt;/BrowserRouter&gt;, document.querySelector('#app')) index.js 12345678910111213141516171819202122232425262728const express = require('express'); // 加载expressconst { render } = require('./build/bundle.ssr'); // 加载ssrconst app = express();app.use(express.static('.')) // 静态资源配置app.get('/*', (req, res) =&gt; { // 所有请求都走这里处理，必须加* const [html, context] = render(req) console.log(context) // context目前没发现啥用处 res.send(` &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;SSR&lt;/title&gt; &lt;link href=&quot;build/styles/main.8f173ff5.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt;${html}&lt;/div&gt; &lt;script src=&quot;build/bundle.web.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; `); console.log(context)});app.listen(8080) 注意： 静态资源配置必须在最上面 app.get(‘/‘)必须有号 HTML字符串必须手动引入CSS和Web构建结果 执行构建123npm run build # 构建Webnpm run build-ssr # 构建SSRnode index.js # 启动Express服务器 查看结果首页样式 首页代码 登录页样式 登录页代码 源码地址Https://github.com/xialeistudio/react-ssr-example","link":"/2020/03/02/2020-03-02-react-ssr-example.html"},{"title":"Webpack4不求人(3) ——性能优化","text":"限定Webpack处理文件范围项目比较小的情况下Webpack的性能问题几乎可以忽略，但是一旦项目复杂度上升，Webpack会有额外的性能损失需要我们进行优化。 通过前面内容的学习我们可以知道Webpack主要干下面这些事情： 通过entry指定的入口脚本进行依赖解析。 找到文件后通过配置的loader对其进行处理。 因此，我们可以从这方面入手进行优化，减少Webpack搜索文件的范围，减少不必要的处理。 loader配置在之前的内容中介绍过loader可以使用test、include、exclude配置项来匹配需要Loader处理的文件，因此推荐给每个loader定义test之后还定义include或exclude。 1234567891011module.exports = { module:{ rules:[ { test:/\\.js$/, use:'babel-loader', include: path.resolve(__dirname, 'src'), // 只处理src目录下的js文件 } ] }}; resolve.extensions配置导入未添加扩展名的模块时，Webpack会通过resolve.extensions后缀去检查文件是否存在。由于resolve.extensions是一个数组，如果数组项比较多，正确的后缀放置得越靠后，Webpack尝试次数就会越多，影响到性能。 因此配置resolve.extensions时需要遵守以下规则： 尽量减少后缀列表，不要将不可能存在的文件后缀配置进来 出现频率越高的后缀尽量写到前面，比如可以将.js写在第一个 业务代码中导入模块时，可以手动加上后缀导入，省去Webpack查找过程 module.noParse配置module.noParse可以告诉Webpack忽略未采用模块系统文件的处理，可以有效地提高性能。比如常见的jQuery非常大，又没有采用模块系统，让Webpack解析这类型文件完全是浪费性能。 因此我们可以配置如下的module.noParse: 12345module.exports = { module:{ noParse:[/jQuery/] }}; IgnorePlugin在导入模块时，IgnorePlugin可以忽略指定模块的生成。比如moment.js在导入时会自动导入本地化文件，一般情况下几乎不使用而且又比较大，此时可以通过IgnorePlugin忽略对本地化文件的生成，减小文件大小。 12345module.exports = { plugins:[ new webpack.IgnorePlugin(/\\.\\/local/, /moment/) ]}; DllPlugin使用过Windows操作系统的读者应该会经常看到以.dll扩展名的文件，这些文件叫做动态链接库，包含了其他程序或动态链接库的函数和数据。 Webpack的DllPlugin的思想是类似的，先将公共模块打包为独立的Dll模块，然后在业务代码中直接引用这些模块。采用DllPlugin之后会大大提升Webpack构建速度，原因在于，包含大量复用模块的动态链接库只需要编译一次，之后的构建中会直接引用这些构建好的模块。 在Webpack中使用动态链接库有以下两个步骤： 通过webpack.DllPlugin插件打包出Dll库 通过webpack.DllReferencePlugin引用打包好的Dll库 下面以React项目为例进行说明。 Dll库需要单独构建，因此我们需要一份单独的配置Webpack文件。 1.新建webpack.dll.config.js 12345678910111213141516171819const webpack = require('webpack');module.exports = { entry:{ react: ['react', 'react-dom'] }, output:{ filename: '_dll_[name].js', // 输出的文件名 path: path.resolve(__dirname, 'dist'), // 输出到dist目录 library: '_dll_[name]' }, plugins: [ // name要等于output.library里的name new webpack.DllPlugin({ name: &quot;_dll_[name]&quot;, path: path.resolve(__dirname, &quot;dist&quot;, &quot;manifest.json&quot;) // 清单文件路径 }) ]}; 2.编辑webpack.config.js 123456789101112131415const webpack = require('webpack');module.exports = { entry: './src/main', output:{ filename: '[name].js', // 输出的文件名 path: path.resolve(__dirname, 'dist'), // 输出到dist目录 }, plugins: [ // 传入manifest.json new webpack.DllReferencePlugin({ manifest: path.resolve(__dirname, &quot;dist&quot;, &quot;manifest.json&quot;) // 清单文件路径 }) ]}; 3.添加构建命令 123456{ &quot;scripts&quot;:{ &quot;build-dll&quot;:&quot;webpack --config webpack.dll.config.js&quot;, &quot;build&quot;:&quot;webpack&quot; }} 4.构建Dll 1npm run build-dll 5.构建应用 1npm run build Dll需要先构建，否则应用将构建失败 HappyPackWebpack默认情况下是单进程执行的，因此无法利用多核优势，通过HappyPack可以变成多进程构建，从而提升构建速度。下面我们一起来看看如何使用happypack来加速构建。 1.安装happypack 1npm isntall happypack 2.编辑配置文件，需要将Loader配置到HappyPack插件中，由HappyPack对Loader进行调用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657const HappyPackPlugin = require('happypack');const path = require('path');module.exports = { entry: './src/main', output:{ path: path.resolve(__dirname, 'build'), filename:'[name].js' }, module:{ rules:[ { test:/\\.js$/, use:'happypack/loader?id=js', // 配置id为js include:[ path.resolve(__dirname,'src') ] }, { test:/\\.scss$/, use:'happypack/loader?id=scss', // 配置id为scss include:[ path.resolve(__dirname,'src') ] }, { test:/\\.css$/, use:'happypack/loader?id=css', // 配置id为css include:[ path.resolve(__dirname,'src') ] } ] }, plugins:[ new HappyPackPlugin({ id:'js', // id为js的loader配置 use:[ { loader:'babel-loader', options:{ plugins:['@babel/transform-runtime'], presets:['@babel/env'] } } ] }), new HappyPackPlugin({ id:'scss', // id为scss的loader配置 use:['style-loader','css-loader','sass-loader'] }), new HappyPackPlugin({ id:'css', // id为css的loader配置 use:['style-loader','css-loader'] }), ]}; Tree-ShakingTree-Shaking原始的本意是”摇动树“，这样就会将一些分支”摇掉“，从而减少主干大小。而Webpack中的Tree-Shaking是类似的，在Webpack项目中，有一个入口文件，相当于树的主干，入口文件又依赖了许多模块。实际开发中，虽然依赖了某个模块，但其实只使用了其中的部分代码，通过Tree-Shaking，可以将模块中未使用的代码剔除掉，从而减少构建结果的大小。 注意：只有使用ES6模块系统的代码，在mode为production时，Tree-Shaking才会生效。因此，在编写代码时尽量使用import/export的方式。 按需加载在开发中，我们一般会将业务代码打包为app.js，其他第三方依赖打包为vendor.js。这样会有一个比较大的问题，如果依赖的第三方模块过多，vendor.js会越来越大，而在浏览器加载时需要完全加载完vendor.js才可以，这样就会造成无谓的等待，因为我们当前页面可能只使用了一部分代码。此时可以使用Webpack来实现按需加载，只有在真正用到这个模块时才会加载相应的js。 比如基于echarts开发了一个数据可视化页面，可以在这个路由组件下面使用异步的方式加载echarts的代码： 1234import('echarts').then(modules =&gt; { const echarts = modules.default; const chart = echarts.init(document.querySelector('#chart'));}); 不过使用按需加载时，构建代码中会包含Promise调用，因此低版本浏览器需要注入Promise的polyfill实现。 提取公共代码Webpack4中可以将多个公共模块打包一份，减少代码冗余，Webpack4之前的版本是使用webpack内置的CommonsChunkPlugin实现的，Webpack4直接配置optimization即可。 123456789101112131415161718module.exports = { optimization:{ splitChunks:{ cacheGroups:{ common:{ // 应用代码中公共模块 chunks: 'all', // 最小公共模块引用次数 minChunks: 2 }, vendor:{ // node_modules中第三方模块 test: /node_modules/, chunks: 'all', minChunks: 1 } } } }}; 第三方库代码的变更一般比较少(通过package.json的版本可以指定依赖版本)，因此构建出来的vendor.js基本不会变就可以利用浏览器的缓存机制进行缓存。 而应用代码的变更是比较频繁的，因此单独打包为common.js，浏览器可以单独缓存，如果应用代码发生变更，浏览器只用重新下载common.js文件，而不用重新下载vendor.js。 热更新HMR(Hot Module Replacement)是Webpack提供的常用功能之一，它允许在运行时对模块进行修改，而无需刷新整个页面(LiveReload需要刷新页面才能加载)，这样有以下优势： 保留应用状态，比如使用Vue/React时如果使用LiveReload，组件状态全部丢失，而HMR不会 只更新变更的内容，节省开发时间 使用以下配置即可打开内置的HMR功能： 123456789101112const webpack = require('webpack');module.exports = { devServer: { hot: true, // 启用热加载 contentBase: './dist', }, plugins:[ new webpack.NamedModulesPlugin(), // 打印更新的模块路径 new webpack.HotModuleReplacementPlugin() // 热更新插件 ]}; 小结本文我们对Webpack4最常用的性能优化技术进行了学习，这些优化方法对业务代码的侵入性非常小（只有按需加载优化会要求使用import()函数进行加载），在实际的开发中，可以结合这些技术进行针对性的优化，比如开发时编译慢，可能就需要使用HappyPack插件进行多进程编译以加快编译速度等等。","link":"/2020/03/06/2020-03-06-webpack-optimize.html"},{"title":"Webpack4不求人(4)——编写自定义Loader","text":"在前面的内容中，我们学习了Webpack的基本知识、常用脚手架和性能优化，虽然说大部分的开发场景社区已经又成熟的模块给我们使用，但是遇到特殊情况还是需要自己有独立开发的能力，因此今天我们一起来学习如何编写自定义Loader。 基本LoaderWebpack中loader是一个CommonJs风格的函数，接收输入的源码，通过同步或异步的方式替换源码后进行输出。 123module.exports = function(source, sourceMap, meta) { } source是输入的内容 sourceMap是可选的 meta是模块的元数据，也是可选的 需要注意的是，该导出函数必须使用function，不能使用箭头函数，因为loader编写过程中会经常使用到this访问选项和其他方法。 我们先编写一个基本的Loader，完成的工作很简单，那就是把输出的字符串进行替换。 1.新建loader-example目录，执行npm初始化，并安装webpack 1234mkdir loader-examplecd loadeer-examplenpm init -ynpm install webpack webpack-cli 2.构建项目目录 123456|----loader # loader目录 |----replace-loader.js # 替换字符串的Loader|----src # 应用源码 |----index.js # 首页|----package.json|----webpack.config.js 3.编写loader/replace-loader.js 123module.exports = function(source) { return source.replace(/World/g, 'Loader');}; 本例中我们Loader只是简单的将源码中的”World“替换成了”Loader“。 4.编写src/index.js 1console.log('Hello World'); 5.编写webpack.config.js 123456789101112131415161718192021const path = require('path');module.exports = { entry: './src/index', target: 'node', // 我们编译为Node.js环境下的JS，等下直接使用Node.js执行编译完成的文件 output:{ path: path.resolve(__dirname, 'build'), filename: '[name].js' }, module:{ rules:[ { test:/\\.js$/, use: 'replace-loader' } ] }, resolveLoader: { modules: ['./node_modules', './loader'] // 配置loader的查找目录 }}; 6.编写package.json 12345{ &quot;scripts&quot;:{ &quot;build&quot;:&quot;webpack&quot; }} 7.执行构建 1npm run build 8.构建完成后，执行build/main.js 1node build/main.js 此时终端输出如下，我们编写的Loader工作正常。 1Hello Loader Loader选项我们使用第三方loader时经常可以看到传递选项的情况： 123456789101112{ test:/\\.js$/, use:[ { loader:'babel-loader', options:{ plugins:['@babel/transform-runtime'], presets:['@babel/env'] } } ]} 在Loader编写时，Webpack中官方推荐通过loader-utils来读取配置选项，我们需要先安装。 1npm install loader-utils 我们给刚才编写的replace-loader传递一个选项，允许自定义替换结果。 123456const loaderUtils = require('loader-utils');module.exports = function(source) { const options = loaderUtils.getOptions(this); return source.replace(/World/g, options.text);}; 接下来编辑webpack.config.js，给replace-loader传递选项。 1234567891011121314151617181920module.exports = { module:{ rules:[ { test:/\\.js$/, use:[ { loader:'replace-loader', options:{ text: 'Webpack4' } } ] } ] }, resolveLoader:{ modules: ['./node_modules', './loader'] }}; 执行构建之后用Node.js执行build/main.js，可以看到输出的内容已经发生变化了。 1Hello Webpack4 异步Loader在Loader中，如果存在异步调用，那么就无法直接通过return返回构建后的结果了，此时需要使用到Webpack提供的回调函数将数据进行回调。 Webpack4给Loader提供了this.async()函数，调用之后返回一个callback，callback的签名如下: 123456function callback( err: Error|null, content: string|Buffer, sourceMap?:SourceMap, meta?: any) 例如我们需要在loader中调用setTimeout进行等待，则相应的代码如下： 1234567module.exports = function(source) { const callback = this.async(); setTimeout(() =&gt; { const output = source.replace(/World/g, 'Webpack4'); callback(null, output); }, 1000);} 执行构建，Webpack会等待一秒，然后再输出构建内容，通过Node.js执行构建后的文件，输出如下 1Hello Webpack4 “Raw” Loader默认情况下，资源文件会被转化为 UTF-8 字符串，然后传给 loader。通过设置 raw，loader 可以接收原始的 Buffer。比如处理非文本文件时(如图片等等)。 12345module.exports = function(source) { assert(source instanceof Buffer); return someSyncOperation(source);};module.exports.raw = true; // 设置当前Loader为raw loader, webpack会将原始的Buffer对象传入 读取loader配置文件babel-loader在使用时可以加载.babelrc配置文件来配置plugins和presets，减少了webpack.config.js的代码量，便于维护。接下来我们编写一个i18n-loader，通过读取语言配置文件完成语言转换。 项目结构1234567|----loader |----i18n-loader.js # loader|----i18n |----zh.json # 中文语言包|----src |----index.js # 入口文件|----webpack.config.js i18n/zh.json 1234{ &quot;hello&quot;: &quot;你好&quot;, &quot;today&quot;: &quot;今天&quot;} loader/i18n-loader.js 1234567891011121314151617181920212223242526const loaderUtils = require('loader-utils');const path = require('path');module.exports = function (source) { const options = loaderUtils.getOptions(this); const locale = options ? options.locale : null; // 读取语言配置文件 let json = null; if (locale) { const filename = path.resolve(__dirname, '..', 'i18n', `${locale}.json`); json = require(filename); } // 读取语言标记 {{}} const matches = source.match(/\\{\\{\\w+\\}\\}/g); for (const match of matches) { const name = match.match(/\\{\\{(\\w+)\\}\\}/)[1].toLowerCase(); if (json !== null &amp;&amp; json[name] !== undefined) { source = source.replace(match, json[name]); } else { source = source.replace(match, name); } } return source;} src/index.js 1console.log('{{Hello}}, {{Today}} is a good day.'); webpack.config.js 12345678910111213141516171819202122232425262728const path = require('path');module.exports = { entry: './src/index', output: { path: path.resolve(__dirname, 'build'), filename: '[name].js' }, target: 'node', module: { rules: [ { test: /\\.js$/, use: [ { loader: 'i18n-loader', options: { // 传递选项 locale: 'zh' } } ] } ] }, resolveLoader: { modules: ['./node_modules', './loader'] }}; package.json 12345{ &quot;scripts&quot;:{ &quot;build&quot;:&quot;webpack&quot; }} 执行构建1npm run build 构建完毕后使用Node.js执行build/main.js输出如下： 1你好, 今天 is a good day. 可以看到i18n-loader成功读取了配置文件。 小结本文简要介绍了Webpack中如何编写一个自定义的loader，权当抛砖引玉，更多的用法等待读者在实际工作中去挖掘，要想掌握Webpack的高级知识，Loader是必不可少的技能，有时候如果社区找不到合适的Loader，大家可以根据需要自己进行开发。","link":"/2020/03/11/2020-03-11-webpack-loader-development.html"},{"title":"Webpack4不求人(5)——编写自定义插件","text":"Webpack通过Loader完成模块的转换工作，让“一切皆模块”成为可能。Plugin机制则让其更加灵活，可以在Webpack生命周期中调用钩子完成各种任务，包括修改输出资源、输出目录等等。 今天我们一起来学习如何编写Webpack插件。 构建流程在编写插件之前，还需要了解一下Webpack的构建流程，以便在合适的时机插入合适的插件逻辑。Webpack的基本构建流程如下： 校验配置文件 生成Compiler对象 初始化默认插件 run/watch：如果运行在watch模式则执行watch方法，否则执行run方法 compilation：创建Compilation对象回调compilation相关钩子 emit：文件内容准备完成，准备生成文件，这是最后一次修改最终文件的机会 afterEmit：文件已经写入磁盘完成 done：完成编译 插件示例一个典型的Webpack插件代码如下： 123456789101112// 插件代码class MyWebpackPlugin { constructor(options) { } apply(compiler) { // 在emit阶段插入钩子函数 compiler.hooks.emit.tap('MyWebpackPlugin', (compilation) =&gt; {}); }}module.exports = MyWebpackPlugin; 接下来需要在webpack.config.js中引入这个插件。 12345678module.exports = { plugins:[ // 传入插件实例 new MyWebpackPlugin({ param:'paramValue' }), ]}; Webpack在启动时会实例化插件对象，在初始化compiler对象之后会调用插件实例的apply方法，传入compiler对象，插件实例在apply方法中会注册感兴趣的钩子，Webpack在执行过程中会根据构建阶段回调相应的钩子。 Compiler &amp;&amp; Compilation对象在编写Webpack插件过程中，最常用也是最主要的两个对象就是Webpack提供的Compiler和Compilation，Plugin通过访问Compiler和Compilation对象来完成工作。 Compiler 对象包含了当前运行Webpack的配置，包括entry、output、loaders等配置，这个对象在启动Webpack时被实例化，而且是全局唯一的。Plugin可以通过该对象获取到Webpack的配置信息进行处理。 Compilation对象可以理解编译对象，包含了模块、依赖、文件等信息。在开发模式下运行Webpack时，每修改一次文件都会产生一个新的Compilation对象，Plugin可以访问到本次编译过程中的模块、依赖、文件内容等信息。 常见钩子Webpack会根据执行流程来回调对应的钩子，下面我们来看看都有哪些常见钩子，这些钩子支持的tap操作是什么。 钩子 说明 参数 类型 afterPlugins 启动一次新的编译 compiler 同步 compile 创建compilation对象之前 compilationParams 同步 compilation compilation对象创建完成 compilation 同步 emit 资源生成完成，输出之前 compilation 异步 afterEmit 资源输出到目录完成 compilation 异步 done 完成编译 stats 同步 TapableTapable是Webpack的一个核心工具，Webpack中许多对象扩展自Tapable类。Tapable类暴露了tap、tapAsync和tapPromise方法，可以根据钩子的同步/异步方式来选择一个函数注入逻辑。 tap 同步钩子 tapAsync 异步钩子，通过callback回调告诉Webpack异步执行完毕 tapPromise 异步钩子，返回一个Promise告诉Webpack异步执行完毕 taptap是一个同步钩子，同步钩子在使用时不可以包含异步调用，因为函数返回时异步逻辑有可能未执行完毕导致问题。 下面一个在compile阶段插入同步钩子的示例。 123compiler.hooks.compile.tap('MyWebpackPlugin', params =&gt; { console.log('我是同步钩子')}); tapAsynctapAsync是一个异步钩子，我们可以通过callback告知Webpack异步逻辑执行完毕。 下面是一个在emit阶段的示例，在1秒后打印文件列表。 123456compiler.hooks.emit.tapAsync('MyWebpackPlugin', (compilation, callback) =&gt; { setTimeout(()=&gt;{ console.log('文件列表', Object.keys(compilation.assets).join(',')); callback(); }, 1000);}); tapPromisetapPromise也是也是异步钩子，和tapAsync的区别在于tapPromise是通过返回Promise来告知Webpack异步逻辑执行完毕。 下面是一个将生成结果上传到CDN的示例。 123456789101112compiler.hooks.afterEmit.tapPromise('MyWebpackPlugin', (compilation) =&gt; { return new Promise((resolve, reject) =&gt; { const filelist = Object.keys(compilation.assets); uploadToCDN(filelist, (err) =&gt; { if(err) { reject(err); return; } resolve(); }); });}); apply方法中插入钩子的一般形式如下： 123compileer.hooks.阶段.tap函数('插件名称', (阶段回调参数) =&gt; { }); 常用API读取输出资源、模块及依赖在emit阶段，我们可以读取最终需要输出的资源、chunk、模块和对应的依赖，如果有需要还可以更改输出资源。 123456789101112131415apply(compiler) { compiler.hooks.emit.tapAsync('MyWebpackPlugin', (compilation, callback) =&gt; { // compilation.chunks存放了代码块列表 compilation.chunks.forEach(chunk =&gt; { // chunk包含多个模块，通过chunk.modulesIterable可以遍历模块列表 for(const module of chunk.modulesIterable) { // module包含多个依赖，通过module.dependencies进行遍历 module.dependencies.forEach(dependency =&gt; { console.log(dependency); }); } }); callback(); });} 修改输出资源通过操作compilation.assets对象，我们可以添加、删除、更改最终输出的资源。 123456789101112131415apply(compiler) { compiler.hooks.emit.tapAsync('MyWebpackPlugin', (compilation) =&gt; { // 修改或添加资源 compilation.assets['main.js'] = { source() { return 'modified content'; }, size() { return this.source().length; } }; // 删除资源 delete compilation.assets['main.js']; });} assets对象需要定义source和size方法，source方法返回资源的内容，支持字符串和Node.js的Buffer，size返回文件的大小字节数。 插件编写实例接下来我们开始编写自定义插件，所有插件使用的示例项目如下(需要安装webpack和webpack-cli)： 123456|----src |----main.js|----plugins |----my-webpack-plugin.js|----package.json|----webpack.config.js 相关文件的内容如下: 12// src/main.jsconsole.log('Hello World'); 123456// package.json{ &quot;scripts&quot;:{ &quot;build&quot;:&quot;webpack&quot; }} 1234567891011121314const path = require('path');const MyWebpackPlugin = require('my-webpack-plugin');// webpack.config.jsmodule.exports = { entry:'./src/main', output:{ path: path.resolve(__dirname, 'build'), filename:'[name].js', }, plugins:[ new MyWebpackPlugin() ]}; 生成清单文件通过在emit阶段操作compilation.assets实现。 12345678910111213141516171819202122class MyWebpackPlugin { apply(compiler) { compiler.hooks.emit.tapAsync('MyWebpackPlugin', (compilation, callback) =&gt; { const manifest = {}; for (const name of Object.keys(compilation.assets)) { manifest[name] = compilation.assets[name].size(); // 将生成文件的文件名和大小写入manifest对象 } compilation.assets['manifest.json'] = { source() { return JSON.stringify(manifest); }, size() { return this.source().length; } }; callback(); }); }}module.exports = MyWebpackPlugin; 构建完成后会在build目录添加manifest.json，内容如下： 1{&quot;main.js&quot;:956} 构建结果上传到七牛在实际开发中，资源文件构建完成后一般会同步到CDN，最终前端界面使用的是CDN服务器上的静态资源。 下面我们编写一个Webpack插件，文件构建完成后上传的七牛CDN。 我们的插件依赖qiniu，因此需要额外安装qiniu模块 1npm install qiniu --save-dev 七牛的Node.js SDK文档地址如下： 1https://developer.qiniu.com/kodo/sdk/1289/nodejs 开始编写插件代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576const qiniu = require('qiniu');const path = require('path');class MyWebpackPlugin { // 七牛SDK mac对象 mac = null; constructor(options) { // 读取传入选项 this.options = options || {}; // 检查选项中的参数 this.checkQiniuConfig(); // 初始化七牛mac对象 this.mac = new qiniu.auth.digest.Mac( this.options.qiniu.accessKey, this.options.qiniu.secretKey ); } checkQiniuConfig() { // 配置未传qiniu，读取环境变量中的配置 if (!this.options.qiniu) { this.options.qiniu = { accessKey: process.env.QINIU_ACCESS_KEY, secretKey: process.env.QINIU_SECRET_KEY, bucket: process.env.QINIU_BUCKET, keyPrefix: process.env.QINIU_KEY_PREFIX || '' }; } const qiniu = this.options.qiniu; if (!qiniu.accessKey || !qiniu.secretKey || !qiniu.bucket) { throw new Error('invalid qiniu config'); } } apply(compiler) { compiler.hooks.afterEmit.tapPromise('MyWebpackPlugin', (compilation) =&gt; { return new Promise((resolve, reject) =&gt; { // 总上传数量 const uploadCount = Object.keys(compilation.assets).length; // 已上传数量 let currentUploadedCount = 0; // 七牛SDK相关参数 const putPolicy = new qiniu.rs.PutPolicy({ scope: this.options.qiniu.bucket }); const uploadToken = putPolicy.uploadToken(this.mac); const config = new qiniu.conf.Config(); config.zone = qiniu.zone.Zone_z1; const formUploader = new qiniu.form_up.FormUploader() const putExtra = new qiniu.form_up.PutExtra(); // 因为是批量上传，需要在最后将错误对象回调 let globalError = null; // 遍历编译资源文件 for (const filename of Object.keys(compilation.assets)) { // 开始上传 formUploader.putFile( uploadToken, this.options.qiniu.keyPrefix + filename, path.resolve(compilation.outputOptions.path, filename), putExtra, (err) =&gt; { console.log(`uploade ${filename} result: ${err ? `Error:${err.message}` : 'Success'}`) currentUploadedCount++; if (err) { globalError = err; } if (currentUploadedCount === uploadCount) { globalError ? reject(globalError) : resolve(); } }); } }) }); }}module.exports = MyWebpackPlugin; Webpack中需要传递给该插件传递相关配置： 1234567891011121314151617181920module.exports = { entry: './src/index', target: 'node', output: { path: path.resolve(__dirname, 'build'), filename: '[name].js', publicPath: 'CDN域名' }, plugins: [ new CleanWebpackPlugin(), new QiniuWebpackPlugin({ qiniu: { accessKey: '七牛AccessKey', secretKey: '七牛SecretKey', bucket: 'static', keyPrefix: 'webpack-inaction/demo1/' } }) ]}; 编译完成后资源会自动上传到七牛CDN，这样前端只用交付index.html即可。 小结至此，Webpack相关常用知识和进阶知识都介绍完毕，需要各位读者在工作中去多加探索，Webpack配合Node.js生态，一定会涌现出更多优秀的新语言和新工具！","link":"/2020/03/18/2020-03-18-webpack-plugin-development.html"},{"title":"Golang Http 验证码示例","text":"验证码（CAPTCHA）是“Completely Automated Public Turing test to tell Computers and Humans Apart”（全自动区分计算机和人类的图灵测试）的缩写，是一种区分用户是计算机还是人的公共全自动程序。可以防止：恶意破解密码、刷票、论坛灌水，有效防止某个黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试，实际上用验证码是现在很多网站通行的方式，我们利用比较简易的方式实现了这个功能。这个问题可以由计算机生成并评判，但是必须只有人类才能解答。由于计算机无法解答CAPTCHA的问题，所以回答出问题的用户就可以被认为是人类。 传统网站验证码工作机制 客户端请求服务器获取验证码图片 服务器生成随机串(验证码值)写入Session，并将验证码值写入到图片中返回给客户端 客户端输入图片上的字符串提交给服务器验证 服务器比对客户端提交的字符串值和 Session 中是否匹配，如果匹配则通过验证 由于服务器生成的验证码值从始至终均未返回给客户端，因此，客户端只能从图片中识别验证码字符串，从而保证人机校验逻辑。 Go的HTTP验证码思路Go 语言的 HTTP 服务器默认不支持 Session，因此验证码值需要换个思路存储，以下是不使用 Session 的逻辑 客户端请求服务器获取验证码ID 服务器生成验证码 ID，并生成验证码值，将 ID 和值的映射关系记录到内存或缓存，并将 ID 返回给客户端 客户端根据返回的 ID 请求服务器获取验证码图片 服务器获取到验证码 ID，从内存或缓存中取出验证码值，将该值写入图片并将图片返回给客户端 客户端提交验证码 ID（第1步获得）和验证码值给服务器验证 服务器获取验证码 ID，从内存或缓存中取出验证码值与客户端提交的验证码值比对 示例 安装验证码依赖 1github.com/dchest/captcha 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package mainimport ( &quot;fmt&quot; &quot;github.com/dchest/captcha&quot; &quot;log&quot; &quot;net/http&quot;)func main() { // 获取验证码 ID http.HandleFunc(&quot;/captcha/generate&quot;, func(w http.ResponseWriter, r *http.Request) { id := captcha.NewLen(6) if _, err := fmt.Fprint(w, id); err != nil { log.Println(&quot;generate captcha error&quot;, err) } }) // 获取验证码图片 http.HandleFunc(&quot;/captcha/image&quot;, func(w http.ResponseWriter, r *http.Request) { id := r.URL.Query().Get(&quot;id&quot;) if id == &quot;&quot; { http.Error(w, &quot;Bad Request&quot;, http.StatusBadRequest) return } w.Header().Set(&quot;Content-Type&quot;, &quot;image/png&quot;) if err := captcha.WriteImage(w, id, 120, 80); err != nil { log.Println(&quot;show captcha error&quot;, err) } }) // 业务处理 http.HandleFunc(&quot;/login&quot;, func(w http.ResponseWriter, r *http.Request) { if err := r.ParseForm(); err != nil { log.Println(&quot;parseForm error&quot;, err) http.Error(w, &quot;Internal Error&quot;, http.StatusInternalServerError) return } // 获取验证码 ID 和验证码值 id := r.FormValue(&quot;id&quot;) value := r.FormValue(&quot;value&quot;) // 比对提交的验证码值和内存中的验证码值 if captcha.VerifyString(id, value) { fmt.Fprint(w, &quot;ok&quot;) } else { fmt.Fprint(w, &quot;mismatch&quot;) } }) log.Fatal(http.ListenAndServe(&quot;:8080&quot;, nil))} 运行 访问/captcha/generate获得验证码 ID 访问/captcha/image?id=验证码 ID 访问/login，并输入第一步的验证码 ID 和第二步的验证码值即可查看验证结果 项目地址https://github.com/xialeistudio/go-http-captcha-example","link":"/2020/08/20/2020-08-20-golang-http-captcha-example.html"},{"title":"Laravel定时任务写入日志用户变为root导致Web进程无法写入日志问题","text":"今天访问接口时返回 接口写入日志失败，通过排查后发现 storage/logs下面出现了root用户新建的日志，导致www用户无法写入日志。 通过排查发现，crontab写入了laravel的定时任务命令。默认情况下，crontab的任务是使用root用户去执行的，因此laravel定时任务新建的文件属主自然成为了root。 解决方法解决方法就是使用指定用户来运行 crontab 任务。比如使用www用户来运行laravel的计划任务命令。 使用下面的命令编辑www用户的定时任务。 1crontab -u www -e 例如写入下面的示例任务： 1* * * * * /usr/local/php/bin/php /data/wwwroot/laravel/artisan schedule:run &gt;&gt; /var/log/laravel-crontab.log 2&gt;&amp;1 保存即可，等待系统运行任务。 运行时错误通过观察发现定时任务并没有成功运行，通过查询/var/log/cron日志发现如下的日志： 12(www) CMD (/usr/local/php/bin/php /data/wwwroot/laravel/artisan schedule:run &gt;&gt; /var/log/laravel-crontab.log 2&gt;&amp;1)(CRON) ERROR chdir failed (/home/www): No such file or directory 可以看到，定时任务确实有执行，但是执行出错。出现这个问题的原因是www 用户没有主目录。 解决方案如下： 新建/home/www目录 将/home/www的用户属主改为www用户 相关命令如下： 12mkdir /home/wwwchown -R www:www /home/www 后续执行没有再出现错误。","link":"/2020/10/20/2020-10-20-laravel-crontab-log-permission.html"},{"title":"Golang组件化网络服务器框架Halia指南","text":"写在前面在netty框架面世之前，几乎没有一个成熟的OOP/组件化规范指导网络服务器开发，一些常用的FrameDecoder,BusinessHandler等等组件紧密耦合在了项目当中，整个项目可以说扩展性比较差。 netty的出现可以说是划时代的，基于OOP/组件化屏蔽了底层 BlockingIO/NonBlockingIO/AsynchrousIO之间的差异，各种组件可以无缝切换，网络服务器开发效率有了非常大的提高。 通过阅读netty源码，以及核心组件的架构，基于Golang进行了实现，至此，Golang的Halia框架面世了！ Halia特性组件化/可扩展Halia框架面向接口编程，并提供默认实现，同时内置常用的解码器，真正做到开箱即用。 高性能基于Golang原生网络库进行开发，无第三方依赖，性能有保障。 易用性Halia框架采用极简设计，没有冗余代码，并附带3个常用解码器示例，助您基于Halia快速开始开发。 开源免费Halia框架基于MIT开源协议发布，无论是商用以及非商用都可以免费使用。 社区驱动Halia框架托管于Github，任何人都可以贡献一臂之力。 快速开始接下来将演示如何开发一个时间回显服务器。 客户端每隔1秒发送时间字符串给服务器，服务器回显该数据。 公用代码encoder.go字符串编码器，将字符串转换为[]byte传输到下一个出站处理器 12345678910111213141516171819202122package mainimport ( &quot;halia/channel&quot;)type StringToByteEncoder struct{}// 编码器不处理处理，交由下一个处理器(也就是业务处理器)处理func (e *StringToByteEncoder) OnError(c channel.HandlerContext, err error) { c.FireOnError(err)}func (e *StringToByteEncoder) Write(c channel.HandlerContext, msg interface{}) error { if str, ok := msg.(string); ok { // string才转换 return c.Write([]byte(str)) } return c.Write(msg)}func (e *StringToByteEncoder) Flush(c channel.HandlerContext) error { return c.Flush()} 客户端代码handler.go客户端业务处理代码。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package mainimport ( &quot;fmt&quot; log &quot;github.com/sirupsen/logrus&quot; &quot;halia/channel&quot; &quot;strings&quot; &quot;time&quot;)type EchoClientHandler struct { log *log.Entry}func NewEchoClientHandler() *EchoClientHandler { return &amp;EchoClientHandler{ log: log.WithField(&quot;component&quot;, &quot;EchoClientHandler&quot;), }}// 发送错误回调func (p *EchoClientHandler) OnError(c channel.HandlerContext, err error) { p.log.WithField(&quot;peer&quot;, c.Channel().RemoteAddr()).Warnln(&quot;error caught&quot;, err)}// 连接已建立func (p *EchoClientHandler) ChannelActive(c channel.HandlerContext) { p.log.WithField(&quot;peer&quot;, c.Channel().RemoteAddr()).Infoln(&quot;connected&quot;) if err := c.WriteAndFlush(&quot;Hello World\\r\\n&quot;); err != nil { p.log.WithError(err).Warnln(&quot;write error&quot;) } p.log.Infof(&quot;pipeline in: %v&quot;, strings.Join(c.Pipeline().InboundNames(), &quot;-&gt;&quot;)) p.log.Infof(&quot;pipeline out: %v&quot;, strings.Join(c.Pipeline().OutboundNames(), &quot;-&gt;&quot;))}// 连接已断开func (p *EchoClientHandler) ChannelInActive(c channel.HandlerContext) { p.log.WithField(&quot;peer&quot;, c.Channel().RemoteAddr()).Infoln(&quot;disconnected&quot;)}// 读取到完整的消息回调func (p *EchoClientHandler) ChannelRead(c channel.HandlerContext, msg interface{}) { data, ok := msg.([]byte) if !ok { p.log.WithField(&quot;peer&quot;, c.Channel().RemoteAddr()).Warnf(&quot;unknown msg type: %+v&quot;, msg) return } str := string(data) p.log.WithField(&quot;peer&quot;, c.Channel().RemoteAddr()).Infoln(&quot;receive &quot;, str) // 1秒后发送数据给服务器 time.AfterFunc(time.Second, func() { if err := c.WriteAndFlush(fmt.Sprintf(&quot;client say:%s\\r\\n&quot;, time.Now().String())); err != nil { p.log.WithError(err).Warnln(&quot;write error&quot;) } })} main.go123456789101112131415161718192021222324252627282930313233package mainimport ( log &quot;github.com/sirupsen/logrus&quot; &quot;halia/bootstrap&quot; &quot;halia/channel&quot; &quot;halia/handler/codec&quot; &quot;net&quot; &quot;os&quot;)func init() { log.SetOutput(os.Stdout) log.SetLevel(log.DebugLevel)}func main() { client := bootstrap.NewClient(&amp;bootstrap.ClientOptions{ // 将原始net.Conn包装为Channel实现，一般情况下用DefaultChannel即可 ChannelFactory: func(conn net.Conn) channel.Channel { c := channel.NewDefaultChannel(conn) // 添加解码器，换行符分割报文解码器 c.Pipeline().AddInbound(&quot;decoder&quot;, codec.NewLineBasedFrameDecoder()) // 添加业务处理器 c.Pipeline().AddInbound(&quot;handler&quot;, NewEchoClientHandler()) // 添加编码器 c.Pipeline().AddOutbound(&quot;encoder&quot;, &amp;StringToByteEncoder{}) return c }, }) // 连接服务器 log.WithField(&quot;component&quot;, &quot;client&quot;).Fatal(client.Dial(&quot;tcp&quot;, &quot;127.0.0.1:8080&quot;))} 服务端代码handler.go123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package mainimport ( log &quot;github.com/sirupsen/logrus&quot; &quot;halia/channel&quot; &quot;strings&quot;)type EchoServerHandler struct { log *log.Entry}func NewEchoServerHandler() *EchoServerHandler { return &amp;EchoServerHandler{ log: log.WithField(&quot;component&quot;, &quot;EchoServerHandler&quot;), }}func (p *EchoServerHandler) OnError(c channel.HandlerContext, err error) { p.log.WithField(&quot;peer&quot;, c.Channel().RemoteAddr()).Warnln(&quot;error caught&quot;, err)}func (p *EchoServerHandler) ChannelActive(c channel.HandlerContext) { p.log.WithField(&quot;peer&quot;, c.Channel().RemoteAddr()).Infoln(&quot;connected&quot;) p.log.Infof(&quot;pipeline in: %v&quot;, strings.Join(c.Pipeline().InboundNames(), &quot;-&gt;&quot;)) p.log.Infof(&quot;pipeline out: %v&quot;, strings.Join(c.Pipeline().OutboundNames(), &quot;-&gt;&quot;))}func (p *EchoServerHandler) ChannelInActive(c channel.HandlerContext) { p.log.WithField(&quot;peer&quot;, c.Channel().RemoteAddr()).Infoln(&quot;disconnected&quot;) p.log.Infof(&quot;pipeline in: %v&quot;, strings.Join(c.Pipeline().InboundNames(), &quot;-&gt;&quot;)) p.log.Infof(&quot;pipeline out: %v&quot;, strings.Join(c.Pipeline().OutboundNames(), &quot;-&gt;&quot;))}func (p *EchoServerHandler) ChannelRead(c channel.HandlerContext, msg interface{}) { data, ok := msg.([]byte) if !ok { p.log.WithField(&quot;peer&quot;, c.Channel().RemoteAddr()).Warnf(&quot;unknown msg type: %+v&quot;, msg) return } str := string(data) p.log.WithField(&quot;peer&quot;, c.Channel().RemoteAddr()).Infoln(&quot;receive &quot;, str) if err := c.Write(&quot;server:&quot; + str + &quot;\\r\\n&quot;); err != nil { p.log.WithField(&quot;peer&quot;, c.Channel().RemoteAddr()).WithError(err).Warnln(&quot;write error&quot;) }} main.go1234567891011121314151617181920212223242526272829package mainimport ( log &quot;github.com/sirupsen/logrus&quot; &quot;halia/bootstrap&quot; &quot;halia/channel&quot; &quot;halia/handler/codec&quot; &quot;net&quot; &quot;os&quot;)func init() { log.SetOutput(os.Stdout) log.SetLevel(log.DebugLevel)}func main() { s := bootstrap.NewServer(&amp;bootstrap.ServerOptions{ ChannelFactory: func(conn net.Conn) channel.Channel { c := channel.NewDefaultChannel(conn) c.Pipeline().AddInbound(&quot;decoder&quot;, codec.NewLineBasedFrameDecoder()) c.Pipeline().AddInbound(&quot;handler&quot;, NewEchoServerHandler()) c.Pipeline().AddOutbound(&quot;encoder&quot;, &amp;StringToByteEncoder{}) return c }, }) log.WithField(&quot;component&quot;, &quot;server&quot;).Fatal(s.Listen(&quot;tcp&quot;, &quot;0.0.0.0:8080&quot;))} 运行先运行服务端，再运行客户端。 服务端输出 12345678910time=&quot;2021-01-12T11:30:13+08:00&quot; level=info msg=started addr=&quot;0.0.0.0:8080&quot; component=server network=tcp pid=7584time=&quot;2021-01-12T11:30:13+08:00&quot; level=info msg=initialized component=channelId machineId=a0c5895a25a3 pid=7584time=&quot;2021-01-12T11:30:18+08:00&quot; level=info msg=connected component=EchoServerHandler peer=&quot;127.0.0.1:57641&quot;time=&quot;2021-01-12T11:30:18+08:00&quot; level=info msg=&quot;pipeline in: InHeadContext-&gt;decoder-&gt;handler&quot; component=EchoServerHandlertime=&quot;2021-01-12T11:30:18+08:00&quot; level=info msg=&quot;pipeline out: OutHeadContext-&gt;encoder-&gt;OutTailContext&quot; component=EchoServerHandlertime=&quot;2021-01-12T11:30:18+08:00&quot; level=info msg=&quot;receive Hello World&quot; component=EchoServerHandler peer=&quot;127.0.0.1:57641&quot;time=&quot;2021-01-12T11:30:19+08:00&quot; level=info msg=&quot;receive client say:2021-01-12 11:30:19.5192868 +0800 CST m=+1.046443501&quot; component=EchoServerHandler peer=&quot;127.0.0.1:57641&quot;time=&quot;2021-01-12T11:30:20+08:00&quot; level=info msg=&quot;receive client say:2021-01-12 11:30:20.5193884 +0800 CST m=+2.046545101&quot; component=EchoServerHandler peer=&quot;127.0.0.1:57641&quot;time=&quot;2021-01-12T11:30:21+08:00&quot; level=info msg=&quot;receive client say:2021-01-12 11:30:21.5345887 +0800 CST m=+3.061745401&quot; component=EchoServerHandler peer=&quot;127.0.0.1:57641&quot;time=&quot;2021-01-12T11:30:22+08:00&quot; level=info msg=&quot;receive client say:2021-01-12 11:30:22.5459978 +0800 CST m=+4.073154501&quot; component=EchoServerHandler peer=&quot;127.0.0.1:57641&quot; 客户端输出 123456789time=&quot;2021-01-12T11:30:18+08:00&quot; level=info msg=connected component=EchoClientHandler peer=&quot;127.0.0.1:8080&quot;time=&quot;2021-01-12T11:30:18+08:00&quot; level=info msg=&quot;pipeline in: InHeadContext-&gt;decoder-&gt;handler&quot; component=EchoClientHandlertime=&quot;2021-01-12T11:30:18+08:00&quot; level=info msg=&quot;pipeline out: OutHeadContext-&gt;encoder-&gt;OutTailContext&quot; component=EchoClientHandlertime=&quot;2021-01-12T11:30:18+08:00&quot; level=info msg=&quot;receive server:Hello World&quot; component=EchoClientHandler peer=&quot;127.0.0.1:8080&quot;time=&quot;2021-01-12T11:30:18+08:00&quot; level=info msg=initialized component=channelId machineId=a0c5895a25a3 pid=960time=&quot;2021-01-12T11:30:19+08:00&quot; level=info msg=&quot;receive server:client say:2021-01-12 11:30:19.5192868 +0800 CST m=+1.046443501&quot; component=EchoClientHandler peer=&quot;127.0.0.1:8080&quot;time=&quot;2021-01-12T11:30:20+08:00&quot; level=info msg=&quot;receive server:client say:2021-01-12 11:30:20.5193884 +0800 CST m=+2.046545101&quot; component=EchoClientHandler peer=&quot;127.0.0.1:8080&quot;time=&quot;2021-01-12T11:30:21+08:00&quot; level=info msg=&quot;receive server:client say:2021-01-12 11:30:21.5345887 +0800 CST m=+3.061745401&quot; component=EchoClientHandler peer=&quot;127.0.0.1:8080&quot;time=&quot;2021-01-12T11:30:22+08:00&quot; level=info msg=&quot;receive server:client say:2021-01-12 11:30:22.5459978 +0800 CST m=+4.073154501&quot; component=EchoClientHandler peer=&quot;127.0.0.1:8080&quot; 写在后面Halia期待您的贡献！ 文档地址 仓库地址","link":"/2021/01/12/2021-01-12-golang-halia-get-started.html"},{"title":"golang依赖注入工具wire指南","text":"wire与依赖注入Wire 是一个的Golang依赖注入工具，通过自动生成代码的方式在编译期完成依赖注入，Java体系中最出名的Spring框架采用运行时注入，个人认为这是wire和其他依赖注入最大的不同之处。 依赖注入(Dependency Injection)也称作控制反转(Inversion of Control)，个人给控制反转下的定义如下： 当前对象需要的依赖对象由外部提供（通常是IoC容器），外部负责依赖对象的构造等操作，当前对象只负责调用，而不关心依赖对象的构造。即依赖对象的控制权交给了IoC容器。 下面给出一个控制反转的示例，比如我们通过配置去创建一个数据库连接： 123456789101112131415161718192021222324252627282930313233343536373839// 连接配置type DatabaseConfig struct { Dsn string }func NewDB(config *DatabaseConfig)(*sql.DB, error) { db,err := sql.Open(&quot;mysql&quot;, config.Dsn) if err != nil { return nil, err } // ...}fun NewConfig()(*DatabaseConfig,error) { // 读取配置文件 fp, err := os.Open(&quot;config.json&quot;) if err != nil { return nil,err } defer fp.Close() // 解析为Json var config DatabaseConfig if err:=json.NewDecoder(fp).Decode(&amp;config);err!=nil { return nil,err } return &amp;config, nil}func InitDatabase() { cfg, err:=NewConfig() if err!=nil { log.Fatal(err) } db,err:=NewDB(cfg) if err!=nil { log.Fatail(err) } // db对象构造完毕} 数据库配置怎么来的，NewDB方法并不关心(示例代码采用的是NewConfig提供的JSON配置对象)，NewDB只负责创建DB对象并返回，和配置方式并没有耦合，所以即使换成配置中心或者其他方式来提供配置，NewDB代码也无需更改，这就是控制反转的魔力！ 来看一个反面例子，也就是控制正转： 当前对象需要的依赖由自己创建，即依赖对象的控制权在当前对象自己手里。 1234567891011121314151617181920212223type DatabaseConfig struct { Dsn string }func NewDB()(*sql.DB, error) { // 读取配置文件 fp, err := os.Open(&quot;config.json&quot;) if err != nil { return nil,err } defer fp.Close() // 解析为Json var config DatabaseConfig if err:=json.NewDecoder(fp).Decode(&amp;config);err!=nil { return nil,err } // 初始化数据库连接 db,err = sql.Open(&quot;mysql&quot;, config.Dsn) if err != nil { return } // ...} 在控制正转模式下，NewDB方法需要自己实现配置对象的创建工作，在示例中需要读取Json配置文件，这是强耦合的代码，一旦配置文件的格式不是Json，NewDB方法将返回错误。 依赖注入固然好用，但是像刚才的例子中去手动管理依赖关系是相当复杂也是相当痛苦的一件事，因此在接下来的内容中会重点介绍golang的依赖注入工具——wire。 上手使用通过go get github.com/google/wire/cmd/wire安装好wire命令行工具即可。 在正式开始之前需要介绍一下wire中的两个概念：Provider和Injector： Provider：负责创建对象的方法，比如上文中控制反转示例的NewDB(提供DB对象)和NewConfig(提供DatabaseConfig对象)方法。 Injector：负责根据对象的依赖，依次构造依赖对象，最终构造目的对象的方法，比如上文中控制反转示例的InitDatabase方法。 现在我们通过wire来实现一个简单的项目。项目结构如下： 12345678910|--cmd |--main.go |--wire.go|--config |--app.json|--internal |--config |--config.go |--db |--db.go config/app.json 12345{ &quot;database&quot;: { &quot;dsn&quot;: &quot;root:root@tcp(localhost:3306)/test&quot; }} internal/config/config.go 12345678910111213141516171819202122232425262728293031package configimport ( &quot;encoding/json&quot; &quot;github.com/google/wire&quot; &quot;os&quot;)var Provider = wire.NewSet(New) // 将New方法声明为Provider，表示New方法可以创建一个被别人依赖的对象,也就是Config对象type Config struct { Database database `json:&quot;database&quot;`}type database struct { Dsn string `json:&quot;dsn&quot;`}func New() (*Config, error) { fp, err := os.Open(&quot;config/app.json&quot;) if err != nil { return nil, err } defer fp.Close() var cfg Config if err := json.NewDecoder(fp).Decode(&amp;cfg); err != nil { return nil, err } return &amp;cfg, nil} internal/db/db.go 123456789101112131415161718192021package dbimport ( &quot;database/sql&quot; _ &quot;github.com/go-sql-driver/mysql&quot; &quot;github.com/google/wire&quot; &quot;wire-example2/internal/config&quot;)var Provider = wire.NewSet(New) // 同理func New(cfg *config.Config) (db *sql.DB, err error) { db, err = sql.Open(&quot;mysql&quot;, cfg.Database.Dsn) if err != nil { return } if err = db.Ping(); err != nil { return } return db, nil} cmd/main.go 123456789101112131415161718192021222324252627package mainimport ( &quot;database/sql&quot; &quot;log&quot;)type App struct { // 最终需要的对象 db *sql.DB}func NewApp(db *sql.DB) *App { return &amp;App{db: db}}func main() { app, err := InitApp() // 使用wire生成的injector方法获取app对象 if err != nil { log.Fatal(err) } var version string row := app.db.QueryRow(&quot;SELECT VERSION()&quot;) if err := row.Scan(&amp;version); err != nil { log.Fatal(err) } log.Println(version)} cmd/wire.go 重点文件，也就是实现Injector的核心所在： 12345678910111213// +build wireinjectpackage mainimport ( &quot;github.com/google/wire&quot; &quot;wire-example2/internal/config&quot; &quot;wire-example2/internal/db&quot;)func InitApp() (*App, error) { panic(wire.Build(config.Provider, db.Provider, NewApp)) // 调用wire.Build方法传入所有的依赖对象以及构建最终对象的函数得到目标对象} 文件编写完毕，进入cmd目录执行wire命令会得到以下输出： 12C:\\Users\\Administrator\\GolandProjects\\wire-example2\\cmd&gt;wirewire: wire-example2/cmd: wrote C:\\Users\\Administrator\\GolandProjects\\wire-example2\\cmd\\wire_gen.go 表明成功生成wire_gen.go文件，文件内容如下： 1234567891011121314151617181920212223242526// Code generated by Wire. DO NOT EDIT.//go:generate go run github.com/google/wire/cmd/wire//+build !wireinjectpackage mainimport ( &quot;wire-example2/internal/config&quot; &quot;wire-example2/internal/db&quot;)// Injectors from wire.go:func InitApp() (*App, error) { configConfig, err := config.New() if err != nil { return nil, err } sqlDB, err := db.New(configConfig) if err != nil { return nil, err } app := NewApp(sqlDB) return app, nil} 可以看到生成App对象的代码已经自动生成了。 Provider说明通过NewSet方法将本包内创建对象的方法声明为Provider以供其他对象使用。NewSet可以接收多个参数，比如我们db包内可以创建Mysql和Redis连接对象，则可以如下声明： 12345678var Provider = wire.NewSet(NewDB, NewRedis)func NewDB(config *Config)(*sql.DB,error) { // 创建数据库对象 }func NewRedis(config *Config)(*redis.Client,error) { // 创建Redis对象} wire.go文件说明wire.go文件需要放在创建目标对象的地方，比如我们Config和DB对象最终是为App服务的，因此wire.go文件需要放在App所在的包内。 wire.go文件名不是固定的，不过大家习惯叫这个文件名。 wire.go的第一行// +build wireinject是必须的，含义如下： 只有添加了名称为”wireinject”的build tag，本文件才会编译，而我们go build main.go的时候通常不会加。因此，该文件不会参与最终编译。 wire.Build(config.Provider, db.Provider, NewApp)通过传入config以及db对象来创建最终需要的App对象 wire_gen.go文件说明该文件由wire自动生成，无需手工编辑！！！ //+build !wireinject标签和wire.go文件的标签相对应，含义如下： 编译时只有未添加“wireinject”的build tag，本文件才参与编译。 因此，任意时刻下，wire.go和wire_gen.go只会有一个参与编译。 高级玩法cleanup函数在创建依赖资源时，如果由某个资源创建失败，那么其他资源需要关闭的情况下，可以使用cleanup函数来关闭资源。比如咱们给db.New方法返回一个cleanup函数来关闭数据库连接，相关代码修改如下(未列出的代码不修改)： internal/db/db.go 12345678910111213func New(cfg *config.Config) (db *sql.DB, cleanup func(), err error) { // 声明第二个返回值 db, err = sql.Open(&quot;mysql&quot;, cfg.Database.Dsn) if err != nil { return } if err = db.Ping(); err != nil { return } cleanup = func() { // cleanup函数中关闭数据库连接 db.Close() } return db, cleanup, nil} cmd/wire.go 123func InitApp() (*App, func(), error) { // 声明第二个返回值 panic(wire.Build(config.Provider, db.Provider, NewApp))} cmd/main.go 12345678910111213func main() { app, cleanup, err := InitApp() // 添加第二个参数 if err != nil { log.Fatal(err) } defer cleanup() // 延迟调用cleanup关闭资源 var version string row := app.db.QueryRow(&quot;SELECT VERSION()&quot;) if err := row.Scan(&amp;version); err != nil { log.Fatal(err) } log.Println(version)} 重新在cmd目录执行wire命令，生成的wire_gen.go如下： 1234567891011121314func InitApp() (*App, func(), error) { configConfig, err := config.New() if err != nil { return nil, nil, err } sqlDB, cleanup, err := db.New(configConfig) if err != nil { return nil, nil, err } app := NewApp(sqlDB) return app, func() { // 返回了清理函数 cleanup() }, nil} 接口绑定在面向接口编程中，代码依赖的往往是接口，而不是具体的struct，此时依赖注入相关代码需要做一点小小的修改，继续刚才的例子，示例修改如下： 新增internal/db/dao.go 123456789101112131415161718192021222324package dbimport &quot;database/sql&quot;type Dao interface { // 接口声明 Version() (string, error)}type dao struct { // 默认实现 db *sql.DB}func (d dao) Version() (string, error) { var version string row := d.db.QueryRow(&quot;SELECT VERSION()&quot;) if err := row.Scan(&amp;version); err != nil { return &quot;&quot;, err } return version, nil}func NewDao(db *sql.DB) *dao { // 生成dao对象的方法 return &amp;dao{db: db}} internal/db/db.go也需要修改Provider，增加NewDao声明: 1var Provider = wire.NewSet(New, NewDao) cmd/main.go文件修改： 123456789101112131415161718192021222324252627package mainimport ( &quot;log&quot; &quot;wire-example2/internal/db&quot;)type App struct { dao db.Dao // 依赖Dao接口}func NewApp(dao db.Dao) *App { // 依赖Dao接口 return &amp;App{dao: dao}}func main() { app, cleanup, err := InitApp() if err != nil { log.Fatal(err) } defer cleanup() version, err := app.dao.Version() // 调用Dao接口方法 if err != nil { log.Fatal(err) } log.Println(version)} 进入cmd目录执行wire命令，此时会出现报错： 12345C:\\Users\\Administrator\\GolandProjects\\wire-example2\\cmd&gt;wirewire: C:\\Users\\Administrator\\GolandProjects\\wire-example2\\cmd\\wire.go:11:1: inject InitApp: no provider found for wire-example2/internal/db.Dao needed by *wire-example2/cmd.App in provider &quot;NewApp&quot; (C:\\Users\\Administrator\\GolandProjects\\wire-example2\\cmd\\main.go:12:6)wire: wire-example2/cmd: generate failedwire: at least one generate failure wire提示inject InitApp: no provider found for wire-example2/internal/db.Dao，也就是没找到能提供db.Dao对象的Provider，咱们不是提供了默认的db.dao实现也注册了Provider吗？这也是go的OOP设计奇特之处。 咱们修改一下internal/db/db.go的Provider声明，增加db.*dao和db.Dao的接口绑定关系: 1var Provider = wire.NewSet(New, NewDao, wire.Bind(new(Dao), new(*dao))) wire.Bind()方法第一个参数为interface{}，第二个参数为实现。 此时再执行wire命令就可以成功了！ 结尾wire工具还有很多玩法，但是就笔者个人工作经验而言，掌握本文介绍到的知识已经能够胜任绝大部分场景了！","link":"/2021/02/06/2021-02-06-go-wire-tutorial.html"},{"title":"修复GitTalk出现Forbidden问题","text":"GitTalk失效原因对于所有自建博客的博主来书，GitTalk应该不陌生。GitTalk通过Github的OpenAPI以及issues功能实现社区评论，确实是一大亮点。 今天在查看文章的时候发现评论区出现了Forbidden错误，通过检查网络请求发现获取Github Token时请求了以下链接 1https://cors-anywhere.herokuapp.com/https://github.com/login/oauth/access_token 通过查询GitTalk官方文档发现github.com的oauth是不允许跨域请求的，cors-anywhere.herokuapp.com是一个第三方提供的CORS代理服务，会默认放行所有CORS请求。目前由于该CORS代理服务遭到滥用，因此做了限制，导致GitTalk失效。 解决方案 通过自己的nginx进行反向代理转发即可。 修改gitalk初始化参数笔者使用的是hexo+icarus主题，其他主题或者博客系统也是类似做法。 编辑themes/icarus/layout/comment/gitalk.ejs 1234567891011121314&lt;script&gt; var gitalk = new Gitalk({ clientID: '&lt;%= get_config('comment.client_id') %&gt;', clientSecret: '&lt;%= get_config('comment.client_secret') %&gt;', id: '&lt;%= md5(page.path) %&gt;', repo: '&lt;%= get_config('comment.repo') %&gt;', owner: '&lt;%= get_config('comment.owner') %&gt;', admin: &lt;%- JSON.stringify(get_config('comment.admin'))%&gt;, createIssueManually: &lt;%= get_config('comment.create_issue_manually', false) %&gt;, distractionFreeMode: &lt;%= get_config('comment.distraction_free_mode', false) %&gt;, proxy: '/github/login/oauth/access_token' // 新添加的 }) gitalk.render('comment-container')&lt;/script&gt; nginx配置编辑nginx配置，笔者的博客域名为www.ddhigh.com，因此需要限制CORS来源域名，否则将有盗用风险! 123456789location /github { add_header Access-Control-Allow-Origin www.ddhigh.com; add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS'; add_header Access-Control-Allow-Headers 'DNT,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization'; if ($request_method = 'OPTIONS') { return 204; } proxy_pass https://github.com/; # 尾部斜杠不能少} 执行nginx -s reload配置。 访问测试访问新写的文章https://www.ddhigh.com/2021/02/25/golang-get-started.html，可以看到界面上已经正常了。 查看Chrome网络状况，可以看到已经走了自己配置的CORS跨域了。 12345Request URL: https://www.ddhigh.com/github/login/oauth/access_tokenRequest Method: POSTStatus Code: 200 Remote Address: 106.52.24.199:443Referrer Policy: strict-origin-when-cross-origin","link":"/2021/02/25/2021-02-25-fix-gittalk-github.html"},{"title":"Go语言程序设计","text":"Go语言概述语言历史Go语言也称为Golang，是由Google公司开发的一种静态强类型、编译型、语言原生支持并发、具有垃圾回收功能的编程语言。起源于2007年，并在2009年正式对外发布。Go语言是非常年轻的一门语言，它的主要目标是“兼具 Python 等动态语言的开发速度和 C/C++等编译型语言的性能与安全性”。 Go语言是编程语言设计的又一次尝试，是对类C语言的重大改进，它不但能让你访问底层操作系统，还提供了强大的网络编程和并发编程支持。Go语言的用途众多，可以进行网络编程、系统编程、并发编程等等。 Go语言的推出，旨在不损失应用程序性能的情况下降低代码的复杂性，具有“部署简单、并发性好、语言设计良好、执行性能好”等优势。 Go语言有时候被描述为“21世纪的C语言”。Go 从C语言继承了相似的表达式语法、控制流结构、基础数据类型、调用参数传值、指针等很多思想，还有C语言编译后的运行效率。 Go语言没有类和继承的概念，通过组合来实现代码复用，同时它通过接口（interface）的概念来实现多态性。所以Go语言的面向对象编程和传统面向对象语言（如C++和Java）并不相同。 Go语言有一个吉祥物，在会议、文档页面和博文中，大多会包含下图所示的 Go Gopher，这是才华横溢的插画家 Renee French 设计的，她也是 Go 设计者之一 Rob Pike 的妻子。 语言特性语法简单 Go语言的设计思想类似Unix的“少即是多”。Go语言的语法规则严谨，没有歧义，这使得Go语言简单易学。Go语言保留了指针，但通常情况下禁止指针运算（保留unsafe包操作指针的能力）。此外，Go语言还内置切片和字典，在保留运行性能的同时也提高了开发效率。 语言级别支持并发 主流的并发模型有多进程模型、多线程模型。和主流多并发模型不同，Go语言采用了基于CSP的协程实现，并且在运行时做了更深度的优化处理。这使得语言级别上并发编程变得极为容易，无须处理回调、也无需关注线程切换，只需要添加一个go关键字即可。 “通过通信去共享内存，而不是通过共享内存去通信”，go语言内置的channel数据结构配合go关键字实现并发通信及控制，这对于需要考虑内存可见性等问题的多线程模型来说，是一个良好的解决方案。 高效的垃圾回收 Go语言的每次升级，垃圾回收器必然是核心组件里修改最多的部分。从并发清理，到降低STW时间，直到Go的1.5版本实现并发标记，逐步引入三色标记和写屏障等等，都是为了能让垃圾回收在不影响用户逻辑的情况下更好地工作。从最开始的秒级别STW到目前的微秒级STW，Go语言开发团队一直在垃圾回收方面进行努力。 静态链接 静态编译的好处显而易见。将运行时、依赖库直接打包到可执行文件内部，简化了部署和发布操作，无须事先安装运行环境和下载诸多第三方库。虽然相比动态编译增加了可执行文件的大小，但是省去了依赖库的管理。随着微服务和容器化的发展，这也成为了Go语言的杀手锏之一，一个二进制文件即可运行服务。 标准库 功能完善、质量可靠的标准库为编程语言提供了有力的支持。在不借助第三方扩展的情况下，就可完成大部分基础功能开发，这大大降低了学习和使用成本。 Go语言标准库可以说极为丰富。其中值得称道的是net/http，仅须简单几条语句就能实现一个高性能 Web Server。 工具链 完整的工具链对于项目开发极为重要。Go语言在此做得相当不错，无论是编译、格式化、错误检查、帮助文档，还是第三方包下载、更新都有对应的工具。 值得一提的gofmt工具，为了解决开发者经常遇到的“代码风格不统一”的难题，官方直接通过gofmt指定一套标准，可以看出go语言在工程方面确实解决了许多实际问题。 此外Go语言内置完整测试框架，其中包括单元测试、性能测试、代码覆盖率、数据竞争，以及用来调优的pprof，这些都是保障代码能正确而稳定运行的必备利器。 Go语言应用场景Go 语言从发布1.0版本以来备受众多开发者关注并得到广泛使用，Go 语言的简单、高效、并发特性吸引了众多传统语言开发者的加入，而且人数越来越多。 鉴于Go语言的特点和设计的初衷，Go语言作为服务器编程语言，很适合处理日志、数据打包、虚拟机处理、文件系统、分布式系统、数据库代理等；网络编程方面，Go语言广泛应用于Web应用、API应用、下载应用等；除此之外，Go语言还适用于内存数据库和云平台领域，目前国外很多云平台都是采用Go开发。 服务器编程。例如处理日志、数据打包、虚拟机处理、文件系统等。 分布式系统、数据库代理器、中间件等。例如Etcd。 网络编程。这一块目前应用最广，包括Web应用、API应用、下载应用等等。 开发云平台。目前国内外很多云平台在采用Go开发。 Go语言知名项目Go发布之后，很多公司特别是云计算公司开始用Go重构他们的基础架构，很多基础设施都是直接采用Go进行了开发，诞生了许多热门项目。 基础设施 代表项目：docker、kubernetes、etcd、consul等。 数据库 代表项目：influxdb、cockroachdb等。 微服务 代表项目：go-kit、micro、kratos等。 安装Go语言Go语言可用于FreeBSD、Linux、Windows和macOS等操作系统。有关对这些平台的要求，请参与Go语言网站列出的系统需求。 Go语言的官方网站为https://golang.org/，国内的用户可以访问https://golang.google.cn/dl/。通常情况下，按照本文的步骤进行安装不会出现问题，遇到安装问题的读者，请通过公众号与我联系。 Windows系统下载链接 32位下载地址：https://golang.google.cn/dl/go1.15.8.windows-386.msi 64位下载地址：https://golang.google.cn/dl/go1.15.8.windows-amd64.msi 默认安装到C:\\go目录下，建议不要更改安装目录。 GOPATH配置 安装完毕后需要配置GOPATH，GOPATH是Go语言用来存放第三方源码、二进制文件、类库等文件的路径。 例如系统用户名为demo，则需要新建以下三个目录： C:\\Users\\demo\\go\\src 存放源码 C:\\Users\\demo\\go\\pkg 存放类库 C:\\Users\\demo\\go\\bin 存在二进制文件 环境变量设置： 新增GOPATH，值为C:\\Users\\demo\\go 新增PATH（已存在则编辑），值为C:\\Users\\demo\\go\\bin Linux系统Linux具有众多发行版，如Ubuntu、CentOS、RedHat、Debian等等，所有发行版的安装步骤是一致的，区别是根据CPU架构选择不同的发布包。 常见的个人计算机CPU架构为amd64，下载amd64架构的发布包即可。 Linux配置命令 123456789101112131415161718# 下载压缩包wget https://golang.google.cn/dl/go1.15.8.linux-amd64.tar.gz# 移动到opt目录mv go1.15.8.linux-amd64.tar.gz /opt# 解压tar xf go1.15.8.linux-amd64.tar.gz# 新建GOPATH目录cd ~mkdir gocd gomkdir pkg src bin# 编辑 ~/.bashrc文件, 添加bin路径到PATH环境变量中echo 'GOPATH=用户主目录/go' &gt;&gt; ~/.bashrcecho 'PATH=/opt/go/bin:$GOPATH/bin:$PATH' &gt;&gt; ~/.bashrc# 更新环境变量source ~/.bashrc# 测试安装结果go version macOS系统Apple公司于2020年发布了采用M1芯片(arm64架构)的硬件产品，支持M1芯片的Go语言版本为1.16，根据CPU架构选择对应的pkg包安装即可。 amd64: https://golang.google.cn/dl/go1.15.8.darwin-amd64.pkg arm64: https://golang.google.cn/dl/go1.16.darwin-arm64.pkg macOS配置命令 123456789101112# 新建GOPATH目录cd ~mkdir gocd gomkdir pkg src bin# 编辑 ~/.bashrc文件, 添加bin路径到PATH环境变量中echo 'GOPATH=用户主目录/go' &gt;&gt; ~/.bashrcecho 'PATH=$GOPATH/bin:$PATH' &gt;&gt; ~/.bashrc# 更新环境变量source ~/.bashrc# 测试安装结果go version 配置集成开发环境本节将介绍如何在本地计算机上配置集成开发环境，以下步骤使用macOS版本作为示例，其他操作系统类似。 Visual Studio Code(简称VSCode)是由微软开发的、同时支持Windows、Linux和macOS操作系统的开源编辑器，它支持测试，并且内置了git功能，提供了丰富的语言支持与常用编程工具。 打开官方网站 https://code.visualstudio.com/，点击蓝色按钮下载即可。 新版本的VSCode不再内置中文语言包，需要安装语言包扩展。安装VSCode后打开VSCode编辑器，在扩展窗口中搜索“Chinese”，安装第一个即可。 用VSCode新建一个空项目，打开项目之后新建main.go，此时VSCode右下角会弹出Go工具链安装的提示，选择”Install All“即可。 编写HTTP服务器代码12345678910111213package mainimport ( &quot;io&quot; &quot;net/http&quot;)func main() { http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) { io.WriteString(w, &quot;hello world&quot;) }) http.ListenAndServe(&quot;:8080&quot;, nil)} 程序结构说明 package 关键字声明文件所在的包，每个go文件都必须声明。每个可执行程序都必须包含main包，程序的入口点为main包的func main函数 import 关键字声明需要导入的包，代码中需要使用http服务器相关方法，因此导入了http包 func main程序的入口点 编译并运行程序编译并运行文件是开发过程中的一个常见步骤，Go提供了完成这个步骤的快捷途径。 Go语言提供了build和run两个命令来编译运行Go程序： go build 会编译可执行文件，并不执行 go run 不会创建可执行文件，直接执行 使用go run运行HTTP服务器，之后通过浏览器打开即可。 小结本文介绍了Go语言的安装以及集成开发环境的配置。通过HTTP服务器演示了Go程序的开发过程。 下一章将学习Go语言的基本语法： 变量和常量 数据类型 运算符 条件语句 循环语句","link":"/2021/02/25/2021-02-25-golang-get-started.html"},{"title":"Golang程序设计——基本语法","text":"本文学习Go语言基本语法，例如变量和常量、数据类型、运算符、条件语句、循环语句。 变量和常量变量和常量是计算机程序不可或缺的部分。本节将介绍如何在Go程序中声明、使用变量和常量、还将介绍声明方式和作用域。 变量声明在Go语言中，声明变量的方式有多种。在前面的文章介绍过，Go语言是一种静态类型语言，因此声明变量时必须指明其类型。 例：声明string类型的变量。 1234567891011package mainimport &quot;fmt&quot;func main() { var s1 string = &quot;Hello World&quot; var s2 = &quot;Hello World&quot; var s3 string s3 = &quot;Hello World&quot; fmt.Println(s1, s2, s3)} 使用关键字var声明变量。 如果变量类型可以通过值推导则不用声明类型。s2通过值可以推导类型为string类型。 变量可以在声明后赋值，未赋值的变量值为该类型的零值。 变量的类型很重要，因为这决定了可将什么值赋给该变量。例如，对于类型为string的变量，不能将整数赋值给它。将不匹配的值赋值给变量时，将导致编译错误。 例：将string类型的值赋值给int类型的变量。 123456789package mainimport &quot;fmt&quot;func main() { var i int i = &quot;Hello World&quot; fmt.Println(i)} 编译该文件将导致编译错误。 123go build main.go # command-line-arguments./main.go:7:4: cannot use &quot;Hello World&quot; (type untyped string) as type int in assignment 多变量声明例：声明多个类型相同的变量并进行赋值（显式指定类型）。 12345678package mainimport &quot;fmt&quot;func main() { var s1, s2 string = &quot;S1&quot;, &quot;S2&quot; fmt.Println(s1, s2)} 例：声明多个类型不同的变量并进行赋值（不能显式指定类型）。 12345678package mainimport &quot;fmt&quot;func main() { var s1, i1= &quot;S1&quot;, 1 fmt.Println(s1, i1)} 例：声明多个类型不同的变量（显式指定类型）。 12345678910111213package mainimport &quot;fmt&quot;func main() { var ( s1 string i1 int ) s1 = &quot;Hello&quot; i1 = 10 fmt.Println(s1, i1)} 声明变量后可以再次赋值，但是同一个变量只允许声明一次，否则将导致编译错误。 简短变量声明在函数中声明变量时，可以用更简洁的方式。 12345678package mainimport &quot;fmt&quot;func main() { s1 := &quot;Hello World&quot; fmt.Println(s1)} :=表示简短变量声明，可以不使用var，不指定类型，但是必须进行赋值。 只能在函数中使用简短变量声明。 变量声明最佳实践Go语言提供了多种变量声明方式，下面的声明方式都是合法的。 12345var s string = &quot;Hello&quot;var s1 = &quot;Hello&quot;var s2 strings2 = &quot;Hello&quot;s3 := &quot;Hello&quot; 该使用哪种方式呢？ Go语言对此有一个限制——只能在函数内部使用简短变量声明，在函数外部必须使用var进行声明。 在标准库中遵循的约定如下：有初始值的情况下，在函数内使用简短变量声明，在函数外使用var并省略类型；无初始值的情况下使用var并指定类型。 12345678910package mainimport &quot;fmt&quot;var s = &quot;Hello World&quot;func main() { s1 := &quot;Hello World&quot; fmt.Println(s, s1)} 变量和零值在Go语言中，声明变量时如果未初始化，则变量为默认值，该默认值也称为零值。在其他语言中未初始化的值为null或undefined。 1234567891011package mainimport &quot;fmt&quot;func main() { var s string var i int var b bool var f float32 fmt.Printf(&quot;%v %v %v %v\\n&quot;, s, i, b, f)} 在Go语言中，检查变量是否为空，必须与该类型的零值比较。例如检测string类型的变量是否为空，可以与””判定。 12345678910package mainimport &quot;fmt&quot;func main() { var s string if s == &quot;&quot; { fmt.Println(&quot;s为空&quot;) }} 变量作用域作用域指变量可以在什么地方使用，而不是说变量在哪里声明的。Go语言使用基于块的词法作用域，简单来说就是{}会产生一个作用域。 Go语言作用域规则如下： 一对大括号({})表示一个块，块是可以嵌套的 对于在块内声明的变量，可以在本块以及子块中访问 子块可以访问父块的变量，父块不能访问子块的变量 例：Go语言的作用域。 12345678910111213141516171819package mainimport &quot;fmt&quot;func main() { var s1 = &quot;s1&quot; { var s2 = &quot;s2&quot; // 可以访问s1,s2 fmt.Println(s1, s2) { var s3 = &quot;s3&quot; // 可以访问s1,s2,s3 fmt.Println(s1, s2, s3) } } // 只能访问s1 fmt.Println(s1)} 简单来说，就是块内可以访问块外的变量，块外不能访问块内变量。 声明常量常量只在整个程序运行过程中都不变的值，常量必须在声明时赋值，声明后不可以更改。 Go语言使用const关键字声明常量。 1234567891011package mainimport &quot;fmt&quot;const s = &quot;Hello&quot;func main() { const s2 = &quot;World&quot; const s3,s4 = &quot;Hello&quot;,&quot;World&quot; fmt.Println(s, s2)} 常量也支持一次声明多个，此外常量的作用域和变量作用域一致。 数据类型Go语言提供了丰富的数据类型，按类别分为布尔型、数值型（整数、浮点数、复数）、字符串型 、派生型。其中派声型包括指针类型、数组类型、结构体类型、接口类型、Channel类型、函数类型、切片类型和Map类型。 派生类型我们将在后面的内容中进行介绍。 布尔类型布尔类型值只能为true或false。某些语言允许使用1和0来表示true和false，但Go语言不允许。 布尔类型的零值为false。 123456789101112package mainimport &quot;fmt&quot;func main() { var b bool if b { fmt.Println(&quot;b是true&quot;) } else { fmt.Println(&quot;b是false&quot;) }} 数值型Go语言中数值型包含整数、浮点数以及复数。 整数型 类型 字节数 范围 byte 1 0 ~ 28 uint8 1 0 ~ 28 int8 1 -27 ~ 27-1 uint16 2 0 ~ 216 int16 2 -215 ~ 215-1 uint32 4 0 ~ 232 int32 4 -231 ~ 231-1 uint64 8 0 ~ 264 int64 8 263 ~ 263-1 int 平台相关(32位或64位) uint 平台相关(32位或64位) 浮点数 类型 字节数 范围 float32 4 -3.403E38 ~ 3.403E38 float64 8 -1.798E308 ~ 1.798E308 复数 略 字符串类型字符串可以是任何字符序列，包括数字、字母和符号。Go语言使用Unicode来存储字符串，因此可以支持世界上所有的语言。 下面是一些字符串示例： 123var s = &quot;$%^&amp;*&quot;var s2 = &quot;1234&quot;var s3 = &quot;你好&quot; 运算符运算符用于在程序运行时执行数据运算和逻辑运算。Go语言支持的运算符有： 算术运算符 逻辑运算符 关系运算符 位运算符 算术运算符算术运算符是用来对数值类型进行算术运算的。下表列出了Go语言支持的算术运算符。 运算符 说明 + 相加 - 相减 * 相乘 / 相除 % 取余 ++ 自增 – 自减 12345678910111213141516171819package mainimport &quot;fmt&quot;func main() { var ( a = 10 b = 20 ) fmt.Printf(&quot;a+b=%d\\n&quot;, a+b) fmt.Printf(&quot;a-b=%d\\n&quot;, a-b) fmt.Printf(&quot;a*b=%d\\n&quot;, a*b) fmt.Printf(&quot;a/b=%d\\n&quot;, a/b) fmt.Printf(&quot;a%%b=%d\\n&quot;, a%b) a++ fmt.Printf(&quot;a++=%d\\n&quot;, a) a-- fmt.Printf(&quot;a--=%d\\n&quot;, a)} 和其他语言不同的是，Go语言不提供++a，–a运算符，只提供a++，a–。 关系运算符关系运算符用来判断两个值的关系。下表列出了Go语言支持的关系运算符。 运算符 说明 == 判断两个值是否相等 != 判断两个值是否不相等 &gt; 判断运算符左边的值是否大于右边的值 &lt; 判断运算符左边的值是否小于右边的值 &gt;= 判断运算符左边的值是否大于等于右边的值 &lt;= 判断运算符左边的值是否小于等于右边的值 123456789101112131415161718192021222324252627package mainimport &quot;fmt&quot;func main() { var ( a = 10 b = 20 ) if a == b { fmt.Println(&quot;a==b&quot;) } else { fmt.Println(&quot;a!=b&quot;) } if a &lt; b { fmt.Println(&quot;a&lt;b&quot;) } else { fmt.Println(&quot;a&gt;=b&quot;) } if a &lt;= b { fmt.Println(&quot;a&lt;=b&quot;) } else { fmt.Println(&quot;a&gt;b&quot;) }} 逻辑运算符逻辑运算符用来对操作数进行逻辑判断。下表列出了Go语言支持的逻辑运算符。 运算符 说明 &amp;&amp; 逻辑与。两边操作数都为true则结果为true，否则为false || 逻辑或。两边操作数只要有一个为true则结果为true，否则为false ! 逻辑非。如果操作数为true则结果为false，否则为true 1234567891011121314151617181920212223package mainimport &quot;fmt&quot;func main() { var a, b = true, false if a &amp;&amp; b { fmt.Println(&quot;a和b同时为true&quot;) } else { fmt.Println(&quot;a和b至少一个为false&quot;) } if a || b { fmt.Println(&quot;a和b至少一个为true&quot;) } else { fmt.Println(&quot;a和b都为false&quot;) } if !a { fmt.Println(&quot;a是false&quot;) } else { fmt.Println(&quot;a是true&quot;) }} 位运算符位运算符用来对整数进行二进制位操作。下表列出了Go语言支持的位运算符。 运算符 说明 &amp; 按位与 | 按位或 ^ 按位异或 &gt;&gt; 右移 &lt;&lt; 左移 123456789101112131415package mainimport &quot;fmt&quot;func main() { var ( a = 1 b = 2 ) fmt.Printf(&quot;a&amp;b=%d\\n&quot;, a&amp;b) fmt.Printf(&quot;a|b=%d\\n&quot;, a|b) fmt.Printf(&quot;a^b=%d\\n&quot;, a^b) fmt.Printf(&quot;a&gt;&gt;1=%d\\n&quot;, a&gt;&gt;1) fmt.Printf(&quot;a&lt;&lt;1=%d\\n&quot;, a&lt;&lt;1)} 条件语句条件语句是计算机程序的重要组成部分，几乎所有编程语言都支持。简单地说，条件语句检查指定的条件是否满足，并在满足时执行指定的操作。 下表列出了Go语言支持的条件语句。 if 由一个布尔表达式后紧跟一个或多个语句组成。 if…else if…else 由多个布尔表达式分支组成，并提供例外分支 switch 基于不同条件执行不同操作，并提供默认操作 例：if的使用。 1234567891011121314package mainimport &quot;fmt&quot;func main() { var a = 10 if a &gt; 10 { fmt.Println(&quot;a大于10&quot;) } else if a == 10 { fmt.Println(&quot;a等于10&quot;) } else { fmt.Println(&quot;a小于10&quot;) }} 例：switch的使用。 123456789101112131415161718package mainimport &quot;fmt&quot;func main() { var a = 10 switch a { case 1: fmt.Println(&quot;a等于1&quot;) case 2: fmt.Println(&quot;a等于2&quot;) case 10: fmt.Println(&quot;a等于3&quot;) default: fmt.Println(&quot;默认分支&quot;) }} 和其他语言不同，Go语言的case分支不需要添加break。 循环语句在其他语言中一般会提供for、while、foreach等关键字实现循环，而在Go语言中只提供for关键字，但是也实现了类似的效果。 forfor循环有着经典的三段式结构： 循环初始化 循环终止条件 循环步进条件 123456789package mainimport &quot;fmt&quot;func main() { for i := 0; i &lt; 10; i++ { fmt.Println(i) }} whilewhile循环指定循环终止条件，不满足条件时循环一直执行并向终止条件靠拢，满足条件后终止循环。（无终止条件的循环称为死循环） 1234567891011package mainimport &quot;fmt&quot;func main() { i := 0 for i &lt; 10 { fmt.Println(i) i++ }} 死循环不需要终止条件。 123456789101112131415package mainimport ( &quot;fmt&quot; &quot;time&quot;)func main() { i := 0 for { fmt.Println(i) i++ time.Sleep(time.Second) }} foreachforeach循环多用来遍历列表、字典等数据结构。 12345678910package mainimport &quot;fmt&quot;func main() { list := []int{1, 2, 3, 4, 5} for index, value := range list { fmt.Println(index, value) }} continuecontinue用来跳过本次循环继续执行下次循环。 123456789101112package mainimport &quot;fmt&quot;func main() { for i := 0; i &lt; 5; i++ { if i == 1 { continue } fmt.Println(i) }} 该程序判断i为1时跳过并执行下次循环，该程序输出如下。 12340234 3.1.5 breakbreak用来跳出循环，后续循环将不执行。 123456789101112package mainimport &quot;fmt&quot;func main() { for i := 0; i &lt; 5; i++ { if i == 1 { break } fmt.Println(i) }} 该程序判断i为1时跳出循环，该程序输出如下。 10 小结本文介绍了Go语言的基本语法，包括变量和常量的使用、基础数据类型、流程控制等知识。下一章将介绍Go语言的数据容器类型，包括数组、切片和映射。","link":"/2021/02/26/2021-02-26-golang-basic.html"},{"title":"Golang程序设计——数据容器","text":"本文学习Go语言数据容器、包括数组、切片和映射。 数组数组是一个数据集合，常用于存储用数字索引的同类型数据。Go语言的数组调用函数时使用的是值传递，因此形参会拷贝一份实参的值。 在Go语言中，声明数组需要同时指定长度和数据类型，数组长度是其类型的一部分，因此[5]int和[1]int是两种类型。 Go语言可以对数组进行写入、读取、删除、遍历等操作。 12345678910111213141516171819202122232425package mainimport &quot;fmt&quot;func main() { // 声明数组并指明长度，不初始化，因此a的5个元素为int类型的零值（0） var a [5]int // 声明数组并指明长度，并初始化4个元素，因此b的最后1个元素为int类型零值（0） var b = [5]int{1, 2, 3, 4} // 声明数组，不指明长度，编译器会根据值数量推导长度为4 var c = [...]int{1, 2, 3, 4} // 数组写入 a[0] = 0 a[1] = 1 // 数组读取 fmt.Printf(&quot;a[0]=%d\\n&quot;, a[0]) // 数组删除（赋零值） a[0] = 0 // 数组的遍历 for index, value := range c { fmt.Printf(&quot;c[%d]=%d\\n&quot;, index, value) } // 输出b fmt.Printf(&quot;b=%v\\n&quot;, b)} 切片使用切片在Go语言中，数组是一个重要的类型，但是使用切片的情况更多。切片是底层数组中的一个连续片段，因此数组支持的特性切片也全部支持，必须顺序遍历、通过索引访问元素等等。 为何使用切片的情况更多呢？主要是因为Go语言的数组不支持自动扩容，而且不支持删除元素，更重要的是Go语言数组是值类型，切片是引用类型，在向函数传参时切片拥有更好的性能。 123456789101112131415161718192021222324252627282930package mainimport &quot;fmt&quot;func main() { // 声明一个大小为0的int类型切片 var a = make([]int, 0) // 添加三个元素 a = append(a, 1, 2, 3) fmt.Println(a) // 遍历元素 for index, value := range a { fmt.Printf(&quot;a[%d]=%d\\n&quot;, index, value) } // 声明一个大小为4的切片 var b = make([]int, 4) // 将a的元素复制到b copy(b, a) // 删除指定下标的元素 a = append(a[:1], a[2:]...) fmt.Printf(&quot;a=%v\\n&quot;, a) fmt.Printf(&quot;b=%v\\n&quot;, b) // 使用值初始化切片 var c = []int{1, 2, 3, 4} fmt.Printf(&quot;c=%v\\n&quot;, c) // 只定义，不初始化切片 var d []int d = append(d, 1, 2, 3) fmt.Printf(&quot;d=%v\\n&quot;, d)} 声明切片可以不使用make初始化，append也不会报错。 运行时结构切片运行时结构如下： 12345type slice struct { array unsafe.Pointer len int cap int} array是底层数组 len是数组大小，可以通过len函数获取 cap是数组容量，可以通过cap函数获取 make函数创建切片有两种写法： 12make([]int, 0) // 1make([]int, 0, 8) // 2 声明了一个长度为0的切片，此时len为0，cap也为0 声明一个长度为0，容量为8的切片，此时len为0，cap为8 追加元素Go语言提供append函数追加元素到切片中，append会在必要时扩容底层数组。扩容规则如下： 新容量小于1024时，每次扩容2倍。例如现有容量为2，扩容后为4 新容量大于1024时，每次扩容1.25倍。例如现有容量为1024，扩容后为1280 1234567891011121314package mainimport &quot;fmt&quot;func main() { // 直接使用值初始化切片 var a = []int{1, 2, 3, 4, 5} a = append(a, 6, 7) var b = []int{9, 10} // 追加b的全部元素到a a = append(a, b...) fmt.Printf(&quot;a=%v\\n&quot;, a) fmt.Printf(&quot;b=%v\\n&quot;, b)} 范围操作符切片支持取范围操作，新切片和原切片共享底层数组，因此对切片的修改会同时影响两个切片。 范围操作符语法如下：a[begin:end]，左闭右开区间。因此a[1:10]包含a切片索引为1~9的元素。 1234567891011121314package mainimport &quot;fmt&quot;func main() { // 直接使用值初始化切片 var a = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10} var b = a[1:10] fmt.Println(b) // 修改新切片元素 b[0] = 11 fmt.Println(a) fmt.Println(b)} 可以看到修改b索引为0的元素为11之后，a切片也同时受到影响。 范围操作符的切片这一点在编程中要特别注意！ 删除元素利用范围操作符和append函数可以删除指定的切片元素。 123456789101112131415package mainimport &quot;fmt&quot;func main() { // 直接使用值初始化切片 var a = []int{1, 2, 3, 4, 5} // 删除第2个元素 a = append(a[:1], a[2:]...) fmt.Println(a) // 删除第2、3个元素 a = []int{1, 2, 3, 4, 5} a = append(a[:1], a[3:]...) fmt.Println(a)} 复制元素通过copy函数可以复制切片的全部或部分元素。在复制切片之前，需要声明好目标切片并设置len。 len必须大于0**，否则将不会复制任何元素。 1234567891011121314package mainimport &quot;fmt&quot;func main() { // 直接使用值初始化切片 var a = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10} var b = make([]int, 0, 8) copy(b, a) fmt.Println(b) var c = make([]int, 8) copy(c, a[9:10]) fmt.Println(c)} 程序输出如下： 12[][10 0 0 0 0 0 0 0] 可以看到切片b没有任何值，切片c成功复制了a的最后一个元素。 映射映射也叫字典、哈希表，数组和切片是通过数字索引访问的顺序集合，而映射是通过键来访问的无序集合。映射在查找方面非常高效，有着O(1)的时间复杂度，是非常常用的数据结构。 使用映射映射必须初始化之后才能使用，这一点和切片不同。 123456789101112131415161718192021package mainimport &quot;fmt&quot;func main() { // 使用make初始化映射 var a = make(map[string]int) a[&quot;zhangsan&quot;] = 18 a[&quot;lisi&quot;] = 28 fmt.Printf(&quot;a=%v\\n&quot;, a) // 使用值初始化映射 var b = map[string]int{ &quot;zhangsan&quot;: 18, &quot;lisi&quot;: 28, } fmt.Printf(&quot;b=%v\\n&quot;, b) // 遍历映射 for key, value := range b { fmt.Printf(&quot;%s=%d\\n&quot;, key, value) }} 下面是未初始化映射的使用 123456789101112package mainimport &quot;fmt&quot;func main() { var a map[string]int a[&quot;zhangsan&quot;] = 1 for k, v := range a { fmt.Printf(&quot;%s=%d\\n&quot;, k, v) }} 该程序会产生运行时错误： 1234panic: assignment to entry in nil mapgoroutine 1 [running]:main.main()/Users/example/go/src/go-microservice-inaction/src/2.1/main.go:7 +0x5d 运行时结构映射的运行时结构如下： 1234567891011type hmap struct { count int flags uint8 B uint8 noverflow uint16 hash0 uint32 buckets unsafe.Pointer oldbuckets unsafe.Pointer nevacuate uintptr extra *mapextra} 部分字段说明如下： count是目前映射的键值对数量 B是映射的容量，对数。例如B为8，则映射容量为28=256 buckets中存储具体的键值对 oldbuckets在扩容中会使用到 nevacuate 扩容进度指示器 当装载因子超过6.5时，映射将发生扩容操作。装载因子计算公式：count/2B。例如当前为为166，此时装载因子为166/28=0.6484375，继续插入元素时，装载因子变为167/28= 0.65234375，此时会触发自动扩容。 每次扩容会增加1倍的空间，同时会对已存在的键值对进行渐进式迁移（一次迁移一小部分）。 添加元素Go语言映射添加元素和其他语言类似，使用[]语法即可。 12var m = make(map[string]int)m[&quot;name&quot;] = 18 添加元素时运行时会自动处理扩容和键值对迁移，无需用户程序关心。 删除元素要从映射中删除元素，需要使用delete函数。 1234var m = map[string]int{ &quot;zhangsan&quot;:18,}delete(m, &quot;zhangsan&quot;) 小结本章介绍了Go语言常用的数据容器，其中对切片和映射的底层原理进行了简单介绍。Go语言通过内置切片和映射解决了C语言需要手动实现这两种常用数据结构的问题，提高了开发效率。在下一章将介绍Go语言的函数。","link":"/2021/03/09/2021-03-09-golang-data-container.html"},{"title":"Golang程序设计——函数","text":"本文学习Go语言函数知识。函数是基本的代码块，用于执行一个任务。在Go语言中，函数可以接收数量不固定的参数，也可以返回多个结果。 函数结构在编程领域，函数向编译器和开发者提供了有关的信息，这些信息指明了函数该接收什么样的输入以及会产生什么样的输出。这些信息是通过函数第一行提供的，第一行称为函数签名。 Go语言声明函数语法如下： 1234func 函数名称(参数名 参数类型) (返回值名称 返回值类型) { // 函数体 return语句} 参数名在参数类型前面，如a int，这一点和其他语言是不同的 函数参数数量可以不固定，但是只允许最后一个参数数量不固定，而且必须是同种类型 返回值名称不是必须的，但是参数名是必须写的 有返回值的函数，函数体内必须包含return语句 示例：函数定义与调用 12345678910package mainimport &quot;fmt&quot;func sum(a, b int) int { return a + b}func main() { fmt.Printf(&quot;1+2=%d\\n&quot;, sum(1, 2))} 在Go语言中，如果多个参数或多个返回值类型相同，只需要在最后一个参数或返回值声明类型。 例如下面的函数签名在Go语言中是合法的。 1func sum2(a, b int) (c, d int) 不定参数函数不定参数也就是数量不固定的参数。例如C语言中的printf函数就是一个典型的不定参数函数。Go语言支持不定参数函数，但是不定参数的类型必须相同。要声明不定参数，需要使用3个点(…)。 示例：不定参数的加法函数 1234567891011121314package mainimport &quot;fmt&quot;func sum(nums ...int) int { total := 0 for _, n := range nums { total += n } return total}func main() { fmt.Printf(&quot;1+2+3+4=%d\\n&quot;, sum(1, 2, 3, 4))} 在sum函数中，nums是一个包含所有参数的切片。 函数返回值多返回值在Go语言中，函数能声明多个返回值，在这种情况下，return可以返回多个结果。函数调用者可通过多变量声明接收多个返回值。 示例：多返回值函数 12345678910111213141516171819202122package mainimport ( &quot;errors&quot; &quot;fmt&quot;)func div(a, b int) (int, error) { if b == 0 { return 0, errors.New(&quot;b is zero&quot;) } return a / b, nil}func main() { ret, err := div(2, 1) if err != nil { fmt.Println(err) return } fmt.Printf(&quot;2/1=%d\\n&quot;, ret)} 命名返回值命名返回值让函数能够在返回前将返回值赋给命名变量，这种设计有利于提高程序可读性。要指定命名返回值，可在函数签名的返回值类型前面添加变量名。 示例：命名返回值函数 1234567891011121314package mainimport ( &quot;fmt&quot;)func sum(a, b int) (total int) { total = a + b return}func main() { fmt.Printf(&quot;1+2=%d\\n&quot;, sum(1, 2))} 使用命名返回值后，return关键字可以单独出现，当然，return关键字继续返回结果值也是合法的。 1234func sum(a, b int) (total int) { total = a + b return total} 函数类型在Go语言中，函数是一种数据类型，可以将函数赋值给变量、或者作为参数传递，也可以作为返回值返回。 示例：将函数作为变量、参数、返回值。 1234567891011121314151617181920212223242526272829package mainimport &quot;fmt&quot;func main() { // 函数作为变量 sum := func(a, b int) int { return a + b } fmt.Printf(&quot;1+1=%d\\n&quot;, sum(1, 1)) // 函数作为参数 sum2(1, 1, func(total int) { fmt.Printf(&quot;1+1=%d\\n&quot;, total) }) // 函数作为返回值 totalFn := sum3(1, 1) fmt.Printf(&quot;1+1=%d\\n&quot;, totalFn())}func sum2(a, b int, callback func(int)) { total := a + b callback(total)}func sum3(a, b int) func() int { return func() int { return a + b }} 匿名函数、闭包、延迟执行函数匿名函数匿名函数指没有名称的函数，只有函数签名（参数和返回值声明）和函数体，匿名函数经常用于回调、闭包、临时函数等。 示例：利用匿名函数实现事件总线。 12345678910111213141516171819202122232425262728package mainimport &quot;fmt&quot;func main() { emitter := make(map[string]func()) addEventListener(emitter, &quot;event1&quot;, func() { fmt.Println(&quot;event1 called&quot;) }) emit(emitter, &quot;event2&quot;)}// 添加事件监听器// emitter 事件总线// event 事件名// callback 回调函数func addEventListener(emitter map[string]func(), event string, callback func()) { emitter[event] = callback}// 触发事件// emitter 事件总线// event 事件名func emit(emitter map[string]func(), event string) { callback, ok := emitter[event] if ok { callback() }} main函数调用addEventListener时传入的第三个函数即为匿名函数。 闭包闭包可以理解为定义在一个函数内部的函数。在本质上，闭包是函数和其引用环境的组合体。引用环境即使在外部函数执行结束也不会被回收，因此可以利用闭包保存保存执行环境。 示例：利用闭包提供唯一ID生成器。 1234567891011121314151617181920package mainimport &quot;fmt&quot;func main() { s1 := sequenceId() s2 := sequenceId() fmt.Printf(&quot;s1 -&gt; %v\\n&quot;, s1()) fmt.Printf(&quot;s1 -&gt; %v\\n&quot;, s1()) fmt.Printf(&quot;s2 -&gt; %v\\n&quot;, s2()) fmt.Printf(&quot;s2 -&gt; %v\\n&quot;, s2())}func sequenceId() func() int { var id int return func() int { id++ return id }} 输出如下 1234s1 -&gt; 1s1 -&gt; 2s2 -&gt; 1s2 -&gt; 2 函数sequenceId定义了一个局部变量id，并返回了一个子函数，子函数内部访问了外部的id，因此这构成一个典型的闭包。在前面的内容中我们学习过变量作用域，内部总是可以访问外部的变量或常量，而外部无法访问内部的变量或常量。此外，由于变量id被子函数使用，因此在sequenceId函数返回后，id也不会被销毁。 每调用一次sequenceId函数都会返回一个新的子函数以及对应的id，因此s1和s2之间的输出互不影响。 注意：由于闭包会导致被引用的变量无法销毁，因此需要注意使用，避免产生内存泄漏。 延迟执行函数在实际编程中往往会打开一些资源，例如文件、网络连接等等，这些资源在使用完毕时（无论是正常关闭或者函数异常）需要主动关闭，当函数的结束分支太多或者逻辑比较复杂时容易发生忘记关闭的情况导致资源泄漏。 Go语言提供了defer关键字用来延迟执行一个函数，一般使用该函数延迟关闭资源。多个defer语句会按照先进后出的方式执行，也就是最后声明的最先执行，典型的栈结构。 示例：defer执行顺序。 123456789101112131415161718package mainimport &quot;fmt&quot;func main() { defer f1() defer f2() fmt.Println(&quot;call main&quot;)}func f1() { fmt.Println(&quot;call f1&quot;)}func f2() { defer fmt.Println(&quot;defer call f2&quot;) fmt.Println(&quot;call f2&quot;)} 输出如下 1234call maincall f2defer call f2call f1 第一行输出call main是因为main函数中只有一个非defer语句，因此call main最先执行 第二行输出call f2是因为f2函数内部有一个非defer语句 第三行输出defer call f2是因为f2函数的fmt.Println(“call f2”)执行完毕后才能执行defer 第四行输出call f1是因为defer f1()最先声明因此最后执行 示例：基于defer和闭包构造一个函数执行耗时记录器。 12345678910111213141516171819202122232425package mainimport ( &quot;fmt&quot; &quot;time&quot;)type Person struct { Name string Age int Sex string}func main() { defer spendTime()() time.Sleep(time.Second) fmt.Println(&quot;call main&quot;)}func spendTime() func() { startAt := time.Now() return func() { fmt.Println(time.Since(startAt)) }} 输出如下 12call main1.002345498s spendTime()会返回一个闭包，因此定义defer时会初始化startAt为当前时间，defer执行时会执行闭包函数得到函数耗时。main函数为了测试方便休眠了一秒钟，因此可以看到输出是超过1秒的。 小结本文介绍了如何在Go语言中使用函数。包括不定参数函数、多返回值和命名返回值函数以及将函数作为类型使用的方法，最后介绍了匿名函数、闭包和延迟执行函数。接下来的内容中将介绍Go语言中的结构体。","link":"/2021/03/17/2021-03-17-golang-function.html"},{"title":"PlanUML指南","text":"简介 统一建模语言（英语：Unified Modeling Language，缩写 UML）是非专利的第三代建模和规约语言。UML是一种开放的方法，用于说明、可视化、构建和编写一个正在开发的、面向对象的、软件密集系统的制品的开放方法 编写UML的软件很多，但是基本是可视化的，需要手动编写，本文主要介绍基于文本的UML编写工具——PlantUML。 安装PlantUML有以下依赖： graphviz jdk Jetbrains IDE插件(可选，本文推荐) 安装graphviz本文使用Homebrew安装graphviz，终端执行以下命令安装graphviz。 1brew install graphviz 安装完毕后查看版本信息。 1dot -v 输出如下： 123456789101112131415dot - graphviz version 2.47.0 (20210316.0004)libdir = &quot;/usr/local/Cellar/graphviz/2.47.0/lib/graphviz&quot;Activated plugin library: libgvplugin_dot_layout.6.dylibUsing layout: dot:dot_layoutActivated plugin library: libgvplugin_core.6.dylibUsing render: dot:coreUsing device: dot:dot:coreThe plugin configuration file: /usr/local/Cellar/graphviz/2.47.0/lib/graphviz/config6 was successfully loaded. render : cairo dot dot_json fig gd json json0 map mp pic pov ps quartz svg tk visio vml vrml xdot xdot_json layout : circo dot fdp neato nop nop1 nop2 osage patchwork sfdp twopi textlayout : textlayout device : bmp canon cgimage cmap cmapx cmapx_np dot dot_json eps exr fig gd gd2 gif gv icns ico imap imap_np ismap jp2 jpe jpeg jpg json json0 mp pct pdf pic pict plain plain-ext png pov ps ps2 psd sgi svg svgz tga tif tiff tk vdx vml vmlz vrml wbmp webp xdot xdot1.2 xdot1.4 xdot_json loadimage : (lib) bmp eps gd gd2 gif jpe jpeg jpg pdf png ps svg webp xbm jdk本文使用Homebrew安装openjdk即可，终端执行以下命令安装openjdk。 1brew install openjdk 安装完毕后查看版本信息。 1java -version 输出如下： 123openjdk version &quot;11.0.10&quot; 2021-01-19OpenJDK Runtime Environment (build 11.0.10+9)OpenJDK 64-Bit Server VM (build 11.0.10+9, mixed mode) Jetbrains IDE插件安装本文以Goland为例。 打开IDE设置，打开Plugins窗口，搜索PlantUML integration 安装完毕后重启IDE 打开IDE设置，搜索plantuml，确保Remote rendering已关闭 PlantUML语法以最常用的时序图、类图、流程图、组件图举例。 时序图Get Started IDE新建一个空项目，打开项目之后，右键新建文件 选择Sequence PlantUML菜单项说明 以微信网页授权为例编写时序图。 12345678910111213141516171819202122@startuml'https://plantuml.com/sequence-diagram'启用自动编号autonumber'生命线自动激活autoactivate onactor 用户用户 -&gt; 应用服务器: 获取用户信息应用服务器 -&gt; 微信服务器: 跳转授权链接:(appid,scope,callback)微信服务器 -&gt; 用户: 请求用户授权return 允许授权return 返回授权code应用服务器 -&gt; 微信服务器: 获取用户access_token(appid,secret,code)return 返回access_token+openid应用服务器 -&gt; 微信服务器: 获取用户信息(openid,access_token)return 用户信息return 用户信息@enduml 渲染效果 语法说明标记声明1234@startuml和@enduml是PlantUML的开始结束标记，无需更改。autonumber 打开启动编号，也就是每个步骤之前都有数字编号，打开之后整个流程更加清晰autoactivate on 打开生命线自动激活，需要配合`return`使用actor 用户 声明`用户`的类型是actor(行为人) 时序声明 使用-&gt;来声明一个时序操作，:后面可以附加消息 使用return来返回消息给调用者 声明参与者默认情况下参与者为矩形，无法看出实际类型。实际应用中，会有数据库、消息队列等等参与者，使用以下关键字来改变参与者的图例。 123actor 用户database 数据库queue 消息队列 类图类图是UML中非常重要的一种类型，能够在实际编码之前为我们提供OOP的详细设计。 Get Started IDE新建一个空项目，打开项目之后，右键新建文件 选择Class 以一个上传类为例编写类图 1234567891011121314151617181920212223242526272829303132333435@startuml'https://plantuml.com/class-diagramnamespace com.ddhigh.uploader { interface Uploader { + String Upload(String filename) Throws IOException } namespace qiniu { class QiniuUploader implements Uploader {- client: qiniu.Client--+ String Upload(String filename) Throws IOException } QiniuUploader *-- qiniu.Client } package aliyun { class AliyunUploader implements Uploader {- client: aliyun.Client--+ String Upload(String filename) Throws IOException } AliyunUploader *-- aliyun.Client } class UploaderFacade { - uploaders: List&lt;Uploader&gt; -- + List&lt;String&gt; Upload(String filename) Throws IOException } UploaderFacade o-- Uploader}@enduml 渲染效果 语法说明包建议使用namespace关键字声明包，package声明的包内的类名必须全局唯一(无视package)，而namespace只要求该namespace内唯一即可。 class/interface与实际编程语言几乎无差别，比如上面例子中采用的是java语法。 可见性PlantUML支持3种可见性： - 私有级别 private # 保护级别 protected + 公有级别 public 元素关系PlantUML主要有以下3种关系： 扩展: 包含implements和extends 聚合: 使用o--，左边的包含右边的 组合: 使用*--,左边的依赖右边的 组合和聚合的区别：(以上面的图为例) 组合：QiniuUploader必须依赖Client才能提供上传功能，组合一般是1对1的。 聚合：UploadFacade可以依赖多个Uploader实例，也可以依赖0个实例(只是这时候不会有文件上传了)，聚合一般是1对多的。 流程图在梳理复杂业务逻辑时，善用流程图能帮我们更加清晰地梳理清楚，也方便我们和其他人员进行沟通（非开发人员基本看不懂代码）。 Get Started IDE新建一个空项目，打开项目之后，右键新建文件 新建Activity类型文件 下面以一个授权获取用户openid并插入数据库，然后查询用户好友进行消息推送的场景编写流程图 12345678910111213141516171819202122@startuml'https://plantuml.com/activity-diagram-betastart:使用code,appid,secret请求微信服务器获取access_token和openid;:使用access_token和openid请求微信服务器获取用户信息;:查询数据库openid是否存在;if (数据库查询失败?) then (是)stopelseif (用户已存在?) then (是):更新用户信息;else (否):新建用户并绑定openid;endif:获取用户好友列表;while(好友列表遍历完成?) is (否):推送消息给好友;endwhile(是)stop@enduml 渲染效果 语法说明 开始和结束: 使用start和stop 处理语句: 使用:和;包裹该流程 条件判断: 使用if,elseif,else,endif,then 循环语句: 使用while,is,endwhile编写 组件图现阶段组件化MVVM框架大行其道，具有代表性的有Vue,React和Angular。我们可以使用组件图来绘制组件关系，简单易懂。 Get Started IDE新建一个空项目，打开项目之后，右键新建文件 选择Component 以微信首页聊天列表为例绘制组件关系图 12345678910111213141516171819202122@startuml'https://plantuml.com/component-diagrampackage widgets { [SearchBar] --&gt; [Text] [SearchBar] --&gt; [Icon] [NavigationBar] --&gt; [Text] [NavigationBar] --&gt; [Icon] [ListView] --&gt; [ListItem] [ListItem] --&gt; [Image] [ListItem] --&gt; [Text]}package routes { [Home] --&gt; [NavigationBar] [Home] --&gt; [SearchBar] [Home] --&gt; [ListView]}@enduml 渲染效果 依赖关系如下： 首页: 导航栏, 搜索框，列表 导航栏: 文本，图标 搜索框: 文本，图标 列表: 列表项 列表项: 文本，图片 语法说明 package 声明包，同一个包内的组件是类似地位 [组件名]声明组件，组件名在单个文件内是唯一的 --&gt; 声明依赖关系，左边依赖右边 (完)","link":"/2021/06/04/2021-06-04-plantuml-tutorial.html"},{"title":"gomonkey私有方法打桩","text":"ApplyMethod基于反射实现，无法对私有方法打桩，本文将解决这一问题。 被测代码1234567891011type Dao struct {}// 私有方法func (d *Dao) method1() error { return errors.New(&quot;failed&quot;)}// Method 公有方法func (d *Dao) Method() error { return d.method1()} method1是私有方法，使用ApplyMethod无法打桩 测试代码12345678910func TestDao_Method(t *testing.T) { // 基于ApplyFunc可以读取到私有方法的地址并进行替换 g := gomonkey.ApplyFunc((*Dao).method1, func(_ *Dao) error { return errors.New(&quot;打桩返回的错误&quot;) }) defer g.Reset() d := Dao{} fmt.Println(d.Method())} 执行执行时需要添加-gcflags=-l禁止内联(内联后函数地址发生变化，某些函数会直接转化为语句调用) 1234=== RUN TestDao_Method打桩返回的错误--- PASS: TestDao_Method (0.00s)PASS 注意事项 执行测试命令时添加-gcflags=-l ``gomonkey.ApplyFunc需要传递(*Dao).method1`(结构体指针对应的函数) 被测方法的接收器必须是结构体指针(因为第2步是传递指针)123func (d *Dao) method1() error { return errors.New(&quot;failed&quot;)}","link":"/2021/09/18/2021-09-18-gomonkey-private-method-stub.html"},{"title":"算法篇——二分查找","text":"本系列文章将学习/复习常用算法和数据结构。希望能够深入浅出的将复杂的知识讲清楚、说明白。 本文介绍第一个基础算法：二分查找。二分查找算法可以在有序的数组中快速查询指定值。 要求：有序数组 时间复杂度：O(logN) 空间复杂度：O(1) 例子大家应该玩过数字猜大小的游戏，接下来看看实际过程。 主持人从1~10选择1个数字，参与者每次猜1个数字，主持人给出提示正确/大了/小了。次数最少的获胜。 线性查找 主持人选定数字5。 参与者：10 主持人：大了 参与者：9 主持人：大了 参与者：8 主持人：大了 … 参与者：5 主持人：正确 参与者采用线性报数方式，从最大的数字开始报，每次减1直到猜中。上面的例子主持人选的数字是5，参与者猜了6次（10,9,8,7,6,5)。效率是O(N)。 主持人的大了/小了提示没有利用上，这肯定不是效率最高的方法。 二分查找 主持人选定数字8。 参与者：5 主持人：小了 参与者：7 主持人：小了 参与者：8 主持人：正确 参与者根据主持人的大了/小了提示每次调整猜测范围直到猜中。上面的例子中主持人选的数字是8，参与者猜了3次： (0+10)/2 =&gt; 5，小了，所以下一次应该猜 比5大的数字，从 5 ~ 10继续猜 (5+10)/2 =&gt; 7(8也可以)，小了，所以下一次继续猜比7大的数字，从7~10继续猜 (7+10)/2 =&gt; 8(9也可以)，正确 可以看到二分查找法每次都能过滤掉1半的数据，达到了O(logN)的时间复杂度 代码示例给定一个有序数组，返回指定值的索引，如果有序数组不存在该值，返回-1。 思路： 找中间值，(0 + 数组最后一位的所以)/2得到中间值的位置，然后对比中间值和目标值大小 如果目标值比中间值小，那么目标值在数组前半部分，应该继续查找 0 ~ 数组中间索引-1的这部分 如果目标值比中间值大，那么目标值在数组后半部分，应该继续查找 数组中间索引+1 ~ 数组结尾的这部分 为什么继续查找时中间索引要+1或者-1移动？ 因为中间值已经比对过了，不满足条件，所以可以直接跳过中间值往前面后者后面一个位置继续查找 12345678910111213141516171819202122232425262728package mainimport &quot;fmt&quot;func main() { fmt.Println(search([]int{1, 2, 3, 4, 5, 6, 7}, 5))}func search(nums []int, target int) int { begin := 0 end := len(nums) - 1 for begin &lt;= end { // 开始位置不能超过结束位置，超过证明所以数据都查过了 midIndex := (begin + end) / 2 // 中间索引 midValue := nums[midIndex] // 中间值 fmt.Printf(&quot;check pos(%v) value(%v)\\n&quot;, midIndex, midValue) if target &lt; midValue { // 目标值比中间值小，所以在左边，将end移动到中间索引-1 end = midIndex - 1 continue } if target &gt; midValue { // 右半边，begin移动到中间索引+1 begin = midIndex + 1 continue } // 相等 return midIndex } return -1} 输出如下 1234check pos(3) value(4)check pos(5) value(6)check pos(4) value(5)4","link":"/2021/12/29/2021-12-29-algo-binarysearch.html"},{"title":"LeetCode142——环形链表2","text":"题目给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。 不允许修改 链表。 示例 1： 123输入：head = [3,2,0,-4], pos = 1输出：返回索引为 1 的链表节点解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 123输入：head = [1,2], pos = 0输出：返回索引为 0 的链表节点解释：链表中有一个环，其尾部连接到第一个节点。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/linked-list-cycle-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路哈希表参考上一篇环形链表，可以利用哈希表存储节点，当再次遇到该节点时，该节点就是成环点。 1234567891011121314// 1. 遍历节点存入map// 2. 如果节点已存在，则该节点是成环节点func detectCycle(head *ListNode) *ListNode { m := make(map[*ListNode]struct{}) p := head for p != nil { if _, ok := m[p]; ok { return p } m[p] = struct{}{} p = p.Next } return nil} 快慢指针 快指针走2步，慢指针走1步 快慢指针相遇时，慢指针走了s个节点，快指针走了2s，同时快指针比慢指针多走了N圈，设环形区间长度为b,因此2s = s+nb，因此s=nb，也就是快慢指针相遇时慢指针走过的距离刚好是环的倍数。 新起指针指向头结点，和慢指针一起向后走，两点相遇时新指针走了a，慢指针走了a+nb，此时新指针和慢指针相遇，新指针指向成环点 123456789101112131415161718192021222324func detectCycle(head *ListNode) *ListNode { if head == nil || head.Next == nil { return nil } fast := head slow := head for fast != nil { slow = slow.Next fast = fast.Next if fast != nil { fast = fast.Next } if fast == slow { // 快慢相遇，新起指针指向节点，然后和慢指针一起走，两者相遇点就是成环点 ptr := head for ptr != slow { ptr = ptr.Next slow = slow.Next } return ptr } } return nil}","link":"/2022/02/05/2022-02-05-linked-list-cycle-ii.html"},{"title":"LeetCode141——环形链表","text":"题目给你一个链表的头节点 head ，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。 如果链表中存在环 ，则返回 true 。 否则，返回 false 。 示例 1： 123输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 123输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/linked-list-cycle著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路哈希表法利用哈希表存储访问过的节点，如果遍历时节点在哈希表，则有环。 Go语言中map的value为struct可以不占用存储空间。 1234567891011func hasCycle(head *ListNode) bool { m := map[*ListNode]struct{}{} for head != nil { if _, ok := m[head]; ok { return true } m[head] = struct{}{} head = head.Next } return false} 快慢指针法 快指针每次走两步，慢指针走一步，如果相遇则存在环 123456789101112131415161718func hasCycle(head *ListNode) bool { if head == nil || head.Next == nil { return false } fast := head slow := head for fast != nil { slow = slow.Next fast = fast.Next // 快指针走1步 if fast != nil { fast = fast.Next // 快指针再走1步 } if fast == slow { // 相遇了 return true } } return false}","link":"/2022/02/05/2022-02-05-linked-list-cycle.html"},{"title":"LeetCode328——奇偶链表","text":"题目给定单链表的头节点 head ，将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后返回重新排序的列表。 第一个节点的索引被认为是 奇数 ， 第二个节点的索引为 偶数 ，以此类推。 请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致。 你必须在 O(1) 的额外空间复杂度和 O(n) 的时间复杂度下解决这个问题。 示例 1: 12输入: head = [1,2,3,4,5]输出: [1,3,5,2,4] 示例2: 12输入: head = [2,1,3,5,6,4,7]输出: [2,3,6,7,1,5,4] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/odd-even-linked-list著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/odd-even-linked-list著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 定义2个链表，odd为奇数链表，even为偶数链表 遍历原链表，根据奇偶位置插入odd或者even 连接odd和even 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 1. 定义以下节点// 1. 偶链表头节点，移动节点// 2. 奇链表头结点，移动节点// 2. 奇链表尾节点.Next = 偶链表头结点func oddEvenList(head *ListNode) *ListNode { // 0,1,2个节点时直接返回 if head == nil || head.Next == nil || head.Next.Next == nil { return head } var ( oddHead *ListNode oddMove *ListNode evenHead *ListNode evenMove *ListNode ) p := head for p != nil { // 连接奇数节点 if oddHead == nil { oddHead = p oddMove = p } else { oddMove.Next = p oddMove = oddMove.Next } p = p.Next // 连接偶数节点 if p != nil { if evenHead == nil { evenHead = p evenMove = p } else { evenMove.Next = p evenMove = evenMove.Next } } // 移动到下一个奇数节点 if p != nil { p = p.Next } } // 断开原来的连接 oddMove.Next = nil evenMove.Next = nil oddMove.Next = evenHead return oddHead}","link":"/2022/02/05/2022-02-05-odd-even-linked-list.html"},{"title":"LeetCode92——反转链表 II","text":"题目给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。 示例 1： 输入：head = [1,2,3,4,5], left = 2, right = 4输出：[1,4,3,2,5] 示例 2： 输入：head = [5], left = 1, right = 1输出：[5] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/reverse-linked-list-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路转数组 大部分的链表题只要未要求原节点上操作，都可以转数组处理，缺点是空间复杂度会额外增加达到O(n)。 将原链表按顺序转为数组 遍历数组，翻转left ~ right之间的数组，此处用双指针即可 定义left和right指针，交换left和right的值 两个指针同时向中间移动，left++,right– 将数组构造为链表返回 12345678910111213141516171819202122232425262728// 数组法// 1. 链表转换为数组// 2. 翻转left ~ right的数据// 3. 重新构造链表func reverseBetween(head *ListNode, left int, right int) *ListNode { array := convertListToArray(head) reverseArrayPart(array, left-1, right-1) return buildLinkList(array)}// 翻转数组指定区间func reverseArrayPart(array []int, left, right int) { for left &lt; right { array[left], array[right] = array[right], array[left] left++ right-- }}// 链表构造为数组func convertListToArray(head *ListNode) []int { array := make([]int, 0) for head != nil { array = append(array, head.Val) head = head.Next } return array} 链表操作 链表相关的操作主要是要掌握定位任意节点的指针。 定位以下节点 leftPrev: 翻转区间开始节点的上一个节点，最终要连接翻转后的头节点，所以需要保留 rightNext: 翻转区间结束节点的后一个节点，最终要连接到最终链表，所以需要保留 left和right节点，翻转开始和翻转结束节点 定义子函数翻转left和right，返回right，翻转思路如下 定义prev和curr指针，prev初始指向null，curr指向head 开始迭代，迭代结束条件curr不等于rightNode 保存curr的下一个节点next:=curr.Next 此时我们有3个节点的指针，prev,curr,next 当前节点指向上一个,curr.Next=prev prev上一个节点指针后移,prev=curr curr后移,curr=next 迭代结束后将curr指向上一个节点curr.Next=prev 按以下顺序连接所有节点：leftPrev -&gt; right -&gt; left -&gt; rightNext，边界情况如下： left是头结点，此时leftPrevNode是空，最终结果链表right节点成为新头结点 right是尾节点，此时rightNextNode是空，无需特殊处理 left == right，无需翻转 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667func reverseBetween(head *ListNode, left int, right int) *ListNode { if left == right { return head } leftPrevNode, leftNode, rightNode, rightNextNode := locateNodes(head, left-1, right-1) rightNode = reverse(leftNode, rightNode) // left是头节点，链表连接顺序，right,left,rightNext if leftPrevNode == nil { leftNode.Next = rightNextNode return rightNode } // 正常连接，连接顺序 leftPrevNode-&gt;right-&gt;left-&gt;rightNextNode leftPrevNode.Next = rightNode leftNode.Next = rightNextNode return head}// 翻转left ~ right之间的节点// 迭代翻转即可// p 指向当前节点// prev 指向上一个节点// next指向p的next节点// 如果p == rightNode则结束翻转并返回rightfunc reverse(leftNode *ListNode, rightNode *ListNode) *ListNode { var ( prev *ListNode p = leftNode ) for p != rightNode { next := p.Next p.Next = prev // p 指向 上一个节点 prev = p // 上一个节点后移 p = next // p后移 } // p 此时向rightNode，需要连接p和上一个节点 p.Next = prev return p}// 定位func locateNodes(head *ListNode, left, right int) (*ListNode, *ListNode, *ListNode, *ListNode) { var ( index = 0 prevNode *ListNode leftPrevNode *ListNode leftNode *ListNode rightNode *ListNode rightNextNode *ListNode ) for head != nil { // 找到左节点 if index == left { leftPrevNode = prevNode leftNode = head } // 找到右节点 if index == right { rightNode = head rightNextNode = head.Next } // 指针移动 index++ prevNode = head head = head.Next } return leftPrevNode, leftNode, rightNode, rightNextNode}","link":"/2022/02/05/2022-02-05-reverse-linked-list-ii.html"},{"title":"LeetCode107——二叉树的层序遍历 II","text":"题目给你二叉树的根节点 root ，返回其节点值 自底向上的层序遍历 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历） 示例 1： 12输入：root = [3,9,20,null,null,15,7]输出：[[15,7],[9,20],[3]] 示例 2： 12输入：root = [1]输出：[[1]] 示例 3： 12输入：root = []输出：[] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路直接用层序遍历即可，结果数组翻转之后就是答案 1234567891011121314151617181920212223242526272829303132// BFS正向遍历，最后翻转一下最终结果func levelOrderBottom(root *TreeNode) [][]int { if root == nil { return [][]int{} } answers := [][]int{} queue := []*TreeNode{root} for len(queue) &gt; 0 { size := len(queue) tmp := queue queue = []*TreeNode{} // 清空，存储下一层的节点 level := []int{} for i := 0; i &lt; size; i++ { node := tmp[0] tmp = tmp[1:] level = append(level, node.Val) if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } answers = append(answers, level) } // 翻转数组 length := len(answers) for i := 0; i &lt; length/2; i++ { answers[i], answers[length-1-i] = answers[length-1-i], answers[i] } return answers}","link":"/2022/02/06/2022-02-06-binary-tree-level-order-traversal-ii.html"},{"title":"LeetCode102--二叉树的层序遍历","text":"题目给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。 示例 1： 12输入：root = [3,9,20,null,null,15,7]输出：[[3],[9,20],[15,7]] 示例 2： 12输入：root = [1]输出：[[1]] 示例 3： 12输入：root = []输出：[] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路层序遍历直接用广度有限遍历即可。 用两个队列存储本层节点tmp和下一层节点queue（可以简化处理清理，避免一个队列操作时即弹出又插入的问题） 获取队列长度，将queue复制到tmp,清空本层节点变量(queue) tmp不断出队即可，出队时把后代节点插入queue 12345678910111213141516171819202122232425262728// BFS遍历即可// 用队列处理，需要注意的是，每次处理一层，每层的大小就是队列的大小，可以准备两个队列，一个用来存储本层，一个用来存储下一层func levelOrder(root *TreeNode) [][]int { if root == nil { return [][]int{} } answers := [][]int{} queue := []*TreeNode{root} for len(queue) &gt; 0 { size := len(queue) tmp := queue queue = []*TreeNode{} // 清空，存储下一层的节点 level := []int{} for i := 0; i &lt; size; i++ { node := tmp[0] tmp = tmp[1:] level = append(level, node.Val) if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } answers = append(answers, level) } return answers}","link":"/2023/05/03/2022-02-06-binary-tree-level-order-traversal.html"},{"title":"LeetCode103——二叉树的锯齿形层序遍历","text":"题目给你二叉树的根节点 root ，返回其节点值的 锯齿形层序遍历 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 示例 1： 12输入：root = [3,9,20,null,null,15,7]输出：[[3],[20,9],[15,7]] 示例 2： 12输入：root = [1]输出：[[1]] 示例 3： 12输入：root = []输出：[] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路用层序遍历的思路即可，不过偶数行需要将该行的值翻转。 123456789101112131415161718192021222324252627282930313233// BFS处理，记录遍历层数，当层数是奇数，翻转下本层元素func zigzagLevelOrder(root *TreeNode) [][]int { if root == nil { return [][]int{} } answers := [][]int{} queue := []*TreeNode{root} for level := 1; len(queue) &gt; 0; level++ { size := len(queue) tmp := queue queue = []*TreeNode{} // 清空，存储下一层的节点 vals := []int{} for i := 0; i &lt; size; i++ { node := tmp[0] tmp = tmp[1:] vals = append(vals, node.Val) if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } if level%2 == 0 { // 偶数行，翻转vals length := len(vals) for i := 0; i &lt; length/2; i++ { vals[i], vals[length-1-i] = vals[length-1-i], vals[i] // length-1是结束下标，-i就是同步往左逼近 } } answers = append(answers, vals) } return answers}","link":"/2022/02/06/2022-02-06-binary-tree-zigzag-level-order-traversal.html"},{"title":"LeetCode105——从前序与中序遍历序列构造二叉树","text":"题目给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。 示例 1: 12输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]输出: [3,9,20,null,null,15,7] 示例 2: 12输入: preorder = [-1], inorder = [-1]输出: [-1] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路利用前序遍历和中序遍历性质 前序遍历节点顺序如下[根，左，右] 中序遍历节点顺序如下[左，根，右] 前序遍历的左/右子树长度和中序遍历的左/右子树长度是相同的 由于这是同一颗树遍历来的，因此前序遍历的第0个元素和中序遍历的根节点是相同的。因此只要能定位中序遍历的根节点，将中序遍历数组拆分为左右两半后就可以了 查找中序遍历的数组中值为前序遍历第0个元素节点的下标，记为middle 此时中序遍历左子树节点列表为[:middle]，右子树节点列表为[middle+1:]，左子树长度为len([:middle])，记为leftTreeSize 根据第3点可知，前序遍历的左子树节点列表为[1:leftTreeSize+1],右子树节点为[leftTreeSize+1:] 12345678910111213141516171819202122// 递归法// 中序，左根右；前序根左右// 1. 根据中序遍历找到根节点(值为preorder[0]的节点)// 2. 中序遍历根节点左边的节点数和前序遍历的节点数是相同的，根据该性质可以将前序遍历拆分为两半func buildTree(preorder []int, inorder []int) *TreeNode { n := len(preorder) if n == 0 { return nil } root := &amp;TreeNode{Val: preorder[0]} // 查找根节点在中序遍历的位置 middle := 0 for ; middle &lt; n; middle++ { if inorder[middle] == preorder[0] { break } } leftTreeSize := len(inorder[:middle]) // 中序遍历的左半边就是左子树 root.Left = buildTree(preorder[1:leftTreeSize+1], inorder[:middle]) // 将前序遍历的左半边和中序的左半边递归构造左子树 root.Right = buildTree(preorder[leftTreeSize+1:], inorder[middle+1:]) // 将前序遍历的右半边和中序遍历的右半边构建右子树 return root}","link":"/2022/02/06/2022-02-06-construct-binary-tree-from-preorder-and-inorder-traversal.html"},{"title":"LeetCode99——恢复二叉搜索树","text":"题目给你二叉搜索树的根节点 root ，该树中的 恰好 两个节点的值被错误地交换。请在不改变其结构的情况下，恢复这棵树 。 示例 1： 123输入：root = [1,3,null,null,2]输出：[3,1,null,null,2]解释：3 不能是 1 的左孩子，因为 3 &gt; 1 。交换 1 和 3 使二叉搜索树有效。 示例 2： 123输入：root = [3,1,4,null,null,2]输出：[2,1,4,null,null,3]解释：2 不能在 3 的右子树中，因为 2 &lt; 3 。交换 2 和 3 使二叉搜索树有效。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/recover-binary-search-tree著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 中序遍历构造一个数组，根据二叉搜索树的性质，中序遍历是严格递增的 遍历该数组，找出后一个值小于前一个值的下标，根据这两个下标访问数组，可以得到两个错误值 遍历二叉树，根据第2步的两个值定位两个二叉树节点 交换两个节点的值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 1. 中序遍历构造一个数组// 2. 检查数组顺序，定位有问题的下标// 3. 中序遍历原来的树，定位指定下标的节点， 交换两个节点值func recoverTree(root *TreeNode) { // 构造数组 var values []int var valueGetter func(root *TreeNode) valueGetter = func(root *TreeNode) { if root == nil { return } valueGetter(root.Left) values = append(values, root.Val) valueGetter(root.Right) } valueGetter(root) // 检查数组值顺序，如果比前面的小或者比后面的大 var ( wrongIndex1 = -1 wrongIndex2 = -1 ) for i := 0; i &lt; len(values)-1; i++ { // 如果比前面的小或者比后面的大 if values[i+1] &lt; values[i] { wrongIndex2 = i + 1 if wrongIndex1 == -1 { wrongIndex1 = i } else { break } } } // 中序遍历，定位到wrongIndex1和wrongIndex2的节点，交换两者的值 var ( locator func(root *TreeNode) wrongNode1 *TreeNode wrongNode2 *TreeNode ) locator = func(root *TreeNode) { if root == nil { return } locator(root.Left) if root.Val == values[wrongIndex1] { // 根据值定位节点 wrongNode1 = root } else if root.Val == values[wrongIndex2] { wrongNode2 = root } locator(root.Right) } locator(root) wrongNode1.Val, wrongNode2.Val = wrongNode2.Val, wrongNode1.Val}","link":"/2022/02/06/2022-02-06-recover-binary-search-tree.html"},{"title":"LeetCode95——不同的二叉搜索树 II","text":"题目给你一个整数 n ，请你生成并返回所有由 n 个节点组成且节点值从 1 到 n 互不相同的不同 二叉搜索树 。可以按 任意顺序 返回答案。 示例 1： 12输入：n = 3输出：[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]] 示例 2： 输入：n = 1输出：[[1]] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/unique-binary-search-trees-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 由于每个节点都可以成为根节点，因此遍历1~n，i为遍历参数名称，此时可以构造如下树 1~i-1为左子树 i为根节点 i+1~n为右子树 递归的调用步骤1可以得到所有的组合 1234567891011121314151617181920212223242526272829303132func generateTrees(n int) []*TreeNode { if n == 0 { return nil } return generate(1, n)}// 生成start ~ end的数列表func generate(start, end int) []*TreeNode { // 非法条件拦截 if start &gt; end { return []*TreeNode{nil} } allNodes := []*TreeNode{} // 遍历n for i := start; i &lt;= end; i++ { // start ~ i-1可以构造左子树节点 leftTrees := generate(start, i-1) // i+1 ~ end可以构造右子树节点 rightTrees := generate(i+1, end) for _, left := range leftTrees { for _, right := range rightTrees { // 组装左根右节点 root := &amp;TreeNode{Val: i} root.Left = left root.Right = right allNodes = append(allNodes, root) } } } return allNodes}","link":"/2022/02/06/2022-02-06-unique-binary-search-trees-ii.html"},{"title":"LeetCode98——验证二叉搜索树","text":"题目给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。 有效 二叉搜索树定义如下： 节点的左子树只包含 小于 当前节点的数。节点的右子树只包含 大于 当前节点的数。所有左子树和右子树自身必须也是二叉搜索树。 示例 1： 12输入：root = [2,1,3]输出：true 示例 2： 123输入：root = [5,1,4,null,null,3,6]输出：false解释：根节点的值是 5 ，但是右子节点的值是 4 。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/validate-binary-search-tree著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路直接用中序遍历即可。中序遍历可以保证后一个值一定比前一个值大。 中序遍历处理顺序：左-&gt;根-&gt;右 123456789101112131415161718192021222324// 中序遍历，值如果都是升序就满足要求func isValidBST(root *TreeNode) bool { var ( lastValue = math.MinInt64 // 上一个值，初始化时保证是最小值即可，这样只要树节点有值就能大于该值 helper func(root *TreeNode) bool // 判断指定节点是否大于lastValue ) helper = func(root *TreeNode) bool { if root == nil { // 节点为空，直接返回true return true } if !helper(root.Left) { // 如果左子树不满足要求则返回false return false } if root.Val &lt;= lastValue { // 如果当前节点&lt;=上一个节点，则不满足要求（中序遍历本节点一定大于上一个节点） return false } lastValue = root.Val // 更新上一个节点 if !helper(root.Right) { // 检查右子树 return false } return true } return helper(root)}","link":"/2022/02/06/2022-02-06-validate-binary-search-tree.html"},{"title":"LeetCode106——从中序与后序遍历序列构造二叉树","text":"题目给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。 示例 1: 12输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]输出：[3,9,20,null,null,15,7] 示例 2: 12输入：inorder = [-1], postorder = [-1]输出：[-1] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 核心是中序遍历的顺序是[左，根，右]，后序遍历是[左，右，根]。而同一颗树不管前/中/后序遍历，节点数是不变的。 1234567891011121314151617181920212223242526272829// 后序遍历顺序: 左右根// 1. postorder最后一个元素为根// 2. 遍历inorder查找根的index// 3. inorder[:index]为左子树，inorder[index+1:]为右子树，左子树大小记为leftTreeSize// 4. postorder[:leftTreeSize]为左子树，postorder[leftTreeSize:len(postorder)-1]是右子树func buildTree(inorder []int, postorder []int) *TreeNode { n := len(inorder) if n == 0 { return nil } if n == 1 { return &amp;TreeNode{Val: inorder[0]} } // 查找中序遍历根的index index := -1 rootValue := postorder[len(postorder)-1] for i := 0; i &lt; len(inorder); i++ { if inorder[i] == rootValue { index = i break } } // 分割数组 leftTreeSize := len(inorder[:index]) root := &amp;TreeNode{Val: rootValue} root.Left = buildTree(inorder[:index], postorder[:leftTreeSize]) root.Right = buildTree(inorder[index+1:], postorder[leftTreeSize:len(postorder)-1]) return root}","link":"/2022/02/08/2022-02-08-construct-binary-tree-from-inorder-and-postorder-traversal.html"},{"title":"LeetCode108——将有序数组转换为二叉搜索树","text":"题目给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。 高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。 示例 1： 12输入：nums = [-10,-3,0,5,9]输出：[0,-3,9,-10,null,5] 示例 2： 123输入：nums = [1,3]输出：[3,1]解释：[1,3] 和 [3,1] 都是高度平衡二叉搜索树。 思路 二叉树的中序遍历是升序，节点顺序为[左，根，右] 对于给定的数组，根据升序的性质，可知，中间节点为根节点，左半部分为左子树，右半部分为右子树 左半部分也是一颗完整的树，复用1的逻辑，因此用递归即可 12345678910111213141516171819202122232425// 升序数组是树的中序遍历结果，中间Index就是根，可以递归的还原为一个树func sortedArrayToBST(nums []int) *TreeNode { if len(nums) == 0 { return nil } if len(nums) == 1 { return &amp;TreeNode{Val: nums[0]} } return helper(nums, 0, len(nums)-1)}func helper(nums []int, start, end int) *TreeNode { if start &gt; end { return nil } // 取得根 rootIndex := (start + end) / 2 rootValue := nums[rootIndex] root := &amp;TreeNode{Val: rootValue} root.Left = helper(nums, start, rootIndex-1) root.Right = helper(nums, rootIndex+1, end) return root}","link":"/2022/02/08/2022-02-08-convert-sorted-array-to-binary-search-tree.html"},{"title":"LeetCode109——有序链表转换二叉搜索树","text":"题目给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。 示例: 123456789给定的有序链表： [-10, -3, 0, 5, 9],一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树： 0 / \\ -3 9 / / -10 5 思路转换为数组 转换为数组后解法跟前面一道题一样。 123456789101112131415161718192021222324252627282930313233// 链表转换为数组，复用108解法func sortedListToBST(head *ListNode) *TreeNode { if head == nil { return nil } list := listToArray(head) return helper(list, 0, len(list)-1)}func listToArray(head *ListNode) []int { result := []int{} for head != nil { result = append(result, head.Val) head = head.Next } return result}func helper(nums []int, start, end int) *TreeNode { if start &gt; end { return nil } // 取得根 rootIndex := (start + end) / 2 rootValue := nums[rootIndex] root := &amp;TreeNode{Val: rootValue} root.Left = helper(nums, start, rootIndex-1) root.Right = helper(nums, rootIndex+1, end) return root} 链表操作 我们遍历到中间节点后，将链表拆分为[左部分，中间点，右部分]即可复用逻辑，而且无额外空间占用 单链表是无法直到中间点在哪里的，因此我们需要先遍历一次，获取链表长度，除以2就是中间的index。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 1. 遍历一遍链表得到链表长度，算出中间节点index// 2. 再次遍历链表，拆分为三段// 1. 起点到中间节点的上一个节点：左子链表// 2. 中间节点// 3. 中间节点的下一个节点到链表末尾：右子链表// 3. 将中间节点作为树根，利用左右子链表，递归构建左右子树，然后挂到根节点func sortedListToBST(head *ListNode) *TreeNode { if head == nil { return nil } return helper(head)}func helper(head *ListNode) *TreeNode { if head == nil { return nil } if head.Next == nil { return &amp;TreeNode{Val: head.Val} } // 获取链表总长度 length := 0 p := head for p != nil { length++ p = p.Next } middle := length / 2 // 取得中间点位置 // 再次遍历到中间点 var ( prev = head // 指向中间点的上一个节点 curr = head.Next // 指向中间点 ) var ( left *ListNode // 左子链表头结点 right *ListNode // 右子链表头结点 ) index := 0 for curr != nil { // index是prev的下标，因此定位到middle的前一个 if index == middle-1 { // 找到中点，将中点和右子链表连接打断 right = curr.Next curr.Next = nil // 将左子链表和中点连接打断 prev.Next = nil left = head break } prev = curr curr = curr.Next index++ } // 此时我们拥有left,curr,right 三个链表，开始递归组合 root := &amp;TreeNode{Val: curr.Val} root.Left = helper(left) // 给你一条链表，给我构建一个树出来 root.Right = helper(right) return root}","link":"/2022/02/08/2022-02-08-convert-sorted-list-to-binary-search-tree.html"},{"title":"算法篇-leetcode 131 分割回文串","text":"题目给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。 回文串 是正着读和反着读都一样的字符串。 示例1 12输入：s = &quot;aab&quot;输出：[[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;],[&quot;aa&quot;,&quot;b&quot;]] 解答题目要求 将字符串字符打散后，将其中的回文串添加到一个单独的List 第1步的所有List构成最后的答案 可以看出，这是一个典型的回溯问题，考察有多少种方法可以组装最后的答案。 方法一：直接回溯思路及算法 回溯需要回答以下3个问题： 回溯终止条件是什么？ 回溯有哪些选择? 如何进入下一个选择？ 对于本题来说，我们需要将字符串打散，从中选择回文串添加到最终答案，因此，需要定义以下变量: $index$, 记录当前选择的字符索引 $path$, 记录本次回文串选择情况 $answer$, 记录最终答案 回答上面提出来的两个问题： 回溯终止条件: $index==s.length()$，此时将$path$拷贝到$answer$，不可以直接添加，因为回溯存在撤回操作，必须断开$answer$和$path$的引用。 回溯有哪些选择：定义变量$right$, 遍历 $s[index,s.length())$，当$s[index,right]$是回文串时，将其加入$path$。 如何进入下一个选择：第2个问题满足条件的情况下，增加$index$然后再次递归即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution { /** * DFS回溯 * 1. 回溯出口 index == s.length() * 2. 回溯递进 遍历[i,n) 如果s[i,j] 是回文串，则加入path，然后递归 s[i,j+1] * * @param s * @return */ public List&lt;List&lt;String&gt;&gt; partition(String s) { List&lt;List&lt;String&gt;&gt; answer = new ArrayList&lt;&gt;(); List&lt;String&gt; path = new ArrayList&lt;&gt;(); dfs(answer, path, 0, s.length(), s); return answer; } private void dfs(List&lt;List&lt;String&gt;&gt; answer, List&lt;String&gt; path, int index, int length, String s) { if (index == length) { answer.add(new ArrayList&lt;&gt;(path)); return; } // 本次有什么选择? // j =&gt; [index,len)，检测s[index,j]是否回文，如果是，则加入path，最后撤销选择 for (int i = index; i &lt; length; i++) { if (!isPalindrome(s, index, i)) { continue; } path.add(s.substring(index, i + 1)); dfs(answer, path, i + 1, length, s); path.remove(path.size() - 1); } } private boolean isPalindrome(String s, int left, int right) { while (left &lt; right) { if (s.charAt(left) != s.charAt(right)) { return false; } left++; right--; } return true; }} 复杂度分析 时间复杂度：$O(N*2^n)$，每个位置的字符可以拆分也可以不拆分，因此时间复杂度是$O(2^n)$，判断每个子字符串是否为回文串需要$O(N)$的时间。 空间复杂度：$O(N*2^n)$，考虑$answer$，每个位置的字符可以拆分也可以不拆分，两种情况都需要占用空间，此部分空间是$O(2^n)$，而对于所有的答案都需要保存，此部分空间是$O(N)$. 方法二：记忆法回溯思路及算法 在方法一的基础上添加$memo$保存$s[i,j]$是否为回文串，减少重复判断。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution { /** * DFS回溯 * 1. 回溯出口 index == s.length() * 2. 回溯递进 遍历[i,n) 如果s[i,j] 是回文串，则加入path，然后递归 s[i,j+1] * * @param s * @return */ public List&lt;List&lt;String&gt;&gt; partition(String s) { List&lt;List&lt;String&gt;&gt; answer = new ArrayList&lt;&gt;(); List&lt;String&gt; path = new ArrayList&lt;&gt;(); Boolean[][] memo = new Boolean[s.length()][s.length()]; dfs(memo, answer, path, 0, s.length(), s); return answer; } private void dfs(Boolean[][] memo, List&lt;List&lt;String&gt;&gt; answer, List&lt;String&gt; path, int index, int length, String s) { if (index == length) { answer.add(new ArrayList&lt;&gt;(path)); return; } // 本次有什么选择? // j =&gt; [index,len)，检测s[index,j]是否回文，如果是，则加入path，最后撤销选择 for (int i = index; i &lt; length; i++) { if (!isPalindrome(memo, s, index, i)) { continue; } path.add(s.substring(index, i + 1)); dfs(memo, answer, path, i + 1, length, s); path.remove(path.size() - 1); } } private boolean isPalindrome(Boolean[][] memo, String s, int left, int right) { if (memo[left][right] != null) { return memo[left][right]; } while (left &lt; right) { if (s.charAt(left) != s.charAt(right)) { return memo[left][right] = false; } left++; right--; } return memo[left][right] = true; }} 复杂度分析 时间复杂度：$O(N*2^n)$，每个位置的字符可以拆分也可以不拆分，因此时间复杂度是$O(2^n)$，判断每个子字符串是否为回文串需要$O(N)$的时间，但是添加了记忆化搜索，每个子串至多搜索一次。 空间复杂度：$O(N*2^n)$，考虑$answer$，每个位置的字符可以拆分也可以不拆分，两种情况都需要占用空间，此部分空间是$O(2^n)$，而对于所有的答案都需要保存，此部分空间是$O(N)$. 方法三：DP+回溯我们可以利用DP通过提前计算好字符串的回文信息。 思路和算法 需要提前截取子字符串然后进行DP。那么问题来了，如何截取所有在子字符串？我们可以定义如下双重循环： 12345for(int right = 0;right &lt; s.length(); right++) { for(int left = 0;left&lt;= right; right++) { // s[left,right] 就是所有的子字符串 }} 思考状态转移方程 定义$dp[i][j]$代表$s[i, j]$是否为回文串 当$s[left] == s[right]$可知字符串两端是相等的，需要考虑$left和right$的距离，通过穷举(笨办法)可知： $right - left = 0$时，$left$和$right$就是同一个字符，显然可以直接得到答案$true$ $right - left = 1$时，$left$和$right$是挨着的，比如$aa$，显然可以直接得到答案$true$ $right - right = 2$时，$left$和$right$中间夹了一个字符，比如$aba$，显然可以直接得到答案$true$ $right - right &gt; 2$ 时，不能直接看不出来了，需要进行状态转移，比如$aabaa$，当$s[0] == s[4]$时，我们需要看看$s[1,3]$是不是回文串，在本例中，由于$s[1,3]$是回文串，因此$s[0,4]$也是。 综上，DP方程如下： $$dp(i,j) = \\begin{cases}false, &amp; \\text{if } s[i] \\ne s[j] \\true, &amp; \\text{if } s[i] = s[j] &amp; j-i \\le 2 \\dp[i+1][j-1], &amp; \\text{if } j-i \\gt 2\\end{cases}$$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 /** * DP+DFS回溯 * 1. DP处理 dp[i][j]是否为回文 * 1.1 dp[i][i] = true * 1.2 dp[i][j] = s[i] == s[j] &amp;&amp; (dp[i+1][j-1] || j-i&lt;=2) * 2. 回溯 * 2.1 回溯出口: index == s.length() * 2.2 回溯递进：j =&gt; [i,s.length()) if(dp[i][j]) 添加子串，然后 dfs(index+1) * * @param s * @return */ public List&lt;List&lt;String&gt;&gt; partition(String s) { int n = s.length(); boolean[][] dp = new boolean[n][n]; for (int right = 0; right &lt; n; right++) { for (int left = 0; left &lt;= right; left++) { if (s.charAt(left) == s.charAt(right)) { if (right - left &lt;= 2) { dp[left][right] = true; } else { dp[left][right] = dp[left + 1][right - 1]; // 上一轮遍历过 } } } } List&lt;List&lt;String&gt;&gt; answer = new ArrayList&lt;&gt;(); List&lt;String&gt; path = new ArrayList&lt;&gt;(); dfs(answer, path, dp, 0, n, s); return answer; } private void dfs(List&lt;List&lt;String&gt;&gt; answer, List&lt;String&gt; path, boolean[][] dp, int index, int n, String s) { if (index == n) { answer.add(new ArrayList&lt;&gt;(path)); return; } for (int right = index; right &lt; n; right++) { if (dp[index][right]) { path.add(s.substring(index, right + 1)); dfs(answer, path, dp, right + 1, n, s); path.remove(path.size() - 1); } } }} 复杂度分析+时间复杂度：$O(2^n)$，计算$dp$需要$O(n^2)$,回溯需要$O(2^n)$。 空间复杂度：$O(N*2^n)$，考虑$answer$，每个位置的字符可以拆分也可以不拆分，两种情况都需要占用空间，此部分空间是$O(2^n)$，而对于所有的答案都需要保存，此部分空间是$O(N)$;考虑$dp$，需要$O(n^2)$的空间","link":"/2022/03/17/2022-03-17-palindrome-partitioning.html"},{"title":"基数排序算法","text":"基数排序又叫桶排序，是一种时间复杂度为$O(n)$的排序算法，但是相比于其他排序算法有$O(n)$的空间复杂度。 思路基数排序的核心思路如下： 准备0~9的10个桶，根据数字当前比较位的值来决定放入哪个桶。如当前比较个位，则数字13应该放入索引为3的桶中；当前比较百位，则123应该放入索引为1的桶中。 当所有数字全部放入桶之后，遍历0~9这10个桶，然后依次将数字保存到待排序数组，因为桶是有序的，所以本轮放回去的数字是有序的。 当前比较的位数左移，比如本轮比较个位，下一轮应该比较百位。 重复步骤1~3。 举例现在我们来看一个实际例子。 待排序数字：717, 328, 803, 422, 586, 944, 557, 308, 496, 624 第1轮比较个位直接按照个位放入桶中。 0 1 2 3 4 5 6 7 8 9 422 803 624 586 717 328 496 557 308 按照从左到右，从上到下的原则将数字归位：422,803,624,586,496,717,557,328,308 第2轮比较十位 0 1 2 3 4 5 6 7 8 9 803 717 422 557 586 496 308 624 328 按照从左到右，从上到下的原则将数字归位：803,308,717,422,624,328,557,586,496 第3轮比较百位 0 1 2 3 4 5 6 7 8 9 308 422 557 624 717 803 328 496 586 按照从左到右，从上到下的原则将数字归位：308,328,422,496,557,586,624,717,803 可以发现，比较的轮次由数组中最大的数字决定，以上面的例子来说，如果还存在一个1234数字，那么需要比较4轮才可以完成排序。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class RadixSort { // 基数排序 public void sort(int[] nums) { if (nums.length &lt;= 1) { return; } var max = Arrays.stream(nums).max().getAsInt(); // 当前处理位数 var exp = 1; // 桶 var bucket = new int[10][nums.length]; // 记录每个桶有几个数字 var bucketCount = new int[10]; while (max &gt;= exp) { // 求得每个数字当前位数的值 for (var num : nums) { // 求得当前位余数 var bitNumber = (num / exp) % 10; // 放入桶, index是桶的index，在同一个桶的数字需要index来标识位置 var index = bucketCount[bitNumber]; bucket[bitNumber][index] = num; // 桶内数量+1 bucketCount[bitNumber]++; } // 桶内数字归位 int k = 0; // 已归位的数字下标 for (var i = 0; i &lt; 10; i++) { if (bucketCount[i] &gt; 0) { // 当前桶有数字 for (int j = 0; j &lt; bucketCount[i]; j++) { // 遍历同一个桶的数字 nums[k] = bucket[i][j]; k++; } } // 桶数字清空 bucketCount[i] = 0; } // 位数左移 exp *= 10; } max = Integer.MIN_VALUE; for (int i = 1; i &lt; nums.length; i++) { var gap = nums[i] - nums[i - 1]; if (gap &gt; max) { max = gap; } } } public static void main(String[] args) { var sort = new RadixSort(); var list = new int[]{422, 803, 624, 586, 496, 717, 557, 328, 308}; sort.sort(list); System.out.println(Arrays.toString(list)); }} 时间复杂度: $O(n)$ ，严格来说是$O(log(n))$。$n$是待排序数组长度，在数据量小的情况下，最外层的while循环遍历次数可以认为是常数，内部嵌套的for循环次数为数组长度$n$，因此时间复杂度为$O(n)$；在数据量大的情况下，最外层的while循环次数为$O(log(n))$，内部嵌套的for循环次数依旧是$n$，因此时间复杂度为$O(nlog(n))$。 空间复杂度：$O(n)$。$n$是待排序数组长度，$bucket$的大小为$10*n$，$bucketCount$大小为$n$，因此总体空间复杂度为$O(n)$。","link":"/2022/12/30/2022-12-30-radix-sort.html"},{"title":"博耶-摩尔多数投票算法","text":"来自维基百科的解释： 博耶-摩尔多数投票算法（英语：Boyer–Moore majority vote algorithm）,中文常作多数投票算法、摩尔投票算法等，是一种用来寻找一组元素中占多数元素的常数空间级时间复杂度算法。这一算法由罗伯特·S·博耶（英语：Robert S. Boyer）和J·斯特罗瑟·摩尔（英语：J Strother Moore）在1981年发表[1]，也是处理数据流（英语：streaming algorithm）的一种典型算法。 简单来说，博耶-摩尔多数投票算法用来寻找数组中的多数元素，相比于用哈希表存储元素和次数使用$O(n)$的时间复杂度来说，该投票算法使用$O(1)$的空间复杂度。 算法摩尔投票算法分为投票-校验两个阶段。投票阶段会统计候选人的票数，遍历数组，如果当前数字和当前候选人不相等，则该候选人票数-1，当候选人票数归0时，需要更换候选人为当前数字；在校验阶段，需要重新遍历数字，并将值等于候选人的数字计数，遍历结束后，比如计数满足要求，则候选人满足要求。 举例比如[A,A, A, B,C]这组元素，我们需要筛选数量超过一半的数字。 首先我们定A为候选人，然后遍历数组，遇到B时A有3个，由于A!=B，因此A结果为2，再和C比较，犹豫A!=C，因此A结尾为1，遍历结束，A是投票阶段的候选人；再遍历数组，统计A的数量为3，超过一半(5/2)，因此A是票数最高的元素。 算法题Leetcode 229. 多数元素 II 给定一个大小为 n 的整数数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。 示例 1： 12输入：nums = [3,2,3]输出：[3] 示例 2： 12输入：nums = [1]输出：[1] 示例 3： 12输入：nums = [1,2]输出：[1,2] 思路题目要求找出所有出现次数超过n/3次的元素，由于摩尔投票算法空间复杂度是常数，因此需要预先定义候选人个数。 设出现次数超过n/3次的元素有$x$个，以下是求解$x$的过程：$$\\begin{equation}\\label{eqn:1}\\begin{aligned}&amp; 假设刚好是n/3个 \\&amp; \\because x * n/3 = n \\&amp; \\therefore x=3 \\&amp; 而实际上题目要求次数 &gt; n/3 \\&amp; \\therefore x &lt; 3 \\&amp; \\therefore x = 2\\end{aligned}\\end{equation}$$所以本题最多能选择2个候选人。 不妨设两个候选人$candidate1$和$candidate2$，$count1$和$count2$都是0 遍历数组，如果当前$nums[i]==candidate1$，则$count1++$，否则$count1–$，对$candidate2$同样处理 如果遍历过程中$count1$或$count2$为0，则更新对应的候选人为$nums[i]$ 投票阶段结束，进入重新计数校验阶段，我们留下了$candidate1$和$candidate2$，再次遍历数组，如果值和这两个候选人相同，则对应的$count$增加 如果$count&gt;nums.length/3$，则将当前候选人加入答案 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Solution2 { // 摩尔投票法 // 1. 因为题目要求超过 n/3 的数字，因此最多有2个数字 // 2. 投票阶段，初始化2个数字，以及count // 3. 遍历nums，如果和num1相等，则count1++，如果和num2相等，则count2++，否则票数-- // 4. 如果num1的count1为0，则num1为当前num // 5. 校验阶段 // 6. 统计num1和num2的次数，看看是否&gt;n/3 public List&lt;Integer&gt; majorityElement(int[] nums) { var answer = new ArrayList&lt;Integer&gt;(); if (nums.length == 0) { return Collections.emptyList(); } int candidate1 = nums[0], count1 = 0; int candidate2 = nums[0], count2 = 0; for (int num : nums) { // 增加1的票数 if (num == candidate1) { count1++; continue; } // 增加2的票数 if (num == candidate2) { count2++; continue; } // 1票数不足，更新候选人1 if (count1 == 0) { candidate1 = num; count1++; continue; } // 2票数不足，更新候选人2 if (count2 == 0) { candidate2 = num; count2++; continue; } // 票数相减 count1--; count2--; } count1 = 0; count2 = 0; for (var num : nums) { if (num == candidate1) { count1++; } else if (num == candidate2) { count2++; } } if (count1 &gt; nums.length / 3) { answer.add(candidate1); } if (count2 &gt; nums.length / 3) { answer.add(candidate2); } return answer; } } 时间复杂度：$O(n)$, $n$是数组长度，需要遍历两次。 空间复杂度: $O(1)$，只需要常数项额外空间。","link":"/2022/12/31/2022-12-31-boyer-moore-majority-vote-algorithm.html"},{"title":"原地哈希算法","text":"原地哈希算法(Cyclic Sort)主要应用在值都在$[0,n]$的数组$nums$中，此时可以将$nums[i]$作为索引，放回原数组，当然，由于程序上索引是从0开始，因此可以将$nums[i]$放到$nums[nums[i]-1]$的位置上。 举例Leetcode 268. 丢失的数字 给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。 示例 1： 123输入：nums = [3,0,1]输出：2解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。 示例 2： 123输入：nums = [0,1]输出：2解释：n = 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，因为它没有出现在 nums 中。 示例 3： 123输入：nums = [9,6,4,2,3,5,7,0,1]输出：8解释：n = 9，因为有 9 个数字，所以所有的数字都在范围 [0,9] 内。8 是丢失的数字，因为它没有出现在 nums 中。 示例 4： 123输入：nums = [0]输出：1解释：n = 1，因为有 1 个数字，所以所有的数字都在范围 [0,1] 内。1 是丢失的数字，因为它没有出现在 nums 中。 提示： n == nums.length 1 &lt;= n &lt;= 104 0 &lt;= nums[i] &lt;= n nums 中的所有数字都 独一无二 进阶：你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题? 解答用哈希表可以解答，但是空间复杂度达到了$O(n)$，没有利用到值都在$[0,n]$这个已知条件。所以我们用原地哈希解答本题。 遍历数组，如果$nums[i]-1&gt;=0$ 且$nums[i] != nums[nums[i]-1]$，证明$nums[i]$未归位，我们将$i$和$nums[i]-1$处的数字交换，此步骤要一直循环到$nums[i]-1$越界或者$nums[i]$归位 重新遍历数组，如果$nums[i] != i+1$，证明当前位置的$nums[i]$是错的，也就是缺少本来应该放到这个位置的数字，所以答案也就呼之欲出了。 123456789101112131415161718192021222324252627class Solution { // 原地哈希 // 1. 将nums[i] 放到 nums[nums[i]-1]的位置 // 2. 重新遍历，如果 nums[i] != i+1 则缺失i+1数字 public int missingNumber(int[] nums) { for (int i = 0; i &lt; nums.length; i++) { // 数字归位 // 如nums[i]为2，那么最终需要放到1号索引 while (nums[i] - 1 &gt;= 0 &amp;&amp; nums[i] != nums[nums[i] - 1]) { swap(nums, i, nums[i] - 1); } } // 数字已归位，查询哪个数字的值和位置不匹配，不匹配的就是缺失的数字 for (int i = 0; i &lt; nums.length; i++) { if (nums[i] != i + 1) { return i + 1; } } return 0; } private void swap(int[] nums, int i, int j) { var temp = nums[i]; nums[i] = nums[j]; nums[j] = temp;} 时间复杂度：$O(n)$。$n$是数组长度，每个元素会被一次性移动归位，此后不再移动，因此每个元素的访问次数是常数，而总共需要访问$n$个数字。 空间复杂度：$O(1)$。复用题目给定的$nums$空间作为哈希表，未引入额外空间。","link":"/2022/12/31/2022-12-31-cyclic-sort.html"},{"title":"厄拉多塞筛素数筛选算法","text":"厄拉多塞筛算法（Eratosthenes Sieve）是一种求素数的方法，由古希腊数学家厄拉多塞提出。它的原理是，给定一个数 n，从 2 开始依次将 $\\sqrt n$ 以内的素数的倍数标记为合数，标记完成后，剩余未被标记的数为素数（从 2 开始）。如此可省去检查每个数的步骤，使筛选素数的过程更加简单。 算法厄拉多塞筛算法具体步骤如下： 读取输入的数 n，将 2 到 n 的所有整数记录在表中 从 2 开始，划去表中所有 2 的倍数 由小到大寻找表中下一个未被划去的整数，再划去表中所有该整数的倍数 重复第（3）步，直到找到的整数大于$\\sqrt n$为止 表中所有未被划去的整数均为素数 朴素的素数筛选算法如下：对给定的数字$i$，设定数字$j$从$2$遍历到$\\sqrt i$，如果中间$i$能整除$j$，则$i$不是素数。该方法的时间复杂度为$O(n\\sqrt n)$ ,$n$是数组长度，外层循环需要遍历$n$次，内层循环需要遍历$\\sqrt n$次。 而厄拉多塞筛算法的时间复杂度为$O(n log(log(n)))$。 举例这是一张来自维基百科的算法示意图。 先从2开始遍历，将2的倍数(2,4,6,8,…)标记为为非素数 继续遍历，当前数字是素数时，继续将当前数字的倍数标记为非素数 直到所有数字标记完，重新标记数组，未被标记的就是素数 算法题Leetcode 204. 计数质数 给定整数 n ，返回 所有小于非负整数 n 的质数的数量 。 示例 1： 123输入：n = 10输出：4解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。 示例 2： 12输入：n = 0输出：0 示例 3： 12输入：n = 1输出：0 代码实现123456789101112131415161718192021222324252627282930class Solution2 { // 厄拉多塞筛素数筛选算法 // 1. 准备O(n)的数组，标识数字是否是质数，初始情况下全部是质数 // 2. 从2开始遍历到sqrt(n),如果数字是质数，则i*i开始，后面i的倍数全是合数 // 3. 从[2,n)筛选质数并统计 public int countPrimes(int n) { if (n &lt; 2) { return 0; } var isPrime = new boolean[n]; Arrays.fill(isPrime, true); for (int i = 2; i * i &lt; n; i++) { // 遍历一半即可 if (isPrime[i]) { // 如果是质数，则将i平方开始的所有i的倍数设为合数 // 任意素数x的倍数有：2x, 3x, 4x, ..., x*x, (x+1)*x, ... // 任意小于x*x的倍数都被之前的素数筛过滤过，如：2 过滤 2x, 4x, ...，3 过滤 3x, ... for (int j = i * i; j &lt; n; j += i) { isPrime[j] = false; } } } var count = 0; for (int i = 2; i &lt; n; i++) { if (isPrime[i]) { count++; } } return count; } } 时间复杂度: $O(nlog(log(n)))$。时间复杂度证明过程有点复杂，我暂时还没消化。 空间复杂度：$O(n)$。需要长度为$n$的数组标记是否素数。","link":"/2022/12/31/2022-12-31-eratosthenes-sieve.html"},{"title":"查找第N大的数","text":"在给定的序列中查找第N大的数，朴素做法是对序列排序，然后根据索引直接查询，时间复杂度为$O(nlogn)$。 本文介绍一种在$O(n)$的时间复杂度查询第N大的数的算法。 算法算法思路就是定义标志变量，然后遍历数组，根据标志变量和当前数组变量的大小更新标志变量，最后根据情况返回标志变量。 示例：查找第2大的数定义$first$和$second$分别存储最大和次大，然后遍历数组时更新即可。 123456789101112131415161718192021222324252627282930/** * 查找第二大的数字 */public class SecondMaximumNumber { public int secondMaximumNumber(int[] nums) { // 最大数 var first = Integer.MIN_VALUE; // 次大数 var second = Integer.MIN_VALUE; for (var num : nums) { // 当前数字比最大数还大，最大数更新为当前数字，原来的最大数更新为第2大 if (num &gt;= first) { second = first; first = num; } else if (num &gt;= second) { // 当前数字小于最大，但是大于第2大，更新第2大 second = num; } } return second; } public static void main(String[] args) { var nums = new int[]{1, 3, 2, 8, 5}; var s = new SecondMaximumNumber(); System.out.println(s.secondMaximumNumber(nums)); }} 示例：查找第3大的数Leetcode: 第三大的数 原理和查第2大的数想通，定义$first$,$second$,$third$三个变量，然后遍历$nums$ 若$num &gt; first$，则$second$赋值给$third$，$first$赋值给$second$,$num$赋值给$first$ 若$num &lt; first$且 $num &gt; second$，则$second$赋值给$third$，$num$赋值给$second$ 若$num &lt; second$且$num &gt; third$，则$num$赋值给$third$ 最后根据题意返回$third$或者$first$即可。 12345678910111213141516171819202122class Solution3 { // 三个变量 public int thirdMax(int[] nums) { var first = Long.MIN_VALUE; var second = first; var third = second; for (var num : nums) { if (num &gt; first) { // 如果num&gt;最大值，原来的最大变次大，原来的次大变三大, 当前边最大 third = second; second = first; first = num; } else if (num &lt; first &amp;&amp; num &gt; second) { // 小于最大，但是大于第二, 第二变第三，当前边第二 third = second; second = num; } else if (num &lt; second &amp;&amp; num &gt; third) { // 小于第二，但是大于第三 third = num; } } return (int) (third == Long.MIN_VALUE ? first : third); } } 时间复杂度:$O(n)$，$n$是数组长度，仅需遍历一次。 空间复杂度: $O(1)$，仅需使用3个变量。","link":"/2023/01/03/2023-01-03-nth-maximum-number.html"},{"title":"解析字符串中的数字","text":"本文分享一种如何在字符串中解析数字的算法。 思路解析字符串中的数字需要判断当前是否是数字字符，以及如何处理连续的数字字符。 本文使用while循环来解析数字，之所以不使用for循环，是笔者认为while循环操控力比for循环要好。 while循环解析方法如下： 如果当前字符是数字，则开启内部while循环 内部while循环退出条件为当前字符不是数字 内部循环操作为读取当前数字，然后加上一个数字乘以10 内部循环退出后，我们就得到一个连续的数字 示例Leetcode 2042. 检查句子中的数字是否递增 123456789101112131415161718192021222324252627class Solution { // 提取字符串中的数字，判断是否严格递增 public boolean areNumbersAscending(String s) { // 定义上一个数字，初始化为最小的数字 var lastNumber = Integer.MIN_VALUE; var i = 0; while (i &lt; s.length()) { if (Character.isDigit(s.charAt(i))) { // 当前是数字，继续处理 var number = 0; // 核心代码 while (i &lt; s.length() &amp;&amp; Character.isDigit(s.charAt(i))) { // 字符串没越界而且当前字符是数字字符 number = number * 10 + (s.charAt(i) - '0'); // (s.charAt(i) - '0') 就是利用ASCII码表直接得到数字值，不需要再做parseInt i++; // 坐标后移 } if (number &lt;= lastNumber) { // 如果当前数字&lt;=上一个数字，证明不是严格递增，return false return false; } // number &gt; lastNumber，更新lastNumber lastNumber = number; } // i后移 i++; } return true; } } 复杂度分析 时间复杂度：$O(n)$，每个字符访问一次。空间复杂度:$O(1)$，仅需常数项额外变量。 注意 时间复杂度就是分析随着数据量增大，算法执行次数的变化。本题虽然有两重循环，有些同学可能无脑以为时间复杂度是$O(n^2)$，实际上是不对的。可以发现每个字符串最多访问一次，所以复杂度是$O(n)$。","link":"/2023/01/03/2023-01-03-parse-number-in-string.html"},{"title":"洗牌算法","text":"洗牌算法用来将给定的序列打乱，可以认为是排序的反操作。 正确性判断对于包含$n$个元素的序列，其全排列有$n!$种。如果序列打乱的结果为$n!$种且每种序列出现的概率相同，则是正确的洗牌算法。 Fisher–Yates 洗牌算法 以下算法说明摘自: https://gaohaoyang.github.io/2016/10/16/shuffle-algorithm/ Fisher–Yates shuffle 的原始版本，最初描述在 1938 年的 Ronald Fisher和 Frank Yates 写的书中，书名为《Statistical tables for biological, agricultural and medical research》。他们使用纸和笔去描述了这个算法，并使用了一个随机数表来提供随机数。它给出了 1 到 N 的数字的的随机排列，具体步骤如下： 写下从 1 到 N 的数字 取一个从 1 到剩下的数字（包括这个数字）的随机数 k 从低位开始，得到第 k 个数字（这个数字还没有被取出），把它写在独立的一个列表的最后一位 重复第 2 步，直到所有的数字都被取出 第 3 步写出的这个序列，现在就是原始数字的随机排列 已经证明如果第 2 步取出的数字是真随机的，那么最后得到的排序一定也是。 正确性证明正确的洗牌算法要保证每个数字出现在每个位置的概率一样。我们来看看Fisher–Yates洗牌算法是否正确。 假设现在有1,2,3,4,5五个数字。 首先在1-5随机一个数，假设是4，随机概率为1/5 再次从1,2,3,5中随机一个数，假设是5，随机概率为1/4，但是5在第一步没被选上的概率是4/5，因此总体概率是1/4*4/5还是1/5 代码123456789public void shuffle(int[] nums) { var n = nums.length; for (int i = 0; i &lt; n; i++) { int newIndex = i + random.nextInt(n - i); // 在i之后的下标随机，可以保证不会随机到i前面的 int temp = nums[i]; nums[i] = nums[newIndex]; nums[newIndex] = temp; }} 时间复杂度: $O(n)$，$n$是数组长度，只需要遍历一次。 空间复杂度：$O(1)$，仅需常数项空间。","link":"/2023/01/03/2023-01-03-shuffle-algorithm.html"},{"title":"计算数字二进制位中1的个数","text":"本文分享一种计算给定数字二进制表示中有多少个1的算法。 位运算对于非硬件相关的开发者来说可能用的比较少，朴素做法是将数字转换为二进制字符串，然后遍历该字符串得到1的个数。 算法 通过右移我们可以访问到数字的指定比特 将该比特与1进行按位与&amp;，结果为1则证明当前比特位是1，计数器+1 根据给定数字的数据类型可以确定需要位移的次数，对于int来说，4个字节，因此需要右移32次，而对于long来说，8个字节，需要右移64次。 代码1234567891011class Solution { public int getBit1Count(int num) { var count = 0; for (int i = 0; i &lt; 32; i++) { if (((num &gt;&gt; i) &amp; 1) == 1) { count++; } } return count; }} 复杂度分析 时间复杂度：$O(1)$，不管多大的数字，只需要右移32次。 空间复杂度：$O(1)$，无需额外空间。","link":"/2023/01/05/2023-01-05-counting-bit1-of-binary-number.html"},{"title":"字符串子序列检测算法","text":"本文分享一种检测一个字符串是否为另一个字符串子序列的算法。 子序列的定义： 若字符串$s1$可以由字符串$s2$删除某些字符得到，则$s1$是$s2$的子序列。换句话说，若$s1$的所有字符都在$s2$中且顺序一致，则$s1$是$s2$的子序列。 例如： a是aaa的子序列，adf是abcdef的子序列，但是cba不是abc的子序列（因为字符顺序变了）。 算法 声明$s1$的下标变量$strIndex$，若$s2$有$s1$的该字符，则$strIndex+1$ 若遍历过程中$strIndex$和$s1$的长度相等，则证明$s1$所有字符都在$s2$中，返回$s1$是$s2$在子序列 遍历结束仍未返回，证明$s1$不是$s2$的子序列 代码1234567891011121314151617class Solution { public boolean isSubsequent(String str, String str1) { var strIndex = 0; // 逐字符遍历 // 如果字符想通，则strIndex++ // 如果strIndex到达末尾，则证明str是子序列 for (var i = 0; i &lt; str1.length(); i++) { if (str.charAt(strIndex) == str1.charAt(i)) { strIndex++; } if (strIndex == str.length()) { return true; } } return false; }} 复杂度分析 时间复杂度：$O(n)$,$n$是$str1$的长度。 空间复杂度：$O(1)$。","link":"/2023/01/05/2023-01-05-subsequence-checking-algorithm.html"},{"title":"水塘抽样算法","text":"下面是维基百科水塘抽样的说明。 水塘抽样是一系列的随机算法，其目的在于从包含 $n$个项目的集合 中选取$k$ 个样本，其中 $n$为一很大或未知的数量，尤其适用于不能把所有 $n$ 个项目都存放到内存的情况。 本文分享在随机数据流中等概率抽取target的水塘抽样算法。 算法 定义$count$计数变量 遍历给定的数据流，如果当前数字等于$target$, $count$+1 在$[0, count]$产生随机数，如果等于$count$，则抽样成功 示例Leetcode 398. 随机数索引 代码 12345678910111213141516171819202122232425262728class Solution { // 哈希表保存&lt;值,List&lt;下标&gt;&gt; private final int[] nums; private final Random random; public Solution(int[] nums) { this.nums = nums; this.random = new Random(System.currentTimeMillis()); } // 水塘抽样 // 统计target count,随机数%count 为0时重置index public int pick(int target) { var count = 0; var index = 0; for (var i = 0; i &lt; nums.length; i++) { if (nums[i] == target) { count++; if (random.nextInt() % count == 0) { index = i; } } } return index; }} 复杂度分析 时间复杂度：$O(n)$,$n$是$nums$长度，需要遍历一次$nums$ 空间复杂度：$O(1)$,严格来说，java默认使用浅拷贝，因此$nums$不会有额外空间占用。","link":"/2023/01/19/2023-01-19-reservoir-sampling.html"},{"title":"滑动窗口算法","text":"滑动窗口算法是查找连续区间常用的算法之一。 本文分享滑动窗口算法的通用框架。 算法 定义$left$和$right$双指针，代表窗口的左边界和右边界 当$right$小于给定区间大小时，我们可以进行操作。 在扩大窗口时，需要加当前新加入的数据进行处理 当当前窗口内数据不满足条件时，右移$left$指针缩小窗口 计算$[left,right]$之间的数据，和最佳答案比较并更新最佳答案 右移$right$ 下面是滑动窗口通用框架的java语言实现。 1234567891011int left = 0;int right = 0;while(right &lt; 上界) { 将right处数据加入窗口 while(窗口数据不符合要求) { 移除left数据 left++ } 根据当前right和left计算最佳答案并更新 right++} 示例Leetcode 3. 无重复字符的最长子串 思路 基于算法框架的思路如下： 定义$left$和$right$双指针，代表窗口的左边界和右边界，再定义HashMap&lt;Character, Integer&gt;存储窗口内的字符和数量(可以使用长度为128的字符数组代替，省去操作hashmap的开销。 当$right$小于$s.length()$时，我们可以进行操作。 在扩大窗口时，将$s.charAt(right)$加入HashMap 当HashMap.get(s.charAt(right)&gt;1)，此时$right$处字符重复，需要收缩左边界，$left$处的字符数量-1，右移$left$ 计算$[left,right]$之间的数据，和最佳答案比较并更新最佳答案 代码 12345678910111213141516171819202122232425262728class Solution { // 滑动窗口 // 定义left,right, hashmap&lt;char,int&gt; // 循环条件 right&lt;s.length() // right字符入map // while刚才入的字符重复，map移除left的字符，left++ // 计算长度 // right++ public int lengthOfLongestSubstring(String s) { var left = 0; var right = 0; var answer = 0; var map = new int[128]; while (right &lt; s.length()) { var rightChar = s.charAt(right); map[rightChar]++; // 窗口有重复字符，收缩左边界 while (map[rightChar] &gt; 1) { var leftChar = s.charAt(left); map[leftChar]--; left++; } answer = Math.max(answer, right - left + 1); right++; } return answer; }} 复杂度分析 时间复杂度：$O(n)$, $n$是字符串长度，每个字符至多访问2次。 空间复杂度: $O(1)$，只需常数项空间。","link":"/2023/01/19/2023-01-19-slide-window-algorithm.html"},{"title":"时间差计算算法","text":"本文分享如何解决计算时间差类的问题。 算法 首先需要将时间转化为数字，比如23:59，可以转化为23*60+59 然后根据数字从小到大排序，此时从[0, n]处的数据有序，可以遍历该区间计算差值 需要注意的是，由于时间的特殊性，比如23:59下一分会归0，因此还需要比如0处和n处的时间差 示例Leetcode 539. 最小时间差 代码 123456789101112131415161718192021222324class Solution { // 模拟 // 时间字符串转化为数字 // 排序，线性遍历，然后再比较第一个和最后一个的差值 public int findMinDifference(List&lt;String&gt; timePoints) { // 24小时总共1440个可能，超过1440，直接返回0（存在重复时间点） if (timePoints.size() &gt; 1440) { return 0; } var array = new int[timePoints.size()]; for (int i = 0; i &lt; timePoints.size(); i++) { var str = timePoints.get(i); array[i] = Integer.parseInt(str.substring(0, 2)) * 60 + Integer.parseInt(str.substring(3)); } Arrays.sort(array); var answer = Integer.MAX_VALUE; for (int i = 1; i &lt; array.length; i++) { answer = Math.min(answer, array[i] - array[i - 1]); } // 和首尾差值比较 return Math.min(answer, array[0] + 1440 - array[array.length - 1]); }} 复杂度分析 时间复杂度：$O(nlogn)$,$n$是序列长度，主要是排序的时间。 空间复杂度：$O(n)$,$n$是序列长度。","link":"/2023/01/19/2023-01-19-time-difference.html"},{"title":"拓补排序","text":"在计算机科学领域，有向图的拓扑排序或拓扑测序是对其顶点的一种线性排序，使得对于从顶点$u$到顶点$v$的每个有向边$uv$, $u$在排序中都在$v$之前。 例如，图形的顶点可以表示要执行的任务，并且边可以表示一个任务必须在另一个任务之前执行的约束；在这个应用中，拓扑排序只是一个有效的任务顺序。 当且仅当图中没有定向环时（即有向无环图），才有可能进行拓扑排序。 任何有向无环图至少有一个拓扑排序。 算法 遍历有向边，构造u-&gt;v边中v的入度表，可使用哈希存储入度 将入度为0的节点入队 队列节点不断出队，出队时减小被更新节点的入度，如果被更新节点入度为0，则该节点入队 重复以上过程，最终可以得到一个从入度为0到最终节点的序列，这就是拓补排序算法。 示例Leetcode 210. 课程表2 12345678910111213141516171819202122232425262728293031323334353637383940class Solution { // 生成邻接表 &lt;当前节点，后置节点&gt; // 进行BFS拓补排序，由最低依赖的开始写入答案 public int[] findOrder(int numCourses, int[][] prerequisites) { Set&lt;Integer&gt;[] graph = new HashSet[numCourses]; for (int i = 0; i &lt; numCourses; i++) { graph[i] = new HashSet&lt;&gt;(); } // 入度 int[] inDegree = new int[numCourses]; for (int[] p : prerequisites) { int current = p[0]; int pre = p[1]; graph[pre].add(current); inDegree[current]++; } Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; numCourses; i++) { if (inDegree[i] == 0) { queue.offer(i); } } int[] answer = new int[numCourses]; int index = 0; while (!queue.isEmpty()) { // 弹出课程 int course = queue.remove(); answer[index++] = course; // 遍历邻接表，减掉入度，入度归0时入队 for (int target : graph[course]) { inDegree[target]--; if (inDegree[target] == 0) { queue.offer(target); } } } return index &gt;= numCourses ? answer : new int[0]; }} 复杂度分析 时间复杂度：$O(n)$ ,$n$是课程数量 空间复杂度：$O(n)$，$n$是课程数量","link":"/2023/02/10/2023-02-10-topological-sorting.html"},{"title":"修复M1使用gomonkey提示permission defined错误","text":"问题Go单元测试在M1上使用github.com/agiledragon/gomonkey/v2 v2.9.0包提示permission defined。网上查阅消息得知是由于内存安全导致，不能同时对内存进行写和执行 解决方法下面分享一种比较简单的方法，需要修改本地的go源码。 修改go/pkg/mod/github.com/agiledragon/gomonkey/v2@v2.9.0/modify_binary_darwin.go的modifyBinary方法。将 1err := mprotectCrossPage(target, len(bytes), syscall.PROT_READ|syscall.PROT_WRITE|syscall.PROT_EXEC) 修改为 1err := mprotectCrossPage(target, len(bytes), syscall.PROT_READ|syscall.PROT_WRITE)","link":"/2023/04/20/2023-04-20-fix-gomonkey-permission-defined.html"},{"title":"读书笔记","text":"本文分享一下五一期间的读书感悟，包括MySQL、Redis、Aurora。 Redis 网络IO可以多线程处理，将请求包体和文件描述符投递到一个request队列，参考结构如下 1234class Request { byte[] req; int fd;} 主线程轮询request队列，取出req数据并按照以往方式准备响应resp，再次投递到一个response队列，参考结构如下 1234class Response { byte[] req; int fd;} 网络IO线程轮询response队列，将数据发往指定fd 优点： 解耦业务线程和IO线程，充分利用多线程能力 基于单线程+队列保证Redis业务线程仍然是单线程，无需同步/互斥逻辑 缺点： 需要维护两个额外队列，当请求激增，主线程处理不过来会造成数据积压 MySQL事务过程 从磁盘加载数据到bufferpool 写入并Flush undo日志 (顺序磁盘IO) 修改bufferpool中的数据 写入redo日志，不flush(无磁盘IO) … 如果有其他数据参与，重复步骤1…4 设置所有redo日志为prepare状态 写入并Flush binlog(顺序磁盘IO) Flush redo日志（顺序磁盘IO） 提交事务 MySQL double-write 引用内容 关于IO的最小单位： 1. 数据库IO的最小单位是16K（MySQL默认，oracle是8K） 2. 文件系统IO的最小单位是4K（也有1K的） 3. 磁盘IO的最小单位是512字节 因此，存在IO写入导致page损坏的风险： 上述例子中，一个脏页只有前面一半落盘了，后面一半还是老数据，所以这一个16K脏页数据无效。 redo日志无法恢复redo日志记录对数据页的物理修改，但是现在出现的问题是页本身无效，redo日志也无法恢复。具体原因如下： 数据文件上有一个老页面，加载到内存之后，内存也有一个老页面 修改内存数据，比如把某脏页第2个字节改为1， redo日志记录把该页第2个字节改为1 当InnoDB刷新脏页出现刷一半的问题时，数据文件上的老页面已经无效了（一半是新的，一半是旧的），跟内存修改时的老页面不一致，redo日志无法应用 double-write流程 脏页刷新时，拷贝到内存中的doublewrite buffer（大小2MB） 将doublewrite buffer分两次写入共享表空间文件（每次1MB，顺序IO，速度快） 将doublewrite buffer数据写入数据文件（随机磁盘IO） 本质上优点类似WAL(Write-Ahead-Log)，通过先顺序写入文件，再随机磁盘IO落盘。 数据恢复回到最开始的问题，InnoDB恢复时可以通过校验和发现数据文件中的脏页数据无效（对比脏页计算出来的校验和和磁盘上的校验和），此时可以通过共享表空间文件找到该页最近的数据，复制到数据文件，再应用redo日志，完成恢复 Amazon分布式MySQL数据库-AuroraAurora是Amazon研发的分布式MySQL，随着数据库上云，传统数据库的磁盘IO瓶颈已经变为了数据计算层和存储曾之间的IO瓶颈。换句话说，由于SSD的广泛使用，磁盘IO本身基本不是瓶颈。 Aurora的主要优点如下： 使用一个独立部署、能容忍错误并且能自动修改的分布式存储服务（跨数据中心），保证数据库不受存储层的可用性影响 不同数据库计算节点之间以及数据库存储节点之间，网络IO只有redolog（没有binlog） 将耗时的串行操作尽量拆解为异步操作，减少延迟 术语定义 计算节点：安装数据库软件的节点 存储节点：存储数据的节点 传统MySQL分布式架构 可以看到MySQL节点之间同步了非常多的数据，而由于MySQL的分层架构，数据库层和存储引擎层是分离的，导致binlog和redolog两份日志出现，实际上这两份日志的功能本质上是一样的，提供数据镜像和数据恢复。 Aurora的网络IOAurora极大减少了网络IO，节点之间真正传输的只有redolog和表的元数据，下图是Aurora的网络IO 一个数据写入流程如下： 存储节点接收到redo日志，写入本地内存队列（无磁盘IO） 将redo日志持久化到磁盘，并返回响应给计算节点（顺序磁盘IO） 整理记录，并检查是否有因为一些操作丢失导致的记录差异。 基于gossip解析和其他节点对齐数据 应用redo日志记录，将数据变更应用到数据页（随机磁盘IO） 定期将日志和新页面备份到S3 定期进行垃圾回收，清理掉无用的旧版本数据，释放存储空间 定期进行CRC校验， 修复损坏数据 只有1/2步会影响计算节点，其他步骤全部是异步的，这是高性能的保证 数据同步流程redo日志关联了（LSN，Log Sequence Number），LSN的概念和MySQL一致，当节点丢失数据时，可以通过gossip和其他节点对比LSN并补齐丢失的数据。 而当需要进行故障恢复时，Aurora首先会保证所有节点上的数据一致，通过使用LSN来实现，Aurora会选出一个保证可用的最高LSN，称为VCL（Volume Complete LSN），任何LSN高于VCL的日志记录会被截断。Aurora还规定只有某些特定的LSN可以作为截断点，称为CPL（Consistency Point LSNs），另外定义了VDL（Volume Durable LSN）为小于等于VCL的最大CPL。 简单例子：当前日志的LSN已经达到了1007，但数据库定义CPL为900，1000，1100这些特定值。那么&gt;1000的LSN数据会被截断，所以，最终VCL是1000。实际流程如下： 每个数据库层事务被切分成多个有序且可被原子操作的小事务（mini-transactions，MTRs） 每个MTR由多个连续的log record组成。 一个MTR的最后一个log record被认为是一个CPL。 Aurora操作 引用内容： Writes：当数据库收到一批log日志的write quorum的确认后，就会向前推进当前的VDL。在每一时刻，会有很多事务在同时进行，数据库会为每个日志分配一个唯一有序的LSN，同时LSN要小于当前VDL和LAL（LSN Allocation Lmit）的和。这段话翻译有些生硬，其实就是为了防止前台操作太快，后台存储系统处理不过来，LSN不能超前VDL太多，其差值最大为LAL，目前设置为10M。同时，为了解决每个分片可能存在的日志丢失问题，每个日志都有一个向前的回链（像是一个反向链表），通过向前回溯，以及Gossip交互，可以为各个节点构建一个完整的日志记录，称之为SCL（Segement Complete LSN），也即所有日志到达了所有节点的最大LSN。 Commits：Aurora的事务提交是完全异步的。工作线程收到commit请求，在一个等待commit的事务列表中记录它的commit LSN，然后就继续处理其它请求。有一个专门的线程在VDL推进时，判断列表中有哪些LSN小于等于VDL，然后将这些事务的应答推回给还在等待的客户端。 Reads：Aurora和很多其它数据库一样，数据页会放在缓存中，命中丢失时才会做一次IO请求，当缓存满时，系统会根据特定的算法汰换数据页。Aurora不一样的是，它要求在缓存中的page LSN一定要大于等于VDL。从而保证在这个数据页中所有请求都已经写到log，且可以通过VDL始终获取到最新的持久化数据。也因此，正常的读取只需要读一个满足条件的分片就足够了。 Replicas：在Aurora中，一个存储磁盘可以挂载一个writer和最多15个read副本。增加一个read副本不会对性能有什么影响。为了加快响应，写请求生成的日志流也会被发送到所有读副本中去。如果这个写请求涉及到当前缓存中的某个数据页，那就把这个请求更新到数据页中，否则就直接丢弃了。这里读副本消费请求是异步的，需要遵循两条规则：一是会更新到数据页的请求，其LSN需要小于等于VDL。二是mini-transaction的修改需要原子性的写入缓存，以保障数据一致性。 数据恢复和MySQL不同，Aurora的数据恢复是后台化的，在存储层即可完成，无需停机。 参考 分布式存储研究——Aurora InnoDB关键特性之double write","link":"/2023/05/03/2023-05-03-reading-note.html"}],"tags":[{"name":"openssl","slug":"openssl","link":"/tags/openssl/"},{"name":"yii","slug":"yii","link":"/tags/yii/"},{"name":"regex","slug":"regex","link":"/tags/regex/"},{"name":"wordpress","slug":"wordpress","link":"/tags/wordpress/"},{"name":"svn","slug":"svn","link":"/tags/svn/"},{"name":"mamp","slug":"mamp","link":"/tags/mamp/"},{"name":"xdebug","slug":"xdebug","link":"/tags/xdebug/"},{"name":"mybatis","slug":"mybatis","link":"/tags/mybatis/"},{"name":"pomelo","slug":"pomelo","link":"/tags/pomelo/"},{"name":"socket.io","slug":"socket-io","link":"/tags/socket-io/"},{"name":"react-native","slug":"react-native","link":"/tags/react-native/"},{"name":"spring-boot","slug":"spring-boot","link":"/tags/spring-boot/"},{"name":"koa","slug":"koa","link":"/tags/koa/"},{"name":"rtmp","slug":"rtmp","link":"/tags/rtmp/"},{"name":"thrift","slug":"thrift","link":"/tags/thrift/"},{"name":"protocol","slug":"protocol","link":"/tags/protocol/"},{"name":"ci","slug":"ci","link":"/tags/ci/"},{"name":"swift","slug":"swift","link":"/tags/swift/"},{"name":"context","slug":"context","link":"/tags/context/"},{"name":"c","slug":"c","link":"/tags/c/"},{"name":"systemd","slug":"systemd","link":"/tags/systemd/"},{"name":"swoole","slug":"swoole","link":"/tags/swoole/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"},{"name":"test","slug":"test","link":"/tags/test/"},{"name":"nestjs","slug":"nestjs","link":"/tags/nestjs/"},{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"es6","slug":"es6","link":"/tags/es6/"},{"name":"redis","slug":"redis","link":"/tags/redis/"},{"name":"shell","slug":"shell","link":"/tags/shell/"},{"name":"laravel","slug":"laravel","link":"/tags/laravel/"},{"name":"halia","slug":"halia","link":"/tags/halia/"},{"name":"gittalk","slug":"gittalk","link":"/tags/gittalk/"},{"name":"testing","slug":"testing","link":"/tags/testing/"},{"name":"binarysearch","slug":"binarysearch","link":"/tags/binarysearch/"},{"name":"linklist","slug":"linklist","link":"/tags/linklist/"},{"name":"tree","slug":"tree","link":"/tags/tree/"},{"name":"sort","slug":"sort","link":"/tags/sort/"},{"name":"string","slug":"string","link":"/tags/string/"}],"categories":[{"name":"backend","slug":"backend","link":"/categories/backend/"},{"name":"frontend","slug":"frontend","link":"/categories/frontend/"},{"name":"php","slug":"backend/php","link":"/categories/backend/php/"},{"name":"angularjs","slug":"frontend/angularjs","link":"/categories/frontend/angularjs/"},{"name":"nginx","slug":"backend/nginx","link":"/categories/backend/nginx/"},{"name":"linux","slug":"backend/linux","link":"/categories/backend/linux/"},{"name":"mysql","slug":"backend/mysql","link":"/categories/backend/mysql/"},{"name":"html5","slug":"frontend/html5","link":"/categories/frontend/html5/"},{"name":"android","slug":"android","link":"/categories/android/"},{"name":"css","slug":"frontend/css","link":"/categories/frontend/css/"},{"name":"devtools","slug":"devtools","link":"/categories/devtools/"},{"name":"javascript","slug":"frontend/javascript","link":"/categories/frontend/javascript/"},{"name":"nodejs","slug":"backend/nodejs","link":"/categories/backend/nodejs/"},{"name":"ios","slug":"ios","link":"/categories/ios/"},{"name":"mongodb","slug":"backend/mongodb","link":"/categories/backend/mongodb/"},{"name":"react","slug":"frontend/react","link":"/categories/frontend/react/"},{"name":"cpp","slug":"backend/cpp","link":"/categories/backend/cpp/"},{"name":"java","slug":"backend/java","link":"/categories/backend/java/"},{"name":"docker","slug":"backend/docker","link":"/categories/backend/docker/"},{"name":"typescript","slug":"frontend/typescript","link":"/categories/frontend/typescript/"},{"name":"go","slug":"backend/go","link":"/categories/backend/go/"},{"name":"vue","slug":"frontend/vue","link":"/categories/frontend/vue/"},{"name":"miniprogram","slug":"frontend/miniprogram","link":"/categories/frontend/miniprogram/"},{"name":"algorithm","slug":"algorithm","link":"/categories/algorithm/"},{"name":"other","slug":"other","link":"/categories/other/"}],"pages":[{"title":"关于","text":"ProfileReading &amp; Learning &amp; Sharing Skill Stack Web Development Microservices/Serverless Distributed Services","link":"/about/index.html"},{"title":"分类","text":"","link":"/categories/index.html"}]}