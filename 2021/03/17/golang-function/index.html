<!doctype html><html lang=zh><head><meta name=viewport content="width=device-width,initial-scale=1"><title>Golang程序设计——函数</title>
<meta charset=utf-8><meta content="Web开发 ,Java ,Go ,Node.js ,PHP ,Koa ,MySQL ,Redis ,前端 ,后端 ,数据库" name=keywords><meta name=description content="本文学习Go语言函数知识。函数是基本的代码块，用于执行一个任务。在Go语言中，函数可以接收数量不固定的参数，也可以返回多个结果。
函数结构 在编程领域，函数向编译器和开发者提供了有关的信息，这些信息指明了函数该接收什么样的输入以及会产生什么样的输出。这些信息是通过函数第一行提供的，第一行称为函数签名。
Go语言声明函数语法如下：
func 函数名称(参数名 参数类型) (返回值名称 返回值类型) { // 函数体 return语句 } 参数名在参数类型前面，如a int，这一点和其他语言是不同的 函数参数数量可以不固定，但是只允许最后一个参数数量不固定，而且必须是同种类型 返回值名称不是必须的，但是参数名是必须写的 有返回值的函数，函数体内必须包含return语句 示例：函数定义与调用"><meta name=author content="Lei Xia"><link rel=canonical href=https://www.ddhigh.com/2021/03/17/golang-function/><link rel=alternate type=application/rss+xml href=https://www.ddhigh.com//index.xml title=每天进步一点点><script async src="https://www.googletagmanager.com/gtag/js?id=G-EC3XLVSGKV"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-EC3XLVSGKV")</script><meta property="og:title" content="Golang程序设计——函数"><meta property="og:description" content="本文学习Go语言函数知识。函数是基本的代码块，用于执行一个任务。在Go语言中，函数可以接收数量不固定的参数，也可以返回多个结果。
函数结构 在编程领域，函数向编译器和开发者提供了有关的信息，这些信息指明了函数该接收什么样的输入以及会产生什么样的输出。这些信息是通过函数第一行提供的，第一行称为函数签名。
Go语言声明函数语法如下：
func 函数名称(参数名 参数类型) (返回值名称 返回值类型) { // 函数体 return语句 } 参数名在参数类型前面，如a int，这一点和其他语言是不同的 函数参数数量可以不固定，但是只允许最后一个参数数量不固定，而且必须是同种类型 返回值名称不是必须的，但是参数名是必须写的 有返回值的函数，函数体内必须包含return语句 示例：函数定义与调用"><meta property="og:type" content="article"><meta property="og:url" content="https://www.ddhigh.com/2021/03/17/golang-function/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-03-17T10:22:36+00:00"><meta property="article:modified_time" content="2021-03-17T10:22:36+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Golang程序设计——函数"><meta name=twitter:description content="本文学习Go语言函数知识。函数是基本的代码块，用于执行一个任务。在Go语言中，函数可以接收数量不固定的参数，也可以返回多个结果。
函数结构 在编程领域，函数向编译器和开发者提供了有关的信息，这些信息指明了函数该接收什么样的输入以及会产生什么样的输出。这些信息是通过函数第一行提供的，第一行称为函数签名。
Go语言声明函数语法如下：
func 函数名称(参数名 参数类型) (返回值名称 返回值类型) { // 函数体 return语句 } 参数名在参数类型前面，如a int，这一点和其他语言是不同的 函数参数数量可以不固定，但是只允许最后一个参数数量不固定，而且必须是同种类型 返回值名称不是必须的，但是参数名是必须写的 有返回值的函数，函数体内必须包含return语句 示例：函数定义与调用"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.ddhigh.com/posts/"},{"@type":"ListItem","position":2,"name":"Golang程序设计——函数","item":"https://www.ddhigh.com/2021/03/17/golang-function/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Golang程序设计——函数","name":"Golang程序设计——函数","description":"本文学习Go语言函数知识。函数是基本的代码块，用于执行一个任务。在Go语言中，函数可以接收数量不固定的参数，也可以返回多个结果。\n函数结构 在编程领域，函数向编译器和开发者提供了有关的信息，这些信息指明了函数该接收什么样的输入以及会产生什么样的输出。这些信息是通过函数第一行提供的，第一行称为函数签名。\nGo语言声明函数语法如下：\nfunc 函数名称(参数名 参数类型) (返回值名称 返回值类型) { // 函数体 return语句 } 参数名在参数类型前面，如a int，这一点和其他语言是不同的 函数参数数量可以不固定，但是只允许最后一个参数数量不固定，而且必须是同种类型 返回值名称不是必须的，但是参数名是必须写的 有返回值的函数，函数体内必须包含return语句 示例：函数定义与调用","keywords":[],"articleBody":"本文学习Go语言函数知识。函数是基本的代码块，用于执行一个任务。在Go语言中，函数可以接收数量不固定的参数，也可以返回多个结果。\n函数结构 在编程领域，函数向编译器和开发者提供了有关的信息，这些信息指明了函数该接收什么样的输入以及会产生什么样的输出。这些信息是通过函数第一行提供的，第一行称为函数签名。\nGo语言声明函数语法如下：\nfunc 函数名称(参数名 参数类型) (返回值名称 返回值类型) { // 函数体 return语句 } 参数名在参数类型前面，如a int，这一点和其他语言是不同的 函数参数数量可以不固定，但是只允许最后一个参数数量不固定，而且必须是同种类型 返回值名称不是必须的，但是参数名是必须写的 有返回值的函数，函数体内必须包含return语句 示例：函数定义与调用\npackage main import \"fmt\" func sum(a, b int) int { return a + b } func main() { fmt.Printf(\"1+2=%d\\n\", sum(1, 2)) } 在Go语言中，如果多个参数或多个返回值类型相同，只需要在最后一个参数或返回值声明类型。\n例如下面的函数签名在Go语言中是合法的。\nfunc sum2(a, b int) (c, d int) 不定参数函数 不定参数也就是数量不固定的参数。例如C语言中的printf函数就是一个典型的不定参数函数。Go语言支持不定参数函数，但是不定参数的类型必须相同。要声明不定参数，需要使用3个点(…)。\n示例：不定参数的加法函数\npackage main import \"fmt\" func sum(nums ...int) int { total := 0 for _, n := range nums { total += n } return total } func main() { fmt.Printf(\"1+2+3+4=%d\\n\", sum(1, 2, 3, 4)) } 在sum函数中，nums是一个包含所有参数的切片。\n函数返回值 多返回值 在Go语言中，函数能声明多个返回值，在这种情况下，return可以返回多个结果。函数调用者可通过多变量声明接收多个返回值。\n示例：多返回值函数\npackage main import ( \"errors\" \"fmt\" ) func div(a, b int) (int, error) { if b == 0 { return 0, errors.New(\"b is zero\") } return a / b, nil } func main() { ret, err := div(2, 1) if err != nil { fmt.Println(err) return } fmt.Printf(\"2/1=%d\\n\", ret) } 命名返回值 命名返回值让函数能够在返回前将返回值赋给命名变量，这种设计有利于提高程序可读性。要指定命名返回值，可在函数签名的返回值类型前面添加变量名。\n示例：命名返回值函数\npackage main import ( \"fmt\" ) func sum(a, b int) (total int) { total = a + b return } func main() { fmt.Printf(\"1+2=%d\\n\", sum(1, 2)) } 使用命名返回值后，return关键字可以单独出现，当然，return关键字继续返回结果值也是合法的。\nfunc sum(a, b int) (total int) { total = a + b return total } 函数类型 在Go语言中，函数是一种数据类型，可以将函数赋值给变量、或者作为参数传递，也可以作为返回值返回。\n示例：将函数作为变量、参数、返回值。\npackage main import \"fmt\" func main() { // 函数作为变量 sum := func(a, b int) int { return a + b } fmt.Printf(\"1+1=%d\\n\", sum(1, 1)) // 函数作为参数 sum2(1, 1, func(total int) { fmt.Printf(\"1+1=%d\\n\", total) }) // 函数作为返回值 totalFn := sum3(1, 1) fmt.Printf(\"1+1=%d\\n\", totalFn()) } func sum2(a, b int, callback func(int)) { total := a + b callback(total) } func sum3(a, b int) func() int { return func() int { return a + b } } 匿名函数、闭包、延迟执行函数 匿名函数 匿名函数指没有名称的函数，只有函数签名（参数和返回值声明）和函数体，匿名函数经常用于回调、闭包、临时函数等。\n示例：利用匿名函数实现事件总线。\npackage main import \"fmt\" func main() { emitter := make(map[string]func()) addEventListener(emitter, \"event1\", func() { fmt.Println(\"event1 called\") }) emit(emitter, \"event2\") } // 添加事件监听器 // emitter 事件总线 // event 事件名 // callback 回调函数 func addEventListener(emitter map[string]func(), event string, callback func()) { emitter[event] = callback } // 触发事件 // emitter 事件总线 // event 事件名 func emit(emitter map[string]func(), event string) { callback, ok := emitter[event] if ok { callback() } } main函数调用addEventListener时传入的第三个函数即为匿名函数。\n闭包 闭包可以理解为定义在一个函数内部的函数。在本质上，闭包是函数和其引用环境的组合体。引用环境即使在外部函数执行结束也不会被回收，因此可以利用闭包保存保存执行环境。\n示例：利用闭包提供唯一ID生成器。\npackage main import \"fmt\" func main() { s1 := sequenceId() s2 := sequenceId() fmt.Printf(\"s1 -\u003e %v\\n\", s1()) fmt.Printf(\"s1 -\u003e %v\\n\", s1()) fmt.Printf(\"s2 -\u003e %v\\n\", s2()) fmt.Printf(\"s2 -\u003e %v\\n\", s2()) } func sequenceId() func() int { var id int return func() int { id++ return id } } 输出如下\ns1 -\u003e 1 s1 -\u003e 2 s2 -\u003e 1 s2 -\u003e 2 函数sequenceId定义了一个局部变量id，并返回了一个子函数，子函数内部访问了外部的id，因此这构成一个典型的闭包。在前面的内容中我们学习过变量作用域，内部总是可以访问外部的变量或常量，而外部无法访问内部的变量或常量。此外，由于变量id被子函数使用，因此在sequenceId函数返回后，id也不会被销毁。\n每调用一次sequenceId函数都会返回一个新的子函数以及对应的id，因此s1和s2之间的输出互不影响。\n注意：由于闭包会导致被引用的变量无法销毁，因此需要注意使用，避免产生内存泄漏。\n延迟执行函数 在实际编程中往往会打开一些资源，例如文件、网络连接等等，这些资源在使用完毕时（无论是正常关闭或者函数异常）需要主动关闭，当函数的结束分支太多或者逻辑比较复杂时容易发生忘记关闭的情况导致资源泄漏。\nGo语言提供了defer关键字用来延迟执行一个函数，一般使用该函数延迟关闭资源。多个defer语句会按照先进后出的方式执行，也就是最后声明的最先执行，典型的栈结构。\n示例：defer执行顺序。\npackage main import \"fmt\" func main() { defer f1() defer f2() fmt.Println(\"call main\") } func f1() { fmt.Println(\"call f1\") } func f2() { defer fmt.Println(\"defer call f2\") fmt.Println(\"call f2\") } 输出如下\ncall main call f2 defer call f2 call f1 第一行输出call main是因为main函数中只有一个非defer语句，因此call main最先执行\n第二行输出call f2是因为f2函数内部有一个非defer语句\n第三行输出defer call f2是因为f2函数的fmt.Println(“call f2”)执行完毕后才能执行defer\n第四行输出call f1是因为defer f1()最先声明因此最后执行\n示例：基于defer和闭包构造一个函数执行耗时记录器。\npackage main import ( \"fmt\" \"time\" ) type Person struct { Name string Age int Sex string } func main() { defer spendTime()() time.Sleep(time.Second) fmt.Println(\"call main\") } func spendTime() func() { startAt := time.Now() return func() { fmt.Println(time.Since(startAt)) } } 输出如下\ncall main 1.002345498s spendTime()会返回一个闭包，因此定义defer时会初始化startAt为当前时间，defer执行时会执行闭包函数得到函数耗时。main函数为了测试方便休眠了一秒钟，因此可以看到输出是超过1秒的。\n小结 本文介绍了如何在Go语言中使用函数。包括不定参数函数、多返回值和命名返回值函数以及将函数作为类型使用的方法，最后介绍了匿名函数、闭包和延迟执行函数。接下来的内容中将介绍Go语言中的结构体。\n","wordCount":"509","inLanguage":"zh","datePublished":"2021-03-17T10:22:36Z","dateModified":"2021-03-17T10:22:36Z","author":{"@type":"Person","name":"Lei Xia"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.ddhigh.com/2021/03/17/golang-function/"},"publisher":{"@type":"Organization","name":"每天进步一点点","logo":{"@type":"ImageObject","url":"https://www.ddhigh.com/favicon.ico"}}}</script><link rel=icon href=/img/favicon.ico sizes=16x16><link rel=apple-touch-icon href=/img/favicon.ico><link rel=manifest href=/img/favicon.ico><link rel=stylesheet href=https://cdn.staticfile.org/lxgw-wenkai-webfont/1.6.0/style.css><link rel=stylesheet href=/css/main.min.eb16e2c37edda7bb7b8f844336c65138877ea26f51562d3d69efff7f073bff83.css integrity="sha256-6xbiw37dp7t7j4RDNsZROId+om9RVi09ae//fwc7/4M=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/highlight/github-dark.min.min.66034289ee9a113219a2c4aae0a8bd2095ab255c832a42efcf5863f10814e7a1.css><script src=/js/highlight.min.min.c607d6febd16934a82eb61d3a896ed9d869f54373cc63ce95864ed5488fe3128.js></script><script>hljs.highlightAll()</script><script>$darkModeInit.Content|safeJS</script></head><body><main class=wrapper><nav class=navigation><section class=container><a class=navigation-brand href=/>每天进步一点点
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><span></span><span></span><span></span></label><ul class=navigation-list id=navigation-list><li class="navigation-item navigation-menu"><a class=navigation-link href=/archives>归档</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/books>出版物</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/guestbook>留言板</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class="navigation-item navigation-social"><a class=navigation-link href=https://github.com/xialeistudio><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li class="navigation-item navigation-dark"><button id=mode type=button aria-label="toggle user light or dark theme">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span>
<span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></li><li class="navigation-item navigation-language"><a href=https://www.ddhigh.com/en/>EN</a></li></ul></section></nav><div id=content><article class=blog-single><header class=blog-title><h1>Golang程序设计——函数</h1></header><p><small>2021年3月17日&nbsp;· 509 字&nbsp;· 3 分钟</small><p><div class=blog-toc><nav id=TableOfContents><ul><li><a href=#函数结构>函数结构</a></li><li><a href=#不定参数函数>不定参数函数</a></li><li><a href=#函数返回值>函数返回值</a><ul><li><a href=#多返回值>多返回值</a></li><li><a href=#命名返回值>命名返回值</a></li></ul></li><li><a href=#函数类型>函数类型</a></li><li><a href=#匿名函数闭包延迟执行函数>匿名函数、闭包、延迟执行函数</a><ul><li><a href=#匿名函数>匿名函数</a></li><li><a href=#闭包>闭包</a></li><li><a href=#延迟执行函数>延迟执行函数</a></li></ul></li><li><a href=#小结>小结</a></li></ul></nav></div><section class=blog-content><p>本文学习Go语言函数知识。函数是基本的代码块，用于执行一个任务。在Go语言中，函数可以接收数量不固定的参数，也可以返回多个结果。</p><h2 id=函数结构>函数结构</h2><p>在编程领域，函数向编译器和开发者提供了有关的信息，这些信息指明了函数该接收什么样的输入以及会产生什么样的输出。这些信息是通过函数第一行提供的，第一行称为函数签名。</p><p>Go语言声明函数语法如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>函数名称</span>(<span style=color:#a6e22e>参数名</span> <span style=color:#a6e22e>参数类型</span>) (<span style=color:#a6e22e>返回值名称</span> <span style=color:#a6e22e>返回值类型</span>) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 函数体
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>return语句</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol><li>参数名在参数类型前面，如<code>a int</code>，这一点和其他语言是不同的</li><li>函数参数数量可以不固定，但是只允许最后一个参数数量不固定，而且必须是同种类型</li><li>返回值名称不是必须的，但是参数名是必须写的</li><li>有返回值的函数，函数体内必须包含return语句</li></ol><p>示例：函数定义与调用</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sum</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>b</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;1+2=%d\n&#34;</span>, <span style=color:#a6e22e>sum</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在Go语言中，如果多个参数或多个返回值类型相同，只需要在最后一个参数或返回值声明类型。</p><p>例如下面的函数签名在Go语言中是合法的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sum2</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span> <span style=color:#66d9ef>int</span>) (<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>d</span> <span style=color:#66d9ef>int</span>) 
</span></span></code></pre></div><h2 id=不定参数函数>不定参数函数</h2><p>不定参数也就是数量不固定的参数。例如C语言中的printf函数就是一个典型的不定参数函数。Go语言支持不定参数函数，但是不定参数的类型必须相同。要声明不定参数，需要使用3个点(&mldr;)。</p><p>示例：不定参数的加法函数</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sum</span>(<span style=color:#a6e22e>nums</span> <span style=color:#f92672>...</span><span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>total</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>nums</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>total</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>n</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>total</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;1+2+3+4=%d\n&#34;</span>, <span style=color:#a6e22e>sum</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在sum函数中，nums是一个包含所有参数的切片。</p><h2 id=函数返回值>函数返回值</h2><h3 id=多返回值>多返回值</h3><p>在Go语言中，函数能声明多个返回值，在这种情况下，return可以返回多个结果。函数调用者可通过多变量声明接收多个返回值。</p><p>示例：多返回值函数</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;errors&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>div</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span> <span style=color:#66d9ef>int</span>) (<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>b</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>New</span>(<span style=color:#e6db74>&#34;b is zero&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>/</span> <span style=color:#a6e22e>b</span>, <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ret</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>div</span>(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;2/1=%d\n&#34;</span>, <span style=color:#a6e22e>ret</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=命名返回值>命名返回值</h3><p>命名返回值让函数能够在返回前将返回值赋给命名变量，这种设计有利于提高程序可读性。要指定命名返回值，可在函数签名的返回值类型前面添加变量名。</p><p>示例：命名返回值函数</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sum</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span> <span style=color:#66d9ef>int</span>) (<span style=color:#a6e22e>total</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>total</span> = <span style=color:#a6e22e>a</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>b</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;1+2=%d\n&#34;</span>, <span style=color:#a6e22e>sum</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>使用命名返回值后，return关键字可以单独出现，当然，return关键字继续返回结果值也是合法的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sum</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span> <span style=color:#66d9ef>int</span>) (<span style=color:#a6e22e>total</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>total</span> = <span style=color:#a6e22e>a</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>b</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>total</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=函数类型>函数类型</h2><p>在Go语言中，函数是一种数据类型，可以将函数赋值给变量、或者作为参数传递，也可以作为返回值返回。</p><p>示例：将函数作为变量、参数、返回值。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 函数作为变量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>sum</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>b</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;1+1=%d\n&#34;</span>, <span style=color:#a6e22e>sum</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 函数作为参数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>sum2</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>total</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;1+1=%d\n&#34;</span>, <span style=color:#a6e22e>total</span>)
</span></span><span style=display:flex><span>	})
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 函数作为返回值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>totalFn</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sum3</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;1+1=%d\n&#34;</span>, <span style=color:#a6e22e>totalFn</span>())
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sum2</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>callback</span> <span style=color:#66d9ef>func</span>(<span style=color:#66d9ef>int</span>)) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>total</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>b</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>callback</span>(<span style=color:#a6e22e>total</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sum3</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>func</span>() <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>func</span>() <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>b</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=匿名函数闭包延迟执行函数>匿名函数、闭包、延迟执行函数</h2><h3 id=匿名函数>匿名函数</h3><p>匿名函数指没有名称的函数，只有函数签名（参数和返回值声明）和函数体，匿名函数经常用于回调、闭包、临时函数等。</p><p>示例：利用匿名函数实现事件总线。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>emitter</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>func</span>())
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>addEventListener</span>(<span style=color:#a6e22e>emitter</span>, <span style=color:#e6db74>&#34;event1&#34;</span>, <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;event1 called&#34;</span>)
</span></span><span style=display:flex><span>	})
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>emit</span>(<span style=color:#a6e22e>emitter</span>, <span style=color:#e6db74>&#34;event2&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// 添加事件监听器
</span></span></span><span style=display:flex><span><span style=color:#75715e>// emitter 事件总线
</span></span></span><span style=display:flex><span><span style=color:#75715e>// event 事件名
</span></span></span><span style=display:flex><span><span style=color:#75715e>// callback 回调函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>addEventListener</span>(<span style=color:#a6e22e>emitter</span> <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>func</span>(), <span style=color:#a6e22e>event</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>callback</span> <span style=color:#66d9ef>func</span>()) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>emitter</span>[<span style=color:#a6e22e>event</span>] = <span style=color:#a6e22e>callback</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 触发事件
</span></span></span><span style=display:flex><span><span style=color:#75715e>// emitter 事件总线
</span></span></span><span style=display:flex><span><span style=color:#75715e>// event 事件名
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>emit</span>(<span style=color:#a6e22e>emitter</span> <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>func</span>(), <span style=color:#a6e22e>event</span> <span style=color:#66d9ef>string</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>callback</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>emitter</span>[<span style=color:#a6e22e>event</span>]
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ok</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>callback</span>()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>main函数调用addEventListener时传入的第三个函数即为匿名函数。</p><h3 id=闭包>闭包</h3><p>闭包可以理解为定义在一个函数内部的函数。在本质上，闭包是函数和其引用环境的组合体。引用环境即使在外部函数执行结束也不会被回收，因此可以利用闭包保存保存执行环境。</p><p>示例：利用闭包提供唯一ID生成器。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>s1</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sequenceId</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>s2</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sequenceId</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;s1 -&gt; %v\n&#34;</span>, <span style=color:#a6e22e>s1</span>())
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;s1 -&gt; %v\n&#34;</span>, <span style=color:#a6e22e>s1</span>())
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;s2 -&gt; %v\n&#34;</span>, <span style=color:#a6e22e>s2</span>())
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;s2 -&gt; %v\n&#34;</span>, <span style=color:#a6e22e>s2</span>())
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sequenceId</span>() <span style=color:#66d9ef>func</span>() <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>id</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>func</span>() <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>id</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>id</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>输出如下</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>s1</span> <span style=color:#f92672>-</span>&gt; <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>s1</span> <span style=color:#f92672>-</span>&gt; <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>s2</span> <span style=color:#f92672>-</span>&gt; <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>s2</span> <span style=color:#f92672>-</span>&gt; <span style=color:#ae81ff>2</span>
</span></span></code></pre></div><p>函数sequenceId定义了一个局部变量id，并返回了一个子函数，子函数内部访问了外部的id，因此这构成一个典型的闭包。在前面的内容中我们学习过变量作用域，内部总是可以访问外部的变量或常量，而外部无法访问内部的变量或常量。此外，由于变量id被子函数使用，因此在sequenceId函数返回后，id也不会被销毁。</p><p>每调用一次sequenceId函数都会返回一个新的子函数以及对应的id，因此s1和s2之间的输出互不影响。</p><blockquote><p>注意：由于闭包会导致被引用的变量无法销毁，因此需要注意使用，避免产生内存泄漏。</p></blockquote><h3 id=延迟执行函数>延迟执行函数</h3><p>在实际编程中往往会打开一些资源，例如文件、网络连接等等，这些资源在使用完毕时（无论是正常关闭或者函数异常）需要主动关闭，当函数的结束分支太多或者逻辑比较复杂时容易发生忘记关闭的情况导致资源泄漏。</p><p>Go语言提供了defer关键字用来延迟执行一个函数，一般使用该函数延迟关闭资源。多个defer语句会按照先进后出的方式执行，也就是最后声明的最先执行，典型的栈结构。</p><p>示例：defer执行顺序。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>f1</span>()
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>f2</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;call main&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>f1</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;call f1&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>f2</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;defer call f2&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;call f2&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>输出如下</p><pre tabindex=0><code>call main
call f2
defer call f2
call f1
</code></pre><ol><li><p>第一行输出call main是因为main函数中只有一个非defer语句，因此call main最先执行</p></li><li><p>第二行输出call f2是因为f2函数内部有一个非defer语句</p></li><li><p>第三行输出defer call f2是因为f2函数的fmt.Println(&ldquo;call f2&rdquo;)执行完毕后才能执行defer</p></li><li><p>第四行输出call f1是因为defer f1()最先声明因此最后执行</p></li></ol><p>示例：基于defer和闭包构造一个函数执行耗时记录器。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;time&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Person</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Name</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Age</span>  <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Sex</span>  <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>spendTime</span>()()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;call main&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>spendTime</span>() <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>startAt</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>()
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Since</span>(<span style=color:#a6e22e>startAt</span>))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>输出如下</p><pre tabindex=0><code>call main
1.002345498s
</code></pre><p>spendTime()会返回一个闭包，因此定义defer时会初始化startAt为当前时间，defer执行时会执行闭包函数得到函数耗时。main函数为了测试方便休眠了一秒钟，因此可以看到输出是超过1秒的。</p><h2 id=小结>小结</h2><p>本文介绍了如何在Go语言中使用函数。包括不定参数函数、多返回值和命名返回值函数以及将函数作为类型使用的方法，最后介绍了匿名函数、闭包和延迟执行函数。接下来的内容中将介绍Go语言中的结构体。</p><p><img alt=img src=https://static.ddhigh.com/blog/2021-03-09-162926-2.png></p><div style="margin-top:2em;border:1px solid #d3d3d3;background-color:#f7f7f7"><ul><li style=margin-bottom:.5em>本文作者: <a href=https://ddhigh.com/ target=_blank style=color:#000;text-decoration:none>xialeistudio</a></li><li style=margin-bottom:.5em>本文链接: <a href=https://www.ddhigh.com/2021/03/17/golang-function/ target=_blank style=color:#000;text-decoration:none>Golang程序设计——函数</a></li><li>版权声明: <a href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank style=color:#000;text-decoration:none>「署名-非商业性使用-相同方式共享 4.0 国际」</a></li></ul></div></section><div class=paginator><a class=prev href=https://www.ddhigh.com/2021/06/04/plantuml-tutorial/><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M9.94496 9C9.28897 9.61644 7.63215 10.997 6.04814 11.7966 5.98257 11.8297 5.98456 11.9753 6.05061 12.0063c1.00435.4716 2.8788 1.9201 3.89435 2.9937M6.44444 11.9667C8.86549 12.0608 14 12 16 11" stroke="currentcolor" stroke-linecap="round"/></svg>
<span>PlanUML指南</span></a>
<a class=next href=https://www.ddhigh.com/2021/03/09/golang-data-container/><span>Golang程序设计——数据容器</span><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M12.055 9C12.711 9.61644 14.3679 10.997 15.9519 11.7966 16.0174 11.8297 16.0154 11.9753 15.9494 12.0063 14.945 12.4779 13.0706 13.9264 12.055 15m3.5006-3.0333C13.1345 12.0608 8 12 6 11" stroke="currentcolor" stroke-linecap="round"/></svg></a></div><div class=comments><script>const getTheme=window.localStorage&&window.localStorage.getItem("theme");let theme=getTheme==="dark"?"dark":"light",s=document.createElement("script");s.src="https://giscus.app/client.js",s.setAttribute("data-repo","xialeistudio/discussion"),s.setAttribute("data-repo-id","R_kgDOKurTRA"),s.setAttribute("data-category","General"),s.setAttribute("data-category-id","DIC_kwDOKurTRM4CbCJt"),s.setAttribute("data-mapping","pathname"),s.setAttribute("data-strict","0"),s.setAttribute("data-reactions-enabled","1"),s.setAttribute("data-emit-metadata","0"),s.setAttribute("data-input-position","bottom"),s.setAttribute("data-theme",theme),s.setAttribute("data-lang","en"),s.setAttribute("data-loading","lazy"),s.setAttribute("crossorigin","anonymous"),s.setAttribute("async",""),document.querySelector("div.comments").innerHTML="",document.querySelector("div.comments").appendChild(s)</script></div></article></div><footer class=footer><p>&copy; 2014 - 2024 <a href=https://www.ddhigh.com/>每天进步一点点</a>
Powered by
<a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>
<a href=https://github.com/guangzhengli/hugo-theme-ladder rel=noopener target=_blank>Ladder</a>
️</p></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.5376 22.7916C11.0152 22.7207 22.5795 21.1781 22.0978 10.4211 22.0536 9.43274 21.9303 8.53367 21.7387 7.71865M10.5376 22.7916C16.876 22.3728 20.0969 19.8899 21.5383 16.9142M10.5376 22.7916C9.7707 22.9055 8.97982 22.8964 8.19743 22.7725M21.7387 7.71865C21.4988 6.69828 21.1518 5.80967 20.7188 5.04257m1.0199 2.67608C22.6022 10.1105 23.0542 13.7848 21.5383 16.9142M20.7188 5.04257c-3.5504-6.28886-12.88753-4.410077-16.44303.0C2.88063 6.77451-.0433281 11.1668 1.38159 16.6571c.89322 3.4417 3.7911 5.6365 6.81584 6.1154M20.7188 5.04257c1.3509 1.89783 3.3111 6.34223 1.6353 10.37273M21.5383 16.9142C21.8737 16.4251 22.1428 15.9235 22.3541 15.4153M8.19743 22.7725C12.1971 23.4683 20.6281 22.971 22.3541 15.4153M14 10.945C13.3836 10.289 12.003 8.63215 11.2034 7.04814 11.1703 6.98257 11.0247 6.98456 10.9937 7.05061 10.5221 8.05496 9.07362 9.92941 8 10.945m3.0333-3.50056C10.9392 9.86549 11 15 12 17" stroke="currentcolor" stroke-linecap="round"/></svg>
</a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function n(){t.innerHTML="Copied",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)}),e.parentNode.appendChild(t)})</script></main></body><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script><script>const images=Array.from(document.querySelectorAll(".blog-content img"));images.forEach(e=>{mediumZoom(e,{margin:10,scrollOffset:40,container:null,template:null,background:"rgba(0, 0, 0, 0.5)"})})</script><script src=/main.min.6bb26b69159420159c74dc9e097b06a578ed2b68c701466a91a44a9632d851bd0af167a1b30012387b4c512b48ad9ad4d3394e04d77ae38d57e1920fe4ed34fe.js integrity="sha512-a7JraRWUIBWcdNyeCXsGpXjtK2jHAUZqkaRKljLYUb0K8WehswASOHtMUStIrZrU0zlOBNd6441X4ZIP5O00/g==" crossorigin=anonymous defer></script></html>