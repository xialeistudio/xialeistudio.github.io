<!doctype html><html lang=zh><head><meta name=viewport content="width=device-width,initial-scale=1"><title>NestJs学习之旅(2)——控制器</title>
<meta charset=utf-8><meta name=google-adsense-account content="ca-pub-2871082647721658"><meta content="Web开发 ,Java ,Go ,Node.js ,PHP ,Koa ,MySQL ,Redis ,前端 ,后端 ,数据库" name=keywords><meta name=description content="本文是NestJs学习之旅的第二篇，主要讲解控制器。
MVC 说到控制器就不得不说经典的MVC架构。
MVC模式（Model–view–controller）是软件工程中的一种软件架构模式，把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）。
控制器（Controller）- 负责转发请求，对请求进行处理，处理完毕后输出响应。 视图 （View） - 界面设计人员进行图形界面设计 模型 （Model）- 数据库查询和业务逻辑 可以看到控制器起着承上启下的作用，是Web开发中必备的一环，视图和模型倒不是必须的，理由如下："><meta name=author content="Lei Xia"><link rel=canonical href=https://www.ddhigh.com/2019/08/20/nestjs-controller/><link rel=alternate type=application/rss+xml href=https://www.ddhigh.com/index.xml title=每天进步一点点><script async defer data-website-id=52f8f0f9-d93d-466b-8ef5-508aae8c4ed4 src=https://analysis.ddhigh.com/script.js></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-EC3XLVSGKV"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-EC3XLVSGKV")</script><meta property="og:title" content="NestJs学习之旅(2)——控制器"><meta property="og:description" content="本文是NestJs学习之旅的第二篇，主要讲解控制器。
MVC 说到控制器就不得不说经典的MVC架构。
MVC模式（Model–view–controller）是软件工程中的一种软件架构模式，把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）。
控制器（Controller）- 负责转发请求，对请求进行处理，处理完毕后输出响应。 视图 （View） - 界面设计人员进行图形界面设计 模型 （Model）- 数据库查询和业务逻辑 可以看到控制器起着承上启下的作用，是Web开发中必备的一环，视图和模型倒不是必须的，理由如下："><meta property="og:type" content="article"><meta property="og:url" content="https://www.ddhigh.com/2019/08/20/nestjs-controller/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-08-20T10:10:21+00:00"><meta property="article:modified_time" content="2019-08-20T10:10:21+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="NestJs学习之旅(2)——控制器"><meta name=twitter:description content="本文是NestJs学习之旅的第二篇，主要讲解控制器。
MVC 说到控制器就不得不说经典的MVC架构。
MVC模式（Model–view–controller）是软件工程中的一种软件架构模式，把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）。
控制器（Controller）- 负责转发请求，对请求进行处理，处理完毕后输出响应。 视图 （View） - 界面设计人员进行图形界面设计 模型 （Model）- 数据库查询和业务逻辑 可以看到控制器起着承上启下的作用，是Web开发中必备的一环，视图和模型倒不是必须的，理由如下："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://www.ddhigh.com/posts/"},{"@type":"ListItem","position":3,"name":"NestJs学习之旅(2)——控制器","item":"https://www.ddhigh.com/2019/08/20/nestjs-controller/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"NestJs学习之旅(2)——控制器","name":"NestJs学习之旅(2)——控制器","description":"本文是NestJs学习之旅的第二篇，主要讲解控制器。\nMVC 说到控制器就不得不说经典的MVC架构。\nMVC模式（Model–view–controller）是软件工程中的一种软件架构模式，把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）。\n控制器（Controller）- 负责转发请求，对请求进行处理，处理完毕后输出响应。 视图 （View） - 界面设计人员进行图形界面设计 模型 （Model）- 数据库查询和业务逻辑 可以看到控制器起着承上启下的作用，是Web开发中必备的一环，视图和模型倒不是必须的，理由如下：","keywords":["nestjs"],"articleBody":"本文是NestJs学习之旅的第二篇，主要讲解控制器。\nMVC 说到控制器就不得不说经典的MVC架构。\nMVC模式（Model–view–controller）是软件工程中的一种软件架构模式，把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）。\n控制器（Controller）- 负责转发请求，对请求进行处理，处理完毕后输出响应。 视图 （View） - 界面设计人员进行图形界面设计 模型 （Model）- 数据库查询和业务逻辑 可以看到控制器起着承上启下的作用，是Web开发中必备的一环，视图和模型倒不是必须的，理由如下：\nAPI项目直接输出JSON数据，无需渲染页面 无数据库或者复杂业务逻辑的项目时可以把请求处理直接在控制器完成 路由 控制器的目的是接收应用程序的特定请求。基于路由机制来实现请求的分发。通常，每个控制器具有多个路由，并且不同的路由可以执行不同的动作。\n为了创建一个基本的控制器，我们使用类和装饰器。装饰器将类与所需的元数据相关联，并使Nest能够创建路由映射（将请求绑定到相应的控制器）。\n控制器定义 使用@Controller装饰器来定义控制器，传入一个可选的路由前缀可以将该控制器绑定到该前缀。\nimport { Controller, Get } from '@nestjs/common'; @Controller('cats') export class CatsController { @Get('list') findAll(): string { return 'This action returns all cats'; } @Get('show') fineOne(): string { return 'one cat'; } @Get() index():string { return 'index'; } } 以上例程会生成以下路由：\nGET /cats/list CatsController::findAll方法处理 GET /cats/show CatsController::show方法处理 GET /cats CatsController::index方法处理 上述例程使用的是@Get装饰器，所以只能处理GET请求，以下是支持的请求方法与对应的装饰器\n请求方法 装饰器名称 说明 GET @Get 匹配GET请求 POST @Post 匹配POST请求 PUT @Put 匹配PUT请求 HEAD @Head 匹配HEAD请求 DELETE @Delete 匹配DELETE请求 OPTIONS @Options 匹配OPTIONS请求 - @All 匹配所有请求方法 动态路由 上文中的路由方法接收的参数是固定的，所以只能匹配固定的请求，如果路由地址是动态变化的(路由地址指请求的path，不包括QueryString)，则上述路由定义方式无法正常工作。\nNestJs支持基于路径的路由定义，使用如下：\nimport {@Controller, Get} from '@nestjs/common'; @Controller('cats') class CatsController { @Get(':id') findOne(@Param() params): string { console.log(params.id); return `This action returns a #${params.id} cat`; } } 当请求/cats/猫ID这种动态路由时(因为猫ID是path的一部分，所以path是变化的)，params.id就是猫ID，做过Vue或者React开发的读者应该熟悉以下写法：\n路由定义 /user/:userId/orders/:orderId 页面地址 /user/1/orders/2\n访问以上页面将产生以下参数:\nuserId =\u003e 1 orderId =\u003e 2 NestJs在这方面是一致的。\n请求参数 上述例子中，我们使用@Params读取了请求路径上的动态参数。NestJs还支持以下的装饰器来获取不同的请求参数\n装饰器名称 底层对象 说明 @Request() req 原始请求对象 @Response() res 原始响应对象 @Param(key?:string) req.params或req.params[key] 路径参数 @Body(key?:string) req.body或req.body[key] 请求体，支持表单或JSON @Query(key?:string) req.query或req.query[key] 请求链接的查询字符串 @Headers(name?:string) req.headers或req.headers[key] 请求头 请求体 在POST/PUT/PATCH请求中，会包含请求体，NestJs通过@Body装饰器可以自动获取该数据。比如如下代码:\n@Controller('user') export class AppController { constructor(private readonly appService: AppService) {} @Post() findAll(@Body() data: any) { return data; } } 以上例程会原样输出请求内容。\n请求体绑定 SpringBoot中@RequestBody注解可以直接绑定到给定的POJO对象实现请求参数自动注入，在NestJs中，该特性也得到了支持。\n定义DTO对象\nexport class UserLoginDTO { readonly username: string; readonly password: string; } 定义控制器\n@Controller('users') class UserController() { @Post('login') login(@Body() userLoginDTO: UserLoginDTO) { console.log(userLoginDTO.username, userLoginDTO.password); } } 可以看到与SpringBoot的开发体验几乎一致。\n响应头 如果需要输出响应头，可以使用@Header(name:string,value:string)装饰器来进行处理。\n请注意：响应头使用@Header()装饰器，请求头使用@Headers()装饰器，末尾有个s的区别!\n@Controller('users') class UserController { @Head(':id') @Header('x-version', '1.0.0') function head(@Param('id') id:number) { } 响应状态码 从响应体的设计可以发现一个问题，由于不推荐直接操纵response对象，如果需要输出响应状态码怎么办?NestJs也为我们提供了解决方案。\n使用@HttpCode(statusCode:number)装饰器可以设定响应状态码。\n在Restful API设计中，DELETE请求应当返回204 No Content状态码，如下代码所示：\n@Controller('users') class UserController { @DELETE(\":id\") @HttpCode(204) delete(@Param('id') id:number) { // 删除成功不需要返回数据 } } 响应体 在express或者开发中，响应内容都是我们手动赋值或者输出的，但是在NestJs，可以直接根据路由函数的返回值类型自动识别响应体类型。NestJs支持以下格式的响应：\nTS类型 响应类型 响应格式 string 字符串 text/html object JSON application/json array JSON application/json null 无(响应体长度为0) 无 undefined 无(响应体长度为0) 无 Promise\u003c*\u003e 根据Promise返回的结果类型确定(规则如上) - 异步路由函数 在前面的例子中，我们所有的路由处理函数都是同步的，但是在实际开发中基本不可能，一旦涉及到数据库访问、缓存访问就会存在IO，有IO就会有异步。\nNestJs天生完美支持异步，有以下两种方法进行异步编程：\nPromise @Get() async findAll(): Promise\u003cany[]\u003e { return Promise.resolve([]); } RxJs RxJs中提供了Observable对象，NestJs可以自动订阅并获取最后一次产生的值。\n@Get() findAll: Observable\u003cany[]\u003e { return of([]); // of为RxJs操作符 } 实现一个Restful API 以下是基于Restful API规范开发的API，本文的主要内容为控制器，所以DTO对象的创建省略。\nimport { Controller, Get, Query, Post, Body, Put, Param, Delete } from '@nestjs/common'; import { CreateCatDto, UpdateCatDto, ListAllEntities } from './dto'; @Controller('users') export class UsersController { // 创建用户，POST请求会自动返回201状态码，响应体为空 @Post() create(@Body() dto: CreateUserDto) { } // 用户列表 @Get() findAll() { return [ {id:1,username:'a',password:'a'}, {id:2,username:'b',password:'b'} ]; } // 查看用户 @Get(':id') findOne(@Param('id') id: number) { return {id,username:'mock username', password: 'mock password'}; } // 更新用户，需要返回编辑后的用户资源 @Put(':id') update(@Param('id') id: number, @Body() updateUserDto: UpdateUserDto) { return {id,username:'updated username',password: 'updated password'}; } // 删除用户，返回204状态码 @Delete(':id') @HttpCode(204) remove(@Param('id') id: number) { } } ","wordCount":"378","inLanguage":"zh","datePublished":"2019-08-20T10:10:21Z","dateModified":"2019-08-20T10:10:21Z","author":{"@type":"Person","name":"Lei Xia"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.ddhigh.com/2019/08/20/nestjs-controller/"},"publisher":{"@type":"Organization","name":"每天进步一点点","logo":{"@type":"ImageObject","url":"https://www.ddhigh.com/favicon.ico"}}}</script><link rel=icon href=/img/favicon.ico sizes=16x16><link rel=apple-touch-icon href=/img/favicon.ico><link rel=manifest href=/img/favicon.ico><link href=/titilliumweb/titilliumweb.css rel=stylesheet><link rel=stylesheet href=/css/main.min.0eb4160ba4a2d63122fe8ae83f1560951a87ab510d5dab0615973b5206555759.css integrity="sha256-DrQWC6Si1jEi/oroPxVglRqHq1ENXasGFZc7UgZVV1k=" crossorigin=anonymous media=screen><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css integrity="sha512-ygEyjMC6rqnzJqWGjRTJUPYMEs9JUOm3i7OWUS9CgQ4XkBUvMsgCS1I8JqavidQ2ClHcREB7IbA2mN08+r9Elg==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=/scss/highlight/github-dark.min.min.66034289ee9a113219a2c4aae0a8bd2095ab255c832a42efcf5863f10814e7a1.css><script src=/js/highlight.min.min.894ca9c68afab956438c4926a0dc7f5293e04e08595bd27abdb123e94801f684.js></script><script>hljs.highlightAll()</script><script>$darkModeInit.Content|safeJS</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2871082647721658" crossorigin=anonymous></script></head><body><main class=wrapper><nav class=navigation><section class=container><a class=navigation-brand href=/>每天进步一点点
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><span></span><span></span><span></span></label><ul class=navigation-list id=navigation-list><li class="navigation-item navigation-menu"><a class=navigation-link href=/>首页</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/archives>归档</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/books>出版物</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/guestbook>留言板</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class="navigation-item navigation-social"><a class=navigation-link href=https://github.com/xialeistudio><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li class="navigation-item navigation-dark"><button id=mode type=button aria-label="toggle user light or dark theme">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span><span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></li><li class="navigation-item navigation-language"><a href=https://www.ddhigh.com/en/>EN</a></li></ul></section></nav><div id=content><article class=blog-single><header class=blog-title><h1>NestJs学习之旅(2)——控制器</h1></header><p><small>2019年8月20日&nbsp;· 378 字&nbsp;· 2 分钟</small><p><div class=blog-toc><nav id=TableOfContents><ul><li><a href=#mvc>MVC</a></li><li><a href=#路由>路由</a></li><li><a href=#控制器定义>控制器定义</a></li><li><a href=#动态路由>动态路由</a></li><li><a href=#请求参数>请求参数</a></li><li><a href=#请求体>请求体</a><ul><li><a href=#请求体绑定>请求体绑定</a></li></ul></li><li><a href=#响应头>响应头</a></li><li><a href=#响应状态码>响应状态码</a></li><li><a href=#响应体>响应体</a></li><li><a href=#异步路由函数>异步路由函数</a><ul><li><a href=#promise>Promise</a></li><li><a href=#rxjs>RxJs</a></li></ul></li><li><a href=#实现一个restful-api>实现一个Restful API</a></li></ul></nav></div><section class=blog-content><p>本文是NestJs学习之旅的第二篇，主要讲解控制器。</p><h2 id=mvc>MVC</h2><p>说到控制器就不得不说经典的MVC架构。</p><blockquote><p>MVC模式（Model–view–controller）是软件工程中的一种软件架构模式，把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）。</p><ul><li>控制器（Controller）- 负责转发请求，对请求进行处理，处理完毕后输出响应。</li><li>视图 （View） - 界面设计人员进行图形界面设计</li><li>模型 （Model）- 数据库查询和业务逻辑</li></ul></blockquote><p>可以看到控制器起着承上启下的作用，是Web开发中必备的一环，视图和模型倒不是必须的，理由如下：</p><ol><li>API项目直接输出JSON数据，无需渲染页面</li><li>无数据库或者复杂业务逻辑的项目时可以把请求处理直接在控制器完成</li></ol><h2 id=路由>路由</h2><p>控制器的目的是接收应用程序的特定请求。基于路由机制来实现请求的分发。通常，每个控制器具有多个路由，并且不同的路由可以执行不同的动作。</p><p>为了创建一个基本的控制器，我们使用类和装饰器。装饰器将类与所需的元数据相关联，并使Nest能够创建路由映射（将请求绑定到相应的控制器）。</p><h2 id=控制器定义>控制器定义</h2><p>使用<code>@Controller</code>装饰器来定义控制器，传入一个可选的路由前缀可以将该控制器绑定到该前缀。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>Controller</span>, <span style=color:#a6e22e>Get</span> } <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;@nestjs/common&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>@Controller</span>(<span style=color:#e6db74>&#39;cats&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CatsController</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>@Get</span>(<span style=color:#e6db74>&#39;list&#39;</span>)
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>findAll</span>()<span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#39;This action returns all cats&#39;</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>@Get</span>(<span style=color:#e6db74>&#39;show&#39;</span>)
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>fineOne</span>()<span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#39;one cat&#39;</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>@Get</span>()
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>index</span>()<span style=color:#f92672>:</span><span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#39;index&#39;</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>以上例程会生成以下路由：</p><ol><li>GET /cats/list CatsController::findAll方法处理</li><li>GET /cats/show CatsController::show方法处理</li><li>GET /cats CatsController::index方法处理</li></ol><p>上述例程使用的是<code>@Get</code>装饰器，所以只能处理<code>GET</code>请求，以下是支持的请求方法与对应的装饰器</p><table><thead><tr><th style=text-align:left>请求方法</th><th style=text-align:left>装饰器名称</th><th style=text-align:left>说明</th></tr></thead><tbody><tr><td style=text-align:left>GET</td><td style=text-align:left>@Get</td><td style=text-align:left>匹配GET请求</td></tr><tr><td style=text-align:left>POST</td><td style=text-align:left>@Post</td><td style=text-align:left>匹配POST请求</td></tr><tr><td style=text-align:left>PUT</td><td style=text-align:left>@Put</td><td style=text-align:left>匹配PUT请求</td></tr><tr><td style=text-align:left>HEAD</td><td style=text-align:left>@Head</td><td style=text-align:left>匹配HEAD请求</td></tr><tr><td style=text-align:left>DELETE</td><td style=text-align:left>@Delete</td><td style=text-align:left>匹配DELETE请求</td></tr><tr><td style=text-align:left>OPTIONS</td><td style=text-align:left>@Options</td><td style=text-align:left>匹配OPTIONS请求</td></tr><tr><td style=text-align:left>-</td><td style=text-align:left>@All</td><td style=text-align:left>匹配所有请求方法</td></tr></tbody></table><h2 id=动态路由>动态路由</h2><p>上文中的路由方法接收的参数是固定的，所以只能匹配固定的请求，如果路由地址是动态变化的(<code>路由地址指请求的path，不包括QueryString</code>)，则上述路由定义方式无法正常工作。</p><p>NestJs支持基于路径的路由定义，使用如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>import</span> {<span style=color:#66d9ef>@Controller</span>, <span style=color:#a6e22e>Get</span>} <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;@nestjs/common&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>@Controller</span>(<span style=color:#e6db74>&#39;cats&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CatsController</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>@Get</span>(<span style=color:#e6db74>&#39;:id&#39;</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>findOne</span>(<span style=color:#66d9ef>@Param</span>() <span style=color:#a6e22e>params</span>)<span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>params</span>.<span style=color:#a6e22e>id</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>`This action returns a #</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>params</span>.<span style=color:#a6e22e>id</span><span style=color:#e6db74>}</span><span style=color:#e6db74> cat`</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>当请求<code>/cats/猫ID</code>这种动态路由时(<code>因为猫ID是path的一部分，所以path是变化的</code>)，<code>params.id</code>就是<code>猫ID</code>，做过Vue或者React开发的读者应该熟悉以下写法：</p><p>路由定义 <code>/user/:userId/orders/:orderId</code>
页面地址 <code>/user/1/orders/2</code></p><p>访问以上页面将产生以下参数:</p><ul><li>userId => 1</li><li>orderId => 2</li></ul><p>NestJs在这方面是一致的。</p><h2 id=请求参数>请求参数</h2><p>上述例子中，我们使用<code>@Params</code>读取了请求路径上的动态参数。NestJs还支持以下的装饰器来获取不同的请求参数</p><table><thead><tr><th style=text-align:left>装饰器名称</th><th style=text-align:left>底层对象</th><th style=text-align:left>说明</th></tr></thead><tbody><tr><td style=text-align:left>@Request()</td><td style=text-align:left>req</td><td style=text-align:left>原始请求对象</td></tr><tr><td style=text-align:left>@Response()</td><td style=text-align:left>res</td><td style=text-align:left>原始响应对象</td></tr><tr><td style=text-align:left>@Param(key?:string)</td><td style=text-align:left>req.params或req.params[key]</td><td style=text-align:left>路径参数</td></tr><tr><td style=text-align:left>@Body(key?:string)</td><td style=text-align:left>req.body或req.body[key]</td><td style=text-align:left>请求体，支持表单或JSON</td></tr><tr><td style=text-align:left>@Query(key?:string)</td><td style=text-align:left>req.query或req.query[key]</td><td style=text-align:left>请求链接的查询字符串</td></tr><tr><td style=text-align:left>@Headers(name?:string)</td><td style=text-align:left>req.headers或req.headers[key]</td><td style=text-align:left>请求头</td></tr></tbody></table><h2 id=请求体>请求体</h2><p>在POST/PUT/PATCH请求中，会包含请求体，NestJs通过<code>@Body</code>装饰器可以自动获取该数据。比如如下代码:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>@Controller</span>(<span style=color:#e6db74>&#39;user&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AppController</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>constructor</span>(<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> <span style=color:#a6e22e>appService</span>: <span style=color:#66d9ef>AppService</span>) {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>@Post</span>()
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>findAll</span>(<span style=color:#66d9ef>@Body</span>() <span style=color:#a6e22e>data</span>: <span style=color:#66d9ef>any</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>data</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>以上例程会原样输出请求内容。</p><h3 id=请求体绑定>请求体绑定</h3><p>SpringBoot中<code>@RequestBody</code>注解可以直接绑定到给定的POJO对象实现请求参数自动注入，在NestJs中，该特性也得到了支持。</p><p>定义DTO对象</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserLoginDTO</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>readonly</span> <span style=color:#a6e22e>username</span>: <span style=color:#66d9ef>string</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>readonly</span> <span style=color:#a6e22e>password</span>: <span style=color:#66d9ef>string</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>定义控制器</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>@Controller</span>(<span style=color:#e6db74>&#39;users&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserController() {</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>@Post</span>(<span style=color:#e6db74>&#39;login&#39;</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>login</span>(<span style=color:#66d9ef>@Body</span>() <span style=color:#a6e22e>userLoginDTO</span>: <span style=color:#66d9ef>UserLoginDTO</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>userLoginDTO</span>.<span style=color:#a6e22e>username</span>, <span style=color:#a6e22e>userLoginDTO</span>.<span style=color:#a6e22e>password</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>可以看到与SpringBoot的开发体验几乎一致。</p><h2 id=响应头>响应头</h2><p>如果需要输出响应头，可以使用<code>@Header(name:string,value:string)</code>装饰器来进行处理。</p><p><code>请注意：响应头使用@Header()装饰器，请求头使用@Headers()装饰器，末尾有个s的区别!</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>@Controller</span>(<span style=color:#e6db74>&#39;users&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserController</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>@Head</span>(<span style=color:#e6db74>&#39;:id&#39;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>@Header</span>(<span style=color:#e6db74>&#39;x-version&#39;</span>, <span style=color:#e6db74>&#39;1.0.0&#39;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>head</span>(<span style=color:#66d9ef>@Param</span>(<span style=color:#e6db74>&#39;id&#39;</span>) <span style=color:#a6e22e>id</span>:<span style=color:#66d9ef>number</span>) {
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h2 id=响应状态码>响应状态码</h2><p>从响应体的设计可以发现一个问题，由于不推荐直接操纵<code>response</code>对象，如果需要输出响应状态码怎么办?NestJs也为我们提供了解决方案。</p><p>使用<code>@HttpCode(statusCode:number)</code>装饰器可以设定响应状态码。</p><p>在Restful API设计中，DELETE请求应当返回<code>204 No Content</code>状态码，如下代码所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>@Controller</span>(<span style=color:#e6db74>&#39;users&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserController</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>@DELETE</span>(<span style=color:#e6db74>&#34;:id&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>@HttpCode</span>(<span style=color:#ae81ff>204</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>delete</span>(<span style=color:#66d9ef>@Param</span>(<span style=color:#e6db74>&#39;id&#39;</span>) <span style=color:#a6e22e>id</span>:<span style=color:#66d9ef>number</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 删除成功不需要返回数据
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=响应体>响应体</h2><p>在express或者开发中，响应内容都是我们手动赋值或者输出的，但是在NestJs，可以直接根据路由函数的返回值<code>类型</code>自动识别响应体类型。NestJs支持以下格式的响应：</p><table><thead><tr><th style=text-align:left>TS类型</th><th style=text-align:left>响应类型</th><th style=text-align:left>响应格式</th></tr></thead><tbody><tr><td style=text-align:left>string</td><td style=text-align:left>字符串</td><td style=text-align:left>text/html</td></tr><tr><td style=text-align:left>object</td><td style=text-align:left>JSON</td><td style=text-align:left>application/json</td></tr><tr><td style=text-align:left>array</td><td style=text-align:left>JSON</td><td style=text-align:left>application/json</td></tr><tr><td style=text-align:left>null</td><td style=text-align:left>无(响应体长度为0)</td><td style=text-align:left>无</td></tr><tr><td style=text-align:left>undefined</td><td style=text-align:left>无(响应体长度为0)</td><td style=text-align:left>无</td></tr><tr><td style=text-align:left>Promise&lt;*></td><td style=text-align:left>根据Promise返回的结果类型确定(规则如上)</td><td style=text-align:left>-</td></tr></tbody></table><h2 id=异步路由函数>异步路由函数</h2><p>在前面的例子中，我们所有的路由处理函数都是同步的，但是在实际开发中基本不可能，一旦涉及到数据库访问、缓存访问就会存在IO，有IO就会有异步。</p><p>NestJs天生完美支持异步，有以下两种方法进行异步编程：</p><h3 id=promise>Promise</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>@Get</span>()
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#a6e22e>findAll</span>()<span style=color:#f92672>:</span> <span style=color:#a6e22e>Promise</span>&lt;<span style=color:#f92672>any</span><span style=color:#960050;background-color:#1e0010>[]</span>&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Promise</span>.<span style=color:#a6e22e>resolve</span>([]);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=rxjs>RxJs</h3><p>RxJs中提供了<code>Observable</code>对象，NestJs可以自动订阅并获取最后一次产生的值。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>@Get</span>()
</span></span><span style=display:flex><span><span style=color:#a6e22e>findAll</span>: <span style=color:#66d9ef>Observable</span>&lt;<span style=color:#f92672>any</span><span style=color:#960050;background-color:#1e0010>[]</span>&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>of</span>([]); <span style=color:#75715e>// of为RxJs操作符
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h2 id=实现一个restful-api>实现一个Restful API</h2><p>以下是基于Restful API规范开发的API，本文的主要内容为控制器，所以DTO对象的创建省略。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>Controller</span>, <span style=color:#a6e22e>Get</span>, <span style=color:#a6e22e>Query</span>, <span style=color:#a6e22e>Post</span>, <span style=color:#a6e22e>Body</span>, <span style=color:#a6e22e>Put</span>, <span style=color:#a6e22e>Param</span>, <span style=color:#a6e22e>Delete</span> } <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;@nestjs/common&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>CreateCatDto</span>, <span style=color:#a6e22e>UpdateCatDto</span>, <span style=color:#a6e22e>ListAllEntities</span> } <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;./dto&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>@Controller</span>(<span style=color:#e6db74>&#39;users&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UsersController</span> {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 创建用户，POST请求会自动返回201状态码，响应体为空
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>@Post</span>()
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>create</span>(<span style=color:#66d9ef>@Body</span>() <span style=color:#a6e22e>dto</span>: <span style=color:#66d9ef>CreateUserDto</span>) {
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 用户列表
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>@Get</span>()
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>findAll() {</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> [
</span></span><span style=display:flex><span>          {<span style=color:#a6e22e>id</span>:<span style=color:#66d9ef>1</span>,<span style=color:#a6e22e>username</span><span style=color:#f92672>:</span><span style=color:#e6db74>&#39;a&#39;</span>,<span style=color:#a6e22e>password</span><span style=color:#f92672>:</span><span style=color:#e6db74>&#39;a&#39;</span>},
</span></span><span style=display:flex><span>          {<span style=color:#a6e22e>id</span>:<span style=color:#66d9ef>2</span>,<span style=color:#a6e22e>username</span><span style=color:#f92672>:</span><span style=color:#e6db74>&#39;b&#39;</span>,<span style=color:#a6e22e>password</span><span style=color:#f92672>:</span><span style=color:#e6db74>&#39;b&#39;</span>}
</span></span><span style=display:flex><span>      ];
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 查看用户
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>@Get</span>(<span style=color:#e6db74>&#39;:id&#39;</span>)
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>findOne</span>(<span style=color:#66d9ef>@Param</span>(<span style=color:#e6db74>&#39;id&#39;</span>) <span style=color:#a6e22e>id</span>: <span style=color:#66d9ef>number</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> {<span style=color:#a6e22e>id</span>,<span style=color:#a6e22e>username</span><span style=color:#f92672>:</span><span style=color:#e6db74>&#39;mock username&#39;</span>, <span style=color:#a6e22e>password</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;mock password&#39;</span>};
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 更新用户，需要返回编辑后的用户资源
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>@Put</span>(<span style=color:#e6db74>&#39;:id&#39;</span>)
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>update</span>(<span style=color:#66d9ef>@Param</span>(<span style=color:#e6db74>&#39;id&#39;</span>) <span style=color:#a6e22e>id</span>: <span style=color:#66d9ef>number</span>, <span style=color:#66d9ef>@Body</span>() <span style=color:#a6e22e>updateUserDto</span>: <span style=color:#66d9ef>UpdateUserDto</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> {<span style=color:#a6e22e>id</span>,<span style=color:#a6e22e>username</span><span style=color:#f92672>:</span><span style=color:#e6db74>&#39;updated username&#39;</span>,<span style=color:#a6e22e>password</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;updated password&#39;</span>};
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 删除用户，返回204状态码
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>@Delete</span>(<span style=color:#e6db74>&#39;:id&#39;</span>)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>@HttpCode</span>(<span style=color:#ae81ff>204</span>)
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>remove</span>(<span style=color:#66d9ef>@Param</span>(<span style=color:#e6db74>&#39;id&#39;</span>) <span style=color:#a6e22e>id</span>: <span style=color:#66d9ef>number</span>) {
</span></span><span style=display:flex><span>   
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=blog-footer><div class=social-share></div><div class=copyright><ul><li style=margin-bottom:.5em>本文作者: <a href=https://ddhigh.com/ target=_blank style=color:#000;text-decoration:none>xialeistudio</a></li><li style=margin-bottom:.5em>本文链接: <a href=https://www.ddhigh.com/2019/08/20/nestjs-controller/ target=_blank style=color:#000;text-decoration:none>NestJs学习之旅(2)——控制器</a></li><li>版权声明: <a href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank style=color:#000;text-decoration:none>「署名-非商业性使用-相同方式共享 4.0 国际」</a></li></ul></div><div style=margin-top:2rem><img src=/img/mp.png alt=qrcode></div></div></section><div class=paginator><a class=prev href=https://www.ddhigh.com/2019/08/21/nestjs-provider/><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M9.94496 9C9.28897 9.61644 7.63215 10.997 6.04814 11.7966 5.98257 11.8297 5.98456 11.9753 6.05061 12.0063c1.00435.4716 2.8788 1.9201 3.89435 2.9937M6.44444 11.9667C8.86549 12.0608 14 12 16 11" stroke="currentcolor" stroke-linecap="round"/></svg><span>NestJs学习之旅(3)——服务提供者</span></a>
<a class=next href=https://www.ddhigh.com/2019/08/19/nestjs-get-started/><span>NestJs学习之旅(1)——快速开始</span><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M12.055 9C12.711 9.61644 14.3679 10.997 15.9519 11.7966 16.0174 11.8297 16.0154 11.9753 15.9494 12.0063 14.945 12.4779 13.0706 13.9264 12.055 15m3.5006-3.0333C13.1345 12.0608 8 12 6 11" stroke="currentcolor" stroke-linecap="round"/></svg></a></div><div class=comments><script>const getTheme=window.localStorage&&window.localStorage.getItem("theme");let theme=getTheme==="dark"?"dark":"light",s=document.createElement("script");s.src="https://giscus.app/client.js",s.setAttribute("data-repo","xialeistudio/discussion"),s.setAttribute("data-repo-id","R_kgDOKurTRA"),s.setAttribute("data-category","General"),s.setAttribute("data-category-id","DIC_kwDOKurTRM4CbCJt"),s.setAttribute("data-mapping","pathname"),s.setAttribute("data-strict","0"),s.setAttribute("data-reactions-enabled","1"),s.setAttribute("data-emit-metadata","0"),s.setAttribute("data-input-position","bottom"),s.setAttribute("data-theme",theme),s.setAttribute("data-lang","en"),s.setAttribute("data-loading","lazy"),s.setAttribute("crossorigin","anonymous"),s.setAttribute("async",""),document.querySelector("div.comments").innerHTML="",document.querySelector("div.comments").appendChild(s)</script></div></article></div><footer class=footer><p>&copy; 2014 - 2024 <a href=https://www.ddhigh.com>每天进步一点点</a>
Powered by
<a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>
<a href=https://github.com/guangzhengli/hugo-theme-ladder rel=noopener target=_blank>Ladder</a>
️</p></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.5376 22.7916C11.0152 22.7207 22.5795 21.1781 22.0978 10.4211 22.0536 9.43274 21.9303 8.53367 21.7387 7.71865M10.5376 22.7916C16.876 22.3728 20.0969 19.8899 21.5383 16.9142M10.5376 22.7916C9.7707 22.9055 8.97982 22.8964 8.19743 22.7725M21.7387 7.71865C21.4988 6.69828 21.1518 5.80967 20.7188 5.04257m1.0199 2.67608C22.6022 10.1105 23.0542 13.7848 21.5383 16.9142M20.7188 5.04257c-3.5504-6.28886-12.88753-4.410077-16.44303.0C2.88063 6.77451-.0433281 11.1668 1.38159 16.6571c.89322 3.4417 3.7911 5.6365 6.81584 6.1154M20.7188 5.04257c1.3509 1.89783 3.3111 6.34223 1.6353 10.37273M21.5383 16.9142C21.8737 16.4251 22.1428 15.9235 22.3541 15.4153M8.19743 22.7725C12.1971 23.4683 20.6281 22.971 22.3541 15.4153M14 10.945C13.3836 10.289 12.003 8.63215 11.2034 7.04814 11.1703 6.98257 11.0247 6.98456 10.9937 7.05061 10.5221 8.05496 9.07362 9.92941 8 10.945m3.0333-3.50056C10.9392 9.86549 11 15 12 17" stroke="currentcolor" stroke-linecap="round"/></svg></a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function n(){t.innerHTML="Copied",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)}),e.parentNode.appendChild(t)})</script><script src=https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js integrity="sha512-9DNXrSjk17bU9MUbRp3IjwcWe46V8FaGA062PFbryPUAEQVRbz4jiZP6FW0AdbqEGtMYBDWnul3eiGBMJOQajA==" crossorigin=anonymous referrerpolicy=no-referrer></script></main></body><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script><script>const images=Array.from(document.querySelectorAll(".blog-content img"));images.forEach(e=>{mediumZoom(e,{margin:10,scrollOffset:40,container:null,template:null,background:"rgba(0, 0, 0, 0.5)"})})</script><script src=/main.min.6bb26b69159420159c74dc9e097b06a578ed2b68c701466a91a44a9632d851bd0af167a1b30012387b4c512b48ad9ad4d3394e04d77ae38d57e1920fe4ed34fe.js integrity="sha512-a7JraRWUIBWcdNyeCXsGpXjtK2jHAUZqkaRKljLYUb0K8WehswASOHtMUStIrZrU0zlOBNd6441X4ZIP5O00/g==" crossorigin=anonymous defer></script></html>