<!doctype html><html lang=zh><head><meta name=viewport content="width=device-width,initial-scale=1"><title>NestJs学习之旅(6)——异常处理</title>
<meta charset=utf-8><meta content="Web开发 ,Java ,Go ,Node.js ,PHP ,Koa ,MySQL ,Redis ,前端 ,后端 ,数据库" name=keywords><meta name=description content="本文是NestJs的第六篇，讲解异常处理。
传统的异常处理 在前面的内容中我们介绍了NestJs的几大常用组件，但是有一点没有做出说明，当我们的应用需要中断此次请求且输出错误信息时，我们需要怎么做？
这个问题有两种解决办法：
services层直接返回中断请求的响应对象，controller直接输出该对象即可"><meta name=author content="Lei Xia"><link rel=canonical href=https://www.ddhigh.com/2019/08/26/nestjs-exception-filter/><link rel=alternate type=application/rss+xml href=https://www.ddhigh.com//index.xml title=每天进步一点点><script async src="https://www.googletagmanager.com/gtag/js?id=G-EC3XLVSGKV"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-EC3XLVSGKV")</script><meta property="og:title" content="NestJs学习之旅(6)——异常处理"><meta property="og:description" content="本文是NestJs的第六篇，讲解异常处理。
传统的异常处理 在前面的内容中我们介绍了NestJs的几大常用组件，但是有一点没有做出说明，当我们的应用需要中断此次请求且输出错误信息时，我们需要怎么做？
这个问题有两种解决办法：
services层直接返回中断请求的响应对象，controller直接输出该对象即可"><meta property="og:type" content="article"><meta property="og:url" content="https://www.ddhigh.com/2019/08/26/nestjs-exception-filter/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-08-26T15:32:29+00:00"><meta property="article:modified_time" content="2019-08-26T15:32:29+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="NestJs学习之旅(6)——异常处理"><meta name=twitter:description content="本文是NestJs的第六篇，讲解异常处理。
传统的异常处理 在前面的内容中我们介绍了NestJs的几大常用组件，但是有一点没有做出说明，当我们的应用需要中断此次请求且输出错误信息时，我们需要怎么做？
这个问题有两种解决办法：
services层直接返回中断请求的响应对象，controller直接输出该对象即可"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.ddhigh.com/posts/"},{"@type":"ListItem","position":2,"name":"NestJs学习之旅(6)——异常处理","item":"https://www.ddhigh.com/2019/08/26/nestjs-exception-filter/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"NestJs学习之旅(6)——异常处理","name":"NestJs学习之旅(6)——异常处理","description":"本文是NestJs的第六篇，讲解异常处理。\n传统的异常处理 在前面的内容中我们介绍了NestJs的几大常用组件，但是有一点没有做出说明，当我们的应用需要中断此次请求且输出错误信息时，我们需要怎么做？\n这个问题有两种解决办法：\nservices层直接返回中断请求的响应对象，controller直接输出该对象即可","keywords":["nestjs"],"articleBody":"本文是NestJs的第六篇，讲解异常处理。\n传统的异常处理 在前面的内容中我们介绍了NestJs的几大常用组件，但是有一点没有做出说明，当我们的应用需要中断此次请求且输出错误信息时，我们需要怎么做？\n这个问题有两种解决办法：\nservices层直接返回中断请求的响应对象，controller直接输出该对象即可\nif(!this.allowLogin()) { return {errcode: 403, errmsg: '不允许登录'}; } services层抛出异常，controller捕获该异常，然后输出响应对象\n以上两种方法都有一定的缺点：\ncontroller调用多个services时，需要依据services层的返回值来进行错误判断，要是漏了判断的话会导致原本需要中断的请求处理继续运行，导致不可预料的后果 如果每个controller都需要try/catch掉services层抛出的异常的话，会多了很多“重复”代码 那有没有一个像SpringBoot的ExceptionHandler相似的解决办法呢?\nNestJs的异常处理 NestJs提供了统一的异常处理器，来集中处理运行过程中未捕获的异常，可以自定义响应参数，非常灵活。\n默认响应 NestJs内置了默认的全局异常过滤器，该过滤器处理HttpException(及其子类)的异常。如果抛出的异常不是上述异常，则会响应以下默认JSON：\n{ \"statusCode\": 500, \"message\": \"Interval server error\" } 内置异常过滤器 由于NestJs内置了默认的异常过滤器，如果在应用内抛出HttpException，是可以被NestJs自动捕获的。\n比如在services层抛出一个HttpException：\n@Injectable() export class UserService { login(username: string, password: string) { if(!this.allowLogin()) { throw new HttpException('您无权登录', HttpStatus.FORBIDDEN); } return {user_id:1, token: 'fake token'} } } controller正常调用该services即可:\n@Controller('users') export class UserController { constructor(private readonly userService: UserService) {} @Post('login') login(@Body('username') username: string, @Body('password') password: string) { return this.userService.login(username, password); } } 客户端访问/user/login时，如果不允许登录，会收到以下响应：\n{ \"statusCode\": 403, \"message\": \"您无权登录\" } 一般情况下，上述JSON的返回的信息是不够的，比如有些业务自定义的错误码没地方可以自定义。\n如果你有这种需求，可以传递object给HttpException的第一个参数来实现：\nthrow new HttpException({errcode: 40010, errmsg: '您无权登录'}, HttpStatus.FORBIDDEN); 客户端访问时，如果不允许登录，会收到以下响应：\n{ \"errcode\": 40010, \"errmsg\": \"您无权登录\" } 自定义异常 企业级应用开发过程中，使用HttpException进行处理对开发是不太友好的，一个比较常用的做法是自定义一个UserException来承载业务异常（系统运行正常，只不过当前请求不满足业务上的要求而中断，比如注册的时候用户名重复的时候打回去，此时数据库查询是正常的，这就是业务异常和系统异常的区别）。\nexport class UserException extends HttpException { constructor(errcode: number, errmsg: string, statusCode: number) { super({ errcode, errmsg }, statusCode); } } 业务层在使用该异常时直接使用以下代码即可，将原来传递对象的代码扁平化了：\nthrow new UserException(40010, '您无权登录', HttpStatus.FORBIDDEN); 语义化业务异常 使用自定义异常时HTTP协议层是正常的，抛出403错误有点不符合语义化的需求。对上例改造一下：\nexport class UserException extends HttpException { constructor(errcode: number, errmsg: string) { super({ errcode, errmsg }, HttpStatus.OK); } } throw new UserException(40010, '您无权登录'); 此时客户端收到的HttpStatus为200，意味着此次请求在协议层面是成功的，只不过业务层返回了错误。前端在处理响应时可以直接对errcode是否为0来确定此次请求是否成功。\n自定义异常过滤器 虽然内置的异常过滤器可以自动处理很多情况，但是不是“可编程”的，也就是说我们无法完全控制异常处理过程，如果我们需要记录日志的话，使用内置的异常过滤器办不到，这时候可以使用**@Catch**注解来自定义异常处理器，添加日志记录什么的。\nimport { ExceptionFilter, Catch, ArgumentsHost, HttpException } from '@nestjs/common'; import { Request, Response } from 'express'; @Catch(HttpException) export class HttpExceptionFilter implements ExceptionFilter\u003cHttpException\u003e { catch(exception: HttpException, host: ArgumentsHost) { const ctx = host.switchToHttp(); const response = ctx.getResponse\u003cResponse\u003e(); const request = ctx.getRequest\u003cRequest\u003e(); const status = exception.getStatus(); // @todo 记录日志 console.log('%s %s error: %s', request.method, request.url, exception.message); // 发送响应 response .status(status) .json({ statusCode: status, message: exception.message path: request.url, }); } } ArgumentHost ArgumentHost是原始请求的包装器，由于NestJs支持HTTP/GRPC/WebSocket，这三种请求的原始请求对象是有差异的，为了异常过滤器能够统一处理这三种异常，NestJs做了包装。最终在使用时处理那种异常由开发者来决定。\nArgumentHost接口定义如下：\nexport interface ArgumentsHost { getArgs\u003cT extends Array\u003cany\u003e = any[]\u003e(): T; getArgByIndex\u003cT = any\u003e(index: number): T; switchToRpc(): RpcArgumentsHost; switchToHttp(): HttpArgumentsHost; switchToWs(): WsArgumentsHost; } 如果需要处理的是WebSocket异常，就使用host.switchToWs()，其他异常以此类推。\n使用自定义异常过滤器 如果定义完自定义异常过滤器之后，直接去访问会抛出异常的接口，此时可以发现并没有走自定义异常过滤器。\n因为我们只是定义，并没有注册。\n使用**@UseFilters**注册自定义异常过滤器。\n异常过滤器有以下三种作用范围：\n方法级别 控制器级别 全局级别 方法级别 只会处理该方法上抛出的异常，其他方法抛出的异常不会处理。\n@Post('login') @UseFilters(UserExceptionFilter) login(@Body('username') username:string, password: string) { throw new UserException(40010, '您无权登录'); } 控制器级别 只会处理该控制器方法上抛出的异常，其他控制器抛出的异常不处理。\n@Controller('user') @UseFilters(UserExceptionFilter) export class UserController { } 全局级别 在应用入口注册，不会对Websocket或者混合应用（同时支持两种应用，如HTTP/GRPC或者HTTP/WebSocket）生效。一般Web开发中全局异常过滤器已经够用了。\n在main.ts中注册全局异常过滤器\nasync function bootstrap() { const app = await NestFactory.create(AppModule); app.useGlobalFilters(new UserExceptionFilter()); await app.listen(3000); } bootstrap(); 依赖注入 由于异常过滤器并不是任何模块上下文的一部分，所以NestJs无法对其进行依赖注入管理，如果有此种需求，比如在异常过滤器中注入service，需要定义服务提供者。服务提供者名称为NestJs规定的常量APP_FILTER\nimport { Module } from '@nestjs/common'; import { APP_FILTER } from '@nestjs/core'; @Module({ providers: [ { provide: APP_FILTER, useClass: UserExceptionFilter, }, ], }) export class AppModule {} 捕获多种异常或者所有异常 上例中提到的自定义异常处理器只会捕获UserException异常，如果有系统异常，会使用内置的异常处理器。通过传入异常类型给**@Catch**装饰器来捕获多种异常。如果不传任何异常类型的话，NestJs会捕获所有异常（也就是Error及其子类）。\nimport { ExceptionFilter, Catch, ArgumentsHost, HttpException } from '@nestjs/common'; import { Request, Response } from 'express'; @Catch() // 捕获所有异常 export class HttpExceptionFilter implements ExceptionFilter\u003cError\u003e { catch(exception: Error, host: ArgumentsHost) { const ctx = host.switchToHttp(); const response = ctx.getResponse\u003cResponse\u003e(); const request = ctx.getRequest\u003cRequest\u003e(); const status = exception.getStatus(); // @todo 记录日志 console.log('%s %s error: %s', request.method, request.url, exception.message); // 发送响应 response .status(status) .json({ statusCode: status, message: exception.message path: request.url, }); } } 结尾 异常过滤器让应用异常有了统一的处理渠道，同时也解决文章开头提出的两个问题。通过自定义异常过滤器，开发者可以进行统一响应格式，统一记录日志等等操作。\n","wordCount":"405","inLanguage":"zh","datePublished":"2019-08-26T15:32:29Z","dateModified":"2019-08-26T15:32:29Z","author":{"@type":"Person","name":"Lei Xia"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.ddhigh.com/2019/08/26/nestjs-exception-filter/"},"publisher":{"@type":"Organization","name":"每天进步一点点","logo":{"@type":"ImageObject","url":"https://www.ddhigh.com/favicon.ico"}}}</script><link rel=icon href=/img/favicon.ico sizes=16x16><link rel=apple-touch-icon href=/img/favicon.ico><link rel=manifest href=/img/favicon.ico><link rel=stylesheet href=https://cdn.staticfile.org/lxgw-wenkai-webfont/1.6.0/style.css><link rel=stylesheet href=/css/main.min.eb16e2c37edda7bb7b8f844336c65138877ea26f51562d3d69efff7f073bff83.css integrity="sha256-6xbiw37dp7t7j4RDNsZROId+om9RVi09ae//fwc7/4M=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/highlight/github-dark.min.min.66034289ee9a113219a2c4aae0a8bd2095ab255c832a42efcf5863f10814e7a1.css><script src=/js/highlight.min.min.c607d6febd16934a82eb61d3a896ed9d869f54373cc63ce95864ed5488fe3128.js></script><script>hljs.highlightAll()</script><script>$darkModeInit.Content|safeJS</script></head><body><main class=wrapper><nav class=navigation><section class=container><a class=navigation-brand href=/>每天进步一点点
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><span></span><span></span><span></span></label><ul class=navigation-list id=navigation-list><li class="navigation-item navigation-menu"><a class=navigation-link href=/archives>归档</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/books>出版物</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/guestbook>留言板</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class="navigation-item navigation-social"><a class=navigation-link href=https://github.com/xialeistudio><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li class="navigation-item navigation-dark"><button id=mode type=button aria-label="toggle user light or dark theme">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span>
<span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></li><li class="navigation-item navigation-language"><a href=https://www.ddhigh.com/en/>EN</a></li></ul></section></nav><div id=content><article class=blog-single><header class=blog-title><h1>NestJs学习之旅(6)——异常处理</h1></header><p><small>2019年8月26日&nbsp;· 405 字&nbsp;· 2 分钟</small><p><div class=blog-toc><nav id=TableOfContents><ul><li><a href=#传统的异常处理>传统的异常处理</a></li><li><a href=#nestjs的异常处理>NestJs的异常处理</a></li><li><a href=#默认响应>默认响应</a></li><li><a href=#内置异常过滤器>内置异常过滤器</a></li><li><a href=#自定义异常>自定义异常</a><ul><li><a href=#语义化业务异常>语义化业务异常</a></li></ul></li><li><a href=#自定义异常过滤器>自定义异常过滤器</a><ul><li><a href=#argumenthost>ArgumentHost</a></li><li><a href=#使用自定义异常过滤器>使用自定义异常过滤器</a></li><li><a href=#方法级别>方法级别</a></li><li><a href=#控制器级别>控制器级别</a></li><li><a href=#全局级别>全局级别</a></li></ul></li><li><a href=#依赖注入>依赖注入</a></li><li><a href=#捕获多种异常或者所有异常>捕获多种异常或者所有异常</a></li><li><a href=#结尾>结尾</a></li></ul></nav></div><section class=blog-content><p>本文是NestJs的第六篇，讲解异常处理。</p><h2 id=传统的异常处理>传统的异常处理</h2><p>在前面的内容中我们介绍了NestJs的几大常用组件，但是有一点没有做出说明，当我们的应用需要中断此次请求且输出错误信息时，我们需要怎么做？</p><p>这个问题有两种解决办法：</p><ol><li><p>services层直接返回中断请求的响应对象，controller直接输出该对象即可</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span><span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>allowLogin</span>()) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> {<span style=color:#a6e22e>errcode</span>: <span style=color:#66d9ef>403</span>, <span style=color:#a6e22e>errmsg</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;不允许登录&#39;</span>};
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>services层抛出异常，controller捕获该异常，然后输出响应对象</p></li></ol><p>以上两种方法都有一定的缺点：</p><ol><li>controller调用多个services时，需要依据services层的返回值来进行错误判断，要是漏了判断的话会导致原本需要中断的请求处理继续运行，导致不可预料的后果</li><li>如果每个controller都需要try/catch掉services层抛出的异常的话，会多了很多“重复”代码</li></ol><p>那有没有一个像SpringBoot的<code>ExceptionHandler</code>相似的解决办法呢?</p><h2 id=nestjs的异常处理>NestJs的异常处理</h2><p>NestJs提供了统一的异常处理器，来集中处理运行过程中<strong>未捕获的异常</strong>，可以自定义响应参数，非常灵活。</p><p><img alt=img src=https://static.ddhigh.com/blog/2019-08-26-073002.png></p><h2 id=默认响应>默认响应</h2><p>NestJs内置了默认的<strong>全局异常过滤器</strong>，该过滤器处理<strong>HttpException</strong>(及其子类)的异常。如果抛出的异常不是上述异常，则会响应以下默认JSON：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;statusCode&#34;</span>: <span style=color:#ae81ff>500</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;message&#34;</span>: <span style=color:#e6db74>&#34;Interval server error&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=内置异常过滤器>内置异常过滤器</h2><p>由于NestJs内置了默认的异常过滤器，如果在应用内抛出HttpException，是可以被NestJs自动捕获的。</p><p>比如在services层抛出一个HttpException：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>@Injectable</span>()
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserService</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>login</span>(<span style=color:#a6e22e>username</span>: <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>password</span>: <span style=color:#66d9ef>string</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span><span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>allowLogin</span>()) {
</span></span><span style=display:flex><span>  		<span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>HttpException</span>(<span style=color:#e6db74>&#39;您无权登录&#39;</span>, <span style=color:#a6e22e>HttpStatus</span>.<span style=color:#a6e22e>FORBIDDEN</span>);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> {<span style=color:#a6e22e>user_id</span>:<span style=color:#66d9ef>1</span>, <span style=color:#a6e22e>token</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;fake token&#39;</span>}
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>controller正常调用该services即可:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>@Controller</span>(<span style=color:#e6db74>&#39;users&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserController</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>constructor</span>(<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> <span style=color:#a6e22e>userService</span>: <span style=color:#66d9ef>UserService</span>) {}
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>@Post</span>(<span style=color:#e6db74>&#39;login&#39;</span>)
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>login</span>(<span style=color:#66d9ef>@Body</span>(<span style=color:#e6db74>&#39;username&#39;</span>) <span style=color:#a6e22e>username</span>: <span style=color:#66d9ef>string</span>, <span style=color:#66d9ef>@Body</span>(<span style=color:#e6db74>&#39;password&#39;</span>) <span style=color:#a6e22e>password</span>: <span style=color:#66d9ef>string</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>userService</span>.<span style=color:#a6e22e>login</span>(<span style=color:#a6e22e>username</span>, <span style=color:#a6e22e>password</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>客户端访问/user/login时，如果不允许登录，会收到以下响应：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;statusCode&#34;</span>: <span style=color:#ae81ff>403</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;message&#34;</span>: <span style=color:#e6db74>&#34;您无权登录&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>一般情况下，上述JSON的返回的信息是不够的，比如有些业务自定义的错误码没地方可以自定义。</p><p>如果你有这种需求，可以传递object给HttpException的第一个参数来实现：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>HttpException</span>({<span style=color:#a6e22e>errcode</span>: <span style=color:#66d9ef>40010</span>, <span style=color:#a6e22e>errmsg</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;您无权登录&#39;</span>}, <span style=color:#a6e22e>HttpStatus</span>.<span style=color:#a6e22e>FORBIDDEN</span>);
</span></span></code></pre></div><p>客户端访问时，如果不允许登录，会收到以下响应：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;errcode&#34;</span>: <span style=color:#ae81ff>40010</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;errmsg&#34;</span>: <span style=color:#e6db74>&#34;您无权登录&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=自定义异常>自定义异常</h2><p>企业级应用开发过程中，使用HttpException进行处理对开发是不太友好的，一个比较常用的做法是自定义一个UserException来承载业务异常（系统运行正常，只不过当前请求不满足业务上的要求而中断，比如注册的时候用户名重复的时候打回去，此时数据库查询是正常的，这就是业务异常和系统异常的区别）。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserException</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>HttpException</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>constructor</span>(<span style=color:#a6e22e>errcode</span>: <span style=color:#66d9ef>number</span>, <span style=color:#a6e22e>errmsg</span>: <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>statusCode</span>: <span style=color:#66d9ef>number</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span>({ <span style=color:#a6e22e>errcode</span>, <span style=color:#a6e22e>errmsg</span> }, <span style=color:#a6e22e>statusCode</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>业务层在使用该异常时直接使用以下代码即可，将原来传递对象的代码扁平化了：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>UserException</span>(<span style=color:#ae81ff>40010</span>, <span style=color:#e6db74>&#39;您无权登录&#39;</span>, <span style=color:#a6e22e>HttpStatus</span>.<span style=color:#a6e22e>FORBIDDEN</span>);
</span></span></code></pre></div><h3 id=语义化业务异常>语义化业务异常</h3><p>使用自定义异常时HTTP协议层是正常的，抛出403错误有点不符合语义化的需求。对上例改造一下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserException</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>HttpException</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>constructor</span>(<span style=color:#a6e22e>errcode</span>: <span style=color:#66d9ef>number</span>, <span style=color:#a6e22e>errmsg</span>: <span style=color:#66d9ef>string</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span>({ <span style=color:#a6e22e>errcode</span>, <span style=color:#a6e22e>errmsg</span> }, <span style=color:#a6e22e>HttpStatus</span>.<span style=color:#a6e22e>OK</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>UserException</span>(<span style=color:#ae81ff>40010</span>, <span style=color:#e6db74>&#39;您无权登录&#39;</span>);
</span></span></code></pre></div><p>此时客户端收到的HttpStatus为200，意味着此次请求在协议层面是成功的，只不过业务层返回了错误。前端在处理响应时可以直接对errcode是否为0来确定此次请求是否成功。</p><h2 id=自定义异常过滤器>自定义异常过滤器</h2><p>虽然内置的异常过滤器可以自动处理很多情况，但是不是“可编程”的，也就是说我们无法完全控制异常处理过程，如果我们需要记录日志的话，使用内置的异常过滤器办不到，这时候可以使用**@Catch**注解来自定义异常处理器，添加日志记录什么的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>ExceptionFilter</span>, <span style=color:#a6e22e>Catch</span>, <span style=color:#a6e22e>ArgumentsHost</span>, <span style=color:#a6e22e>HttpException</span> } <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;@nestjs/common&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>Request</span>, <span style=color:#a6e22e>Response</span> } <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;express&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>@Catch</span>(<span style=color:#a6e22e>HttpException</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HttpExceptionFilter</span> <span style=color:#66d9ef>implements</span> <span style=color:#a6e22e>ExceptionFilter</span>&lt;<span style=color:#f92672>HttpException</span>&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>catch</span>(<span style=color:#a6e22e>exception</span>: <span style=color:#66d9ef>HttpException</span>, <span style=color:#a6e22e>host</span>: <span style=color:#66d9ef>ArgumentsHost</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>ctx</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>host</span>.<span style=color:#a6e22e>switchToHttp</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>response</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>getResponse</span>&lt;<span style=color:#f92672>Response</span>&gt;();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>request</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>getRequest</span>&lt;<span style=color:#f92672>Request</span>&gt;();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>status</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>exception</span>.<span style=color:#a6e22e>getStatus</span>();
</span></span><span style=display:flex><span>		<span style=color:#75715e>// @todo 记录日志
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;%s %s error: %s&#39;</span>, <span style=color:#a6e22e>request</span>.<span style=color:#a6e22e>method</span>, <span style=color:#a6e22e>request</span>.<span style=color:#a6e22e>url</span>, <span style=color:#a6e22e>exception</span>.<span style=color:#a6e22e>message</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 发送响应
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>response</span>
</span></span><span style=display:flex><span>      .<span style=color:#a6e22e>status</span>(<span style=color:#a6e22e>status</span>)
</span></span><span style=display:flex><span>      .<span style=color:#a6e22e>json</span>({
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>statusCode</span>: <span style=color:#66d9ef>status</span>,
</span></span><span style=display:flex><span>      	<span style=color:#a6e22e>message</span>: <span style=color:#66d9ef>exception.message</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>path</span>: <span style=color:#66d9ef>request.url</span>,
</span></span><span style=display:flex><span>      });
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=argumenthost>ArgumentHost</h3><p>ArgumentHost是原始请求的包装器，由于NestJs支持HTTP/GRPC/WebSocket，这三种请求的原始请求对象是有差异的，为了异常过滤器能够统一处理这三种异常，NestJs做了包装。最终在使用时处理那种异常由开发者来决定。</p><p>ArgumentHost接口定义如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>ArgumentsHost</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>getArgs</span>&lt;<span style=color:#f92672>T</span> <span style=color:#a6e22e>extends</span> <span style=color:#a6e22e>Array</span><span style=color:#960050;background-color:#1e0010>&lt;</span><span style=color:#a6e22e>any</span>&gt; <span style=color:#f92672>=</span> <span style=color:#66d9ef>any</span>[]<span style=color:#f92672>&gt;</span>()<span style=color:#f92672>:</span> <span style=color:#a6e22e>T</span>;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>getArgByIndex</span>&lt;<span style=color:#f92672>T</span> <span style=color:#960050;background-color:#1e0010>=</span> <span style=color:#a6e22e>any</span>&gt;(<span style=color:#a6e22e>index</span>: <span style=color:#66d9ef>number</span>)<span style=color:#f92672>:</span> <span style=color:#a6e22e>T</span>;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>switchToRpc</span>()<span style=color:#f92672>:</span> <span style=color:#a6e22e>RpcArgumentsHost</span>;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>switchToHttp</span>()<span style=color:#f92672>:</span> <span style=color:#a6e22e>HttpArgumentsHost</span>;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>switchToWs</span>()<span style=color:#f92672>:</span> <span style=color:#a6e22e>WsArgumentsHost</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果需要处理的是WebSocket异常，就使用<strong>host.switchToWs()</strong>，其他异常以此类推。</p><h3 id=使用自定义异常过滤器>使用自定义异常过滤器</h3><p>如果定义完自定义异常过滤器之后，直接去访问会抛出异常的接口，此时可以发现并没有走自定义异常过滤器。</p><p>因为我们<strong>只是定义，并没有注册</strong>。</p><p>使用**@UseFilters**注册自定义异常过滤器。</p><p>异常过滤器有以下三种作用范围：</p><ul><li>方法级别</li><li>控制器级别</li><li>全局级别</li></ul><h3 id=方法级别>方法级别</h3><p>只会处理该方法上抛出的异常，其他方法抛出的异常不会处理。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>@Post</span>(<span style=color:#e6db74>&#39;login&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>@UseFilters</span>(<span style=color:#a6e22e>UserExceptionFilter</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>login</span>(<span style=color:#66d9ef>@Body</span>(<span style=color:#e6db74>&#39;username&#39;</span>) <span style=color:#a6e22e>username</span>:<span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>password</span>: <span style=color:#66d9ef>string</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>UserException</span>(<span style=color:#ae81ff>40010</span>, <span style=color:#e6db74>&#39;您无权登录&#39;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=控制器级别>控制器级别</h3><p>只会处理该控制器方法上抛出的异常，其他控制器抛出的异常不处理。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>@Controller</span>(<span style=color:#e6db74>&#39;user&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>@UseFilters</span>(<span style=color:#a6e22e>UserExceptionFilter</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserController</span> {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=全局级别>全局级别</h3><p>在应用入口注册，不会对Websocket或者混合应用（同时支持两种应用，如HTTP/GRPC或者HTTP/WebSocket）生效。一般Web开发中全局异常过滤器已经够用了。</p><p>在main.ts中注册全局异常过滤器</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>bootstrap() {</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>app</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>NestFactory</span>.<span style=color:#a6e22e>create</span>(<span style=color:#a6e22e>AppModule</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>app</span>.<span style=color:#a6e22e>useGlobalFilters</span>(<span style=color:#66d9ef>new</span> <span style=color:#a6e22e>UserExceptionFilter</span>());
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>app</span>.<span style=color:#a6e22e>listen</span>(<span style=color:#ae81ff>3000</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>bootstrap</span>();
</span></span></code></pre></div><h2 id=依赖注入>依赖注入</h2><p>由于异常过滤器并不是任何模块上下文的一部分，所以NestJs无法对其进行依赖注入管理，如果有此种需求，比如在异常过滤器中注入service，需要定义服务提供者。服务提供者名称为NestJs规定的常量APP_FILTER</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>Module</span> } <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;@nestjs/common&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>APP_FILTER</span> } <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;@nestjs/core&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>@Module</span>({
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>providers</span><span style=color:#f92672>:</span> [
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>provide</span>: <span style=color:#66d9ef>APP_FILTER</span>,
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>useClass</span>: <span style=color:#66d9ef>UserExceptionFilter</span>,
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>  ],
</span></span><span style=display:flex><span>})
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AppModule</span> {}
</span></span></code></pre></div><h2 id=捕获多种异常或者所有异常>捕获多种异常或者所有异常</h2><p>上例中提到的自定义异常处理器只会捕获UserException异常，如果有系统异常，会使用内置的异常处理器。通过传入异常类型给**@Catch**装饰器来捕获多种异常。如果不传任何异常类型的话，NestJs会捕获所有异常（也就是Error及其子类）。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>ExceptionFilter</span>, <span style=color:#a6e22e>Catch</span>, <span style=color:#a6e22e>ArgumentsHost</span>, <span style=color:#a6e22e>HttpException</span> } <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;@nestjs/common&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>Request</span>, <span style=color:#a6e22e>Response</span> } <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;express&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>@Catch</span>() <span style=color:#75715e>// 捕获所有异常
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HttpExceptionFilter</span> <span style=color:#66d9ef>implements</span> <span style=color:#a6e22e>ExceptionFilter</span>&lt;<span style=color:#f92672>Error</span>&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>catch</span>(<span style=color:#a6e22e>exception</span>: <span style=color:#66d9ef>Error</span>, <span style=color:#a6e22e>host</span>: <span style=color:#66d9ef>ArgumentsHost</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>ctx</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>host</span>.<span style=color:#a6e22e>switchToHttp</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>response</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>getResponse</span>&lt;<span style=color:#f92672>Response</span>&gt;();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>request</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>getRequest</span>&lt;<span style=color:#f92672>Request</span>&gt;();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>status</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>exception</span>.<span style=color:#a6e22e>getStatus</span>();
</span></span><span style=display:flex><span>		<span style=color:#75715e>// @todo 记录日志
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;%s %s error: %s&#39;</span>, <span style=color:#a6e22e>request</span>.<span style=color:#a6e22e>method</span>, <span style=color:#a6e22e>request</span>.<span style=color:#a6e22e>url</span>, <span style=color:#a6e22e>exception</span>.<span style=color:#a6e22e>message</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 发送响应
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>response</span>
</span></span><span style=display:flex><span>      .<span style=color:#a6e22e>status</span>(<span style=color:#a6e22e>status</span>)
</span></span><span style=display:flex><span>      .<span style=color:#a6e22e>json</span>({
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>statusCode</span>: <span style=color:#66d9ef>status</span>,
</span></span><span style=display:flex><span>      	<span style=color:#a6e22e>message</span>: <span style=color:#66d9ef>exception.message</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>path</span>: <span style=color:#66d9ef>request.url</span>,
</span></span><span style=display:flex><span>      });
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=结尾>结尾</h2><p>异常过滤器让应用异常有了统一的处理渠道，同时也解决文章开头提出的两个问题。通过自定义异常过滤器，开发者可以进行统一响应格式，统一记录日志等等操作。</p><div style="margin-top:2em;border:1px solid #d3d3d3;background-color:#f7f7f7"><ul><li style=margin-bottom:.5em>本文作者: <a href=https://ddhigh.com/ target=_blank style=color:#000;text-decoration:none>xialeistudio</a></li><li style=margin-bottom:.5em>本文链接: <a href=https://www.ddhigh.com/2019/08/26/nestjs-exception-filter/ target=_blank style=color:#000;text-decoration:none>NestJs学习之旅(6)——异常处理</a></li><li>版权声明: <a href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank style=color:#000;text-decoration:none>「署名-非商业性使用-相同方式共享 4.0 国际」</a></li></ul></div></section><div class=paginator><a class=prev href=https://www.ddhigh.com/2019/08/27/nestjs-guard/><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M9.94496 9C9.28897 9.61644 7.63215 10.997 6.04814 11.7966 5.98257 11.8297 5.98456 11.9753 6.05061 12.0063c1.00435.4716 2.8788 1.9201 3.89435 2.9937M6.44444 11.9667C8.86549 12.0608 14 12 16 11" stroke="currentcolor" stroke-linecap="round"/></svg>
<span>NestJs学习之旅(7)——路由守卫</span></a>
<a class=next href=https://www.ddhigh.com/2019/08/24/socks5-protocol/><span>socks5协议详解</span><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M12.055 9C12.711 9.61644 14.3679 10.997 15.9519 11.7966 16.0174 11.8297 16.0154 11.9753 15.9494 12.0063 14.945 12.4779 13.0706 13.9264 12.055 15m3.5006-3.0333C13.1345 12.0608 8 12 6 11" stroke="currentcolor" stroke-linecap="round"/></svg></a></div><div class=comments><script>const getTheme=window.localStorage&&window.localStorage.getItem("theme");let theme=getTheme==="dark"?"dark":"light",s=document.createElement("script");s.src="https://giscus.app/client.js",s.setAttribute("data-repo","xialeistudio/discussion"),s.setAttribute("data-repo-id","R_kgDOKurTRA"),s.setAttribute("data-category","General"),s.setAttribute("data-category-id","DIC_kwDOKurTRM4CbCJt"),s.setAttribute("data-mapping","pathname"),s.setAttribute("data-strict","0"),s.setAttribute("data-reactions-enabled","1"),s.setAttribute("data-emit-metadata","0"),s.setAttribute("data-input-position","bottom"),s.setAttribute("data-theme",theme),s.setAttribute("data-lang","en"),s.setAttribute("data-loading","lazy"),s.setAttribute("crossorigin","anonymous"),s.setAttribute("async",""),document.querySelector("div.comments").innerHTML="",document.querySelector("div.comments").appendChild(s)</script></div></article></div><footer class=footer><p>&copy; 2014 - 2024 <a href=https://www.ddhigh.com/>每天进步一点点</a>
Powered by
<a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>
<a href=https://github.com/guangzhengli/hugo-theme-ladder rel=noopener target=_blank>Ladder</a>
️</p></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.5376 22.7916C11.0152 22.7207 22.5795 21.1781 22.0978 10.4211 22.0536 9.43274 21.9303 8.53367 21.7387 7.71865M10.5376 22.7916C16.876 22.3728 20.0969 19.8899 21.5383 16.9142M10.5376 22.7916C9.7707 22.9055 8.97982 22.8964 8.19743 22.7725M21.7387 7.71865C21.4988 6.69828 21.1518 5.80967 20.7188 5.04257m1.0199 2.67608C22.6022 10.1105 23.0542 13.7848 21.5383 16.9142M20.7188 5.04257c-3.5504-6.28886-12.88753-4.410077-16.44303.0C2.88063 6.77451-.0433281 11.1668 1.38159 16.6571c.89322 3.4417 3.7911 5.6365 6.81584 6.1154M20.7188 5.04257c1.3509 1.89783 3.3111 6.34223 1.6353 10.37273M21.5383 16.9142C21.8737 16.4251 22.1428 15.9235 22.3541 15.4153M8.19743 22.7725C12.1971 23.4683 20.6281 22.971 22.3541 15.4153M14 10.945C13.3836 10.289 12.003 8.63215 11.2034 7.04814 11.1703 6.98257 11.0247 6.98456 10.9937 7.05061 10.5221 8.05496 9.07362 9.92941 8 10.945m3.0333-3.50056C10.9392 9.86549 11 15 12 17" stroke="currentcolor" stroke-linecap="round"/></svg>
</a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function n(){t.innerHTML="Copied",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)}),e.parentNode.appendChild(t)})</script></main></body><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script><script>const images=Array.from(document.querySelectorAll(".blog-content img"));images.forEach(e=>{mediumZoom(e,{margin:10,scrollOffset:40,container:null,template:null,background:"rgba(0, 0, 0, 0.5)"})})</script><script src=/main.min.6bb26b69159420159c74dc9e097b06a578ed2b68c701466a91a44a9632d851bd0af167a1b30012387b4c512b48ad9ad4d3394e04d77ae38d57e1920fe4ed34fe.js integrity="sha512-a7JraRWUIBWcdNyeCXsGpXjtK2jHAUZqkaRKljLYUb0K8WehswASOHtMUStIrZrU0zlOBNd6441X4ZIP5O00/g==" crossorigin=anonymous defer></script></html>