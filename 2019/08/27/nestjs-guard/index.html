<!doctype html><html lang=zh><head><meta name=viewport content="width=device-width,initial-scale=1"><title>NestJs学习之旅(7)——路由守卫</title>
<meta charset=utf-8><meta name=google-adsense-account content="ca-pub-2871082647721658"><meta content="Web开发 ,Java ,Go ,Node.js ,PHP ,Koa ,MySQL ,Redis ,前端 ,后端 ,数据库" name=keywords><meta name=description content="本文是NestJs的第七篇，讲解路由守卫。
传统的Web应用中去检测用户登录、权限判断等等都是在控制器层或者中间件层做的，而在目前比较推荐的模块化与组件化架构中，不同职责的功能建议拆分到不同的类文件中去。
通过前几篇的学习可以发现NestJs在这方面做的很好，传统的express/koa应用中，需要开发者去思考项目结构以及代码组织，而NestJs不需要你这样做，降低了开发成本，另外也统一了开发风格。
路由守卫 熟悉Vue,React的伙伴应该比较熟悉这个概念，通俗的说就是在访问指定的路由之前回调一个处理函数，如果该函数返回true或者**调用了next()**就会放行当前访问，否则阻断当前访问。"><meta name=author content="Lei Xia"><link rel=canonical href=https://www.ddhigh.com/2019/08/27/nestjs-guard/><link rel=alternate type=application/rss+xml href=https://www.ddhigh.com//index.xml title=每天进步一点点><script async defer data-website-id=52f8f0f9-d93d-466b-8ef5-508aae8c4ed4 src=https://analysis.ddhigh.com/script.js></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-EC3XLVSGKV"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-EC3XLVSGKV")</script><meta property="og:url" content="https://www.ddhigh.com/2019/08/27/nestjs-guard/"><meta property="og:site_name" content="每天进步一点点"><meta property="og:title" content="NestJs学习之旅(7)——路由守卫"><meta property="og:description" content="本文是NestJs的第七篇，讲解路由守卫。
传统的Web应用中去检测用户登录、权限判断等等都是在控制器层或者中间件层做的，而在目前比较推荐的模块化与组件化架构中，不同职责的功能建议拆分到不同的类文件中去。
通过前几篇的学习可以发现NestJs在这方面做的很好，传统的express/koa应用中，需要开发者去思考项目结构以及代码组织，而NestJs不需要你这样做，降低了开发成本，另外也统一了开发风格。
路由守卫 熟悉Vue,React的伙伴应该比较熟悉这个概念，通俗的说就是在访问指定的路由之前回调一个处理函数，如果该函数返回true或者**调用了next()**就会放行当前访问，否则阻断当前访问。"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-08-27T14:58:36+00:00"><meta property="article:modified_time" content="2019-08-27T14:58:36+00:00"><meta property="article:tag" content="Nestjs"><meta name=twitter:card content="summary"><meta name=twitter:title content="NestJs学习之旅(7)——路由守卫"><meta name=twitter:description content="本文是NestJs的第七篇，讲解路由守卫。
传统的Web应用中去检测用户登录、权限判断等等都是在控制器层或者中间件层做的，而在目前比较推荐的模块化与组件化架构中，不同职责的功能建议拆分到不同的类文件中去。
通过前几篇的学习可以发现NestJs在这方面做的很好，传统的express/koa应用中，需要开发者去思考项目结构以及代码组织，而NestJs不需要你这样做，降低了开发成本，另外也统一了开发风格。
路由守卫 熟悉Vue,React的伙伴应该比较熟悉这个概念，通俗的说就是在访问指定的路由之前回调一个处理函数，如果该函数返回true或者**调用了next()**就会放行当前访问，否则阻断当前访问。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.ddhigh.com/posts/"},{"@type":"ListItem","position":2,"name":"NestJs学习之旅(7)——路由守卫","item":"https://www.ddhigh.com/2019/08/27/nestjs-guard/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"NestJs学习之旅(7)——路由守卫","name":"NestJs学习之旅(7)——路由守卫","description":"本文是NestJs的第七篇，讲解路由守卫。\n传统的Web应用中去检测用户登录、权限判断等等都是在控制器层或者中间件层做的，而在目前比较推荐的模块化与组件化架构中，不同职责的功能建议拆分到不同的类文件中去。\n通过前几篇的学习可以发现NestJs在这方面做的很好，传统的express/koa应用中，需要开发者去思考项目结构以及代码组织，而NestJs不需要你这样做，降低了开发成本，另外也统一了开发风格。\n路由守卫 熟悉Vue,React的伙伴应该比较熟悉这个概念，通俗的说就是在访问指定的路由之前回调一个处理函数，如果该函数返回true或者**调用了next()**就会放行当前访问，否则阻断当前访问。","keywords":["nestjs"],"articleBody":"本文是NestJs的第七篇，讲解路由守卫。\n传统的Web应用中去检测用户登录、权限判断等等都是在控制器层或者中间件层做的，而在目前比较推荐的模块化与组件化架构中，不同职责的功能建议拆分到不同的类文件中去。\n通过前几篇的学习可以发现NestJs在这方面做的很好，传统的express/koa应用中，需要开发者去思考项目结构以及代码组织，而NestJs不需要你这样做，降低了开发成本，另外也统一了开发风格。\n路由守卫 熟悉Vue,React的伙伴应该比较熟悉这个概念，通俗的说就是在访问指定的路由之前回调一个处理函数，如果该函数返回true或者**调用了next()**就会放行当前访问，否则阻断当前访问。\nNestJs中路由守卫也是如此，通过继承CanActive接口即可定义一个路由守卫。\nimport { CanActivate, ExecutionContext, Injectable } from '@nestjs/common'; import { Observable } from 'rxjs'; @Injectable() class AppGuard implements CanActivate { canActivate(context: ExecutionContext): boolean | Promise\u003cboolean\u003e | Observable\u003cboolean\u003e { return true; } } 路由守卫与中间件 区别 路由守卫本质上也是中间件的一种，koa或者express开发中接口鉴权就是基于中间件开发的，如果当前请求是不被允许的，当前中间件将不会调用后续中间件，达到阻断请求的目的。\n但是中间件的职责是不明确的，中间件可以干任何事（数据校验，格式转化，响应体压缩等等），这导致只能通过名称来识别中间件，项目迭代比较久以后，有比较高的维护成本。\n联系 由于单一职责的关系，路由守卫只能返回true和false来决定放行/阻断当前请求，不可以修改request/response对象，因为一旦破坏单一职责的原则，排查问题比较麻烦。\n如果需要修改request对象，可以结合中间件一起使用。\n路由守卫在所有中间件执行完毕之后开始执行。\n以下是一个结合路由守卫和中间件的例子。\n// auth.middleware.ts // 中间件职责：读取请求头Authorization，如果存在且有效的话，设置user对象到request中 import { Injectable, NestMiddleware } from '@nestjs/common'; import { Request, Response } from 'express'; @Injectable() export class AuthMiddleware implements NestMiddleware\u003cRequest|any, Response\u003e { constructor(private readonly userService: UserService) {} async use(req: Request|any, res: Response, next: Function) { const token = req.header('authorization'); if(!token) { next(); return; } const user = await this.userService.getUserByToken(token); if(!user) { next(); return; } request.user = user; next(); } } // user.guard.ts import { CanActivate, ExecutionContext, Injectable } from '@nestjs/common'; import { Observable } from 'rxjs'; import { Request } from 'express'; @Injectable() export class UserGuard implements CanActivate { canActivate(context: ExecutionContext): boolean | Promise\u003cboolean\u003e | Observable\u003cboolean\u003e { const request = context.switchToHttp().getRequest\u003cRequest | any\u003e(); // 直接检测是否有user对象，因为无user对象证明无token或者token无效 return !!request.user; } } 以上例子是笔者常用的一种方法，这样职责比较清晰，而且user对象可以在其他中间件中读取。\n使用路由守卫来保护我们的应用 NestJs使用**@UseGuards()**装饰器来注入路由守卫。支持全局守卫、控制器级别守卫、方法级别守卫。\n下面以一个实际的例子来演示路由守卫的工作过程。\n登录流程 用户输入账号密码后进行登录，如果登录成功下发Token 客户端在请求头Authorization中加入第1步下发的Token进行请求 路由守卫读取当前请求的Authorization信息并与数据库的进行比对，如果成功则放行，否则阻断请求 定义token校验业务类 // user.service.ts @Injetable() export class UserService { // 模拟校验，这里直接返回true，实际开发中自行实现即可 validateToken(token: string) { return true; } } 定义路由守卫 // user.guard.ts @Injetable() export class UserGuard implements CanActive { constructor(private readonly userService: UserService) {} canActivate(context: ExecutionContext): boolean | Promise\u003cboolean\u003e | Observable\u003cboolean\u003e { const request = context.switchToHttp().getRequest\u003cRequest\u003e(); // 读取token const authorization = request.header('authorization'); if (!authorization) { return false; } return this.userService.validateToken(authorization); } } 定义控制器 @Controller('user') export class UserController { // 请求登录 @Post('login') login() { return {token:'fake_token'}; // 直接下发token，真实场景下需要验证账号密码 } // 查看当前用户信息 @Get('info') @UseGuards(UserGuard) // 方法级路由守卫 info() { return {username: 'fake_user'}; } } 一个完整的路由守卫应用实例就已经出来了，虽然咱们的路由守卫没啥逻辑都是直接放行的，但是实际开发中也是基于这种思路去开发的，只不过校验的逻辑不一样罢了。\n路由守卫级别 控制器级别 该级别会对被装饰控制器的所有路由方法生效。\n@Controller('user') @UseGuards(UserGuard) export class UserController { // 查看当前用户信息 @Get('info') info() { return {username: 'fake_user'}; } } 方法级别 该级别只对被装饰的方法生效。\n@Get('info') @UseGuards(UserGuard) info() { return {username: 'fake_user'}; } 全局级别 与全局异常过滤器类似，该级别对所有控制器的所有路由方法生效。该方法与全局异常过滤器一样不会对WebSocket和GRPC生效。\nasync function bootstrap() { const app = await NestFactory.create(AppModule); // 由于main.ts启动时并未初始化依赖注入容器，所以依赖必须手动传入，一般情况下不建议使用全局守卫，因为依赖注入得自己解决。 app.useGlobalGuards(new UserGuard(new UserService())); await app.listen(3000); } bootstrap(); 执行上下文 CanActive接口的方法中有一个ExecutionContext对象，该对象为请求上下文对象，该对象定义如下：\nexport interface ExecutionContext extends ArgumentsHost { getClass\u003cT = any\u003e(): Type\u003cT\u003e; getHandler(): Function; } 可以看到继承了ArgumentHost，ArgumentHost在之前的异常处理文章中已经提到过了，这里不再赘述。\ngetClass() 获取当前访问的Controller对象（不是实例），T为调用时传入的具体控制器对象泛型参数 getHandler() 获取当前访问路由的方法 例如访问 /user/info 时，getClass()将返回UserController对象（不是实例），getHandler()将返回info()函数的引用。\n这个特性有什么作用呢？\nNestJs中可以使用反射来获取定义在方法、属性、类等等上面的自定义属性，这一点和Java的注解有点类似。\n反射示例——基于角色的权限验证(RBAC) 定义角色装饰器 被角色装饰器装饰的控制器或者方法在访问时，路由守卫会读取当前用户的角色，与装饰器传入的角色相匹配，如果匹配失败，将阻断请求，否则将放行请求。\n// roles.decorator.ts import { SetMetadata } from '@nestjs/common'; export const Roles = (...roles: string[]) =\u003e SetMetadata('roles', roles); 定义控制器 假设我们有一个只允许管理员访问的创建用户的接口：\n@Post('create') @Roles('admin') async create(@Body() createUserDTO: CreateUserDTO) { this.userService.create(createUserDTO); } 定义路由守卫 // role.guard.ts import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common'; import { Observable } from 'rxjs'; import { Reflector } from '@nestjs/core'; @Injectable() export class RolesGuard implements CanActivate { constructor(private readonly reflector: Reflector) {} canActivate(context: ExecutionContext): boolean { // 获取roles元数据，roles与roles.decorator.ts中SetMetadata()第一个参数一致 const roles = this.reflector.get\u003cstring[]\u003e('roles', context.getHandler()); if (!roles) { // 未被装饰器装饰，直接放行 return true; } const request = context.switchToHttp().getRequest(); const user = request.user; // 读取请求对象的user，该user对象可以通过中间件来设置（本文前面有例子） const hasRole = () =\u003e user.roles.some((role) =\u003e roles.includes(role)); return user \u0026\u0026 user.roles \u0026\u0026 hasRole(); } } 以上就是读取自定义装饰器数据开发RBAC的例子，写的比较简陋，但是原理是一样的，代码量少的话便于理解核心。\n异常处理 路由守卫返回false时框架会抛出ForbiddenException，客户端收到的默认响应如下：\n{ \"statusCode\": 403, \"message\": \"Forbidden resource\" } 如果需要抛出其他异常，比如UnauthorizedException，可以直接在路由守卫的canActive()方法中抛出。\n另外，在这里抛出的异常时可以被异常过滤器捕获并且处理的，所以我们可以自定义异常类型以及输出自定义响应数据。\n结尾 本文除了路由守卫之外另一个重要的知识是【自定义元数据装饰器】的使用，基于该装饰器可以开发很多令人惊艳的功能，这个就看各位看官的实现了。\n","wordCount":"457","inLanguage":"zh","datePublished":"2019-08-27T14:58:36Z","dateModified":"2019-08-27T14:58:36Z","author":{"@type":"Person","name":"Lei Xia"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.ddhigh.com/2019/08/27/nestjs-guard/"},"publisher":{"@type":"Organization","name":"每天进步一点点","logo":{"@type":"ImageObject","url":"https://www.ddhigh.com/favicon.ico"}}}</script><link rel=icon href=/img/favicon.ico sizes=16x16><link rel=apple-touch-icon href=/img/favicon.ico><link rel=manifest href=/img/favicon.ico><link rel=stylesheet href=https://cdn.staticfile.org/lxgw-wenkai-webfont/1.6.0/style.css><link rel=stylesheet href=/css/main.min.d0df733b91ef046970ecd63de7aa626886fd263fd3fb2b8ff28b560e505831f7.css integrity="sha256-0N9zO5HvBGlw7NY956piaIb9Jj/T+yuP8otWDlBYMfc=" crossorigin=anonymous media=screen><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css integrity="sha512-ygEyjMC6rqnzJqWGjRTJUPYMEs9JUOm3i7OWUS9CgQ4XkBUvMsgCS1I8JqavidQ2ClHcREB7IbA2mN08+r9Elg==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=/scss/highlight/github-dark.min.min.66034289ee9a113219a2c4aae0a8bd2095ab255c832a42efcf5863f10814e7a1.css><script src=/js/highlight.min.min.c607d6febd16934a82eb61d3a896ed9d869f54373cc63ce95864ed5488fe3128.js></script><script>hljs.highlightAll()</script><script>$darkModeInit.Content|safeJS</script></head><body><main class=wrapper><nav class=navigation><section class=container><a class=navigation-brand href=/>每天进步一点点
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><span></span><span></span><span></span></label><ul class=navigation-list id=navigation-list><li class="navigation-item navigation-menu"><a class=navigation-link href=/>首页</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/archives>归档</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/books>出版物</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/guestbook>留言板</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class="navigation-item navigation-social"><a class=navigation-link href=https://github.com/xialeistudio><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li class="navigation-item navigation-dark"><button id=mode type=button aria-label="toggle user light or dark theme">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span>
<span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></li><li class="navigation-item navigation-language"><a href=https://www.ddhigh.com/en/>EN</a></li></ul></section></nav><div id=content><article class=blog-single><header class=blog-title><h1>NestJs学习之旅(7)——路由守卫</h1></header><p><small>2019年8月27日&nbsp;· 457 字&nbsp;· 3 分钟</small><p><div class=blog-toc><nav id=TableOfContents><ul><li><a href=#路由守卫>路由守卫</a></li><li><a href=#路由守卫与中间件>路由守卫与中间件</a><ul><li><a href=#区别>区别</a></li><li><a href=#联系>联系</a></li></ul></li><li><a href=#使用路由守卫来保护我们的应用>使用路由守卫来保护我们的应用</a><ul><li><a href=#登录流程>登录流程</a></li><li><a href=#定义token校验业务类>定义token校验业务类</a></li><li><a href=#定义路由守卫>定义路由守卫</a></li><li><a href=#定义控制器>定义控制器</a></li></ul></li><li><a href=#路由守卫级别>路由守卫级别</a><ul><li><a href=#控制器级别>控制器级别</a></li><li><a href=#方法级别>方法级别</a></li><li><a href=#全局级别>全局级别</a></li></ul></li><li><a href=#执行上下文>执行上下文</a></li><li><a href=#反射示例基于角色的权限验证rbac>反射示例——基于角色的权限验证(RBAC)</a><ul><li><a href=#定义角色装饰器>定义角色装饰器</a></li><li><a href=#定义控制器-1>定义控制器</a></li><li><a href=#定义路由守卫-1>定义路由守卫</a></li></ul></li><li><a href=#异常处理>异常处理</a></li><li><a href=#结尾>结尾</a></li></ul></nav></div><section class=blog-content><p>本文是NestJs的第七篇，讲解路由守卫。</p><p>传统的Web应用中去检测用户登录、权限判断等等都是在控制器层或者中间件层做的，而在目前比较推荐的模块化与组件化架构中，不同职责的功能建议拆分到不同的类文件中去。</p><p>通过前几篇的学习可以发现NestJs在这方面做的很好，传统的express/koa应用中，需要开发者去思考项目结构以及代码组织，而NestJs不需要你这样做，降低了开发成本，另外也统一了开发风格。</p><h2 id=路由守卫>路由守卫</h2><p>熟悉Vue,React的伙伴应该比较熟悉这个概念，通俗的说就是在访问指定的路由之前回调一个处理函数，如果该函数<strong>返回true</strong>或者**调用了next()**就会放行当前访问，否则阻断当前访问。</p><p>NestJs中路由守卫也是如此，通过继承<strong>CanActive</strong>接口即可定义一个路由守卫。</p><p><img alt=img src=https://static.ddhigh.com/blog/2019-08-27-055230.png></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>CanActivate</span>, <span style=color:#a6e22e>ExecutionContext</span>, <span style=color:#a6e22e>Injectable</span> } <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;@nestjs/common&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>Observable</span> } <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;rxjs&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>@Injectable</span>()
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AppGuard</span> <span style=color:#66d9ef>implements</span> <span style=color:#a6e22e>CanActivate</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>canActivate</span>(<span style=color:#a6e22e>context</span>: <span style=color:#66d9ef>ExecutionContext</span>)<span style=color:#f92672>:</span> <span style=color:#66d9ef>boolean</span> <span style=color:#f92672>|</span> <span style=color:#a6e22e>Promise</span>&lt;<span style=color:#f92672>boolean</span>&gt; <span style=color:#f92672>|</span> <span style=color:#a6e22e>Observable</span>&lt;<span style=color:#f92672>boolean</span>&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=路由守卫与中间件>路由守卫与中间件</h2><h3 id=区别>区别</h3><p>路由守卫本质上也是中间件的一种，koa或者express开发中接口鉴权就是基于中间件开发的，如果当前请求是不被允许的，当前中间件将不会调用后续中间件，达到阻断请求的目的。</p><p>但是中间件的职责是不明确的，中间件可以干任何事（数据校验，格式转化，响应体压缩等等），这导致只能通过名称来识别中间件，项目迭代比较久以后，有比较高的维护成本。</p><h3 id=联系>联系</h3><p>由于单一职责的关系，路由守卫只能返回true和false来决定放行/阻断当前请求，不可以修改request/response对象，因为一旦破坏单一职责的原则，排查问题比较麻烦。</p><p>如果需要修改request对象，可以结合中间件一起使用。</p><blockquote><p>路由守卫在所有中间件执行完毕之后开始执行。</p></blockquote><p>以下是一个结合路由守卫和中间件的例子。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#75715e>// auth.middleware.ts
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 中间件职责：读取请求头Authorization，如果存在且有效的话，设置user对象到request中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>Injectable</span>, <span style=color:#a6e22e>NestMiddleware</span> } <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;@nestjs/common&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>Request</span>, <span style=color:#a6e22e>Response</span> } <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;express&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>@Injectable</span>()
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AuthMiddleware</span> <span style=color:#66d9ef>implements</span> <span style=color:#a6e22e>NestMiddleware</span>&lt;<span style=color:#f92672>Request</span><span style=color:#960050;background-color:#1e0010>|</span><span style=color:#a6e22e>any</span><span style=color:#960050;background-color:#1e0010>,</span> <span style=color:#a6e22e>Response</span>&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>constructor</span>(<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> <span style=color:#a6e22e>userService</span>: <span style=color:#66d9ef>UserService</span>) {}
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>async</span> <span style=color:#a6e22e>use</span>(<span style=color:#a6e22e>req</span>: <span style=color:#66d9ef>Request</span><span style=color:#f92672>|</span><span style=color:#66d9ef>any</span>, <span style=color:#a6e22e>res</span>: <span style=color:#66d9ef>Response</span>, <span style=color:#a6e22e>next</span>: <span style=color:#66d9ef>Function</span>) {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>token</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>req</span>.<span style=color:#a6e22e>header</span>(<span style=color:#e6db74>&#39;authorization&#39;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span><span style=color:#a6e22e>token</span>) {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>next</span>();
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>user</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>userService</span>.<span style=color:#a6e22e>getUserByToken</span>(<span style=color:#a6e22e>token</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span><span style=color:#a6e22e>user</span>) {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>next</span>();
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>request</span>.<span style=color:#a6e22e>user</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>user</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>next</span>();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#75715e>// user.guard.ts
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>CanActivate</span>, <span style=color:#a6e22e>ExecutionContext</span>, <span style=color:#a6e22e>Injectable</span> } <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;@nestjs/common&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>Observable</span> } <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;rxjs&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>Request</span> } <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;express&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>@Injectable</span>()
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserGuard</span> <span style=color:#66d9ef>implements</span> <span style=color:#a6e22e>CanActivate</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>canActivate</span>(<span style=color:#a6e22e>context</span>: <span style=color:#66d9ef>ExecutionContext</span>)<span style=color:#f92672>:</span> <span style=color:#66d9ef>boolean</span> <span style=color:#f92672>|</span> <span style=color:#a6e22e>Promise</span>&lt;<span style=color:#f92672>boolean</span>&gt; <span style=color:#f92672>|</span> <span style=color:#a6e22e>Observable</span>&lt;<span style=color:#f92672>boolean</span>&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>request</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>switchToHttp</span>().<span style=color:#a6e22e>getRequest</span>&lt;<span style=color:#f92672>Request</span> <span style=color:#960050;background-color:#1e0010>|</span> <span style=color:#a6e22e>any</span>&gt;();
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 直接检测是否有user对象，因为无user对象证明无token或者token无效
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>!!</span><span style=color:#a6e22e>request</span>.<span style=color:#a6e22e>user</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>以上例子是笔者常用的一种方法，这样职责比较清晰，而且user对象可以在其他中间件中读取。</p><h2 id=使用路由守卫来保护我们的应用>使用路由守卫来保护我们的应用</h2><p>NestJs使用**@UseGuards()**装饰器来注入路由守卫。支持全局守卫、控制器级别守卫、方法级别守卫。</p><p>下面以一个实际的例子来演示路由守卫的工作过程。</p><h3 id=登录流程>登录流程</h3><ol><li>用户输入账号密码后进行登录，如果登录成功下发Token</li><li>客户端在请求头Authorization中加入第1步下发的Token进行请求</li><li>路由守卫读取当前请求的Authorization信息并与数据库的进行比对，如果成功则放行，否则阻断请求</li></ol><h3 id=定义token校验业务类>定义token校验业务类</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#75715e>// user.service.ts
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>@Injetable</span>()
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserService</span> {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 模拟校验，这里直接返回true，实际开发中自行实现即可
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>validateToken</span>(<span style=color:#a6e22e>token</span>: <span style=color:#66d9ef>string</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=定义路由守卫>定义路由守卫</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#75715e>// user.guard.ts
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>@Injetable</span>()
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserGuard</span> <span style=color:#66d9ef>implements</span> <span style=color:#a6e22e>CanActive</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>constructor</span>(<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> <span style=color:#a6e22e>userService</span>: <span style=color:#66d9ef>UserService</span>) {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>canActivate</span>(<span style=color:#a6e22e>context</span>: <span style=color:#66d9ef>ExecutionContext</span>)<span style=color:#f92672>:</span> <span style=color:#66d9ef>boolean</span> <span style=color:#f92672>|</span> <span style=color:#a6e22e>Promise</span>&lt;<span style=color:#f92672>boolean</span>&gt; <span style=color:#f92672>|</span> <span style=color:#a6e22e>Observable</span>&lt;<span style=color:#f92672>boolean</span>&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>request</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>switchToHttp</span>().<span style=color:#a6e22e>getRequest</span>&lt;<span style=color:#f92672>Request</span>&gt;();
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 读取token
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>authorization</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>request</span>.<span style=color:#a6e22e>header</span>(<span style=color:#e6db74>&#39;authorization&#39;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>authorization</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>userService</span>.<span style=color:#a6e22e>validateToken</span>(<span style=color:#a6e22e>authorization</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=定义控制器>定义控制器</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>@Controller</span>(<span style=color:#e6db74>&#39;user&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserController</span> {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 请求登录
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>@Post</span>(<span style=color:#e6db74>&#39;login&#39;</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>login() {</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> {<span style=color:#a6e22e>token</span><span style=color:#f92672>:</span><span style=color:#e6db74>&#39;fake_token&#39;</span>}; <span style=color:#75715e>// 直接下发token，真实场景下需要验证账号密码    
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  }
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 查看当前用户信息
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>@Get</span>(<span style=color:#e6db74>&#39;info&#39;</span>)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>@UseGuards</span>(<span style=color:#a6e22e>UserGuard</span>) <span style=color:#75715e>// 方法级路由守卫
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>info() {</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> {<span style=color:#a6e22e>username</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;fake_user&#39;</span>};
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>一个完整的路由守卫应用实例就已经出来了，虽然咱们的路由守卫没啥逻辑都是直接放行的，但是实际开发中也是基于这种思路去开发的，只不过校验的逻辑不一样罢了。</p><h2 id=路由守卫级别>路由守卫级别</h2><h3 id=控制器级别>控制器级别</h3><p>该级别会对被装饰控制器的所有路由方法生效。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>@Controller</span>(<span style=color:#e6db74>&#39;user&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>@UseGuards</span>(<span style=color:#a6e22e>UserGuard</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserController</span> {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 查看当前用户信息
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>@Get</span>(<span style=color:#e6db74>&#39;info&#39;</span>)
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>info() {</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> {<span style=color:#a6e22e>username</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;fake_user&#39;</span>};
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=方法级别>方法级别</h3><p>该级别只对被装饰的方法生效。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>@Get</span>(<span style=color:#e6db74>&#39;info&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>@UseGuards</span>(<span style=color:#a6e22e>UserGuard</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>info() {</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> {<span style=color:#a6e22e>username</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;fake_user&#39;</span>};
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=全局级别>全局级别</h3><p>与全局异常过滤器类似，该级别对所有控制器的所有路由方法生效。该方法与全局异常过滤器一样不会对WebSocket和GRPC生效。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>bootstrap() {</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>app</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>NestFactory</span>.<span style=color:#a6e22e>create</span>(<span style=color:#a6e22e>AppModule</span>);
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 由于main.ts启动时并未初始化依赖注入容器，所以依赖必须手动传入，一般情况下不建议使用全局守卫，因为依赖注入得自己解决。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>app</span>.<span style=color:#a6e22e>useGlobalGuards</span>(<span style=color:#66d9ef>new</span> <span style=color:#a6e22e>UserGuard</span>(<span style=color:#66d9ef>new</span> <span style=color:#a6e22e>UserService</span>()));
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>app</span>.<span style=color:#a6e22e>listen</span>(<span style=color:#ae81ff>3000</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>bootstrap</span>();
</span></span></code></pre></div><h2 id=执行上下文>执行上下文</h2><p><strong>CanActive</strong>接口的方法中有一个<strong>ExecutionContext</strong>对象，该对象为请求上下文对象，该对象定义如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>ExecutionContext</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>ArgumentsHost</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>getClass</span>&lt;<span style=color:#f92672>T</span> <span style=color:#960050;background-color:#1e0010>=</span> <span style=color:#a6e22e>any</span>&gt;()<span style=color:#f92672>:</span> <span style=color:#a6e22e>Type</span>&lt;<span style=color:#f92672>T</span>&gt;;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>getHandler</span>()<span style=color:#f92672>:</span> Function;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>可以看到继承了ArgumentHost，ArgumentHost在之前的异常处理文章中已经提到过了，这里不再赘述。</p><ul><li>getClass() 获取当前访问的Controller对象（不是实例），T为调用时传入的具体控制器对象泛型参数</li><li>getHandler() 获取当前访问路由的方法</li></ul><p>例如访问 /user/info 时，getClass()将返回UserController对象（不是实例），getHandler()将返回info()函数的引用。</p><p>这个特性有什么作用呢？</p><blockquote><p>NestJs中可以使用反射来获取定义在方法、属性、类等等上面的自定义属性，这一点和Java的注解有点类似。</p></blockquote><h2 id=反射示例基于角色的权限验证rbac>反射示例——基于角色的权限验证(RBAC)</h2><h3 id=定义角色装饰器>定义角色装饰器</h3><p>被角色装饰器装饰的控制器或者方法在访问时，路由守卫会读取当前用户的角色，与装饰器传入的角色相匹配，如果匹配失败，将阻断请求，否则将放行请求。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#75715e>// roles.decorator.ts
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>SetMetadata</span> } <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;@nestjs/common&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>Roles</span> <span style=color:#f92672>=</span> (...<span style=color:#a6e22e>roles</span>: <span style=color:#66d9ef>string</span>[]) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>SetMetadata</span>(<span style=color:#e6db74>&#39;roles&#39;</span>, <span style=color:#a6e22e>roles</span>);
</span></span></code></pre></div><h3 id=定义控制器-1>定义控制器</h3><p>假设我们有一个只允许管理员访问的创建用户的接口：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>@Post</span>(<span style=color:#e6db74>&#39;create&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>@Roles</span>(<span style=color:#e6db74>&#39;admin&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#a6e22e>create</span>(<span style=color:#66d9ef>@Body</span>() <span style=color:#a6e22e>createUserDTO</span>: <span style=color:#66d9ef>CreateUserDTO</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>userService</span>.<span style=color:#a6e22e>create</span>(<span style=color:#a6e22e>createUserDTO</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=定义路由守卫-1>定义路由守卫</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#75715e>// role.guard.ts
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>Injectable</span>, <span style=color:#a6e22e>CanActivate</span>, <span style=color:#a6e22e>ExecutionContext</span> } <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;@nestjs/common&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>Observable</span> } <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;rxjs&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>Reflector</span> } <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;@nestjs/core&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>@Injectable</span>()
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>RolesGuard</span> <span style=color:#66d9ef>implements</span> <span style=color:#a6e22e>CanActivate</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>constructor</span>(<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> <span style=color:#a6e22e>reflector</span>: <span style=color:#66d9ef>Reflector</span>) {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>canActivate</span>(<span style=color:#a6e22e>context</span>: <span style=color:#66d9ef>ExecutionContext</span>)<span style=color:#f92672>:</span> <span style=color:#66d9ef>boolean</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 获取roles元数据，roles与roles.decorator.ts中SetMetadata()第一个参数一致
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>roles</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>reflector</span>.<span style=color:#66d9ef>get</span>&lt;<span style=color:#f92672>string</span><span style=color:#960050;background-color:#1e0010>[]</span>&gt;(<span style=color:#e6db74>&#39;roles&#39;</span>, <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>getHandler</span>());
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>roles</span>) { <span style=color:#75715e>// 未被装饰器装饰，直接放行
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>request</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>switchToHttp</span>().<span style=color:#a6e22e>getRequest</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>user</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>request</span>.<span style=color:#a6e22e>user</span>; <span style=color:#75715e>// 读取请求对象的user，该user对象可以通过中间件来设置（本文前面有例子）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>hasRole</span> <span style=color:#f92672>=</span> () <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>user</span>.<span style=color:#a6e22e>roles</span>.<span style=color:#a6e22e>some</span>((<span style=color:#a6e22e>role</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>roles</span>.<span style=color:#a6e22e>includes</span>(<span style=color:#a6e22e>role</span>));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>user</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>user</span>.<span style=color:#a6e22e>roles</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>hasRole</span>();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>以上就是读取自定义装饰器数据开发RBAC的例子，写的比较简陋，但是原理是一样的，代码量少的话便于理解核心。</p><h2 id=异常处理>异常处理</h2><p>路由守卫返回false时框架会抛出ForbiddenException，客户端收到的默认响应如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;statusCode&#34;</span>: <span style=color:#ae81ff>403</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;message&#34;</span>: <span style=color:#e6db74>&#34;Forbidden resource&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果需要抛出其他异常，比如UnauthorizedException，可以直接在路由守卫的canActive()方法中抛出。</p><p>另外，在这里抛出的异常时可以被异常过滤器捕获并且处理的，所以我们可以自定义异常类型以及输出自定义响应数据。</p><h2 id=结尾>结尾</h2><p>本文除了路由守卫之外另一个重要的知识是【自定义元数据装饰器】的使用，基于该装饰器可以开发很多令人惊艳的功能，这个就看各位看官的实现了。</p><div class=blog-footer><div class=social-share></div><div class=copyright><ul><li style=margin-bottom:.5em>本文作者: <a href=https://ddhigh.com/ target=_blank style=color:#000;text-decoration:none>xialeistudio</a></li><li style=margin-bottom:.5em>本文链接: <a href=https://www.ddhigh.com/2019/08/27/nestjs-guard/ target=_blank style=color:#000;text-decoration:none>NestJs学习之旅(7)——路由守卫</a></li><li>版权声明: <a href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank style=color:#000;text-decoration:none>「署名-非商业性使用-相同方式共享 4.0 国际」</a></li></ul></div><div style=margin-top:2rem><img src=/img/mp.png alt=qrcode></div></div></section><div class=paginator><a class=prev href=https://www.ddhigh.com/2019/08/28/nestjs-pipe/><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M9.94496 9C9.28897 9.61644 7.63215 10.997 6.04814 11.7966 5.98257 11.8297 5.98456 11.9753 6.05061 12.0063c1.00435.4716 2.8788 1.9201 3.89435 2.9937M6.44444 11.9667C8.86549 12.0608 14 12 16 11" stroke="currentcolor" stroke-linecap="round"/></svg>
<span>NestJs学习之旅(8)——管道</span></a>
<a class=next href=https://www.ddhigh.com/2019/08/26/nestjs-exception-filter/><span>NestJs学习之旅(6)——异常处理</span><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M12.055 9C12.711 9.61644 14.3679 10.997 15.9519 11.7966 16.0174 11.8297 16.0154 11.9753 15.9494 12.0063 14.945 12.4779 13.0706 13.9264 12.055 15m3.5006-3.0333C13.1345 12.0608 8 12 6 11" stroke="currentcolor" stroke-linecap="round"/></svg></a></div><div class=comments><script>const getTheme=window.localStorage&&window.localStorage.getItem("theme");let theme=getTheme==="dark"?"dark":"light",s=document.createElement("script");s.src="https://giscus.app/client.js",s.setAttribute("data-repo","xialeistudio/discussion"),s.setAttribute("data-repo-id","R_kgDOKurTRA"),s.setAttribute("data-category","General"),s.setAttribute("data-category-id","DIC_kwDOKurTRM4CbCJt"),s.setAttribute("data-mapping","pathname"),s.setAttribute("data-strict","0"),s.setAttribute("data-reactions-enabled","1"),s.setAttribute("data-emit-metadata","0"),s.setAttribute("data-input-position","bottom"),s.setAttribute("data-theme",theme),s.setAttribute("data-lang","en"),s.setAttribute("data-loading","lazy"),s.setAttribute("crossorigin","anonymous"),s.setAttribute("async",""),document.querySelector("div.comments").innerHTML="",document.querySelector("div.comments").appendChild(s)</script></div></article></div><footer class=footer><p>&copy; 2014 - 2024 <a href=https://www.ddhigh.com/>每天进步一点点</a>
Powered by
<a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>
<a href=https://github.com/guangzhengli/hugo-theme-ladder rel=noopener target=_blank>Ladder</a>
️</p></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.5376 22.7916C11.0152 22.7207 22.5795 21.1781 22.0978 10.4211 22.0536 9.43274 21.9303 8.53367 21.7387 7.71865M10.5376 22.7916C16.876 22.3728 20.0969 19.8899 21.5383 16.9142M10.5376 22.7916C9.7707 22.9055 8.97982 22.8964 8.19743 22.7725M21.7387 7.71865C21.4988 6.69828 21.1518 5.80967 20.7188 5.04257m1.0199 2.67608C22.6022 10.1105 23.0542 13.7848 21.5383 16.9142M20.7188 5.04257c-3.5504-6.28886-12.88753-4.410077-16.44303.0C2.88063 6.77451-.0433281 11.1668 1.38159 16.6571c.89322 3.4417 3.7911 5.6365 6.81584 6.1154M20.7188 5.04257c1.3509 1.89783 3.3111 6.34223 1.6353 10.37273M21.5383 16.9142C21.8737 16.4251 22.1428 15.9235 22.3541 15.4153M8.19743 22.7725C12.1971 23.4683 20.6281 22.971 22.3541 15.4153M14 10.945C13.3836 10.289 12.003 8.63215 11.2034 7.04814 11.1703 6.98257 11.0247 6.98456 10.9937 7.05061 10.5221 8.05496 9.07362 9.92941 8 10.945m3.0333-3.50056C10.9392 9.86549 11 15 12 17" stroke="currentcolor" stroke-linecap="round"/></svg>
</a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function n(){t.innerHTML="Copied",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)}),e.parentNode.appendChild(t)})</script><script src=https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js integrity="sha512-9DNXrSjk17bU9MUbRp3IjwcWe46V8FaGA062PFbryPUAEQVRbz4jiZP6FW0AdbqEGtMYBDWnul3eiGBMJOQajA==" crossorigin=anonymous referrerpolicy=no-referrer></script></main></body><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script><script>const images=Array.from(document.querySelectorAll(".blog-content img"));images.forEach(e=>{mediumZoom(e,{margin:10,scrollOffset:40,container:null,template:null,background:"rgba(0, 0, 0, 0.5)"})})</script><script src=/main.min.6bb26b69159420159c74dc9e097b06a578ed2b68c701466a91a44a9632d851bd0af167a1b30012387b4c512b48ad9ad4d3394e04d77ae38d57e1920fe4ed34fe.js integrity="sha512-a7JraRWUIBWcdNyeCXsGpXjtK2jHAUZqkaRKljLYUb0K8WehswASOHtMUStIrZrU0zlOBNd6441X4ZIP5O00/g==" crossorigin=anonymous defer></script></html>