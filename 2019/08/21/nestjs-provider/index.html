<!doctype html><html lang=zh><head><meta name=viewport content="width=device-width,initial-scale=1"><title>NestJs学习之旅(3)——服务提供者</title>
<meta charset=utf-8><meta name=description content="Ladder@本文是NestJs学习之旅的第三篇，讲解服务提供者。
简介 服务提供者是NestJs一个非常重要的概念，一般来说，被装饰器@Injectable()修饰的类都可以视为服务提供者。服务提供者一般包含以下几种：
Services(业务逻辑) Factory(用来创建提供者) Repository(数据库访问使用) Utils(工具函数) 使用 下文中将以Services来说明服务提供者的具体使用。
典型的MVC架构中其实有一个问题，业务逻辑到底放哪里？
放在控制器，代码复用成了问题，不可能去New一个控制器然后调用方法，控制器方法都是根据路由地址绑定的 放在Model，导致Model层臃肿，Model应该是直接和数据库打交道的，业务逻辑跟数据库的关系并不是强制绑定的，只有业务逻辑涉及到数据查询/存储才会使用到Model层 现阶段比较流行的架构是多添加一个Services层来写业务逻辑，分离Model层不应该做的事情。
// 业务类 user.service.ts @Injectable() export class UserServices { private readonly users: User[] = []; create(user: User) { this.users.push(user); } findAll(): User[] { return this.users; } } // 用户控制器 @Controller('users') export class UserController { constructor(private readonly userService: UserService) {} // 注入UserService @Post() async create(@Body() createUserDTO:CreateUserDTO) { this.userService.create(createUserDTO); } @Get() async findAll() { return this.userService.findAll(); } } 服务提供者的Scope SpringBoot中提供了Scope注解来指明Bean的作用域，NestJs也提供了类似的@Scope()装饰器："><meta name=author content="Lei Xia"><link rel=canonical href=https://www.ddhigh.com/2019/08/21/nestjs-provider/><link rel=alternate type=application/rss+xml href=https://www.ddhigh.com//index.xml title="Lei Xia"><meta property="og:title" content="NestJs学习之旅(3)——服务提供者"><meta property="og:description" content="本文是NestJs学习之旅的第三篇，讲解服务提供者。
简介 服务提供者是NestJs一个非常重要的概念，一般来说，被装饰器@Injectable()修饰的类都可以视为服务提供者。服务提供者一般包含以下几种：
Services(业务逻辑) Factory(用来创建提供者) Repository(数据库访问使用) Utils(工具函数) 使用 下文中将以Services来说明服务提供者的具体使用。
典型的MVC架构中其实有一个问题，业务逻辑到底放哪里？
放在控制器，代码复用成了问题，不可能去New一个控制器然后调用方法，控制器方法都是根据路由地址绑定的 放在Model，导致Model层臃肿，Model应该是直接和数据库打交道的，业务逻辑跟数据库的关系并不是强制绑定的，只有业务逻辑涉及到数据查询/存储才会使用到Model层 现阶段比较流行的架构是多添加一个Services层来写业务逻辑，分离Model层不应该做的事情。
// 业务类 user.service.ts @Injectable() export class UserServices { private readonly users: User[] = []; create(user: User) { this.users.push(user); } findAll(): User[] { return this.users; } } // 用户控制器 @Controller('users') export class UserController { constructor(private readonly userService: UserService) {} // 注入UserService @Post() async create(@Body() createUserDTO:CreateUserDTO) { this.userService.create(createUserDTO); } @Get() async findAll() { return this.userService.findAll(); } } 服务提供者的Scope SpringBoot中提供了Scope注解来指明Bean的作用域，NestJs也提供了类似的@Scope()装饰器："><meta property="og:type" content="article"><meta property="og:url" content="https://www.ddhigh.com/2019/08/21/nestjs-provider/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-08-21T10:27:42+00:00"><meta property="article:modified_time" content="2019-08-21T10:27:42+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="NestJs学习之旅(3)——服务提供者"><meta name=twitter:description content="本文是NestJs学习之旅的第三篇，讲解服务提供者。
简介 服务提供者是NestJs一个非常重要的概念，一般来说，被装饰器@Injectable()修饰的类都可以视为服务提供者。服务提供者一般包含以下几种：
Services(业务逻辑) Factory(用来创建提供者) Repository(数据库访问使用) Utils(工具函数) 使用 下文中将以Services来说明服务提供者的具体使用。
典型的MVC架构中其实有一个问题，业务逻辑到底放哪里？
放在控制器，代码复用成了问题，不可能去New一个控制器然后调用方法，控制器方法都是根据路由地址绑定的 放在Model，导致Model层臃肿，Model应该是直接和数据库打交道的，业务逻辑跟数据库的关系并不是强制绑定的，只有业务逻辑涉及到数据查询/存储才会使用到Model层 现阶段比较流行的架构是多添加一个Services层来写业务逻辑，分离Model层不应该做的事情。
// 业务类 user.service.ts @Injectable() export class UserServices { private readonly users: User[] = []; create(user: User) { this.users.push(user); } findAll(): User[] { return this.users; } } // 用户控制器 @Controller('users') export class UserController { constructor(private readonly userService: UserService) {} // 注入UserService @Post() async create(@Body() createUserDTO:CreateUserDTO) { this.userService.create(createUserDTO); } @Get() async findAll() { return this.userService.findAll(); } } 服务提供者的Scope SpringBoot中提供了Scope注解来指明Bean的作用域，NestJs也提供了类似的@Scope()装饰器："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.ddhigh.com/posts/"},{"@type":"ListItem","position":2,"name":"NestJs学习之旅(3)——服务提供者","item":"https://www.ddhigh.com/2019/08/21/nestjs-provider/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"NestJs学习之旅(3)——服务提供者","name":"NestJs学习之旅(3)——服务提供者","description":"本文是NestJs学习之旅的第三篇，讲解服务提供者。\n简介 服务提供者是NestJs一个非常重要的概念，一般来说，被装饰器@Injectable()修饰的类都可以视为服务提供者。服务提供者一般包含以下几种：\nServices(业务逻辑) Factory(用来创建提供者) Repository(数据库访问使用) Utils(工具函数) 使用 下文中将以Services来说明服务提供者的具体使用。\n典型的MVC架构中其实有一个问题，业务逻辑到底放哪里？\n放在控制器，代码复用成了问题，不可能去New一个控制器然后调用方法，控制器方法都是根据路由地址绑定的 放在Model，导致Model层臃肿，Model应该是直接和数据库打交道的，业务逻辑跟数据库的关系并不是强制绑定的，只有业务逻辑涉及到数据查询/存储才会使用到Model层 现阶段比较流行的架构是多添加一个Services层来写业务逻辑，分离Model层不应该做的事情。\n// 业务类 user.service.ts @Injectable() export class UserServices { private readonly users: User[] = []; create(user: User) { this.users.push(user); } findAll(): User[] { return this.users; } } // 用户控制器 @Controller(\u0026#39;users\u0026#39;) export class UserController { constructor(private readonly userService: UserService) {} // 注入UserService @Post() async create(@Body() createUserDTO:CreateUserDTO) { this.userService.create(createUserDTO); } @Get() async findAll() { return this.userService.findAll(); } } 服务提供者的Scope SpringBoot中提供了Scope注解来指明Bean的作用域，NestJs也提供了类似的@Scope()装饰器：","keywords":["nestjs"],"articleBody":"本文是NestJs学习之旅的第三篇，讲解服务提供者。\n简介 服务提供者是NestJs一个非常重要的概念，一般来说，被装饰器@Injectable()修饰的类都可以视为服务提供者。服务提供者一般包含以下几种：\nServices(业务逻辑) Factory(用来创建提供者) Repository(数据库访问使用) Utils(工具函数) 使用 下文中将以Services来说明服务提供者的具体使用。\n典型的MVC架构中其实有一个问题，业务逻辑到底放哪里？\n放在控制器，代码复用成了问题，不可能去New一个控制器然后调用方法，控制器方法都是根据路由地址绑定的 放在Model，导致Model层臃肿，Model应该是直接和数据库打交道的，业务逻辑跟数据库的关系并不是强制绑定的，只有业务逻辑涉及到数据查询/存储才会使用到Model层 现阶段比较流行的架构是多添加一个Services层来写业务逻辑，分离Model层不应该做的事情。\n// 业务类 user.service.ts @Injectable() export class UserServices { private readonly users: User[] = []; create(user: User) { this.users.push(user); } findAll(): User[] { return this.users; } } // 用户控制器 @Controller('users') export class UserController { constructor(private readonly userService: UserService) {} // 注入UserService @Post() async create(@Body() createUserDTO:CreateUserDTO) { this.userService.create(createUserDTO); } @Get() async findAll() { return this.userService.findAll(); } } 服务提供者的Scope SpringBoot中提供了Scope注解来指明Bean的作用域，NestJs也提供了类似的@Scope()装饰器：\nscope名称 说明 SINGLETON 单例模式，整个应用内只存在一份实例 REQUEST 每个请求初始化一次 TRANSIENT 每次注入都会实例化 @Injectable({scope: Scope.REQUEST}) export class UserService { } 可选的依赖项 默认情况下，如果依赖注入的对象不存在会提示错误，中断应用运行，此时可以使用@Optional()来指明选择性注入，但依赖注入的对象不存在时不会发生错误。\n@Controller('users') export class UserController { constructor(@Optional() private readonly userService:UserService){} } 基于属性的注入 上文中的注入都是基于构造函数的，这样做有一个缺陷，如果涉及到继承的话，子类必须显示调用super来实例化父类。如果父类的构造函数参数过多的话反而成了子类的负担。\n针对这个问题，NestJs建议的方式是基于属性进行注入。\n@Controller('users') export class UserController { @Inject() private readonly userService:UserService; } 服务提供者注册 只有被注册过的服务提供者才能被NestJs进行自动注入。\n@Module({ controllers:[UserController], // 注册控制器 providers: [UserServices], // 注册服务提供者，可以是services,factory等等 }) export class UserModule { } 自定义服务提供者 使用值 上文中提供的Services一般用在编写业务逻辑，结构基本是固定的，如果需要集成其他库作为注入对象的话，需要使用的自定义的服务提供者。\n比如我们使用sequelize创建了数据库连接，想把他注入到我们的Services中进行数据库操作。可以使用以下方式进行处理：\n// sequelize.ts 数据库访问 export const sequelize = new Sequelize({ /// }); // sequelize.provider.ts import {sequelize} from './sequelize'; export const sequelizeProvider = { provide: 'SEQUELIZE', // 服务提供者标识 useValue: sequelize, // 直接使用值 } // user.module.ts @Module({ providers:[UserService, sequelizeProvider] }) export class UserModule {} // user.service.ts @Injectable() export class UserService { constructor(@Inject('SEQUELIZE') private readonly sequelize: Sequelize) {} } 使用类 OOP的一个重要思想就是面向接口化设计，比如我们开发了一个日志接口，有写入本地文件的实现，也有写入syslog的实现。依赖注入到时候我们希望使用接口进行注入，而不是具体的实现。\n// logger.ts export interface Logger { log(log:string); } // file.logger.ts export class FileLogger implements Logger { log(log:string) { // 写入本地文件 } } // syslog.logger.ts export class SyslogLogger implements Logger { log(log:string) { // 写入Syslog } } // logger.provider.ts export const loggerProvider = { provide: Logger, // 使用接口标识 useClass: process.env.NODE_ENV==='development'?FileLogger:SyslogLogger, // 开发日志写入本地，生产日志写入syslog } // user.module.ts @Module({ providers:[UserService,loggerProvider] }) export class UserModule { } // user.service.ts @Injectable() export class UserService { constructor(@Inject(Logger) private readonly logger: Logger) {} } 使用工厂 工厂模式相信大家都不陌生，工厂模式本质上是一个函数或者方法，返回我们需要的产品。\n传统的第三方库都是提供callback形式或者事件形式的进行连接，比如redis，如果需要使用该类型的注入对象，工厂模式是最佳方式。\n以下是使用工厂模式创建数据库连接的例子：\n// database.provider.ts export const databaseProvider = { provide:'DATABASE', useFactory: async(optionsProvider: OptionsProvider) { // 使用依赖，注入顺序和下面定义的顺序一致 return new Promise((resolve, reject) =\u003e { const connection = createConnection(optionsProvider.getDatabaseConfig()) connection.on('ready',()=\u003eresolve(connection)); connection.on('error',(e)=\u003ereject(e)); }); }, inject:[OptionsProvider], // 注入依赖 } // user.module.ts @Module({ providers:[OptionsProvider, databaseProvider] }) export class UserModule { } // user.service.ts @Injectable() export class UserService { constructor(@Inject('DATABASE') private readonly connection: Connection) {} } 别名方式 别名方式可以基于现有的提供者进行创建。\nconst loggerAliasProvider = { provide: 'AliasedLoggerService', useExisting: Logger, }; 导出服务提供者到其他模块 模块的详细知识将在后文提到，但是有一点需要提前知道，只有被模块导出的服务提供者才能被其他模块导入\n基于类型的导出 上文中的UserService是基于类型而不是进入名称进行注入的。\n@Module({ providers: [UserService], exports: [UserService], // 重要 }) export class UserModule {} 基于名称的导出 上文中DATABASE和SEQUELIZE这种服务提供者都是自定义的，而且指定的标识符。\n@Module({ providers: [sequelizeProvider], exports: ['SEQUELIZE'], // 其他模块的组件直接使用@Inject('SEQUELIZE')即可 }) 结尾 服务提供者是NestJs的精华之一，提供了几种方式方便我们在各种环境下的服务提供者创建。\n","wordCount":"363","inLanguage":"zh","datePublished":"2019-08-21T10:27:42Z","dateModified":"2019-08-21T10:27:42Z","author":{"@type":"Person","name":"Lei Xia"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.ddhigh.com/2019/08/21/nestjs-provider/"},"publisher":{"@type":"Organization","name":"Lei Xia","logo":{"@type":"ImageObject","url":"https://www.ddhigh.com/favicon.ico"}}}</script><link rel=icon href=/img/favicon.ico sizes=16x16><link rel=apple-touch-icon href=/img/favicon.ico><link rel=manifest href=/img/favicon.ico><link rel=stylesheet href=https://cdn.staticfile.org/lxgw-wenkai-webfont/1.6.0/style.css><link rel=stylesheet href=/css/main.min.eb16e2c37edda7bb7b8f844336c65138877ea26f51562d3d69efff7f073bff83.css integrity="sha256-6xbiw37dp7t7j4RDNsZROId+om9RVi09ae//fwc7/4M=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/highlight/github-dark.min.min.66034289ee9a113219a2c4aae0a8bd2095ab255c832a42efcf5863f10814e7a1.css><script src=/js/highlight.min.min.c607d6febd16934a82eb61d3a896ed9d869f54373cc63ce95864ed5488fe3128.js></script><script>hljs.highlightAll()</script><script>$darkModeInit.Content|safeJS</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-EC3XLVSGKV"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-EC3XLVSGKV")</script></head><body><main class=wrapper><nav class=navigation><section class=container><a class=navigation-brand href=/>HOME
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><span></span><span></span><span></span></label><ul class=navigation-list id=navigation-list><li class="navigation-item navigation-menu"><a class=navigation-link href=/archives>归档</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/books>出版物</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/guestbook>留言板</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class="navigation-item navigation-social"><a class=navigation-link href=https://github.com/xialeistudio><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li class="navigation-item navigation-dark"><button id=mode type=button aria-label="toggle user light or dark theme">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span>
<span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></li><li class="navigation-item navigation-language"><a href=https://www.ddhigh.com/en/>EN</a></li></ul></section></nav><div id=content><article class=blog-single><header class=blog-title><h1>NestJs学习之旅(3)——服务提供者</h1></header><p><small>2019年8月21日&nbsp;· 363 字&nbsp;· 2 分钟</small><p><div class=blog-toc><nav id=TableOfContents><ul><li><a href=#简介>简介</a></li><li><a href=#使用>使用</a></li><li><a href=#服务提供者的scope>服务提供者的Scope</a></li><li><a href=#可选的依赖项>可选的依赖项</a></li><li><a href=#基于属性的注入>基于属性的注入</a></li><li><a href=#服务提供者注册>服务提供者注册</a></li><li><a href=#自定义服务提供者>自定义服务提供者</a><ul><li><a href=#使用值>使用值</a></li><li><a href=#使用类>使用类</a></li><li><a href=#使用工厂>使用工厂</a></li><li><a href=#别名方式>别名方式</a></li></ul></li><li><a href=#导出服务提供者到其他模块>导出服务提供者到其他模块</a><ul><li><a href=#基于类型的导出>基于类型的导出</a></li><li><a href=#基于名称的导出>基于名称的导出</a></li></ul></li><li><a href=#结尾>结尾</a></li></ul></nav></div><section class=blog-content><p>本文是NestJs学习之旅的第三篇，讲解服务提供者。</p><h2 id=简介>简介</h2><p>服务提供者是NestJs一个非常重要的概念，一般来说，被装饰器<code>@Injectable()</code>修饰的类都可以视为服务提供者。服务提供者一般包含以下几种：</p><ul><li>Services(业务逻辑)</li><li>Factory(用来创建提供者)</li><li>Repository(数据库访问使用)</li><li>Utils(工具函数)</li></ul><h2 id=使用>使用</h2><p>下文中将以Services来说明服务提供者的具体使用。</p><p>典型的MVC架构中其实有一个问题，业务逻辑到底放哪里？</p><ul><li>放在控制器，代码复用成了问题，不可能去New一个控制器然后调用方法，控制器方法都是根据路由地址绑定的</li><li>放在Model，导致Model层臃肿，Model应该是直接和数据库打交道的，业务逻辑跟数据库的关系并不是强制绑定的，只有业务逻辑涉及到数据查询/存储才会使用到Model层</li></ul><p>现阶段比较流行的架构是多添加一个Services层来写业务逻辑，分离Model层不应该做的事情。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#75715e>// 业务类 user.service.ts
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>@Injectable</span>()
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserServices</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> <span style=color:#a6e22e>users</span>: <span style=color:#66d9ef>User</span>[] <span style=color:#f92672>=</span> [];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>create</span>(<span style=color:#a6e22e>user</span>: <span style=color:#66d9ef>User</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>users</span>.<span style=color:#a6e22e>push</span>(<span style=color:#a6e22e>user</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>findAll</span>()<span style=color:#f92672>:</span> <span style=color:#a6e22e>User</span>[] {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>users</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#75715e>// 用户控制器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>@Controller</span>(<span style=color:#e6db74>&#39;users&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserController</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>constructor</span>(<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> <span style=color:#a6e22e>userService</span>: <span style=color:#66d9ef>UserService</span>) {} <span style=color:#75715e>// 注入UserService
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>@Post</span>()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>async</span> <span style=color:#a6e22e>create</span>(<span style=color:#66d9ef>@Body</span>() <span style=color:#a6e22e>createUserDTO</span>:<span style=color:#66d9ef>CreateUserDTO</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>userService</span>.<span style=color:#a6e22e>create</span>(<span style=color:#a6e22e>createUserDTO</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>@Get</span>()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>async</span> <span style=color:#a6e22e>findAll() {</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>userService</span>.<span style=color:#a6e22e>findAll</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=服务提供者的scope>服务提供者的Scope</h2><p>SpringBoot中提供了Scope注解来指明Bean的作用域，NestJs也提供了类似的<code>@Scope()</code>装饰器：</p><table><thead><tr><th style=text-align:left>scope名称</th><th style=text-align:left>说明</th></tr></thead><tbody><tr><td style=text-align:left>SINGLETON</td><td style=text-align:left>单例模式，整个应用内只存在一份实例</td></tr><tr><td style=text-align:left>REQUEST</td><td style=text-align:left>每个请求初始化一次</td></tr><tr><td style=text-align:left>TRANSIENT</td><td style=text-align:left>每次注入都会实例化</td></tr></tbody></table><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>@Injectable</span>({<span style=color:#a6e22e>scope</span>: <span style=color:#66d9ef>Scope.REQUEST</span>})
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserService</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=可选的依赖项>可选的依赖项</h2><p>默认情况下，如果依赖注入的对象不存在会提示错误，中断应用运行，此时可以使用<code>@Optional()</code>来指明选择性注入，但依赖注入的对象不存在时不会发生错误。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>@Controller</span>(<span style=color:#e6db74>&#39;users&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserController</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>constructor</span>(<span style=color:#66d9ef>@Optional</span>() <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> <span style=color:#a6e22e>userService</span>:<span style=color:#66d9ef>UserService</span>){}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=基于属性的注入>基于属性的注入</h2><p>上文中的注入都是基于构造函数的，这样做有一个缺陷，如果涉及到继承的话，子类必须显示调用<code>super</code>来实例化父类。如果父类的构造函数参数过多的话反而成了子类的负担。</p><p>针对这个问题，NestJs建议的方式是<code>基于属性</code>进行注入。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>@Controller</span>(<span style=color:#e6db74>&#39;users&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserController</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>@Inject</span>()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> <span style=color:#a6e22e>userService</span>:<span style=color:#66d9ef>UserService</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=服务提供者注册>服务提供者注册</h2><p>只有被注册过的服务提供者才能被NestJs进行自动注入。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>@Module</span>({
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>controllers</span><span style=color:#f92672>:</span>[<span style=color:#a6e22e>UserController</span>], <span style=color:#75715e>// 注册控制器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>providers</span><span style=color:#f92672>:</span> [<span style=color:#a6e22e>UserServices</span>], <span style=color:#75715e>// 注册服务提供者，可以是services,factory等等
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>})
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserModule</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=自定义服务提供者>自定义服务提供者</h2><h3 id=使用值>使用值</h3><p>上文中提供的Services一般用在编写业务逻辑，结构基本是固定的，如果需要集成其他库作为注入对象的话，需要使用的自定义的服务提供者。</p><p>比如我们使用sequelize创建了数据库连接，想把他注入到我们的Services中进行数据库操作。可以使用以下方式进行处理：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#75715e>// sequelize.ts 数据库访问
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>sequelize</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Sequelize</span>({
</span></span><span style=display:flex><span>    <span style=color:#75715e>///
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>});
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#75715e>// sequelize.provider.ts
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>import</span> {<span style=color:#a6e22e>sequelize</span>} <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;./sequelize&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>sequelizeProvider</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>provide</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;SEQUELIZE&#39;</span>, <span style=color:#75715e>// 服务提供者标识
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>useValue</span>: <span style=color:#66d9ef>sequelize</span>, <span style=color:#75715e>// 直接使用值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#75715e>// user.module.ts
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>@Module</span>({
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>providers</span><span style=color:#f92672>:</span>[<span style=color:#a6e22e>UserService</span>, <span style=color:#a6e22e>sequelizeProvider</span>]
</span></span><span style=display:flex><span>})
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserModule</span> {}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#75715e>// user.service.ts
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>@Injectable</span>()
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserService</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>constructor</span>(<span style=color:#66d9ef>@Inject</span>(<span style=color:#e6db74>&#39;SEQUELIZE&#39;</span>) <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> <span style=color:#a6e22e>sequelize</span>: <span style=color:#66d9ef>Sequelize</span>) {}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=使用类>使用类</h3><p>OOP的一个重要思想就是<code>面向接口化</code>设计，比如我们开发了一个日志接口，有写入本地文件的实现，也有写入syslog的实现。依赖注入到时候我们希望使用接口进行注入，而不是具体的实现。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#75715e>// logger.ts
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Logger</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>log</span>:<span style=color:#66d9ef>string</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#75715e>// file.logger.ts
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FileLogger</span> <span style=color:#66d9ef>implements</span> <span style=color:#a6e22e>Logger</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>log</span>:<span style=color:#66d9ef>string</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 写入本地文件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#75715e>// syslog.logger.ts
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SyslogLogger</span> <span style=color:#66d9ef>implements</span> <span style=color:#a6e22e>Logger</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>log</span>:<span style=color:#66d9ef>string</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 写入Syslog
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#75715e>// logger.provider.ts
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>loggerProvider</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>provide</span>: <span style=color:#66d9ef>Logger</span>, <span style=color:#75715e>// 使用接口标识
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>useClass</span>: <span style=color:#66d9ef>process.env.NODE_ENV</span><span style=color:#f92672>===</span><span style=color:#e6db74>&#39;development&#39;</span><span style=color:#f92672>?</span><span style=color:#a6e22e>FileLogger</span>:<span style=color:#66d9ef>SyslogLogger</span>, <span style=color:#75715e>// 开发日志写入本地，生产日志写入syslog
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#75715e>// user.module.ts
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>@Module</span>({
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>providers</span><span style=color:#f92672>:</span>[<span style=color:#a6e22e>UserService</span>,<span style=color:#a6e22e>loggerProvider</span>]
</span></span><span style=display:flex><span>})
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserModule</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#75715e>// user.service.ts
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>@Injectable</span>()
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserService</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>constructor</span>(<span style=color:#66d9ef>@Inject</span>(<span style=color:#a6e22e>Logger</span>) <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> <span style=color:#a6e22e>logger</span>: <span style=color:#66d9ef>Logger</span>) {}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=使用工厂>使用工厂</h3><p>工厂模式相信大家都不陌生，工厂模式本质上是一个函数或者方法，返回我们需要的产品。</p><p>传统的第三方库都是提供callback形式或者事件形式的进行连接，比如redis，如果需要使用该类型的注入对象，工厂模式是最佳方式。</p><p>以下是使用工厂模式创建数据库连接的例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#75715e>// database.provider.ts
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>databaseProvider</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>provide</span><span style=color:#f92672>:</span><span style=color:#e6db74>&#39;DATABASE&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>useFactory</span>: <span style=color:#66d9ef>async</span>(<span style=color:#a6e22e>optionsProvider</span>: <span style=color:#66d9ef>OptionsProvider</span>) { <span style=color:#75715e>// 使用依赖，注入顺序和下面定义的顺序一致
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Promise</span>((<span style=color:#a6e22e>resolve</span>, <span style=color:#a6e22e>reject</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>connection</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>createConnection</span>(<span style=color:#a6e22e>optionsProvider</span>.<span style=color:#a6e22e>getDatabaseConfig</span>())
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>connection</span>.<span style=color:#a6e22e>on</span>(<span style=color:#e6db74>&#39;ready&#39;</span>,()<span style=color:#f92672>=&gt;</span><span style=color:#a6e22e>resolve</span>(<span style=color:#a6e22e>connection</span>));
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>connection</span>.<span style=color:#a6e22e>on</span>(<span style=color:#e6db74>&#39;error&#39;</span>,(<span style=color:#a6e22e>e</span>)<span style=color:#f92672>=&gt;</span><span style=color:#a6e22e>reject</span>(<span style=color:#a6e22e>e</span>));
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>inject</span><span style=color:#f92672>:</span>[<span style=color:#a6e22e>OptionsProvider</span>], <span style=color:#75715e>// 注入依赖
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#75715e>// user.module.ts
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>@Module</span>({
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>providers</span><span style=color:#f92672>:</span>[<span style=color:#a6e22e>OptionsProvider</span>, <span style=color:#a6e22e>databaseProvider</span>]
</span></span><span style=display:flex><span>})
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserModule</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#75715e>// user.service.ts
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>@Injectable</span>()
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserService</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>constructor</span>(<span style=color:#66d9ef>@Inject</span>(<span style=color:#e6db74>&#39;DATABASE&#39;</span>) <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> <span style=color:#a6e22e>connection</span>: <span style=color:#66d9ef>Connection</span>) {}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=别名方式>别名方式</h3><p>别名方式可以基于现有的提供者进行创建。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>loggerAliasProvider</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>provide</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;AliasedLoggerService&#39;</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>useExisting</span>: <span style=color:#66d9ef>Logger</span>,
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h2 id=导出服务提供者到其他模块>导出服务提供者到其他模块</h2><p>模块的详细知识将在后文提到，但是有一点需要提前知道，<code>只有被模块导出的服务提供者才能被其他模块导入</code></p><h3 id=基于类型的导出>基于类型的导出</h3><p>上文中的<code>UserService</code>是基于类型而不是进入名称进行注入的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>@Module</span>({
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>providers</span><span style=color:#f92672>:</span> [<span style=color:#a6e22e>UserService</span>],
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>exports</span><span style=color:#f92672>:</span> [<span style=color:#a6e22e>UserService</span>], <span style=color:#75715e>// 重要
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>})
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserModule</span> {}
</span></span></code></pre></div><h3 id=基于名称的导出>基于名称的导出</h3><p>上文中<code>DATABASE</code>和<code>SEQUELIZE</code>这种服务提供者都是自定义的，而且指定的标识符。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>@Module</span>({
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>providers</span><span style=color:#f92672>:</span> [<span style=color:#a6e22e>sequelizeProvider</span>],
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>exports</span><span style=color:#f92672>:</span> [<span style=color:#e6db74>&#39;SEQUELIZE&#39;</span>], <span style=color:#75715e>// 其他模块的组件直接使用@Inject(&#39;SEQUELIZE&#39;)即可
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>})
</span></span></code></pre></div><h2 id=结尾>结尾</h2><p>服务提供者是NestJs的精华之一，提供了几种方式方便我们在各种环境下的服务提供者创建。</p><div style="margin-top:2em;border:1px solid #d3d3d3;background-color:#f7f7f7"><ul><li style=margin-bottom:.5em>本文作者: <a href=https://ddhigh.com/ target=_blank style=color:#000;text-decoration:none>xialeistudio</a></li><li style=margin-bottom:.5em>本文链接: <a href=https://www.ddhigh.com/2019/08/21/nestjs-provider/ target=_blank style=color:#000;text-decoration:none>NestJs学习之旅(3)——服务提供者</a></li><li>版权声明: <a href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank style=color:#000;text-decoration:none>「署名-非商业性使用-相同方式共享 4.0 国际」</a></li></ul></div></section><div class=paginator><a class=prev href=https://www.ddhigh.com/2019/08/22/nestjs-module/><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M9.94496 9C9.28897 9.61644 7.63215 10.997 6.04814 11.7966 5.98257 11.8297 5.98456 11.9753 6.05061 12.0063c1.00435.4716 2.8788 1.9201 3.89435 2.9937M6.44444 11.9667C8.86549 12.0608 14 12 16 11" stroke="currentcolor" stroke-linecap="round"/></svg>
<span>NestJs学习之旅(4)——模块系统</span></a>
<a class=next href=https://www.ddhigh.com/2019/08/20/nestjs-controller/><span>NestJs学习之旅(2)——控制器</span><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M12.055 9C12.711 9.61644 14.3679 10.997 15.9519 11.7966 16.0174 11.8297 16.0154 11.9753 15.9494 12.0063 14.945 12.4779 13.0706 13.9264 12.055 15m3.5006-3.0333C13.1345 12.0608 8 12 6 11" stroke="currentcolor" stroke-linecap="round"/></svg></a></div><div class=comments><script>const getTheme=window.localStorage&&window.localStorage.getItem("theme");let theme=getTheme==="dark"?"dark":"light",s=document.createElement("script");s.src="https://giscus.app/client.js",s.setAttribute("data-repo","xialeistudio/discussion"),s.setAttribute("data-repo-id","R_kgDOKurTRA"),s.setAttribute("data-category","General"),s.setAttribute("data-category-id","DIC_kwDOKurTRM4CbCJt"),s.setAttribute("data-mapping","pathname"),s.setAttribute("data-strict","0"),s.setAttribute("data-reactions-enabled","1"),s.setAttribute("data-emit-metadata","0"),s.setAttribute("data-input-position","bottom"),s.setAttribute("data-theme",theme),s.setAttribute("data-lang","en"),s.setAttribute("data-loading","lazy"),s.setAttribute("crossorigin","anonymous"),s.setAttribute("async",""),document.querySelector("div.comments").innerHTML="",document.querySelector("div.comments").appendChild(s)</script></div></article></div><footer class=footer><p>&copy; 2014 - 2024 <a href=https://www.ddhigh.com/>Lei Xia</a>
Powered by
<a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>
<a href=https://github.com/guangzhengli/hugo-theme-ladder rel=noopener target=_blank>Ladder</a>
️</p></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.5376 22.7916C11.0152 22.7207 22.5795 21.1781 22.0978 10.4211 22.0536 9.43274 21.9303 8.53367 21.7387 7.71865M10.5376 22.7916C16.876 22.3728 20.0969 19.8899 21.5383 16.9142M10.5376 22.7916C9.7707 22.9055 8.97982 22.8964 8.19743 22.7725M21.7387 7.71865C21.4988 6.69828 21.1518 5.80967 20.7188 5.04257m1.0199 2.67608C22.6022 10.1105 23.0542 13.7848 21.5383 16.9142M20.7188 5.04257c-3.5504-6.28886-12.88753-4.410077-16.44303.0C2.88063 6.77451-.0433281 11.1668 1.38159 16.6571c.89322 3.4417 3.7911 5.6365 6.81584 6.1154M20.7188 5.04257c1.3509 1.89783 3.3111 6.34223 1.6353 10.37273M21.5383 16.9142C21.8737 16.4251 22.1428 15.9235 22.3541 15.4153M8.19743 22.7725C12.1971 23.4683 20.6281 22.971 22.3541 15.4153M14 10.945C13.3836 10.289 12.003 8.63215 11.2034 7.04814 11.1703 6.98257 11.0247 6.98456 10.9937 7.05061 10.5221 8.05496 9.07362 9.92941 8 10.945m3.0333-3.50056C10.9392 9.86549 11 15 12 17" stroke="currentcolor" stroke-linecap="round"/></svg>
</a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function n(){t.innerHTML="Copied",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)}),e.parentNode.appendChild(t)})</script></main></body><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script><script>const images=Array.from(document.querySelectorAll(".blog-content img"));images.forEach(e=>{mediumZoom(e,{margin:10,scrollOffset:40,container:null,template:null,background:"rgba(0, 0, 0, 0.5)"})})</script><script src=/main.min.6bb26b69159420159c74dc9e097b06a578ed2b68c701466a91a44a9632d851bd0af167a1b30012387b4c512b48ad9ad4d3394e04d77ae38d57e1920fe4ed34fe.js integrity="sha512-a7JraRWUIBWcdNyeCXsGpXjtK2jHAUZqkaRKljLYUb0K8WehswASOHtMUStIrZrU0zlOBNd6441X4ZIP5O00/g==" crossorigin=anonymous defer></script></html>