<!doctype html><html lang=zh><head><meta name=viewport content="width=device-width,initial-scale=1"><title>NestJs学习之旅(9)——拦截器</title>
<meta charset=utf-8><meta content="Web开发 ,Java ,Go ,Node.js ,PHP ,Koa ,MySQL ,Redis ,前端 ,后端 ,数据库" name=keywords><meta name=description content="本文是NestJs的第九篇，讲解拦截器。
拦截器是一个实现了NestInterceptor接口且被**@Injectable**装饰器修饰的类。
拦截器是基于AOP编程思想的一种应用，以下是常用的功能：
在方法执行之前或之后执行额外的逻辑，这些逻辑一般不属于业务的一部分 转换函数执行结果 转换函数执行时抛出的异常 扩展函数基本行为 特定场景下完全重写函数的行为（比如缓存拦截器，一旦有可用的缓存则直接返回，不执行真正的业务逻辑，即业务逻辑处理函数行为已经被重写） 拦截器接口 每个拦截器都需要实现NestInterceptor接口的**intercept()**方法，该方法接收两个参数。方法原型如下："><meta name=author content="Lei Xia"><link rel=canonical href=https://www.ddhigh.com/2019/09/10/nestjs-interceptor/><meta name=baidu-site-verification content="IdPCSpVMQx"><link rel=alternate type=application/rss+xml href=https://www.ddhigh.com//index.xml title="Lei Xia"><script async src="https://www.googletagmanager.com/gtag/js?id=G-EC3XLVSGKV"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-EC3XLVSGKV")</script><meta property="og:title" content="NestJs学习之旅(9)——拦截器"><meta property="og:description" content="本文是NestJs的第九篇，讲解拦截器。
拦截器是一个实现了NestInterceptor接口且被**@Injectable**装饰器修饰的类。
拦截器是基于AOP编程思想的一种应用，以下是常用的功能：
在方法执行之前或之后执行额外的逻辑，这些逻辑一般不属于业务的一部分 转换函数执行结果 转换函数执行时抛出的异常 扩展函数基本行为 特定场景下完全重写函数的行为（比如缓存拦截器，一旦有可用的缓存则直接返回，不执行真正的业务逻辑，即业务逻辑处理函数行为已经被重写） 拦截器接口 每个拦截器都需要实现NestInterceptor接口的**intercept()**方法，该方法接收两个参数。方法原型如下："><meta property="og:type" content="article"><meta property="og:url" content="https://www.ddhigh.com/2019/09/10/nestjs-interceptor/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-09-10T15:17:32+00:00"><meta property="article:modified_time" content="2019-09-10T15:17:32+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="NestJs学习之旅(9)——拦截器"><meta name=twitter:description content="本文是NestJs的第九篇，讲解拦截器。
拦截器是一个实现了NestInterceptor接口且被**@Injectable**装饰器修饰的类。
拦截器是基于AOP编程思想的一种应用，以下是常用的功能：
在方法执行之前或之后执行额外的逻辑，这些逻辑一般不属于业务的一部分 转换函数执行结果 转换函数执行时抛出的异常 扩展函数基本行为 特定场景下完全重写函数的行为（比如缓存拦截器，一旦有可用的缓存则直接返回，不执行真正的业务逻辑，即业务逻辑处理函数行为已经被重写） 拦截器接口 每个拦截器都需要实现NestInterceptor接口的**intercept()**方法，该方法接收两个参数。方法原型如下："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.ddhigh.com/posts/"},{"@type":"ListItem","position":2,"name":"NestJs学习之旅(9)——拦截器","item":"https://www.ddhigh.com/2019/09/10/nestjs-interceptor/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"NestJs学习之旅(9)——拦截器","name":"NestJs学习之旅(9)——拦截器","description":"本文是NestJs的第九篇，讲解拦截器。\n拦截器是一个实现了NestInterceptor接口且被**@Injectable**装饰器修饰的类。\n拦截器是基于AOP编程思想的一种应用，以下是常用的功能：\n在方法执行之前或之后执行额外的逻辑，这些逻辑一般不属于业务的一部分 转换函数执行结果 转换函数执行时抛出的异常 扩展函数基本行为 特定场景下完全重写函数的行为（比如缓存拦截器，一旦有可用的缓存则直接返回，不执行真正的业务逻辑，即业务逻辑处理函数行为已经被重写） 拦截器接口 每个拦截器都需要实现NestInterceptor接口的**intercept()**方法，该方法接收两个参数。方法原型如下：","keywords":["nestjs"],"articleBody":"本文是NestJs的第九篇，讲解拦截器。\n拦截器是一个实现了NestInterceptor接口且被**@Injectable**装饰器修饰的类。\n拦截器是基于AOP编程思想的一种应用，以下是常用的功能：\n在方法执行之前或之后执行额外的逻辑，这些逻辑一般不属于业务的一部分 转换函数执行结果 转换函数执行时抛出的异常 扩展函数基本行为 特定场景下完全重写函数的行为（比如缓存拦截器，一旦有可用的缓存则直接返回，不执行真正的业务逻辑，即业务逻辑处理函数行为已经被重写） 拦截器接口 每个拦截器都需要实现NestInterceptor接口的**intercept()**方法，该方法接收两个参数。方法原型如下：\nfunction intercept(context: ExecutionContext, next: CallHandler): Observable\u003cany\u003e ExecutionContext 执行上下文，与NestJs学习之旅(7)——路由守卫中的执行上下文相同 CallHandler 路由处理函数 CallHandler 该接口是对路由处理函数的抽象，接口定义如下：\nexport interface CallHandler\u003cT = any\u003e { handle(): Observable\u003cT\u003e; } handle()函数的返回值也就是对应路由函数的返回值。\n以获取用户列表为例：\n// user.controller.ts @Controller('user') export class UserController { @Get() list() { return []; } } 当访问 /user/list 时，路由处理函数返回**[]**，如果在应用拦截器的情况下，调用CallHandler接口的handle()方法得到的也是Observable\u003c[]\u003e(RxJs包装对象)。\n所以，如果在拦截器中调用了next.handle()方法就会执行对应的路由处理函数，如果不调用的话就不会执行。\n一个请求链路日志记录拦截器 随着微服务的兴起，原来的单一项目被拆分成多个比较小的子模块，这些子模块可以独立开发、独立部署、独立运行，大大提高了开发、执行效率，但是带来的问题也比较多，一个经常遇到的问题是接口调用出错不好查找日志。\n如果在业务逻辑中硬编码这种链路调用日志是非常不可取的，严重违反了单一职责的原则，这在微服务开发中是相当不好的一种行为，会让微服务变得臃肿，这些逻辑完全可以通过拦截器来实现。\n// app.interceptor.ts import { CallHandler, ExecutionContext, Injectable, Logger, NestInterceptor } from '@nestjs/common'; import { Observable } from 'rxjs'; import { tap } from 'rxjs/operators'; import { Request } from 'express'; import { format } from 'util'; @Injectable() export class AppInterceptor implements NestInterceptor { private readonly logger = new Logger(); // 实例化日志记录器 intercept(context: ExecutionContext, next: CallHandler): Observable\u003cany\u003e { const start = Date.now(); // 请求开始时间 return next.handle().pipe(tap((response) =\u003e { // 调用完handle()后得到RxJs响应对象，使用tap可以得到路由函数的返回值 const host = context.switchToHttp(); const request = host.getRequest\u003cRequest\u003e(); // 打印请求方法，请求链接，处理时间和响应数据 this.logger.log(format( '%s %s %dms %s', request.method, request.url, Date.now() - start, JSON.stringify(response), )); })); } } // user.controller.ts @UseInterceptors(AppInterceptor) export class UserController { @Get() list() { return []; } } 当访问 /user时控制台想输出\n[Nest] 96310 - 09/10/2019, 2:44 PM GET /user 1ms [] 拦截器作用域 拦截器可以在以下作用域进行绑定：\n全局拦截器 控制器拦截器 路由方法拦截器 全局拦截器 在main.ts中使用以下代码即可：\nconst app = await NestFactory.create(AppModule); app.useGlobalInterceptors(new AppInterceptor()); 控制器拦截器 将对该控制器所有路由方法生效：\n@Controller('user') @UseInterceptors(AppInterceptor) export class UserController { } 路由方法拦截器 只对当前被装饰的路由方法进行拦截：\n@Controller('user') export class UserController { @UseInterceptors(AppInterceptor) @Get() list() { return []; } } 响应处理 CallHandler接口的handle()返回值实际上是RxJs的Observable对象，利用RxJs操作符可以对该对象进行操作，比如有一个API接口，之前返回的数据结构如下，如果正常响应，响应体就是数据，没有包装结构：\n{ \"id\":1, \"name\":\"xialei\" } 新的需求是要把之前的纯数据响应包装为一个data属性，结构如下：\n{ \"data\": { \"id\": 1, \"name\":\"xialei\" } } 接到这个需求时有的小伙伴可能已经在梳理响应接口的数量然后评估工时准备进行开发了，而使用NestJs的拦截器，不到一炷香的时间即可实现该需求。\nimport { CallHandler, ExecutionContext, Injectable, Logger, NestInterceptor } from '@nestjs/common'; import { Observable } from 'rxjs'; import { map } from 'rxjs/operators'; @Injectable() export class AppInterceptor implements NestInterceptor { intercept(context: ExecutionContext, next: CallHandler): Observable\u003cany\u003e { return next.handle(). pipe(map(data =\u003e ({ data }))); // map操作符与Array.prototype.map类似 } } 应用上述拦截器后响应数据就会被包上一层data属性。\n异常映射 另外一个有趣的例子是利用RxJs的catchError来覆盖路由处理函数抛出的异常。\nimport { Injectable, NestInterceptor, ExecutionContext, BadGatewayException, CallHandler, } from '@nestjs/common'; import { Observable, throwError } from 'rxjs'; import { catchError } from 'rxjs/operators'; @Injectable() export class ErrorsInterceptor implements NestInterceptor { intercept(context: ExecutionContext, next: CallHandler): Observable\u003cany\u003e { return next .handle() .pipe( catchError(err =\u003e throwError(new BadGatewayException())) // catchError用来捕获异常 ); } } 重写路由函数逻辑 在文章开始部分提到了拦截器可以重写路由处理函数逻辑。如下是一个缓存拦截器的例子\nimport { Injectable, NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common'; import { Observable, of } from 'rxjs'; @Injectable() export class CacheInterceptor implements NestInterceptor { constructor(private readonly cacheService: CacheService) {} async intercept(context: ExecutionContext, next: CallHandler): Observable\u003cany\u003e { const host = context.switchToHttp(); const request = host.getRequest(); if(request.method !== 'GET') { // 非GET请求放行 return next.handle(); } const cachedData = await this.cacheService.get(request.url); if(cachedData) { // 命中缓存，直接放行 return of(cachedData); } return next.handle().pipe(tap(response) =\u003e { // 响应数据写入缓存，此处可以等待缓存写入完成，也可以不等待 this.cacheService.set(request.method, response); }); } } 结尾 本文是NestJs基础知识的最后一篇，接下将针对特定模块进行更新，比如数据库、上传、鉴权等等。\n","wordCount":"405","inLanguage":"zh","datePublished":"2019-09-10T15:17:32Z","dateModified":"2019-09-10T15:17:32Z","author":{"@type":"Person","name":"Lei Xia"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.ddhigh.com/2019/09/10/nestjs-interceptor/"},"publisher":{"@type":"Organization","name":"Lei Xia","logo":{"@type":"ImageObject","url":"https://www.ddhigh.com/favicon.ico"}}}</script><link rel=icon href=/img/favicon.ico sizes=16x16><link rel=apple-touch-icon href=/img/favicon.ico><link rel=manifest href=/img/favicon.ico><link rel=stylesheet href=https://cdn.staticfile.org/lxgw-wenkai-webfont/1.6.0/style.css><link rel=stylesheet href=/css/main.min.eb16e2c37edda7bb7b8f844336c65138877ea26f51562d3d69efff7f073bff83.css integrity="sha256-6xbiw37dp7t7j4RDNsZROId+om9RVi09ae//fwc7/4M=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/highlight/github-dark.min.min.66034289ee9a113219a2c4aae0a8bd2095ab255c832a42efcf5863f10814e7a1.css><script src=/js/highlight.min.min.c607d6febd16934a82eb61d3a896ed9d869f54373cc63ce95864ed5488fe3128.js></script><script>hljs.highlightAll()</script><script>$darkModeInit.Content|safeJS</script></head><body><main class=wrapper><nav class=navigation><section class=container><a class=navigation-brand href=/>每天进步一点点
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><span></span><span></span><span></span></label><ul class=navigation-list id=navigation-list><li class="navigation-item navigation-menu"><a class=navigation-link href=/archives>归档</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/books>出版物</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/guestbook>留言板</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class="navigation-item navigation-social"><a class=navigation-link href=https://github.com/xialeistudio><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li class="navigation-item navigation-dark"><button id=mode type=button aria-label="toggle user light or dark theme">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span>
<span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></li><li class="navigation-item navigation-language"><a href=https://www.ddhigh.com/en/>EN</a></li></ul></section></nav><div id=content><article class=blog-single><header class=blog-title><h1>NestJs学习之旅(9)——拦截器</h1></header><p><small>2019年9月10日&nbsp;· 405 字&nbsp;· 2 分钟</small><p><div class=blog-toc><nav id=TableOfContents><ul><li><a href=#拦截器接口>拦截器接口</a></li><li><a href=#callhandler>CallHandler</a></li><li><a href=#一个请求链路日志记录拦截器>一个请求链路日志记录拦截器</a></li><li><a href=#拦截器作用域>拦截器作用域</a><ul><li><a href=#全局拦截器>全局拦截器</a></li><li><a href=#控制器拦截器>控制器拦截器</a></li><li><a href=#路由方法拦截器>路由方法拦截器</a></li></ul></li><li><a href=#响应处理>响应处理</a></li><li><a href=#异常映射>异常映射</a></li><li><a href=#重写路由函数逻辑>重写路由函数逻辑</a></li><li><a href=#结尾>结尾</a></li></ul></nav></div><section class=blog-content><p>本文是NestJs的第九篇，讲解拦截器。</p><p>拦截器是一个实现了<strong>NestInterceptor</strong>接口且被**@Injectable**装饰器修饰的类。</p><p><img alt=img src=https://static.ddhigh.com/blog/2019-09-10-061428.png></p><p>拦截器是基于AOP编程思想的一种应用，以下是常用的功能：</p><ul><li>在方法执行之前或之后执行<strong>额外的逻辑</strong>，这些逻辑一般不属于业务的一部分</li><li><strong>转换</strong>函数执行结果</li><li><strong>转换</strong>函数执行时抛出的异常</li><li>扩展函数基本行为</li><li>特定场景下完全重写函数的行为（比如缓存拦截器，一旦有可用的缓存则直接返回，不执行真正的业务逻辑，即业务逻辑处理函数行为已经被重写）</li></ul><h2 id=拦截器接口>拦截器接口</h2><p>每个拦截器都需要实现<strong>NestInterceptor</strong>接口的**intercept()**方法，该方法接收两个参数。方法原型如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>intercept</span>(<span style=color:#a6e22e>context</span>: <span style=color:#66d9ef>ExecutionContext</span>, <span style=color:#a6e22e>next</span>: <span style=color:#66d9ef>CallHandler</span>)<span style=color:#f92672>:</span> <span style=color:#a6e22e>Observable</span>&lt;<span style=color:#f92672>any</span>&gt;
</span></span></code></pre></div><ul><li>ExecutionContext 执行上下文，与<a href=https://www.ddhigh.com/2019/08/27/nestjs-guard.html>NestJs学习之旅(7)——路由守卫</a>中的<strong>执行上下文</strong>相同</li><li>CallHandler 路由处理函数</li></ul><h2 id=callhandler>CallHandler</h2><p>该接口是对路由处理函数的抽象，接口定义如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>CallHandler</span>&lt;<span style=color:#f92672>T</span> <span style=color:#960050;background-color:#1e0010>=</span> <span style=color:#a6e22e>any</span>&gt; {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>handle</span>()<span style=color:#f92672>:</span> <span style=color:#a6e22e>Observable</span>&lt;<span style=color:#f92672>T</span>&gt;;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>handle()函数的返回值也就是对应路由函数的返回值。</p><p>以获取用户列表为例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#75715e>// user.controller.ts
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>@Controller</span>(<span style=color:#e6db74>&#39;user&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserController</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>@Get</span>()
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>list() {</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> [];
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>当访问 /user/list 时，路由处理函数返回**[]**，如果在应用拦截器的情况下，调用CallHandler接口的handle()方法得到的也是Observable&lt;[]>(RxJs包装对象)。</p><p><strong>所以，如果在拦截器中调用了next.handle()方法就会执行对应的路由处理函数，如果不调用的话就不会执行。</strong></p><h2 id=一个请求链路日志记录拦截器>一个请求链路日志记录拦截器</h2><p>随着微服务的兴起，原来的单一项目被拆分成多个比较小的子模块，这些子模块可以独立开发、独立部署、独立运行，大大提高了开发、执行效率，但是带来的问题也比较多，一个经常遇到的问题是接口调用出错不好查找日志。</p><p>如果在业务逻辑中硬编码这种链路调用日志是非常不可取的，严重违反了单一职责的原则，这在微服务开发中是相当不好的一种行为，会让微服务变得臃肿，这些逻辑完全可以通过拦截器来实现。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#75715e>// app.interceptor.ts
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>CallHandler</span>, <span style=color:#a6e22e>ExecutionContext</span>, <span style=color:#a6e22e>Injectable</span>, <span style=color:#a6e22e>Logger</span>, <span style=color:#a6e22e>NestInterceptor</span> } <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;@nestjs/common&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>Observable</span> } <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;rxjs&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>tap</span> } <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;rxjs/operators&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>Request</span> } <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;express&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>format</span> } <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;util&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>@Injectable</span>()
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AppInterceptor</span> <span style=color:#66d9ef>implements</span> <span style=color:#a6e22e>NestInterceptor</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> <span style=color:#a6e22e>logger</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Logger</span>(); <span style=color:#75715e>// 实例化日志记录器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>intercept</span>(<span style=color:#a6e22e>context</span>: <span style=color:#66d9ef>ExecutionContext</span>, <span style=color:#a6e22e>next</span>: <span style=color:#66d9ef>CallHandler</span>)<span style=color:#f92672>:</span> <span style=color:#a6e22e>Observable</span>&lt;<span style=color:#f92672>any</span>&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>start</span> <span style=color:#f92672>=</span> Date.<span style=color:#a6e22e>now</span>(); <span style=color:#75715e>// 请求开始时间
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>next</span>.<span style=color:#a6e22e>handle</span>().<span style=color:#a6e22e>pipe</span>(<span style=color:#a6e22e>tap</span>((<span style=color:#a6e22e>response</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 调用完handle()后得到RxJs响应对象，使用tap可以得到路由函数的返回值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>host</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>switchToHttp</span>();
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>request</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>host</span>.<span style=color:#a6e22e>getRequest</span>&lt;<span style=color:#f92672>Request</span>&gt;();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 打印请求方法，请求链接，处理时间和响应数据
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>logger</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>format</span>(
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;%s %s %dms %s&#39;</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>request</span>.<span style=color:#a6e22e>method</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>request</span>.<span style=color:#a6e22e>url</span>,
</span></span><span style=display:flex><span>        Date.<span style=color:#a6e22e>now</span>() <span style=color:#f92672>-</span> <span style=color:#a6e22e>start</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>JSON</span>.<span style=color:#a6e22e>stringify</span>(<span style=color:#a6e22e>response</span>),
</span></span><span style=display:flex><span>      ));
</span></span><span style=display:flex><span>    }));
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#75715e>// user.controller.ts
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>@UseInterceptors</span>(<span style=color:#a6e22e>AppInterceptor</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserController</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>@Get</span>()
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>list() {</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> [];
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>当访问 /user时控制台想输出</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>[Nest] 96310   - 09/10/2019, 2:44 PM   GET /user 1ms []
</span></span></code></pre></div><h2 id=拦截器作用域>拦截器作用域</h2><p>拦截器可以在以下作用域进行绑定：</p><ul><li>全局拦截器</li><li>控制器拦截器</li><li>路由方法拦截器</li></ul><h3 id=全局拦截器>全局拦截器</h3><p>在main.ts中使用以下代码即可：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>app</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>NestFactory</span>.<span style=color:#a6e22e>create</span>(<span style=color:#a6e22e>AppModule</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>app</span>.<span style=color:#a6e22e>useGlobalInterceptors</span>(<span style=color:#66d9ef>new</span> <span style=color:#a6e22e>AppInterceptor</span>());
</span></span></code></pre></div><h3 id=控制器拦截器>控制器拦截器</h3><p>将对该控制器所有<strong>路由</strong>方法生效：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>@Controller</span>(<span style=color:#e6db74>&#39;user&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>@UseInterceptors</span>(<span style=color:#a6e22e>AppInterceptor</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserController</span> {
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=路由方法拦截器>路由方法拦截器</h3><p>只对当前被装饰的路由方法进行拦截：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>@Controller</span>(<span style=color:#e6db74>&#39;user&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserController</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>@UseInterceptors</span>(<span style=color:#a6e22e>AppInterceptor</span>)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>@Get</span>()
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>list() {</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> [];
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=响应处理>响应处理</h2><p>CallHandler接口的handle()返回值实际上是RxJs的Observable对象，利用RxJs操作符可以对该对象进行操作，比如有一个API接口，之前返回的数据结构如下，如果正常响应，响应体就是数据，没有包装结构：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;id&#34;</span>:<span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;name&#34;</span>:<span style=color:#e6db74>&#34;xialei&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>新的需求是要把之前的纯数据响应包装为一个data属性，结构如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;data&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;id&#34;</span>: <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;name&#34;</span>:<span style=color:#e6db74>&#34;xialei&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>接到这个需求时有的小伙伴可能已经在梳理响应接口的数量然后评估工时准备进行开发了，而使用NestJs的拦截器，不到一炷香的时间即可实现该需求。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>CallHandler</span>, <span style=color:#a6e22e>ExecutionContext</span>, <span style=color:#a6e22e>Injectable</span>, <span style=color:#a6e22e>Logger</span>, <span style=color:#a6e22e>NestInterceptor</span> } <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;@nestjs/common&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>Observable</span> } <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;rxjs&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>map</span> } <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;rxjs/operators&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>@Injectable</span>()
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AppInterceptor</span> <span style=color:#66d9ef>implements</span> <span style=color:#a6e22e>NestInterceptor</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>intercept</span>(<span style=color:#a6e22e>context</span>: <span style=color:#66d9ef>ExecutionContext</span>, <span style=color:#a6e22e>next</span>: <span style=color:#66d9ef>CallHandler</span>)<span style=color:#f92672>:</span> <span style=color:#a6e22e>Observable</span>&lt;<span style=color:#f92672>any</span>&gt; {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>next</span>.<span style=color:#a6e22e>handle</span>().
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>pipe</span>(<span style=color:#a6e22e>map</span>(<span style=color:#a6e22e>data</span> <span style=color:#f92672>=&gt;</span> ({ <span style=color:#a6e22e>data</span> }))); <span style=color:#75715e>// map操作符与Array.prototype.map类似
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>应用上述拦截器后响应数据就会被包上一层data属性。</p><h2 id=异常映射>异常映射</h2><p>另外一个有趣的例子是利用RxJs的catchError来覆盖路由处理函数抛出的异常。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>import</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>Injectable</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>NestInterceptor</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>ExecutionContext</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>BadGatewayException</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>CallHandler</span>,
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;@nestjs/common&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>Observable</span>, <span style=color:#a6e22e>throwError</span> } <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;rxjs&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>catchError</span> } <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;rxjs/operators&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>@Injectable</span>()
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ErrorsInterceptor</span> <span style=color:#66d9ef>implements</span> <span style=color:#a6e22e>NestInterceptor</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>intercept</span>(<span style=color:#a6e22e>context</span>: <span style=color:#66d9ef>ExecutionContext</span>, <span style=color:#a6e22e>next</span>: <span style=color:#66d9ef>CallHandler</span>)<span style=color:#f92672>:</span> <span style=color:#a6e22e>Observable</span>&lt;<span style=color:#f92672>any</span>&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>next</span>
</span></span><span style=display:flex><span>      .<span style=color:#a6e22e>handle</span>()
</span></span><span style=display:flex><span>      .<span style=color:#a6e22e>pipe</span>(
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>catchError</span>(<span style=color:#a6e22e>err</span> <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>throwError</span>(<span style=color:#66d9ef>new</span> <span style=color:#a6e22e>BadGatewayException</span>())) <span style=color:#75715e>// catchError用来捕获异常
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      );
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=重写路由函数逻辑>重写路由函数逻辑</h2><p>在文章开始部分提到了拦截器可以重写路由处理函数逻辑。如下是一个缓存拦截器的例子</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>Injectable</span>, <span style=color:#a6e22e>NestInterceptor</span>, <span style=color:#a6e22e>ExecutionContext</span>, <span style=color:#a6e22e>CallHandler</span> } <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;@nestjs/common&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>Observable</span>, <span style=color:#66d9ef>of</span> } <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;rxjs&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>@Injectable</span>()
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CacheInterceptor</span> <span style=color:#66d9ef>implements</span> <span style=color:#a6e22e>NestInterceptor</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>constructor</span>(<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> <span style=color:#a6e22e>cacheService</span>: <span style=color:#66d9ef>CacheService</span>) {}
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>async</span> <span style=color:#a6e22e>intercept</span>(<span style=color:#a6e22e>context</span>: <span style=color:#66d9ef>ExecutionContext</span>, <span style=color:#a6e22e>next</span>: <span style=color:#66d9ef>CallHandler</span>)<span style=color:#f92672>:</span> <span style=color:#a6e22e>Observable</span>&lt;<span style=color:#f92672>any</span>&gt; {
</span></span><span style=display:flex><span>  	<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>host</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>switchToHttp</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>request</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>host</span>.<span style=color:#a6e22e>getRequest</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(<span style=color:#a6e22e>request</span>.<span style=color:#a6e22e>method</span> <span style=color:#f92672>!==</span> <span style=color:#e6db74>&#39;GET&#39;</span>) {  
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 非GET请求放行
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>next</span>.<span style=color:#a6e22e>handle</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>cachedData</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>cacheService</span>.<span style=color:#66d9ef>get</span>(<span style=color:#a6e22e>request</span>.<span style=color:#a6e22e>url</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(<span style=color:#a6e22e>cachedData</span>) { 
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 命中缓存，直接放行
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>of</span>(<span style=color:#a6e22e>cachedData</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>next</span>.<span style=color:#a6e22e>handle</span>().<span style=color:#a6e22e>pipe</span>(<span style=color:#a6e22e>tap</span>(<span style=color:#a6e22e>response</span>) <span style=color:#f92672>=&gt;</span> { 
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 响应数据写入缓存，此处可以等待缓存写入完成，也可以不等待
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>cacheService</span>.<span style=color:#66d9ef>set</span>(<span style=color:#a6e22e>request</span>.<span style=color:#a6e22e>method</span>, <span style=color:#a6e22e>response</span>);
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=结尾>结尾</h2><p>本文是NestJs基础知识的最后一篇，接下将针对特定模块进行更新，比如数据库、上传、鉴权等等。</p><div style="margin-top:2em;border:1px solid #d3d3d3;background-color:#f7f7f7"><ul><li style=margin-bottom:.5em>本文作者: <a href=https://ddhigh.com/ target=_blank style=color:#000;text-decoration:none>xialeistudio</a></li><li style=margin-bottom:.5em>本文链接: <a href=https://www.ddhigh.com/2019/09/10/nestjs-interceptor/ target=_blank style=color:#000;text-decoration:none>NestJs学习之旅(9)——拦截器</a></li><li>版权声明: <a href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank style=color:#000;text-decoration:none>「署名-非商业性使用-相同方式共享 4.0 国际」</a></li></ul></div></section><div class=paginator><a class=prev href=https://www.ddhigh.com/2019/09/12/leetcode-two-sum/><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M9.94496 9C9.28897 9.61644 7.63215 10.997 6.04814 11.7966 5.98257 11.8297 5.98456 11.9753 6.05061 12.0063c1.00435.4716 2.8788 1.9201 3.89435 2.9937M6.44444 11.9667C8.86549 12.0608 14 12 16 11" stroke="currentcolor" stroke-linecap="round"/></svg>
<span>leetcode(1) —— 两数之和</span></a>
<a class=next href=https://www.ddhigh.com/2019/08/28/nestjs-pipe/><span>NestJs学习之旅(8)——管道</span><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M12.055 9C12.711 9.61644 14.3679 10.997 15.9519 11.7966 16.0174 11.8297 16.0154 11.9753 15.9494 12.0063 14.945 12.4779 13.0706 13.9264 12.055 15m3.5006-3.0333C13.1345 12.0608 8 12 6 11" stroke="currentcolor" stroke-linecap="round"/></svg></a></div><div class=comments><script>const getTheme=window.localStorage&&window.localStorage.getItem("theme");let theme=getTheme==="dark"?"dark":"light",s=document.createElement("script");s.src="https://giscus.app/client.js",s.setAttribute("data-repo","xialeistudio/discussion"),s.setAttribute("data-repo-id","R_kgDOKurTRA"),s.setAttribute("data-category","General"),s.setAttribute("data-category-id","DIC_kwDOKurTRM4CbCJt"),s.setAttribute("data-mapping","pathname"),s.setAttribute("data-strict","0"),s.setAttribute("data-reactions-enabled","1"),s.setAttribute("data-emit-metadata","0"),s.setAttribute("data-input-position","bottom"),s.setAttribute("data-theme",theme),s.setAttribute("data-lang","en"),s.setAttribute("data-loading","lazy"),s.setAttribute("crossorigin","anonymous"),s.setAttribute("async",""),document.querySelector("div.comments").innerHTML="",document.querySelector("div.comments").appendChild(s)</script></div></article></div><footer class=footer><p>&copy; 2014 - 2024 <a href=https://www.ddhigh.com/>Lei Xia</a>
Powered by
<a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>
<a href=https://github.com/guangzhengli/hugo-theme-ladder rel=noopener target=_blank>Ladder</a>
️</p></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.5376 22.7916C11.0152 22.7207 22.5795 21.1781 22.0978 10.4211 22.0536 9.43274 21.9303 8.53367 21.7387 7.71865M10.5376 22.7916C16.876 22.3728 20.0969 19.8899 21.5383 16.9142M10.5376 22.7916C9.7707 22.9055 8.97982 22.8964 8.19743 22.7725M21.7387 7.71865C21.4988 6.69828 21.1518 5.80967 20.7188 5.04257m1.0199 2.67608C22.6022 10.1105 23.0542 13.7848 21.5383 16.9142M20.7188 5.04257c-3.5504-6.28886-12.88753-4.410077-16.44303.0C2.88063 6.77451-.0433281 11.1668 1.38159 16.6571c.89322 3.4417 3.7911 5.6365 6.81584 6.1154M20.7188 5.04257c1.3509 1.89783 3.3111 6.34223 1.6353 10.37273M21.5383 16.9142C21.8737 16.4251 22.1428 15.9235 22.3541 15.4153M8.19743 22.7725C12.1971 23.4683 20.6281 22.971 22.3541 15.4153M14 10.945C13.3836 10.289 12.003 8.63215 11.2034 7.04814 11.1703 6.98257 11.0247 6.98456 10.9937 7.05061 10.5221 8.05496 9.07362 9.92941 8 10.945m3.0333-3.50056C10.9392 9.86549 11 15 12 17" stroke="currentcolor" stroke-linecap="round"/></svg>
</a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function n(){t.innerHTML="Copied",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)}),e.parentNode.appendChild(t)})</script></main></body><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script><script>const images=Array.from(document.querySelectorAll(".blog-content img"));images.forEach(e=>{mediumZoom(e,{margin:10,scrollOffset:40,container:null,template:null,background:"rgba(0, 0, 0, 0.5)"})})</script><script src=/main.min.6bb26b69159420159c74dc9e097b06a578ed2b68c701466a91a44a9632d851bd0af167a1b30012387b4c512b48ad9ad4d3394e04d77ae38d57e1920fe4ed34fe.js integrity="sha512-a7JraRWUIBWcdNyeCXsGpXjtK2jHAUZqkaRKljLYUb0K8WehswASOHtMUStIrZrU0zlOBNd6441X4ZIP5O00/g==" crossorigin=anonymous defer></script></html>