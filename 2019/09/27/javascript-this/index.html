<!doctype html><html lang=zh><head><meta name=viewport content="width=device-width,initial-scale=1"><title>Javavscript基础——this指向</title>
<meta charset=utf-8><meta name=description content='Ladder@本文研究一下Javascript的this指向。
Javascript的this指向问题，有些人可能觉得很简单，有些人却觉得扑朔迷离，看完本文之后相应会对this的掌握有一个直观的判断，而不是"开局全靠猜"。
敲黑板 function函数this指向由调用方式确定，跟定义环境无关。
箭头函数this指向由定义环境决定，与调用方式无关，也不可以bind(this)。'><meta name=author content="Lei Xia"><link rel=canonical href=https://www.ddhigh.com/2019/09/27/javascript-this/><link rel=alternate type=application/rss+xml href=https://www.ddhigh.com//index.xml title="Lei Xia"><script async src="https://www.googletagmanager.com/gtag/js?id=G-EC3XLVSGKV"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-EC3XLVSGKV")</script><meta property="og:title" content="Javavscript基础——this指向"><meta property="og:description" content='本文研究一下Javascript的this指向。
Javascript的this指向问题，有些人可能觉得很简单，有些人却觉得扑朔迷离，看完本文之后相应会对this的掌握有一个直观的判断，而不是"开局全靠猜"。
敲黑板 function函数this指向由调用方式确定，跟定义环境无关。
箭头函数this指向由定义环境决定，与调用方式无关，也不可以bind(this)。'><meta property="og:type" content="article"><meta property="og:url" content="https://www.ddhigh.com/2019/09/27/javascript-this/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-09-27T12:00:00+00:00"><meta property="article:modified_time" content="2019-09-27T12:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Javavscript基础——this指向"><meta name=twitter:description content='本文研究一下Javascript的this指向。
Javascript的this指向问题，有些人可能觉得很简单，有些人却觉得扑朔迷离，看完本文之后相应会对this的掌握有一个直观的判断，而不是"开局全靠猜"。
敲黑板 function函数this指向由调用方式确定，跟定义环境无关。
箭头函数this指向由定义环境决定，与调用方式无关，也不可以bind(this)。'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.ddhigh.com/posts/"},{"@type":"ListItem","position":2,"name":"Javavscript基础——this指向","item":"https://www.ddhigh.com/2019/09/27/javascript-this/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Javavscript基础——this指向","name":"Javavscript基础——this指向","description":"本文研究一下Javascript的this指向。\nJavascript的this指向问题，有些人可能觉得很简单，有些人却觉得扑朔迷离，看完本文之后相应会对this的掌握有一个直观的判断，而不是\u0026quot;开局全靠猜\u0026quot;。\n敲黑板 function函数this指向由调用方式确定，跟定义环境无关。\n箭头函数this指向由定义环境决定，与调用方式无关，也不可以bind(this)。","keywords":[],"articleBody":"本文研究一下Javascript的this指向。\nJavascript的this指向问题，有些人可能觉得很简单，有些人却觉得扑朔迷离，看完本文之后相应会对this的掌握有一个直观的判断，而不是\"开局全靠猜\"。\n敲黑板 function函数this指向由调用方式确定，跟定义环境无关。\n箭头函数this指向由定义环境决定，与调用方式无关，也不可以bind(this)。\n严格模式 非严格模式下，全局作用域下的this指向window\n严格模式下，全局作用域下的this指向undefined\n以下讨论均为非严格模式，这个不影响今天的讨论。\n实践 说结论往往是让人难以理解的，下面通过不同的调用场景对this做一个说明。\n1. 直接调用 function test() { console.log(this); } test(); // 输出undefined 直接调用是最简单的， 大部分人在这里都能回答的很好。\n总结 直接调用时this指向全局作用域。\n非严格模式this指向window 严格模式this指向undefined 2. 对象调用 'use strict' var n = 1; var a = { n: 2, b: function() { console.log(this.n); } }; a.b(); // 输出2 var b = a.b; b(); // 输出1 面试题：请问上述例子输出什么? 非严格模式下，输出2和1，严格模式下输出2和一个报错(this指向undefined，访问undefined的n属性肯定报错)\n那如果你这么回答，满分!\n分析 知其然还要知其所以然，我们分析一下：\n为什么输出2?\n因为a.b()是对象调用方式，所以b()中的this指向a\n为什么输出1?\n这个非常有意思，而且也很有迷惑性，面试的时候经常问到，也经常有人被问倒。\nvar b = a.b 把a.b赋值给变量b，b就是一个函数，请注意: 这里只是赋值，没有调用，所以b中的this指向还不确定。\nb(); 调用函数b，这是什么调用方式? 普通调用，所以this指向全局作用域。\n总结 对象调用方式下this指向调用对象。\n是否GET? 如果没有GET，请关注公众号NodeJs之路，我在线给你答疑。\n开胃菜已经吃了，下面来点\"有难度的(实际上也没啥难度)\"。\n3. 嵌套对象调用 var n = 1; var a = { n: 2, b: { n: 3, c: function() { console.log(this.n) } } }; 面试题：请问上述例子中function中的this指向哪里? 正确答案：未确定调用环境的情况下，this的指向不确定。\n错误答案：指向a.b对象，Too young too simple!\nvar n = 1; var a = { n: 2, b: { n: 3, c: function() { console.log(this.n) } } }; a.b.c(); // 输出3 a.c = a.b.c; a.c(); // 输出2 var c = a.b.c; c(); // 输出1 这道题跟之前那道对象调用很像。\n为什么输出3?\n对象调用方式下指向调用对象，a.b.c()中c()是通过a.b对象调用，指向对象a.b\n为什么输出?\na.c = a.b.c 给a对象定义一个函数c，注意，此时没有调用！this指向不确定\na.c() 通过a对象来调用c()，所以this指向对象a\n为什么输出1？\nvar c = a.b.c 函数赋值给普通变量，注意，此时没有调用!\nc(); 普通方式调用，指向window\n总结 嵌套对象调用方式下，this指向最终调用函数的对象。\na.b.c.d.e.f.g.h() h函数中的this指向a.b.c.d.e.f.g\n4. 构造函数方式调用 var name = 1; function Person() { this.name = 2; } var p1= Person(); // p1为undefined console.log(p1.name); // 报错 var p2 = new Person(); console.log(p2.name); // 输出2 p1为什么是undefined?\n这道题比较坑，跟调用方式和this指向无关，因为Person函数没有返回值，js中，默认会返回undefined.\np2.name为什么是2?\n使用new操作符时，构造函数的返回值默认指向对象实例，所以p2.name就是Person()中的this.name\n如果在Person()函数中加上return this的话，Person()返回值还是this，因为这是普通调用。\n5. 构造函数中指明返回值 原则上构造函数不应该有返回值，但是如果真的写了会怎么样？我们来探讨一下。\n返回复杂对象 function Person() { this.name = 2; return {}; } var p1 = new Person(); console.log(p1.name)// 输出undefined 返回简单对象 虽然Js只有对象，但是有一些如string,number这种一般叫做简单对象,date,regex,array,object等等叫复杂对象。\nfunction Person() { this.name = 2; return 1; } var p1 = new Person(); console.log(p1.name)// 输出2 返回null 使用typeof null返回的是[object]，证明null是个对象，不过咱们来看看构造函数返回null的表现。\nfunction Person() { this.name = 2; return null; } var p1 = new Person(); console.log(p1.name)// 输出2 总结 构造函数中this指向对象实例本身，如果构造函数指明了返回值，那么表现如下：\n返回普通值，this指向不变，还是对象实例本身 返回复杂对象，this指向新对象，也就是你new Person()返回的是那个新对象 6. bind var a = { n: 1 }; var b = { n: 2 } function f() { console.log(this.n); } var fa = f.bind(a); var fb = fa.bind(b); fa(); // 输出1 fb(); // 输出1 第1个输出1应该不难理解，bind可以更改function内部的this指向。多次bind已经bind过的函数，this指向不变。\nbind的实现原理有点复杂，将在下一篇文章进行详细解读。\n总结 bind可以手动绑定function的this，this指向第1次bind时的this。\n7. apply/call 这两个函数在this指向上表现一致，放到一起讲\nvar a = { n: 1 }; var b = { n: 2 } function f() { console.log(this.n); } f.call(a); // 输出1 f.apply(b); // 输出2 call和apply的第1个参数为function执行时的this，这个this是确定的，对未使用过bind的函数进行多次apply/call，this指向都会改变。\n8. 箭头函数 var n = 1; var b = { n: 2, a: () =\u003e { console.log(this.n); } } b.a(); // 输出1 b.a.call({n:3}); // 输出1 b.a定义时的this和n,b所在的this一致，默认情况下为全局作用域\n箭头函数的this指向定义时所在的this，这个是明确的，但是如果定义时所在的是1个function，那么this指向同上面7点。\n说下我之前学JS遇到过的问题: ES5下function才会有作用域隔离, {}这种玩意不会隔离作用域。\n结尾 直接调用this指向全局作用域window，严格模式指向undefined\n对象调用方式指向调用对象\n嵌套对象调用方式指向最终调用对象(离function最近的那个)\n构造函数方式调用指向对象实例\n构造函数返回String/Number等简单类型时this指向不变，返回null指向也不变 构造函数返回Object/Array等复杂对象时，new Person()的返回值为return的对象 bind可以更改function的this,一经绑定，永不改变。但是并不执行函数\napply/call可以更改没有被bind过的this\n箭头函数的this指向为定义箭头函数的this\n","wordCount":"374","inLanguage":"zh","datePublished":"2019-09-27T12:00:00Z","dateModified":"2019-09-27T12:00:00Z","author":{"@type":"Person","name":"Lei Xia"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.ddhigh.com/2019/09/27/javascript-this/"},"publisher":{"@type":"Organization","name":"Lei Xia","logo":{"@type":"ImageObject","url":"https://www.ddhigh.com/favicon.ico"}}}</script><link rel=icon href=/img/favicon.ico sizes=16x16><link rel=apple-touch-icon href=/img/favicon.ico><link rel=manifest href=/img/favicon.ico><link rel=stylesheet href=https://cdn.staticfile.org/lxgw-wenkai-webfont/1.6.0/style.css><link rel=stylesheet href=/css/main.min.eb16e2c37edda7bb7b8f844336c65138877ea26f51562d3d69efff7f073bff83.css integrity="sha256-6xbiw37dp7t7j4RDNsZROId+om9RVi09ae//fwc7/4M=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/highlight/github-dark.min.min.66034289ee9a113219a2c4aae0a8bd2095ab255c832a42efcf5863f10814e7a1.css><script src=/js/highlight.min.min.c607d6febd16934a82eb61d3a896ed9d869f54373cc63ce95864ed5488fe3128.js></script><script>hljs.highlightAll()</script><script>$darkModeInit.Content|safeJS</script></head><body><main class=wrapper><nav class=navigation><section class=container><a class=navigation-brand href=/>HOME
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><span></span><span></span><span></span></label><ul class=navigation-list id=navigation-list><li class="navigation-item navigation-menu"><a class=navigation-link href=/archives>归档</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/books>出版物</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/guestbook>留言板</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class="navigation-item navigation-social"><a class=navigation-link href=https://github.com/xialeistudio><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li class="navigation-item navigation-dark"><button id=mode type=button aria-label="toggle user light or dark theme">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span>
<span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></li><li class="navigation-item navigation-language"><a href=https://www.ddhigh.com/en/>EN</a></li></ul></section></nav><div id=content><article class=blog-single><header class=blog-title><h1>Javavscript基础——this指向</h1></header><p><small>2019年9月27日&nbsp;· 374 字&nbsp;· 2 分钟</small><p><div class=blog-toc><nav id=TableOfContents><ul><li><a href=#敲黑板>敲黑板</a></li><li><a href=#严格模式>严格模式</a></li><li><a href=#实践>实践</a><ul><li><a href=#1-直接调用>1. 直接调用</a></li><li><a href=#2-对象调用>2. 对象调用</a></li><li><a href=#3-嵌套对象调用>3. 嵌套对象调用</a></li><li><a href=#4-构造函数方式调用>4. 构造函数方式调用</a></li><li><a href=#5-构造函数中指明返回值>5. 构造函数中指明返回值</a></li><li><a href=#6-bind>6. bind</a></li><li><a href=#7-applycall>7. apply/call</a></li><li><a href=#8-箭头函数>8. 箭头函数</a></li></ul></li><li><a href=#结尾>结尾</a></li></ul></nav></div><section class=blog-content><p>本文研究一下Javascript的this指向。</p><p>Javascript的this指向问题，有些人可能觉得很简单，有些人却觉得扑朔迷离，看完本文之后相应会对this的掌握有一个直观的判断，而不是"开局全靠猜"。</p><h2 id=敲黑板>敲黑板</h2><ol><li><p>function函数this指向由<code>调用方式</code>确定，跟定义环境无关。</p></li><li><p>箭头函数this指向由<code>定义环境</code>决定，与<code>调用方式无关</code>，也不可以<code>bind(this)</code>。</p></li></ol><h2 id=严格模式>严格模式</h2><ol><li><p>非严格模式下，全局作用域下的this指向<code>window</code></p></li><li><p>严格模式下，全局作用域下的this指向<code>undefined</code></p></li></ol><p>以下讨论均为<code>非严格模式</code>，这个不影响今天的讨论。</p><h2 id=实践>实践</h2><p>说结论往往是让人难以理解的，下面通过不同的调用场景对this做一个说明。</p><h3 id=1-直接调用>1. 直接调用</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>test</span>() {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#66d9ef>this</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>test</span>(); <span style=color:#75715e>// 输出undefined
</span></span></span></code></pre></div><p>直接调用是最简单的， 大部分人在这里都能回答的很好。</p><h4 id=总结>总结</h4><blockquote><p>直接调用时this指向<code>全局作用域</code>。</p><ul><li>非严格模式this指向window</li><li>严格模式this指向undefined</li></ul></blockquote><h3 id=2-对象调用>2. 对象调用</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#e6db74>&#39;use strict&#39;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>n</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>n</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>2</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>b</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>function</span>() {
</span></span><span style=display:flex><span>  	<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>n</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>a</span>.<span style=color:#a6e22e>b</span>(); <span style=color:#75715e>// 输出2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>b</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>a</span>.<span style=color:#a6e22e>b</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>b</span>(); <span style=color:#75715e>// 输出1
</span></span></span></code></pre></div><h4 id=面试题请问上述例子输出什么>面试题：请问上述例子输出什么?</h4><blockquote><p>非严格模式下，输出2和1，严格模式下输出2和一个报错(this指向undefined，访问undefined的n属性肯定报错)</p></blockquote><p>那如果你这么回答，<code>满分</code>!</p><h4 id=分析>分析</h4><p>知其然还要知其所以然，我们分析一下：</p><p>为什么输出2?</p><blockquote><p>因为<code>a.b()</code>是对象调用方式，所以b()中的this指向a</p></blockquote><p>为什么输出1?</p><p>这个非常有意思，而且也很有迷惑性，面试的时候经常问到，也经常有人被问倒。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>b</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>a</span>.<span style=color:#a6e22e>b</span>
</span></span></code></pre></div><p>把<code>a.b</code>赋值给<code>变量b</code>，b就是一个函数，<code>请注意: 这里只是赋值，没有调用，所以b中的this指向还不确定</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>b();
</span></span></code></pre></div><p>调用函数<code>b</code>，这是什么调用方式? <strong><code>普通调用</code></strong>，所以this指向全局作用域。</p><h4 id=总结-1>总结</h4><p>对象调用方式下this指向调用对象。</p><p>是否GET? 如果没有GET，请关注公众号<code>NodeJs之路</code>，我在线给你答疑。</p><p>开胃菜已经吃了，下面来点"有难度的(实际上也没啥难度)"。</p><h3 id=3-嵌套对象调用>3. 嵌套对象调用</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>n</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>n</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>2</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>b</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>n</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>3</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>c</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>function</span>() {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>n</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=面试题请问上述例子中function中的this指向哪里>面试题：请问上述例子中function中的this指向哪里?</h4><blockquote><p>正确答案：<code>未确定调用环境</code>的情况下，this的指向<code>不确定</code>。</p><p>错误答案：指向a.b对象，Too young too simple!</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>n</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>n</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>2</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>b</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>n</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>3</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>c</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>function</span>() {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>n</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>a</span>.<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>c</span>(); <span style=color:#75715e>// 输出3
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>a</span>.<span style=color:#a6e22e>c</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>a</span>.<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>c</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>a</span>.<span style=color:#a6e22e>c</span>(); <span style=color:#75715e>// 输出2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>c</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>a</span>.<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>c</span>; 
</span></span><span style=display:flex><span><span style=color:#a6e22e>c</span>(); <span style=color:#75715e>// 输出1
</span></span></span></code></pre></div><p>这道题跟之前那道<code>对象调用</code>很像。</p><p>为什么输出3?</p><blockquote><p>对象调用方式下指向调用对象，a.b.c()中c()是通过<code>a.b</code>对象调用，指向对象<code>a.b</code></p></blockquote><p>为什么输出?</p><blockquote><p>a.c = a.b.c 给a对象定义一个函数c，注意，此时没有调用！this指向不确定</p><p>a.c() 通过a对象来调用c()，所以this指向对象<code>a</code></p></blockquote><p>为什么输出1？</p><blockquote><p>var c = a.b.c 函数赋值给普通变量，注意，此时没有调用!</p><p>c(); 普通方式调用，指向window</p></blockquote><h4 id=总结-2>总结</h4><p>嵌套对象调用方式下，this指向<code>最终调用</code>函数的对象。</p><p><code>a.b.c.d.e.f.g.h()</code> h函数中的this指向<code>a.b.c.d.e.f.g</code></p><h3 id=4-构造函数方式调用>4. 构造函数方式调用</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>Person</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>p1</span><span style=color:#f92672>=</span> <span style=color:#a6e22e>Person</span>(); <span style=color:#75715e>// p1为undefined
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>p1</span>.<span style=color:#a6e22e>name</span>); <span style=color:#75715e>// 报错
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>p2</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Person</span>();
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>p2</span>.<span style=color:#a6e22e>name</span>); <span style=color:#75715e>// 输出2
</span></span></span></code></pre></div><p>p1为什么是undefined?</p><blockquote><p>这道题比较坑，跟调用方式和this指向无关，因为Person函数没有返回值，js中，默认会返回undefined.</p></blockquote><p>p2.name为什么是2?</p><blockquote><p>使用new操作符时，构造函数的返回值<code>默认</code>指向对象实例，所以p2.name就是Person()中的this.name</p></blockquote><p>如果在<code>Person()</code>函数中加上<code>return this</code>的话，<code>Person()</code>返回值还是<code>this</code>，因为这是普通调用。</p><h3 id=5-构造函数中指明返回值>5. 构造函数中指明返回值</h3><p>原则上构造函数不应该有返回值，但是如果真的写了会怎么样？我们来探讨一下。</p><h4 id=返回复杂对象>返回复杂对象</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>Person</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> {};
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>p1</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Person</span>();
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>p1</span>.<span style=color:#a6e22e>name</span>)<span style=color:#75715e>// 输出undefined
</span></span></span></code></pre></div><h4 id=返回简单对象>返回简单对象</h4><p>虽然Js只有对象，但是有一些如string,number这种一般叫做简单对象,date,regex,array,object等等叫复杂对象。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>Person</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>p1</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Person</span>();
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>p1</span>.<span style=color:#a6e22e>name</span>)<span style=color:#75715e>// 输出2
</span></span></span></code></pre></div><h4 id=返回null>返回null</h4><p>使用<code>typeof null</code>返回的是<code>[object]</code>，证明null是个对象，不过咱们来看看构造函数返回null的表现。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>Person</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>p1</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Person</span>();
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>p1</span>.<span style=color:#a6e22e>name</span>)<span style=color:#75715e>// 输出2
</span></span></span></code></pre></div><h4 id=总结-3>总结</h4><p>构造函数中this指向对象实例本身，如果构造函数指明了返回值，那么表现如下：</p><ul><li>返回普通值，this指向不变，还是对象实例本身</li><li>返回复杂对象，this指向新对象，也就是你new Person()返回的是那个新对象</li></ul><h3 id=6-bind>6. bind</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span>  <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>n</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>b</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>n</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>f</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>n</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>fa</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>bind</span>(<span style=color:#a6e22e>a</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>fb</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>fa</span>.<span style=color:#a6e22e>bind</span>(<span style=color:#a6e22e>b</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>fa</span>(); <span style=color:#75715e>// 输出1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>fb</span>(); <span style=color:#75715e>// 输出1
</span></span></span></code></pre></div><p>第1个输出1应该不难理解，bind可以更改function内部的this指向。多次bind已经bind过的函数，this指向不变。</p><p>bind的实现原理有点复杂，将在下一篇文章进行详细解读。</p><h4 id=总结-4>总结</h4><p>bind可以手动绑定function的this，<code>this</code>指向<code>第1次</code>bind时的this。</p><h3 id=7-applycall>7. apply/call</h3><p>这两个函数在this指向上表现一致，放到一起讲</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span>  <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>n</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>b</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>n</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>f</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>n</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>call</span>(<span style=color:#a6e22e>a</span>); <span style=color:#75715e>// 输出1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>apply</span>(<span style=color:#a6e22e>b</span>); <span style=color:#75715e>// 输出2
</span></span></span></code></pre></div><blockquote><p>call和apply的第1个参数为function执行时的this，这个this是确定的，对未使用过bind的函数进行多次apply/call，this指向都会改变。</p></blockquote><h3 id=8-箭头函数>8. 箭头函数</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>n</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>b</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>n</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>2</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>a</span><span style=color:#f92672>:</span> () =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>n</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>a</span>(); <span style=color:#75715e>// 输出1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>a</span>.<span style=color:#a6e22e>call</span>({<span style=color:#a6e22e>n</span><span style=color:#f92672>:</span><span style=color:#ae81ff>3</span>}); <span style=color:#75715e>// 输出1
</span></span></span></code></pre></div><p>b.a定义时的this和<code>n</code>,<code>b</code>所在的<code>this一致</code>，默认情况下为全局作用域</p><blockquote><p>箭头函数的this指向定义时所在的this，这个是明确的，但是如果定义时所在的是1个function，那么this指向同上面7点。</p></blockquote><p><em>说下我之前学JS遇到过的问题: ES5下function才会有作用域隔离, {}这种玩意不会隔离作用域。</em></p><h2 id=结尾>结尾</h2><ol><li><p>直接调用this指向全局作用域window，严格模式指向undefined</p></li><li><p>对象调用方式指向调用对象</p></li><li><p>嵌套对象调用方式指向最终调用对象(离function最近的那个)</p></li><li><p>构造函数方式调用指向对象实例</p><ol><li>构造函数返回String/Number等简单类型时this指向不变，返回null指向也不变</li><li>构造函数返回Object/Array等复杂对象时，new Person()的返回值为return的对象</li></ol></li><li><p>bind可以更改function的this,一经绑定，永不改变。<code>但是并不执行函数</code></p></li><li><p>apply/call可以更改没有被bind过的this</p></li><li><p>箭头函数的<code>this</code>指向为<code>定义</code>箭头函数的<code>this</code></p></li></ol><div style="margin-top:2em;border:1px solid #d3d3d3;background-color:#f7f7f7"><ul><li style=margin-bottom:.5em>本文作者: <a href=https://ddhigh.com/ target=_blank style=color:#000;text-decoration:none>xialeistudio</a></li><li style=margin-bottom:.5em>本文链接: <a href=https://www.ddhigh.com/2019/09/27/javascript-this/ target=_blank style=color:#000;text-decoration:none>Javavscript基础——this指向</a></li><li>版权声明: <a href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank style=color:#000;text-decoration:none>「署名-非商业性使用-相同方式共享 4.0 国际」</a></li></ul></div></section><div class=paginator><a class=prev href=https://www.ddhigh.com/2019/10/11/https-protocol/><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M9.94496 9C9.28897 9.61644 7.63215 10.997 6.04814 11.7966 5.98257 11.8297 5.98456 11.9753 6.05061 12.0063c1.00435.4716 2.8788 1.9201 3.89435 2.9937M6.44444 11.9667C8.86549 12.0608 14 12 16 11" stroke="currentcolor" stroke-linecap="round"/></svg>
<span>HTTPS协议是如何保证安全的?</span></a>
<a class=next href=https://www.ddhigh.com/2019/09/23/javascript-prototype/><span>Javavscript基础——原型和原型链</span><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M12.055 9C12.711 9.61644 14.3679 10.997 15.9519 11.7966 16.0174 11.8297 16.0154 11.9753 15.9494 12.0063 14.945 12.4779 13.0706 13.9264 12.055 15m3.5006-3.0333C13.1345 12.0608 8 12 6 11" stroke="currentcolor" stroke-linecap="round"/></svg></a></div><div class=comments><script>const getTheme=window.localStorage&&window.localStorage.getItem("theme");let theme=getTheme==="dark"?"dark":"light",s=document.createElement("script");s.src="https://giscus.app/client.js",s.setAttribute("data-repo","xialeistudio/discussion"),s.setAttribute("data-repo-id","R_kgDOKurTRA"),s.setAttribute("data-category","General"),s.setAttribute("data-category-id","DIC_kwDOKurTRM4CbCJt"),s.setAttribute("data-mapping","pathname"),s.setAttribute("data-strict","0"),s.setAttribute("data-reactions-enabled","1"),s.setAttribute("data-emit-metadata","0"),s.setAttribute("data-input-position","bottom"),s.setAttribute("data-theme",theme),s.setAttribute("data-lang","en"),s.setAttribute("data-loading","lazy"),s.setAttribute("crossorigin","anonymous"),s.setAttribute("async",""),document.querySelector("div.comments").innerHTML="",document.querySelector("div.comments").appendChild(s)</script></div></article></div><footer class=footer><p>&copy; 2014 - 2024 <a href=https://www.ddhigh.com/>Lei Xia</a>
Powered by
<a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>
<a href=https://github.com/guangzhengli/hugo-theme-ladder rel=noopener target=_blank>Ladder</a>
️</p></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.5376 22.7916C11.0152 22.7207 22.5795 21.1781 22.0978 10.4211 22.0536 9.43274 21.9303 8.53367 21.7387 7.71865M10.5376 22.7916C16.876 22.3728 20.0969 19.8899 21.5383 16.9142M10.5376 22.7916C9.7707 22.9055 8.97982 22.8964 8.19743 22.7725M21.7387 7.71865C21.4988 6.69828 21.1518 5.80967 20.7188 5.04257m1.0199 2.67608C22.6022 10.1105 23.0542 13.7848 21.5383 16.9142M20.7188 5.04257c-3.5504-6.28886-12.88753-4.410077-16.44303.0C2.88063 6.77451-.0433281 11.1668 1.38159 16.6571c.89322 3.4417 3.7911 5.6365 6.81584 6.1154M20.7188 5.04257c1.3509 1.89783 3.3111 6.34223 1.6353 10.37273M21.5383 16.9142C21.8737 16.4251 22.1428 15.9235 22.3541 15.4153M8.19743 22.7725C12.1971 23.4683 20.6281 22.971 22.3541 15.4153M14 10.945C13.3836 10.289 12.003 8.63215 11.2034 7.04814 11.1703 6.98257 11.0247 6.98456 10.9937 7.05061 10.5221 8.05496 9.07362 9.92941 8 10.945m3.0333-3.50056C10.9392 9.86549 11 15 12 17" stroke="currentcolor" stroke-linecap="round"/></svg>
</a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function n(){t.innerHTML="Copied",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)}),e.parentNode.appendChild(t)})</script></main></body><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script><script>const images=Array.from(document.querySelectorAll(".blog-content img"));images.forEach(e=>{mediumZoom(e,{margin:10,scrollOffset:40,container:null,template:null,background:"rgba(0, 0, 0, 0.5)"})})</script><script src=/main.min.6bb26b69159420159c74dc9e097b06a578ed2b68c701466a91a44a9632d851bd0af167a1b30012387b4c512b48ad9ad4d3394e04d77ae38d57e1920fe4ed34fe.js integrity="sha512-a7JraRWUIBWcdNyeCXsGpXjtK2jHAUZqkaRKljLYUb0K8WehswASOHtMUStIrZrU0zlOBNd6441X4ZIP5O00/g==" crossorigin=anonymous defer></script></html>