<!doctype html><html lang=zh><head><meta name=viewport content="width=device-width,initial-scale=1"><title>TS简明教程(2)</title>
<meta charset=utf-8><meta content="Web开发 ,Java ,Go ,Node.js ,PHP ,Koa ,MySQL ,Redis ,前端 ,后端 ,数据库" name=keywords><meta name=description content="本文是TS简明教程的第二篇，讲解面向对象相关的知识。
类 传统JS使用函数和原型链进行集成，在ES6出现了class关键，JS也能使用传统OOP的方式进行继承，但是还是存在一定的局限性，在TS中，OOP已经和传统语言差不多。
class Parent { name: string; age: number; constructor(name: string, age: number) { this."><meta name=author content="Lei Xia"><link rel=canonical href=https://www.ddhigh.com/2019/07/29/typescript-quick-guide2/><link rel=alternate type=application/rss+xml href=https://www.ddhigh.com//index.xml title=每天进步一点点><script async defer data-website-id=52f8f0f9-d93d-466b-8ef5-508aae8c4ed4 src=https://analysis.ddhigh.com/script.js></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-EC3XLVSGKV"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-EC3XLVSGKV")</script><meta property="og:title" content="TS简明教程(2)"><meta property="og:description" content="本文是TS简明教程的第二篇，讲解面向对象相关的知识。
类 传统JS使用函数和原型链进行集成，在ES6出现了class关键，JS也能使用传统OOP的方式进行继承，但是还是存在一定的局限性，在TS中，OOP已经和传统语言差不多。
class Parent { name: string; age: number; constructor(name: string, age: number) { this."><meta property="og:type" content="article"><meta property="og:url" content="https://www.ddhigh.com/2019/07/29/typescript-quick-guide2/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-07-29T10:11:30+00:00"><meta property="article:modified_time" content="2019-07-29T10:11:30+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="TS简明教程(2)"><meta name=twitter:description content="本文是TS简明教程的第二篇，讲解面向对象相关的知识。
类 传统JS使用函数和原型链进行集成，在ES6出现了class关键，JS也能使用传统OOP的方式进行继承，但是还是存在一定的局限性，在TS中，OOP已经和传统语言差不多。
class Parent { name: string; age: number; constructor(name: string, age: number) { this."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.ddhigh.com/posts/"},{"@type":"ListItem","position":2,"name":"TS简明教程(2)","item":"https://www.ddhigh.com/2019/07/29/typescript-quick-guide2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"TS简明教程(2)","name":"TS简明教程(2)","description":"本文是TS简明教程的第二篇，讲解面向对象相关的知识。\n类 传统JS使用函数和原型链进行集成，在ES6出现了class关键，JS也能使用传统OOP的方式进行继承，但是还是存在一定的局限性，在TS中，OOP已经和传统语言差不多。\nclass Parent { name: string; age: number; constructor(name: string, age: number) { this.","keywords":[],"articleBody":"本文是TS简明教程的第二篇，讲解面向对象相关的知识。\n类 传统JS使用函数和原型链进行集成，在ES6出现了class关键，JS也能使用传统OOP的方式进行继承，但是还是存在一定的局限性，在TS中，OOP已经和传统语言差不多。\nclass Parent { name: string; age: number; constructor(name: string, age: number) { this.name = name; this.age = age; } say() { return `name: ${this.name}, age: ${this.age}`; } } const parent = new Parent(); parent.say(); 可以看到TS的OOP写法和Java还是有点类似的。但是他两的构造方法名不同，TS构造方法名为constructor，Java是类名。\n继承 继承用来扩展现有的类，TS中这一点和传统语言一样使用extends语法。\nclass Parent { name: string; constructor(name: string) { this.name = name; } say() { console.log(`Parent say: ${this.name}`); } } class Child extends Parent { age: number; constructor(name: string, age: number) { // 覆盖父类构造方法 super(name); // 调用父类构造方法 this.age = age; } say() { console.log(`Child say: ${this.name} ${this.age}`); } } const child: Parent = new Child(\"haha\" ,1); child.say(); // 输出 Child say haha 1 子类存在构造方法时，必须显示调用父类构造方法先有父亲，后有儿子 TS方法调用是基于值而不是基于类型声明，比如child声明为Parent类型，但是值是子类型，所以调用方法时会调用子类的say 访问限定符 public TS中方法和属性默认的访问限定符为public，所有外部或内部成员都可访问。\nclass Parent { public name: string; // public可以不加 say() { console.log(`say ${this.name}`); } } const p = new Parent(); p.name = 'hello'; p.say(); // 输出 say hello private 私有访问，只能在本类访问,子类和其他类都不行。\nclass Parent { private name: string; private say() { console.log(`say ${this.name}`); } } const p = new Parent(); p.name = 'hello'; // 错误，private限定的属性不能被外部访问 p.say(); // 错误，private限定的访问不能被外部访问 protected 保护性访问，只能被本类或本类的子类(子类的子类也可以访问)。\nclass Parent { protected name: string; constructor(name: string) { this.name = name; } protected say() { console.log(`say ${this.name}`); } } class Child extends Parent { public say() { // 提升访问性 console.log(`say ${this.name}`); // 访问父类属性 } } const c = new Child('hello'); c.say(); // 输出 say hello 访问限定符只能提升，不能降低，如下例子是无法通过编译的：\nclass Parent { protected name: string; } class Child extends Parent { private name: string; // 错误，子类访问性必须\u003e=父类的访问性 } 只读限定 TS使用readonly声明只读属性(方法不能使用)，必须在声明时或者构造时进行赋值,其他地方不能赋值\nclass Parent { private readonly name = 'hello'; private readonly age: number; constructor(age: number) { this.age = age; } } 参数属性 在上例中我们在构造方法中使用this.age = age对已存在的私有只读属性age进行了赋值。由于该操作时常用操作，所以TS有了更加便捷的写法：\nclass Parent { constructor(readonly name: string, private readonly age: number) { } say() { console.log(`say ${this.name} ${this.age}`); } } 上例中声明了公有只读的name属性，私有只读的age属性\ngetter \u0026\u0026 setter 在传统语言中，几乎不会直接声明公有属性，然后对其进行操作，都会先定义私有属性，然后提供getter和setter方法对其操作(Java中很多类都是这种情况)\nclass Parent { private _name: string; get name(): string { return this._name; } set name(name: string) { console.log(`name设置前: ${this._name} 设置后: ${name}`); this._name = name; } } const parent = new Parent(); parent.name = 'ok'; // 可以直接使用赋值语句，但是会自动调用set name(name: string)方法 getter和setter方法提高了开发者对属性的控制，一起对属性的访问都是可控的，为以后的扩展性打下了基础（比如如果需要加缓存，我们可以在set时设置缓存,get时读取缓存，如果是直接操作属性的话，该功能实现起来很麻烦\n静态属性 \u0026\u0026 静态方法 以上讨论的都是实例属性和梳理方法，需要有实例才能调用，如果有些属性或方法并不是存在于实例上时可以使用静态方法或静态属性\nclass Parent { static name: string; static say() { console.log(`name ${this.name}`); // 方法是静态，属性是静态时可以使用this } } Parent.say();// 使用类名调用静态方法 需要注意的是实例可以直接调用静态，静态不能直接调用实例，因为实例需要实例化后调用\n抽象类 传统语言中接口只包含实现，不包含细节。而抽象类可以包含细节。一般来说，有些公有方法可以放到抽象类做，不同的子类完成不同功能的代码可以放到抽象类做。\nabstract class Animal { abstract say(): void; // 声明抽象方法，子类必须实现 eat() { console.log(`animal eat`); } } class Human extends Animal { // 使用extends关键字 say() { console.log('human say words'); } } class Dog extends Animal { say() { console.log('dog say wangwang'); } } 接口 接口用来限定子类的行为，不关心具体实现。与传统语言不同的是,TS接口还可以限定变量或常量的属性\n限定子类行文：\ninterface Animal { say(): void; eat(): void; } class Human implements Animal { say() { console.log('human say'); } eat() { console.log('human eat'); } } 限定变量属性：\ninterface A { name?: string; age: number; } const obj: A = { age: 10, // name是可选的 }; 可索引类型 使用可索引类型来描述可以通过索引访问得到的类型。如person[\"name\"],list[0]\ninterface HashMap { [key: string]: any; // 冒号左边为属性名类型，右边为值类型 } const map: HashMap = {}; map[\"name\"] = \"1\"; map.a = \"2\"; 接口继承 与类继承类似，接口也可以通过继承来扩展现有的功能：\ninterface Animal { eat(): void; // 动物会吃，但是怎么吃的不管 } interface Human extends Animal { say(): void; // 人会说话，但是怎么说，说什么不管 } 混合类型 JS中，函数可以直接调用也可以通过对象方式调用，TS中可以通过接口声明被修饰的函数支持的调用方式：\ninterface Counter { (start: number): string; step: number; reset(): void; } function getCounter(): Counter { const counter = \u003cCounter\u003e function(start: number) {}; counter.step = 1; counter.reset = function() {}; } const c = getCounter(); c(1); c.reset(); c.step = 2; 结语 面向对象中的类和接口内容实在是太多了，本文只选择了开发中常用到的用法进行说明，不足之处，敬请包涵。\n","wordCount":"514","inLanguage":"zh","datePublished":"2019-07-29T10:11:30Z","dateModified":"2019-07-29T10:11:30Z","author":{"@type":"Person","name":"Lei Xia"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.ddhigh.com/2019/07/29/typescript-quick-guide2/"},"publisher":{"@type":"Organization","name":"每天进步一点点","logo":{"@type":"ImageObject","url":"https://www.ddhigh.com/favicon.ico"}}}</script><link rel=icon href=/img/favicon.ico sizes=16x16><link rel=apple-touch-icon href=/img/favicon.ico><link rel=manifest href=/img/favicon.ico><link rel=stylesheet href=https://cdn.staticfile.org/lxgw-wenkai-webfont/1.6.0/style.css><link rel=stylesheet href=/css/main.min.d0df733b91ef046970ecd63de7aa626886fd263fd3fb2b8ff28b560e505831f7.css integrity="sha256-0N9zO5HvBGlw7NY956piaIb9Jj/T+yuP8otWDlBYMfc=" crossorigin=anonymous media=screen><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css integrity="sha512-ygEyjMC6rqnzJqWGjRTJUPYMEs9JUOm3i7OWUS9CgQ4XkBUvMsgCS1I8JqavidQ2ClHcREB7IbA2mN08+r9Elg==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=/scss/highlight/github-dark.min.min.66034289ee9a113219a2c4aae0a8bd2095ab255c832a42efcf5863f10814e7a1.css><script src=/js/highlight.min.min.c607d6febd16934a82eb61d3a896ed9d869f54373cc63ce95864ed5488fe3128.js></script><script>hljs.highlightAll()</script><script>$darkModeInit.Content|safeJS</script></head><body><main class=wrapper><nav class=navigation><section class=container><a class=navigation-brand href=/>每天进步一点点
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><span></span><span></span><span></span></label><ul class=navigation-list id=navigation-list><li class="navigation-item navigation-menu"><a class=navigation-link href=/>首页</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/archives>归档</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/books>出版物</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/guestbook>留言板</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class="navigation-item navigation-social"><a class=navigation-link href=https://github.com/xialeistudio><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li class="navigation-item navigation-dark"><button id=mode type=button aria-label="toggle user light or dark theme">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span>
<span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></li><li class="navigation-item navigation-language"><a href=https://www.ddhigh.com/en/>EN</a></li></ul></section></nav><div id=content><article class=blog-single><header class=blog-title><h1>TS简明教程(2)</h1></header><p><small>2019年7月29日&nbsp;· 514 字&nbsp;· 3 分钟</small><p><div class=blog-toc><nav id=TableOfContents><ul><li><a href=#类>类</a></li><li><a href=#继承>继承</a></li><li><a href=#访问限定符>访问限定符</a><ul><li><a href=#public>public</a></li><li><a href=#private>private</a></li><li><a href=#protected>protected</a></li></ul></li><li><a href=#只读限定>只读限定</a></li><li><a href=#参数属性>参数属性</a></li><li><a href=#getter--setter>getter && setter</a></li><li><a href=#静态属性--静态方法>静态属性 && 静态方法</a></li><li><a href=#抽象类>抽象类</a></li><li><a href=#接口>接口</a><ul><li><a href=#可索引类型>可索引类型</a></li><li><a href=#接口继承>接口继承</a></li><li><a href=#混合类型>混合类型</a></li></ul></li><li><a href=#结语>结语</a></li></ul></nav></div><section class=blog-content><p>本文是TS简明教程的第二篇，讲解面向对象相关的知识。</p><h2 id=类>类</h2><p>传统JS使用<code>函数</code>和<code>原型链</code>进行集成，在<code>ES6</code>出现了<code>class</code>关键，JS也能使用传统OOP的方式进行继承，但是还是存在一定的局限性，在TS中，OOP已经和传统语言差不多。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Parent</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>name</span>: <span style=color:#66d9ef>string</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>age</span>: <span style=color:#66d9ef>number</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>constructor</span>(<span style=color:#a6e22e>name</span>: <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>age</span>: <span style=color:#66d9ef>number</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>name</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>age</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>age</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>say() {</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>`name: </span><span style=color:#e6db74>${</span><span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span><span style=color:#e6db74>}</span><span style=color:#e6db74>, age: </span><span style=color:#e6db74>${</span><span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>age</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>parent</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Parent</span>();
</span></span><span style=display:flex><span><span style=color:#a6e22e>parent</span>.<span style=color:#a6e22e>say</span>();
</span></span></code></pre></div><p>可以看到TS的OOP写法和Java还是有点类似的。但是他两的构造方法名不同，TS构造方法名为<code>constructor</code>，Java是<code>类名</code>。</p><h2 id=继承>继承</h2><p>继承用来扩展现有的类，TS中这一点和传统语言一样使用<code>extends</code>语法。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Parent</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>name</span>: <span style=color:#66d9ef>string</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>constructor</span>(<span style=color:#a6e22e>name</span>: <span style=color:#66d9ef>string</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>name</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>say() {</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>`Parent say: </span><span style=color:#e6db74>${</span><span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Child</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>Parent</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>age</span>: <span style=color:#66d9ef>number</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>constructor</span>(<span style=color:#a6e22e>name</span>: <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>age</span>: <span style=color:#66d9ef>number</span>) { <span style=color:#75715e>// 覆盖父类构造方法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>super</span>(<span style=color:#a6e22e>name</span>); <span style=color:#75715e>// 调用父类构造方法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>age</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>age</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>say() {</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>`Child say: </span><span style=color:#e6db74>${</span><span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span><span style=color:#e6db74>}</span><span style=color:#e6db74> </span><span style=color:#e6db74>${</span><span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>age</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>child</span>: <span style=color:#66d9ef>Parent</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Child</span>(<span style=color:#e6db74>&#34;haha&#34;</span> ,<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>child</span>.<span style=color:#a6e22e>say</span>(); <span style=color:#75715e>// 输出 Child say haha 1
</span></span></span></code></pre></div><ol><li>子类存在构造方法时，必须<code>显示调用</code>父类构造方法<code>先有父亲，后有儿子</code></li><li>TS方法调用是基于<code>值</code>而不是基于<code>类型声明</code>，比如<code>child</code>声明为<code>Parent</code>类型，但是值是子类型，所以调用方法时会调用<code>子类</code>的<code>say</code></li></ol><h2 id=访问限定符>访问限定符</h2><h3 id=public>public</h3><p>TS中方法和属性默认的访问限定符为<code>public</code>，所有外部或内部成员都可访问。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Parent</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>name</span>: <span style=color:#66d9ef>string</span>; <span style=color:#75715e>// public可以不加
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>say() {</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>`say </span><span style=color:#e6db74>${</span><span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>p</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Parent</span>();
</span></span><span style=display:flex><span><span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;hello&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>say</span>(); <span style=color:#75715e>// 输出 say hello
</span></span></span></code></pre></div><h3 id=private>private</h3><p>私有访问，只能在<code>本类</code>访问,<code>子类和其他类都不行</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Parent</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>name</span>: <span style=color:#66d9ef>string</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>say() {</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>`say </span><span style=color:#e6db74>${</span><span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>p</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Parent</span>();
</span></span><span style=display:flex><span><span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;hello&#39;</span>; <span style=color:#75715e>// 错误，private限定的属性不能被外部访问
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>say</span>(); <span style=color:#75715e>// 错误，private限定的访问不能被外部访问
</span></span></span></code></pre></div><h3 id=protected>protected</h3><p>保护性访问，只能<code>被本类或本类的子类(子类的子类也可以访问)</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Parent</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#a6e22e>name</span>: <span style=color:#66d9ef>string</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>constructor</span>(<span style=color:#a6e22e>name</span>: <span style=color:#66d9ef>string</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>name</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#a6e22e>say() {</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>`say </span><span style=color:#e6db74>${</span><span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Child</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>Parent</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>say() {</span> <span style=color:#75715e>// 提升访问性
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>`say </span><span style=color:#e6db74>${</span><span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>); <span style=color:#75715e>// 访问父类属性
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>c</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Child</span>(<span style=color:#e6db74>&#39;hello&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>say</span>(); <span style=color:#75715e>// 输出 say hello
</span></span></span></code></pre></div><p>访问限定符只能提升，不能降低，如下例子是<code>无法通过编译的</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Parent</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#a6e22e>name</span>: <span style=color:#66d9ef>string</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Child</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>Parent</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>name</span>: <span style=color:#66d9ef>string</span>; <span style=color:#75715e>// 错误，子类访问性必须&gt;=父类的访问性
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h2 id=只读限定>只读限定</h2><p>TS使用<code>readonly</code>声明只读<code>属性(方法不能使用)</code>，必须在<code>声明时</code>或者<code>构造时</code>进行赋值,<code>其他地方不能赋值</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Parent</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> <span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;hello&#39;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> <span style=color:#a6e22e>age</span>: <span style=color:#66d9ef>number</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>constructor</span>(<span style=color:#a6e22e>age</span>: <span style=color:#66d9ef>number</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>age</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>age</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=参数属性>参数属性</h2><p>在上例中我们在构造方法中使用<code>this.age = age</code>对已存在的<code>私有只读属性age</code>进行了赋值。由于该操作时常用操作，所以TS有了更加便捷的写法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Parent</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>constructor</span>(<span style=color:#66d9ef>readonly</span> <span style=color:#a6e22e>name</span>: <span style=color:#66d9ef>string</span>, <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> <span style=color:#a6e22e>age</span>: <span style=color:#66d9ef>number</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>say() {</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>`say </span><span style=color:#e6db74>${</span><span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span><span style=color:#e6db74>}</span><span style=color:#e6db74> </span><span style=color:#e6db74>${</span><span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>age</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上例中声明了<code>公有只读的name属性，私有只读的age属性</code></p><h2 id=getter--setter>getter && setter</h2><p>在传统语言中，几乎不会直接声明公有属性，然后对其进行操作，都会先定义私有属性，然后提供<code>getter</code>和<code>setter</code>方法对其操作(<code>Java中很多类都是这种情况</code>)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Parent</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>_name</span>: <span style=color:#66d9ef>string</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>get</span> <span style=color:#a6e22e>name</span>()<span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>_name</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>set</span> <span style=color:#a6e22e>name</span>(<span style=color:#a6e22e>name</span>: <span style=color:#66d9ef>string</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>`name设置前: </span><span style=color:#e6db74>${</span><span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>_name</span><span style=color:#e6db74>}</span><span style=color:#e6db74> 设置后: </span><span style=color:#e6db74>${</span><span style=color:#a6e22e>name</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>_name</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>name</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>parent</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Parent</span>();
</span></span><span style=display:flex><span><span style=color:#a6e22e>parent</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;ok&#39;</span>; <span style=color:#75715e>// 可以直接使用赋值语句，但是会自动调用set name(name: string)方法
</span></span></span></code></pre></div><p>getter和setter方法提高了开发者对属性的控制，一起对属性的访问都是可控的，为以后的扩展性打下了基础（比如如果需要加缓存，我们可以在set时设置缓存,get时读取缓存，如果是直接操作属性的话，该功能实现起来很麻烦</p><h2 id=静态属性--静态方法>静态属性 && 静态方法</h2><p>以上讨论的都是<code>实例属性和梳理方法</code>，需要有实例才能调用，如果有些属性或方法并不是存在于实例上时可以使用静态方法或静态属性</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Parent</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#a6e22e>name</span>: <span style=color:#66d9ef>string</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#a6e22e>say() {</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>`name </span><span style=color:#e6db74>${</span><span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>); <span style=color:#75715e>// 方法是静态，属性是静态时可以使用this
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>Parent</span>.<span style=color:#a6e22e>say</span>();<span style=color:#75715e>// 使用类名调用静态方法
</span></span></span></code></pre></div><p>需要注意的是<code>实例可以直接调用静态，静态不能直接调用实例</code>，因为<code>实例需要实例化后调用</code></p><h2 id=抽象类>抽象类</h2><p>传统语言中接口只包含实现，不包含细节。而抽象类可以包含细节。一般来说，有些公有方法可以放到抽象类做，不同的子类完成不同功能的代码可以放到抽象类做。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Animal</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>abstract</span> <span style=color:#a6e22e>say</span>()<span style=color:#f92672>:</span> <span style=color:#66d9ef>void</span>; <span style=color:#75715e>// 声明抽象方法，子类必须实现
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>eat() {</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>`animal eat`</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Human</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>Animal</span> { <span style=color:#75715e>// 使用extends关键字
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>say() {</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;human say words&#39;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Dog</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>Animal</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>say() {</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;dog say wangwang&#39;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=接口>接口</h2><p>接口用来限定子类的行为，不关心具体实现。与传统语言不同的是,TS接口还可以限定变量或常量的属性</p><p>限定子类行文：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Animal</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>say</span>()<span style=color:#f92672>:</span> <span style=color:#66d9ef>void</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>eat</span>()<span style=color:#f92672>:</span> <span style=color:#66d9ef>void</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Human</span> <span style=color:#66d9ef>implements</span> <span style=color:#a6e22e>Animal</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>say() {</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;human say&#39;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>eat() {</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;human eat&#39;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>限定变量属性：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>A</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>name?</span>: <span style=color:#66d9ef>string</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>age</span>: <span style=color:#66d9ef>number</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>obj</span>: <span style=color:#66d9ef>A</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>age</span>: <span style=color:#66d9ef>10</span>,
</span></span><span style=display:flex><span>    <span style=color:#75715e>// name是可选的
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span></code></pre></div><h3 id=可索引类型>可索引类型</h3><p>使用<code>可索引类型</code>来<code>描述</code>可以通过<code>索引访问得到</code>的类型。如<code>person["name"]</code>,<code>list[0]</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>HashMap</span> {
</span></span><span style=display:flex><span>    [<span style=color:#a6e22e>key</span>: <span style=color:#66d9ef>string</span>]<span style=color:#f92672>:</span> <span style=color:#66d9ef>any</span>; <span style=color:#75715e>// 冒号左边为属性名类型，右边为值类型
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>map</span>: <span style=color:#66d9ef>HashMap</span> <span style=color:#f92672>=</span> {};
</span></span><span style=display:flex><span><span style=color:#a6e22e>map</span>[<span style=color:#e6db74>&#34;name&#34;</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;1&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>map</span>.<span style=color:#a6e22e>a</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;2&#34;</span>;
</span></span></code></pre></div><h3 id=接口继承>接口继承</h3><p>与类继承类似，接口也可以通过继承来扩展现有的功能：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Animal</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>eat</span>()<span style=color:#f92672>:</span> <span style=color:#66d9ef>void</span>; <span style=color:#75715e>// 动物会吃，但是怎么吃的不管
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Human</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>Animal</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>say</span>()<span style=color:#f92672>:</span> <span style=color:#66d9ef>void</span>; <span style=color:#75715e>// 人会说话，但是怎么说，说什么不管
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h3 id=混合类型>混合类型</h3><p>JS中，函数可以直接调用也可以通过对象方式调用，TS中可以通过接口声明被修饰的函数支持的调用方式：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Counter</span> {
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>start</span>: <span style=color:#66d9ef>number</span>)<span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>step</span>: <span style=color:#66d9ef>number</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>reset</span>()<span style=color:#f92672>:</span> <span style=color:#66d9ef>void</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>getCounter</span>()<span style=color:#f92672>:</span> <span style=color:#a6e22e>Counter</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>counter</span> <span style=color:#f92672>=</span> &lt;<span style=color:#f92672>Counter</span>&gt; <span style=color:#66d9ef>function</span>(<span style=color:#a6e22e>start</span>: <span style=color:#66d9ef>number</span>) {};
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>counter</span>.<span style=color:#a6e22e>step</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>counter</span>.<span style=color:#a6e22e>reset</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>() {};
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>c</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>getCounter</span>();
</span></span><span style=display:flex><span><span style=color:#a6e22e>c</span>(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>reset</span>();
</span></span><span style=display:flex><span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>step</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
</span></span></code></pre></div><h2 id=结语>结语</h2><p>面向对象中的类和接口内容实在是太多了，本文只选择了开发中常用到的用法进行说明，不足之处，敬请包涵。</p><div class=blog-footer><div class=social-share></div><div class=copyright><ul><li style=margin-bottom:.5em>本文作者: <a href=https://ddhigh.com/ target=_blank style=color:#000;text-decoration:none>xialeistudio</a></li><li style=margin-bottom:.5em>本文链接: <a href=https://www.ddhigh.com/2019/07/29/typescript-quick-guide2/ target=_blank style=color:#000;text-decoration:none>TS简明教程(2)</a></li><li>版权声明: <a href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank style=color:#000;text-decoration:none>「署名-非商业性使用-相同方式共享 4.0 国际」</a></li></ul></div><div style=margin-top:2rem><img src=/img/mp.png alt=qrcode></div></div></section><div class=paginator><a class=prev href=https://www.ddhigh.com/2019/07/30/typescript-quick-guide3/><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M9.94496 9C9.28897 9.61644 7.63215 10.997 6.04814 11.7966 5.98257 11.8297 5.98456 11.9753 6.05061 12.0063c1.00435.4716 2.8788 1.9201 3.89435 2.9937M6.44444 11.9667C8.86549 12.0608 14 12 16 11" stroke="currentcolor" stroke-linecap="round"/></svg>
<span>TS简明教程(3)</span></a>
<a class=next href=https://www.ddhigh.com/2019/07/27/miniprogram-unit-test/><span>手把手从零开始小程序单元测试(附避坑指南以及源码跟踪)</span><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M12.055 9C12.711 9.61644 14.3679 10.997 15.9519 11.7966 16.0174 11.8297 16.0154 11.9753 15.9494 12.0063 14.945 12.4779 13.0706 13.9264 12.055 15m3.5006-3.0333C13.1345 12.0608 8 12 6 11" stroke="currentcolor" stroke-linecap="round"/></svg></a></div><div class=comments><script>const getTheme=window.localStorage&&window.localStorage.getItem("theme");let theme=getTheme==="dark"?"dark":"light",s=document.createElement("script");s.src="https://giscus.app/client.js",s.setAttribute("data-repo","xialeistudio/discussion"),s.setAttribute("data-repo-id","R_kgDOKurTRA"),s.setAttribute("data-category","General"),s.setAttribute("data-category-id","DIC_kwDOKurTRM4CbCJt"),s.setAttribute("data-mapping","pathname"),s.setAttribute("data-strict","0"),s.setAttribute("data-reactions-enabled","1"),s.setAttribute("data-emit-metadata","0"),s.setAttribute("data-input-position","bottom"),s.setAttribute("data-theme",theme),s.setAttribute("data-lang","en"),s.setAttribute("data-loading","lazy"),s.setAttribute("crossorigin","anonymous"),s.setAttribute("async",""),document.querySelector("div.comments").innerHTML="",document.querySelector("div.comments").appendChild(s)</script></div></article></div><footer class=footer><p>&copy; 2014 - 2024 <a href=https://www.ddhigh.com/>每天进步一点点</a>
Powered by
<a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>
<a href=https://github.com/guangzhengli/hugo-theme-ladder rel=noopener target=_blank>Ladder</a>
️</p></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.5376 22.7916C11.0152 22.7207 22.5795 21.1781 22.0978 10.4211 22.0536 9.43274 21.9303 8.53367 21.7387 7.71865M10.5376 22.7916C16.876 22.3728 20.0969 19.8899 21.5383 16.9142M10.5376 22.7916C9.7707 22.9055 8.97982 22.8964 8.19743 22.7725M21.7387 7.71865C21.4988 6.69828 21.1518 5.80967 20.7188 5.04257m1.0199 2.67608C22.6022 10.1105 23.0542 13.7848 21.5383 16.9142M20.7188 5.04257c-3.5504-6.28886-12.88753-4.410077-16.44303.0C2.88063 6.77451-.0433281 11.1668 1.38159 16.6571c.89322 3.4417 3.7911 5.6365 6.81584 6.1154M20.7188 5.04257c1.3509 1.89783 3.3111 6.34223 1.6353 10.37273M21.5383 16.9142C21.8737 16.4251 22.1428 15.9235 22.3541 15.4153M8.19743 22.7725C12.1971 23.4683 20.6281 22.971 22.3541 15.4153M14 10.945C13.3836 10.289 12.003 8.63215 11.2034 7.04814 11.1703 6.98257 11.0247 6.98456 10.9937 7.05061 10.5221 8.05496 9.07362 9.92941 8 10.945m3.0333-3.50056C10.9392 9.86549 11 15 12 17" stroke="currentcolor" stroke-linecap="round"/></svg>
</a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function n(){t.innerHTML="Copied",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)}),e.parentNode.appendChild(t)})</script><script src=https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js integrity="sha512-9DNXrSjk17bU9MUbRp3IjwcWe46V8FaGA062PFbryPUAEQVRbz4jiZP6FW0AdbqEGtMYBDWnul3eiGBMJOQajA==" crossorigin=anonymous referrerpolicy=no-referrer></script></main></body><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script><script>const images=Array.from(document.querySelectorAll(".blog-content img"));images.forEach(e=>{mediumZoom(e,{margin:10,scrollOffset:40,container:null,template:null,background:"rgba(0, 0, 0, 0.5)"})})</script><script src=/main.min.6bb26b69159420159c74dc9e097b06a578ed2b68c701466a91a44a9632d851bd0af167a1b30012387b4c512b48ad9ad4d3394e04d77ae38d57e1920fe4ed34fe.js integrity="sha512-a7JraRWUIBWcdNyeCXsGpXjtK2jHAUZqkaRKljLYUb0K8WehswASOHtMUStIrZrU0zlOBNd6441X4ZIP5O00/g==" crossorigin=anonymous defer></script></html>