<!doctype html><html lang=en><head><meta name=viewport content="width=device-width,initial-scale=1"><title>LeetCode109——有序链表转换二叉搜索树</title>
<meta charset=utf-8><meta name=description content="Ladder@题目 给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。
本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。
示例:
给定的有序链表： [-10, -3, 0, 5, 9], 一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树： 0 / \ -3 9 / / -10 5 思路 转换为数组 转换为数组后解法跟前面一道题一样。
// 链表转换为数组，复用108解法 func sortedListToBST(head *ListNode) *TreeNode { if head == nil { return nil } list := listToArray(head) return helper(list, 0, len(list)-1) } func listToArray(head *ListNode) []int { result := []int{} for head != nil { result = append(result, head."><meta name=author content="Lei Xia"><link rel=canonical href=https://www.ddhigh.com/2022/02/08/convert-sorted-list-to-binary-search-tree/><link rel=alternate type=application/rss+xml href=https://www.ddhigh.com//index.xml title="Lei Xia"><script async defer data-website-id=865c8529-0729-4cf5-88a9-448616abbcbb src=https://umami-beta-peach.vercel.app/xialeistudio></script><meta property="og:title" content="LeetCode109——有序链表转换二叉搜索树"><meta property="og:description" content="题目 给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。
本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。
示例:
给定的有序链表： [-10, -3, 0, 5, 9], 一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树： 0 / \ -3 9 / / -10 5 思路 转换为数组 转换为数组后解法跟前面一道题一样。
// 链表转换为数组，复用108解法 func sortedListToBST(head *ListNode) *TreeNode { if head == nil { return nil } list := listToArray(head) return helper(list, 0, len(list)-1) } func listToArray(head *ListNode) []int { result := []int{} for head != nil { result = append(result, head."><meta property="og:type" content="article"><meta property="og:url" content="https://www.ddhigh.com/2022/02/08/convert-sorted-list-to-binary-search-tree/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-02-08T20:24:19+00:00"><meta property="article:modified_time" content="2022-02-08T20:24:19+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="LeetCode109——有序链表转换二叉搜索树"><meta name=twitter:description content="题目 给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。
本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。
示例:
给定的有序链表： [-10, -3, 0, 5, 9], 一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树： 0 / \ -3 9 / / -10 5 思路 转换为数组 转换为数组后解法跟前面一道题一样。
// 链表转换为数组，复用108解法 func sortedListToBST(head *ListNode) *TreeNode { if head == nil { return nil } list := listToArray(head) return helper(list, 0, len(list)-1) } func listToArray(head *ListNode) []int { result := []int{} for head != nil { result = append(result, head."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.ddhigh.com/posts/"},{"@type":"ListItem","position":2,"name":"LeetCode109——有序链表转换二叉搜索树","item":"https://www.ddhigh.com/2022/02/08/convert-sorted-list-to-binary-search-tree/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"LeetCode109——有序链表转换二叉搜索树","name":"LeetCode109——有序链表转换二叉搜索树","description":"题目 给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。\n本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。\n示例:\n给定的有序链表： [-10, -3, 0, 5, 9], 一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树： 0 / \\ -3 9 / / -10 5 思路 转换为数组 转换为数组后解法跟前面一道题一样。\n// 链表转换为数组，复用108解法 func sortedListToBST(head *ListNode) *TreeNode { if head == nil { return nil } list := listToArray(head) return helper(list, 0, len(list)-1) } func listToArray(head *ListNode) []int { result := []int{} for head != nil { result = append(result, head.","keywords":["tree","leetcode"],"articleBody":"题目 给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。\n本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。\n示例:\n给定的有序链表： [-10, -3, 0, 5, 9], 一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树： 0 / \\ -3 9 / / -10 5 思路 转换为数组 转换为数组后解法跟前面一道题一样。\n// 链表转换为数组，复用108解法 func sortedListToBST(head *ListNode) *TreeNode { if head == nil { return nil } list := listToArray(head) return helper(list, 0, len(list)-1) } func listToArray(head *ListNode) []int { result := []int{} for head != nil { result = append(result, head.Val) head = head.Next } return result } func helper(nums []int, start, end int) *TreeNode { if start \u003e end { return nil } // 取得根 rootIndex := (start + end) / 2 rootValue := nums[rootIndex] root := \u0026TreeNode{Val: rootValue} root.Left = helper(nums, start, rootIndex-1) root.Right = helper(nums, rootIndex+1, end) return root } 链表操作 我们遍历到中间节点后，将链表拆分为[左部分，中间点，右部分]即可复用逻辑，而且无额外空间占用\n单链表是无法直到中间点在哪里的，因此我们需要先遍历一次，获取链表长度，除以2就是中间的index。\n// 1. 遍历一遍链表得到链表长度，算出中间节点index // 2. 再次遍历链表，拆分为三段 // 1. 起点到中间节点的上一个节点：左子链表 // 2. 中间节点 // 3. 中间节点的下一个节点到链表末尾：右子链表 // 3. 将中间节点作为树根，利用左右子链表，递归构建左右子树，然后挂到根节点 func sortedListToBST(head *ListNode) *TreeNode { if head == nil { return nil } return helper(head) } func helper(head *ListNode) *TreeNode { if head == nil { return nil } if head.Next == nil { return \u0026TreeNode{Val: head.Val} } // 获取链表总长度 length := 0 p := head for p != nil { length++ p = p.Next } middle := length / 2 // 取得中间点位置 // 再次遍历到中间点 var ( prev = head // 指向中间点的上一个节点 curr = head.Next // 指向中间点 ) var ( left *ListNode // 左子链表头结点 right *ListNode // 右子链表头结点 ) index := 0 for curr != nil { // index是prev的下标，因此定位到middle的前一个 if index == middle-1 { // 找到中点，将中点和右子链表连接打断 right = curr.Next curr.Next = nil // 将左子链表和中点连接打断 prev.Next = nil left = head break } prev = curr curr = curr.Next index++ } // 此时我们拥有left,curr,right 三个链表，开始递归组合 root := \u0026TreeNode{Val: curr.Val} root.Left = helper(left) // 给你一条链表，给我构建一个树出来 root.Right = helper(right) return root } ","wordCount":"292","inLanguage":"en","datePublished":"2022-02-08T20:24:19Z","dateModified":"2022-02-08T20:24:19Z","author":{"@type":"Person","name":"Lei Xia"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.ddhigh.com/2022/02/08/convert-sorted-list-to-binary-search-tree/"},"publisher":{"@type":"Organization","name":"Lei Xia","logo":{"@type":"ImageObject","url":"https://www.ddhigh.com/favicon.ico"}}}</script><link rel=icon href=/img/favicon.ico sizes=16x16><link rel=apple-touch-icon href=/img/favicon.ico><link rel=manifest href=/img/favicon.ico><link rel=stylesheet href=https://cdn.staticfile.org/lxgw-wenkai-webfont/1.6.0/style.css><link rel=stylesheet href=/css/main.min.ff1bc260fafbfb440e10194d7d06d57eb5e85eed11d12d06255581262664204e.css integrity="sha256-/xvCYPr7+0QOEBlNfQbVfrXoXu0R0S0GJVWBJiZkIE4=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/highlight/github-dark.min.min.66034289ee9a113219a2c4aae0a8bd2095ab255c832a42efcf5863f10814e7a1.css><script src=/js/highlight.min.min.c607d6febd16934a82eb61d3a896ed9d869f54373cc63ce95864ed5488fe3128.js></script><script>hljs.highlightAll()</script><script>(()=>{var t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,e=localStorage.getItem("theme");t&&e===null&&(localStorage.setItem("theme","dark"),document.documentElement.setAttribute("data-dark-mode","")),t&&e==="dark"&&document.documentElement.setAttribute("data-dark-mode",""),e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script></head><body><main class=wrapper><nav class=navigation><section class=container><a class=navigation-brand href=/>HOME
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><span></span><span></span><span></span></label><ul class=navigation-list id=navigation-list><li class="navigation-item navigation-menu"><a class=navigation-link href=/archives>Archive</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/tags>Tags</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/books>Books</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/guestbook>Guestbook</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class="navigation-item navigation-social"><a class=navigation-link href=https://github.com/xialeistudio><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li class="navigation-item navigation-dark"><button id=mode type=button aria-label="toggle user light or dark theme">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span>
<span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></li></ul></section></nav><div id=content><article class=blog-single><header class=blog-title><h1>LeetCode109——有序链表转换二叉搜索树</h1></header><p><small>February 8, 2022&nbsp;· 292 words&nbsp;· 2 min</small><p><div class=blog-toc><nav id=TableOfContents><ul><li><a href=#题目>题目</a></li><li><a href=#思路>思路</a><ul><li><a href=#转换为数组>转换为数组</a></li><li><a href=#链表操作>链表操作</a></li></ul></li></ul></nav></div><section class=blog-content><h2 id=题目>题目</h2><p>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p><p><strong>示例:</strong></p><pre tabindex=0><code>给定的有序链表： [-10, -3, 0, 5, 9],

一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：

      0
     / \
   -3   9
   /   /
 -10  5
</code></pre><h2 id=思路>思路</h2><h3 id=转换为数组>转换为数组</h3><blockquote><p>转换为数组后解法跟前面一道题一样。</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 链表转换为数组，复用108解法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sortedListToBST</span>(<span style=color:#a6e22e>head</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>ListNode</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>head</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>list</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>listToArray</span>(<span style=color:#a6e22e>head</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>helper</span>(<span style=color:#a6e22e>list</span>, <span style=color:#ae81ff>0</span>, len(<span style=color:#a6e22e>list</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>listToArray</span>(<span style=color:#a6e22e>head</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>ListNode</span>) []<span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>result</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>head</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>result</span> = append(<span style=color:#a6e22e>result</span>, <span style=color:#a6e22e>head</span>.<span style=color:#a6e22e>Val</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>head</span> = <span style=color:#a6e22e>head</span>.<span style=color:#a6e22e>Next</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>result</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>helper</span>(<span style=color:#a6e22e>nums</span> []<span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>start</span>, <span style=color:#a6e22e>end</span> <span style=color:#66d9ef>int</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>start</span> &gt; <span style=color:#a6e22e>end</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 取得根
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>rootIndex</span> <span style=color:#f92672>:=</span> (<span style=color:#a6e22e>start</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>end</span>) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>rootValue</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>nums</span>[<span style=color:#a6e22e>rootIndex</span>]
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>root</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>TreeNode</span>{<span style=color:#a6e22e>Val</span>: <span style=color:#a6e22e>rootValue</span>}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span> = <span style=color:#a6e22e>helper</span>(<span style=color:#a6e22e>nums</span>, <span style=color:#a6e22e>start</span>, <span style=color:#a6e22e>rootIndex</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span> = <span style=color:#a6e22e>helper</span>(<span style=color:#a6e22e>nums</span>, <span style=color:#a6e22e>rootIndex</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>end</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>root</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=链表操作>链表操作</h3><blockquote><p>我们遍历到中间节点后，将链表拆分为[左部分，中间点，右部分]即可复用逻辑，而且无额外空间占用</p></blockquote><p>单链表是无法直到中间点在哪里的，因此我们需要先遍历一次，获取链表长度，除以2就是中间的index。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 1. 遍历一遍链表得到链表长度，算出中间节点index
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 2. 再次遍历链表，拆分为三段
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 1. 起点到中间节点的上一个节点：左子链表
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 2. 中间节点
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 3. 中间节点的下一个节点到链表末尾：右子链表
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 3. 将中间节点作为树根，利用左右子链表，递归构建左右子树，然后挂到根节点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sortedListToBST</span>(<span style=color:#a6e22e>head</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>ListNode</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>head</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>helper</span>(<span style=color:#a6e22e>head</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>helper</span>(<span style=color:#a6e22e>head</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>ListNode</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>head</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>head</span>.<span style=color:#a6e22e>Next</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>TreeNode</span>{<span style=color:#a6e22e>Val</span>: <span style=color:#a6e22e>head</span>.<span style=color:#a6e22e>Val</span>}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 获取链表总长度
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>length</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>p</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>head</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>p</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>length</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>p</span> = <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Next</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>middle</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>length</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span> <span style=color:#75715e>// 取得中间点位置
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 再次遍历到中间点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>var</span> (
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>prev</span> = <span style=color:#a6e22e>head</span>      <span style=color:#75715e>// 指向中间点的上一个节点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>curr</span> = <span style=color:#a6e22e>head</span>.<span style=color:#a6e22e>Next</span> <span style=color:#75715e>// 指向中间点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> (
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>left</span>  <span style=color:#f92672>*</span><span style=color:#a6e22e>ListNode</span> <span style=color:#75715e>// 左子链表头结点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>right</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>ListNode</span> <span style=color:#75715e>// 右子链表头结点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>index</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>curr</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// index是prev的下标，因此定位到middle的前一个
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>index</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>middle</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> {
</span></span><span style=display:flex><span>			<span style=color:#75715e>// 找到中点，将中点和右子链表连接打断
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#a6e22e>right</span> = <span style=color:#a6e22e>curr</span>.<span style=color:#a6e22e>Next</span>
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>curr</span>.<span style=color:#a6e22e>Next</span> = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>			<span style=color:#75715e>// 将左子链表和中点连接打断
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#a6e22e>prev</span>.<span style=color:#a6e22e>Next</span> = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>left</span> = <span style=color:#a6e22e>head</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>prev</span> = <span style=color:#a6e22e>curr</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>curr</span> = <span style=color:#a6e22e>curr</span>.<span style=color:#a6e22e>Next</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>index</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 此时我们拥有left,curr,right 三个链表，开始递归组合
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>root</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>TreeNode</span>{<span style=color:#a6e22e>Val</span>: <span style=color:#a6e22e>curr</span>.<span style=color:#a6e22e>Val</span>}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span> = <span style=color:#a6e22e>helper</span>(<span style=color:#a6e22e>left</span>) <span style=color:#75715e>// 给你一条链表，给我构建一个树出来
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span> = <span style=color:#a6e22e>helper</span>(<span style=color:#a6e22e>right</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>root</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></section><div class=paginator><a class=prev href=https://www.ddhigh.com/2022/02/08/convert-sorted-array-to-binary-search-tree/><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M9.94496 9C9.28897 9.61644 7.63215 10.997 6.04814 11.7966 5.98257 11.8297 5.98456 11.9753 6.05061 12.0063c1.00435.4716 2.8788 1.9201 3.89435 2.9937M6.44444 11.9667C8.86549 12.0608 14 12 16 11" stroke="currentcolor" stroke-linecap="round"/></svg>
<span>LeetCode108——将有序数组转换为二叉搜索树</span></a>
<a class=next href=https://www.ddhigh.com/2022/02/06/binary-tree-zigzag-level-order-traversal/><span>LeetCode103——二叉树的锯齿形层序遍历</span><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M12.055 9C12.711 9.61644 14.3679 10.997 15.9519 11.7966 16.0174 11.8297 16.0154 11.9753 15.9494 12.0063 14.945 12.4779 13.0706 13.9264 12.055 15m3.5006-3.0333C13.1345 12.0608 8 12 6 11" stroke="currentcolor" stroke-linecap="round"/></svg></a></div><div class=comments><script>const getTheme=window.localStorage&&window.localStorage.getItem("theme");let theme=getTheme==="dark"?"dark":"light",s=document.createElement("script");s.src="https://giscus.app/client.js",s.setAttribute("data-repo","xialeistudio/discussion"),s.setAttribute("data-repo-id","R_kgDOKurTRA"),s.setAttribute("data-category","General"),s.setAttribute("data-category-id","DIC_kwDOKurTRM4CbCJt"),s.setAttribute("data-mapping","pathname"),s.setAttribute("data-strict","0"),s.setAttribute("data-reactions-enabled","1"),s.setAttribute("data-emit-metadata","0"),s.setAttribute("data-input-position","bottom"),s.setAttribute("data-theme",theme),s.setAttribute("data-lang","en"),s.setAttribute("data-loading","lazy"),s.setAttribute("crossorigin","anonymous"),s.setAttribute("async",""),document.querySelector("div.comments").innerHTML="",document.querySelector("div.comments").appendChild(s)</script></div></article></div><footer class=footer><p>&copy; 2014 - 2024 <a href=https://www.ddhigh.com/>Lei Xia</a>
Powered by
<a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>
<a href=https://github.com/guangzhengli/hugo-theme-ladder rel=noopener target=_blank>Ladder</a>
<a href=https://umami-beta-peach.vercel.app/ target=_blank>Statistics</a>
️</p></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.5376 22.7916C11.0152 22.7207 22.5795 21.1781 22.0978 10.4211 22.0536 9.43274 21.9303 8.53367 21.7387 7.71865M10.5376 22.7916C16.876 22.3728 20.0969 19.8899 21.5383 16.9142M10.5376 22.7916C9.7707 22.9055 8.97982 22.8964 8.19743 22.7725M21.7387 7.71865C21.4988 6.69828 21.1518 5.80967 20.7188 5.04257m1.0199 2.67608C22.6022 10.1105 23.0542 13.7848 21.5383 16.9142M20.7188 5.04257c-3.5504-6.28886-12.88753-4.410077-16.44303.0C2.88063 6.77451-.0433281 11.1668 1.38159 16.6571c.89322 3.4417 3.7911 5.6365 6.81584 6.1154M20.7188 5.04257c1.3509 1.89783 3.3111 6.34223 1.6353 10.37273M21.5383 16.9142C21.8737 16.4251 22.1428 15.9235 22.3541 15.4153M8.19743 22.7725C12.1971 23.4683 20.6281 22.971 22.3541 15.4153M14 10.945C13.3836 10.289 12.003 8.63215 11.2034 7.04814 11.1703 6.98257 11.0247 6.98456 10.9937 7.05061 10.5221 8.05496 9.07362 9.92941 8 10.945m3.0333-3.50056C10.9392 9.86549 11 15 12 17" stroke="currentcolor" stroke-linecap="round"/></svg>
</a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function n(){t.innerHTML="Copied",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)}),e.parentNode.appendChild(t)})</script></main></body><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script><script>const images=Array.from(document.querySelectorAll(".blog-content img"));images.forEach(e=>{mediumZoom(e,{margin:10,scrollOffset:40,container:null,template:null,background:"rgba(0, 0, 0, 0.5)"})})</script><script src=/main.min.6bb26b69159420159c74dc9e097b06a578ed2b68c701466a91a44a9632d851bd0af167a1b30012387b4c512b48ad9ad4d3394e04d77ae38d57e1920fe4ed34fe.js integrity="sha512-a7JraRWUIBWcdNyeCXsGpXjtK2jHAUZqkaRKljLYUb0K8WehswASOHtMUStIrZrU0zlOBNd6441X4ZIP5O00/g==" crossorigin=anonymous defer></script></html>