<!doctype html><html lang=en><head><meta name=viewport content="width=device-width,initial-scale=1"><title>厄拉多塞筛素数筛选算法</title>
<meta charset=utf-8><meta name=description content="Ladder@厄拉多塞筛算法（Eratosthenes Sieve）是一种求素数的方法，由古希腊数学家厄拉多塞提出。它的原理是，给定一个数 n，从 2 开始依次将 $\sqrt n$ 以内的素数的倍数标记为合数，标记完成后，剩余未被标记的数为素数（从 2 开始）。如此可省去检查每个数的步骤，使筛选素数的过程更加简单。
算法 厄拉多塞筛算法具体步骤如下：
读取输入的数 n，将 2 到 n 的所有整数记录在表中 从 2 开始，划去表中所有 2 的倍数 由小到大寻找表中下一个未被划去的整数，再划去表中所有该整数的倍数 重复第（3）步，直到找到的整数大于$\sqrt n$为止 表中所有未被划去的整数均为素数 朴素的素数筛选算法如下：对给定的数字$i$，设定数字$j$从$2$遍历到$\sqrt i$，如果中间$i$能整除$j$，则$i$不是素数。该方法的时间复杂度为$O(n\sqrt n)$ ,$n$是数组长度，外层循环需要遍历$n$次，内层循环需要遍历$\sqrt n$次。
而厄拉多塞筛算法的时间复杂度为$O(n log(log(n)))$。
举例 这是一张来自维基百科的算法示意图。
先从2开始遍历，将2的倍数(2,4,6,8,&mldr;)标记为为非素数 继续遍历，当前数字是素数时，继续将当前数字的倍数标记为非素数 直到所有数字标记完，重新标记数组，未被标记的就是素数 算法题 Leetcode 204. 计数质数
给定整数 n ，返回 所有小于非负整数 n 的质数的数量 。
示例 1：
输入：n = 10 输出：4 解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。 示例 2："><meta name=author content="Lei Xia"><link rel=canonical href=https://www.ddhigh.com/2022/12/31/eratosthenes-sieve/><link rel=alternate type=application/rss+xml href=https://www.ddhigh.com//index.xml title="Lei Xia"><meta property="og:title" content="厄拉多塞筛素数筛选算法"><meta property="og:description" content="厄拉多塞筛算法（Eratosthenes Sieve）是一种求素数的方法，由古希腊数学家厄拉多塞提出。它的原理是，给定一个数 n，从 2 开始依次将 $\sqrt n$ 以内的素数的倍数标记为合数，标记完成后，剩余未被标记的数为素数（从 2 开始）。如此可省去检查每个数的步骤，使筛选素数的过程更加简单。
算法 厄拉多塞筛算法具体步骤如下：
读取输入的数 n，将 2 到 n 的所有整数记录在表中 从 2 开始，划去表中所有 2 的倍数 由小到大寻找表中下一个未被划去的整数，再划去表中所有该整数的倍数 重复第（3）步，直到找到的整数大于$\sqrt n$为止 表中所有未被划去的整数均为素数 朴素的素数筛选算法如下：对给定的数字$i$，设定数字$j$从$2$遍历到$\sqrt i$，如果中间$i$能整除$j$，则$i$不是素数。该方法的时间复杂度为$O(n\sqrt n)$ ,$n$是数组长度，外层循环需要遍历$n$次，内层循环需要遍历$\sqrt n$次。
而厄拉多塞筛算法的时间复杂度为$O(n log(log(n)))$。
举例 这是一张来自维基百科的算法示意图。
先从2开始遍历，将2的倍数(2,4,6,8,&mldr;)标记为为非素数 继续遍历，当前数字是素数时，继续将当前数字的倍数标记为非素数 直到所有数字标记完，重新标记数组，未被标记的就是素数 算法题 Leetcode 204. 计数质数
给定整数 n ，返回 所有小于非负整数 n 的质数的数量 。
示例 1：
输入：n = 10 输出：4 解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。 示例 2："><meta property="og:type" content="article"><meta property="og:url" content="https://www.ddhigh.com/2022/12/31/eratosthenes-sieve/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-12-31T14:13:45+00:00"><meta property="article:modified_time" content="2022-12-31T14:13:45+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="厄拉多塞筛素数筛选算法"><meta name=twitter:description content="厄拉多塞筛算法（Eratosthenes Sieve）是一种求素数的方法，由古希腊数学家厄拉多塞提出。它的原理是，给定一个数 n，从 2 开始依次将 $\sqrt n$ 以内的素数的倍数标记为合数，标记完成后，剩余未被标记的数为素数（从 2 开始）。如此可省去检查每个数的步骤，使筛选素数的过程更加简单。
算法 厄拉多塞筛算法具体步骤如下：
读取输入的数 n，将 2 到 n 的所有整数记录在表中 从 2 开始，划去表中所有 2 的倍数 由小到大寻找表中下一个未被划去的整数，再划去表中所有该整数的倍数 重复第（3）步，直到找到的整数大于$\sqrt n$为止 表中所有未被划去的整数均为素数 朴素的素数筛选算法如下：对给定的数字$i$，设定数字$j$从$2$遍历到$\sqrt i$，如果中间$i$能整除$j$，则$i$不是素数。该方法的时间复杂度为$O(n\sqrt n)$ ,$n$是数组长度，外层循环需要遍历$n$次，内层循环需要遍历$\sqrt n$次。
而厄拉多塞筛算法的时间复杂度为$O(n log(log(n)))$。
举例 这是一张来自维基百科的算法示意图。
先从2开始遍历，将2的倍数(2,4,6,8,&mldr;)标记为为非素数 继续遍历，当前数字是素数时，继续将当前数字的倍数标记为非素数 直到所有数字标记完，重新标记数组，未被标记的就是素数 算法题 Leetcode 204. 计数质数
给定整数 n ，返回 所有小于非负整数 n 的质数的数量 。
示例 1：
输入：n = 10 输出：4 解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。 示例 2："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.ddhigh.com/posts/"},{"@type":"ListItem","position":2,"name":"厄拉多塞筛素数筛选算法","item":"https://www.ddhigh.com/2022/12/31/eratosthenes-sieve/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"厄拉多塞筛素数筛选算法","name":"厄拉多塞筛素数筛选算法","description":"厄拉多塞筛算法（Eratosthenes Sieve）是一种求素数的方法，由古希腊数学家厄拉多塞提出。它的原理是，给定一个数 n，从 2 开始依次将 $\\sqrt n$ 以内的素数的倍数标记为合数，标记完成后，剩余未被标记的数为素数（从 2 开始）。如此可省去检查每个数的步骤，使筛选素数的过程更加简单。\n算法 厄拉多塞筛算法具体步骤如下：\n读取输入的数 n，将 2 到 n 的所有整数记录在表中 从 2 开始，划去表中所有 2 的倍数 由小到大寻找表中下一个未被划去的整数，再划去表中所有该整数的倍数 重复第（3）步，直到找到的整数大于$\\sqrt n$为止 表中所有未被划去的整数均为素数 朴素的素数筛选算法如下：对给定的数字$i$，设定数字$j$从$2$遍历到$\\sqrt i$，如果中间$i$能整除$j$，则$i$不是素数。该方法的时间复杂度为$O(n\\sqrt n)$ ,$n$是数组长度，外层循环需要遍历$n$次，内层循环需要遍历$\\sqrt n$次。\n而厄拉多塞筛算法的时间复杂度为$O(n log(log(n)))$。\n举例 这是一张来自维基百科的算法示意图。\n先从2开始遍历，将2的倍数(2,4,6,8,\u0026hellip;)标记为为非素数 继续遍历，当前数字是素数时，继续将当前数字的倍数标记为非素数 直到所有数字标记完，重新标记数组，未被标记的就是素数 算法题 Leetcode 204. 计数质数\n给定整数 n ，返回 所有小于非负整数 n 的质数的数量 。\n示例 1：\n输入：n = 10 输出：4 解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。 示例 2：","keywords":[],"articleBody":" 厄拉多塞筛算法（Eratosthenes Sieve）是一种求素数的方法，由古希腊数学家厄拉多塞提出。它的原理是，给定一个数 n，从 2 开始依次将 $\\sqrt n$ 以内的素数的倍数标记为合数，标记完成后，剩余未被标记的数为素数（从 2 开始）。如此可省去检查每个数的步骤，使筛选素数的过程更加简单。\n算法 厄拉多塞筛算法具体步骤如下：\n读取输入的数 n，将 2 到 n 的所有整数记录在表中 从 2 开始，划去表中所有 2 的倍数 由小到大寻找表中下一个未被划去的整数，再划去表中所有该整数的倍数 重复第（3）步，直到找到的整数大于$\\sqrt n$为止 表中所有未被划去的整数均为素数 朴素的素数筛选算法如下：对给定的数字$i$，设定数字$j$从$2$遍历到$\\sqrt i$，如果中间$i$能整除$j$，则$i$不是素数。该方法的时间复杂度为$O(n\\sqrt n)$ ,$n$是数组长度，外层循环需要遍历$n$次，内层循环需要遍历$\\sqrt n$次。\n而厄拉多塞筛算法的时间复杂度为$O(n log(log(n)))$。\n举例 这是一张来自维基百科的算法示意图。\n先从2开始遍历，将2的倍数(2,4,6,8,…)标记为为非素数 继续遍历，当前数字是素数时，继续将当前数字的倍数标记为非素数 直到所有数字标记完，重新标记数组，未被标记的就是素数 算法题 Leetcode 204. 计数质数\n给定整数 n ，返回 所有小于非负整数 n 的质数的数量 。\n示例 1：\n输入：n = 10 输出：4 解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。 示例 2：\n输入：n = 0 输出：0 示例 3：\n输入：n = 1 输出：0 代码实现 class Solution2 { // 厄拉多塞筛素数筛选算法 // 1. 准备O(n)的数组，标识数字是否是质数，初始情况下全部是质数 // 2. 从2开始遍历到sqrt(n),如果数字是质数，则i*i开始，后面i的倍数全是合数 // 3. 从[2,n)筛选质数并统计 public int countPrimes(int n) { if (n \u003c 2) { return 0; } var isPrime = new boolean[n]; Arrays.fill(isPrime, true); for (int i = 2; i * i \u003c n; i++) { // 遍历一半即可 if (isPrime[i]) { // 如果是质数，则将i平方开始的所有i的倍数设为合数 // 任意素数x的倍数有：2x, 3x, 4x, ..., x*x, (x+1)*x, ... // 任意小于x*x的倍数都被之前的素数筛过滤过，如：2 过滤 2x, 4x, ...，3 过滤 3x, ... for (int j = i * i; j \u003c n; j += i) { isPrime[j] = false; } } } var count = 0; for (int i = 2; i \u003c n; i++) { if (isPrime[i]) { count++; } } return count; } } 时间复杂度: $O(nlog(log(n)))$。时间复杂度证明过程有点复杂，我暂时还没消化。\n空间复杂度：$O(n)$。需要长度为$n$的数组标记是否素数。\n","wordCount":"197","inLanguage":"en","datePublished":"2022-12-31T14:13:45Z","dateModified":"2022-12-31T14:13:45Z","author":{"@type":"Person","name":"Lei Xia"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.ddhigh.com/2022/12/31/eratosthenes-sieve/"},"publisher":{"@type":"Organization","name":"Lei Xia","logo":{"@type":"ImageObject","url":"https://www.ddhigh.com/favicon.ico"}}}</script><link rel=icon href=/img/favicon.ico sizes=16x16><link rel=apple-touch-icon href=/img/favicon.ico><link rel=manifest href=/img/favicon.ico><link rel=stylesheet href=https://cdn.staticfile.org/lxgw-wenkai-webfont/1.6.0/style.css><link rel=stylesheet href=/css/main.min.5dd042a107aa191c819948e5648b04844bec5bdd365fdcf2b880177ce3d89b79.css integrity="sha256-XdBCoQeqGRyBmUjlZIsEhEvsW902X9zyuIAXfOPYm3k=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/highlight/github-dark.min.min.66034289ee9a113219a2c4aae0a8bd2095ab255c832a42efcf5863f10814e7a1.css><script src=/js/highlight.min.min.c607d6febd16934a82eb61d3a896ed9d869f54373cc63ce95864ed5488fe3128.js></script><script>hljs.highlightAll()</script><script>$darkModeInit.Content|safeJS</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-EC3XLVSGKV"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-EC3XLVSGKV")</script></head><body><main class=wrapper><nav class=navigation><section class=container><a class=navigation-brand href=/>HOME
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><span></span><span></span><span></span></label><ul class=navigation-list id=navigation-list><li class="navigation-item navigation-menu"><a class=navigation-link href=/archives>Archive</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/books>Books</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/guestbook>Guestbook</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class="navigation-item navigation-social"><a class=navigation-link href=https://github.com/xialeistudio><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li class="navigation-item navigation-dark"><button id=mode type=button aria-label="toggle user light or dark theme">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span>
<span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></li></ul></section></nav><div id=content><article class=blog-single><header class=blog-title><h1>厄拉多塞筛素数筛选算法</h1></header><p><small>December 31, 2022&nbsp;· 197 words&nbsp;· One minute</small><p><div class=blog-toc><nav id=TableOfContents><ul><li><a href=#算法>算法</a></li><li><a href=#举例>举例</a></li><li><a href=#算法题>算法题</a><ul><li><a href=#代码实现>代码实现</a></li></ul></li></ul></nav></div><section class=blog-content><blockquote><p>厄拉多塞筛算法（Eratosthenes Sieve）是一种求素数的方法，由古希腊数学家厄拉多塞提出。它的原理是，给定一个数 n，从 2 开始依次将 $\sqrt n$ 以内的素数的倍数标记为合数，标记完成后，剩余未被标记的数为素数（从 2 开始）。如此可省去检查每个数的步骤，使筛选素数的过程更加简单。</p></blockquote><h2 id=算法>算法</h2><p>厄拉多塞筛算法具体步骤如下：</p><ol><li>读取输入的数 n，将 2 到 n 的所有整数记录在表中</li><li>从 2 开始，划去表中所有 2 的倍数</li><li>由小到大寻找表中下一个未被划去的整数，再划去表中所有该整数的倍数</li><li>重复第（3）步，直到找到的整数大于$\sqrt n$为止</li><li>表中所有未被划去的整数均为素数</li></ol><p>朴素的素数筛选算法如下：对给定的数字$i$，设定数字$j$从$2$遍历到$\sqrt i$，如果中间$i$能整除$j$，则$i$不是素数。该方法的时间复杂度为$O(n\sqrt n)$ ,$n$是数组长度，外层循环需要遍历$n$次，内层循环需要遍历$\sqrt n$次。</p><p>而厄拉多塞筛算法的时间复杂度为$O(n log(log(n)))$。</p><h2 id=举例>举例</h2><p>这是一张来自<a href=https://zh.wikipedia.org/wiki/%E5%9F%83%E6%8B%89%E6%89%98%E6%96%AF%E7%89%B9%E5%B0%BC%E7%AD%9B%E6%B3%95 target=_blank rel=noopener>维基百科</a>的算法示意图。</p><p><img alt=算法示例 src=https://static.ddhigh.com/algorithm/Sieve_of_Eratosthenes_animation.gif></p><ol><li>先从2开始遍历，将2的倍数(2,4,6,8,&mldr;)标记为为非素数</li><li>继续遍历，当前数字是素数时，继续将当前数字的倍数标记为非素数</li><li>直到所有数字标记完，重新标记数组，未被标记的就是素数</li></ol><h2 id=算法题>算法题</h2><p>Leetcode <a href=https://leetcode.cn/problems/count-primes/ target=_blank rel=noopener>204. 计数质数</a></p><p>给定整数 <code>n</code> ，返回 <em>所有小于非负整数 <code>n</code> 的质数的数量</em> 。</p><p><strong>示例 1：</strong></p><pre tabindex=0><code>输入：n = 10
输出：4
解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。
</code></pre><p><strong>示例 2：</strong></p><pre tabindex=0><code>输入：n = 0
输出：0
</code></pre><p><strong>示例 3：</strong></p><pre tabindex=0><code>输入：n = 1
输出：0
</code></pre><h3 id=代码实现>代码实现</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution2</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 厄拉多塞筛素数筛选算法</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 1. 准备O(n)的数组，标识数字是否是质数，初始情况下全部是质数</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 2. 从2开始遍历到sqrt(n),如果数字是质数，则i*i开始，后面i的倍数全是合数</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 3. 从[2,n)筛选质数并统计</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>countPrimes</span>(<span style=color:#66d9ef>int</span> n) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (n <span style=color:#f92672>&lt;</span> 2) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> 0;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> isPrime <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>boolean</span><span style=color:#f92672>[</span>n<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>            Arrays.<span style=color:#a6e22e>fill</span>(isPrime, <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 2; i <span style=color:#f92672>*</span> i <span style=color:#f92672>&lt;</span> n; i<span style=color:#f92672>++</span>) { <span style=color:#75715e>// 遍历一半即可</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (isPrime<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>) { <span style=color:#75715e>// 如果是质数，则将i平方开始的所有i的倍数设为合数</span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 任意素数x的倍数有：2x, 3x, 4x, ..., x*x, (x+1)*x, ...</span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 任意小于x*x的倍数都被之前的素数筛过滤过，如：2 过滤 2x, 4x, ...，3 过滤 3x, ...</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> i <span style=color:#f92672>*</span> i; j <span style=color:#f92672>&lt;</span> n; j <span style=color:#f92672>+=</span> i) {
</span></span><span style=display:flex><span>                        isPrime<span style=color:#f92672>[</span>j<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> count <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 2; i <span style=color:#f92672>&lt;</span> n; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (isPrime<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>) {
</span></span><span style=display:flex><span>                    count<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> count;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>时间复杂度: $O(nlog(log(n)))$。时间复杂度证明过程有点复杂，我暂时还没消化。</p><p>空间复杂度：$O(n)$。需要长度为$n$的数组标记是否素数。</p></section><div class=paginator><a class=prev href=https://www.ddhigh.com/2022/12/31/cyclic-sort/><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M9.94496 9C9.28897 9.61644 7.63215 10.997 6.04814 11.7966 5.98257 11.8297 5.98456 11.9753 6.05061 12.0063c1.00435.4716 2.8788 1.9201 3.89435 2.9937M6.44444 11.9667C8.86549 12.0608 14 12 16 11" stroke="currentcolor" stroke-linecap="round"/></svg>
<span>原地哈希算法</span></a>
<a class=next href=https://www.ddhigh.com/2022/12/31/boyer-moore-majority-vote-algorithm/><span>博耶-摩尔多数投票算法</span><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M12.055 9C12.711 9.61644 14.3679 10.997 15.9519 11.7966 16.0174 11.8297 16.0154 11.9753 15.9494 12.0063 14.945 12.4779 13.0706 13.9264 12.055 15m3.5006-3.0333C13.1345 12.0608 8 12 6 11" stroke="currentcolor" stroke-linecap="round"/></svg></a></div><div class=comments><script>const getTheme=window.localStorage&&window.localStorage.getItem("theme");let theme=getTheme==="dark"?"dark":"light",s=document.createElement("script");s.src="https://giscus.app/client.js",s.setAttribute("data-repo","xialeistudio/discussion"),s.setAttribute("data-repo-id","R_kgDOKurTRA"),s.setAttribute("data-category","General"),s.setAttribute("data-category-id","DIC_kwDOKurTRM4CbCJt"),s.setAttribute("data-mapping","pathname"),s.setAttribute("data-strict","0"),s.setAttribute("data-reactions-enabled","1"),s.setAttribute("data-emit-metadata","0"),s.setAttribute("data-input-position","bottom"),s.setAttribute("data-theme",theme),s.setAttribute("data-lang","en"),s.setAttribute("data-loading","lazy"),s.setAttribute("crossorigin","anonymous"),s.setAttribute("async",""),document.querySelector("div.comments").innerHTML="",document.querySelector("div.comments").appendChild(s)</script></div></article></div><footer class=footer><p>&copy; 2014 - 2024 <a href=https://www.ddhigh.com/>Lei Xia</a>
Powered by
<a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>
<a href=https://github.com/guangzhengli/hugo-theme-ladder rel=noopener target=_blank>Ladder</a>
️</p></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.5376 22.7916C11.0152 22.7207 22.5795 21.1781 22.0978 10.4211 22.0536 9.43274 21.9303 8.53367 21.7387 7.71865M10.5376 22.7916C16.876 22.3728 20.0969 19.8899 21.5383 16.9142M10.5376 22.7916C9.7707 22.9055 8.97982 22.8964 8.19743 22.7725M21.7387 7.71865C21.4988 6.69828 21.1518 5.80967 20.7188 5.04257m1.0199 2.67608C22.6022 10.1105 23.0542 13.7848 21.5383 16.9142M20.7188 5.04257c-3.5504-6.28886-12.88753-4.410077-16.44303.0C2.88063 6.77451-.0433281 11.1668 1.38159 16.6571c.89322 3.4417 3.7911 5.6365 6.81584 6.1154M20.7188 5.04257c1.3509 1.89783 3.3111 6.34223 1.6353 10.37273M21.5383 16.9142C21.8737 16.4251 22.1428 15.9235 22.3541 15.4153M8.19743 22.7725C12.1971 23.4683 20.6281 22.971 22.3541 15.4153M14 10.945C13.3836 10.289 12.003 8.63215 11.2034 7.04814 11.1703 6.98257 11.0247 6.98456 10.9937 7.05061 10.5221 8.05496 9.07362 9.92941 8 10.945m3.0333-3.50056C10.9392 9.86549 11 15 12 17" stroke="currentcolor" stroke-linecap="round"/></svg>
</a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function n(){t.innerHTML="Copied",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)}),e.parentNode.appendChild(t)})</script></main></body><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script><script>const images=Array.from(document.querySelectorAll(".blog-content img"));images.forEach(e=>{mediumZoom(e,{margin:10,scrollOffset:40,container:null,template:null,background:"rgba(0, 0, 0, 0.5)"})})</script><script src=/main.min.6bb26b69159420159c74dc9e097b06a578ed2b68c701466a91a44a9632d851bd0af167a1b30012387b4c512b48ad9ad4d3394e04d77ae38d57e1920fe4ed34fe.js integrity="sha512-a7JraRWUIBWcdNyeCXsGpXjtK2jHAUZqkaRKljLYUb0K8WehswASOHtMUStIrZrU0zlOBNd6441X4ZIP5O00/g==" crossorigin=anonymous defer></script></html>