<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>每天进步一点点</title>
  
  <subtitle>Coding Change Anything</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https//www.ddhigh.com/"/>
  <updated>2022-12-30T11:23:38.177Z</updated>
  <id>https//www.ddhigh.com/</id>
  
  <author>
    <name>xialeistudio</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基数排序算法</title>
    <link href="https//www.ddhigh.com/2022/12/30/radix-sort.html"/>
    <id>https//www.ddhigh.com/2022/12/30/radix-sort.html</id>
    <published>2022-12-30T10:57:38.000Z</published>
    <updated>2022-12-30T11:23:38.177Z</updated>
    
    <content type="html"><![CDATA[<p>基数排序又叫桶排序，是一种时间复杂度为$O(n)$的排序算法，但是相比于其他排序算法有$O(n)$的空间复杂度。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>基数排序的核心思路如下：</p><ol><li>准备0~9的10个桶，根据数字当前比较位的值来决定放入哪个桶。如当前比较个位，则数字13应该放入索引为3的桶中；当前比较百位，则123应该放入索引为1的桶中。</li><li>当所有数字全部放入桶之后，遍历0~9这10个桶，然后依次将数字保存到待排序数组，因为桶是有序的，所以本轮放回去的数字是有序的。</li><li>当前比较的位数左移，比如本轮比较个位，下一轮应该比较百位。</li><li>重复步骤1~3。</li></ol><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>现在我们来看一个实际例子。</p><p>待排序数字：717, 328, 803, 422, 586, 944, 557, 308, 496, 624</p><h3 id="第1轮比较个位"><a href="#第1轮比较个位" class="headerlink" title="第1轮比较个位"></a>第1轮比较个位</h3><p>直接按照个位放入桶中。</p><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td></td><td></td><td>422</td><td>803</td><td>624</td><td></td><td>586</td><td>717</td><td>328</td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td>496</td><td>557</td><td>308</td></tr></tbody></table><p>按照从左到右，从上到下的原则将数字归位：422,803,624,586,496,717,557,328,308</p><h3 id="第2轮比较十位"><a href="#第2轮比较十位" class="headerlink" title="第2轮比较十位"></a>第2轮比较十位</h3><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td>803</td><td>717</td><td>422</td><td></td><td></td><td>557</td><td></td><td></td><td>586</td><td>496</td></tr><tr><td>308</td><td></td><td>624</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td>328</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>按照从左到右，从上到下的原则将数字归位：803,308,717,422,624,328,557,586,496</p><h3 id="第3轮比较百位"><a href="#第3轮比较百位" class="headerlink" title="第3轮比较百位"></a>第3轮比较百位</h3><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td></td><td></td><td></td><td>308</td><td>422</td><td>557</td><td>624</td><td>717</td><td>803</td><td></td></tr><tr><td></td><td></td><td></td><td>328</td><td>496</td><td>586</td><td></td><td></td><td></td></tr></tbody></table><p>按照从左到右，从上到下的原则将数字归位：308,328,422,496,557,586,624,717,803</p><p>可以发现，比较的轮次由数组中最大的数字决定，以上面的例子来说，如果还存在一个1234数字，那么需要比较4轮才可以完成排序。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RadixSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 基数排序</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (nums.length &lt;= <span class="hljs-number">1</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">var</span> max = Arrays.stream(nums).max().getAsInt();</span><br><span class="line">        <span class="hljs-comment">// 当前处理位数</span></span><br><span class="line">        <span class="hljs-keyword">var</span> exp = <span class="hljs-number">1</span>;</span><br><span class="line">        <span class="hljs-comment">// 桶</span></span><br><span class="line">        <span class="hljs-keyword">var</span> bucket = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>][nums.length];</span><br><span class="line">        <span class="hljs-comment">// 记录每个桶有几个数字</span></span><br><span class="line">        <span class="hljs-keyword">var</span> bucketCount = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];</span><br><span class="line">        <span class="hljs-keyword">while</span> (max &gt;= exp) &#123;</span><br><span class="line">            <span class="hljs-comment">// 求得每个数字当前位数的值</span></span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> num : nums) &#123;</span><br><span class="line">                <span class="hljs-comment">// 求得当前位余数</span></span><br><span class="line">                <span class="hljs-keyword">var</span> bitNumber = (num / exp) % <span class="hljs-number">10</span>;</span><br><span class="line">                <span class="hljs-comment">// 放入桶, index是桶的index，在同一个桶的数字需要index来标识位置</span></span><br><span class="line">                <span class="hljs-keyword">var</span> index = bucketCount[bitNumber];</span><br><span class="line">                bucket[bitNumber][index] = num;</span><br><span class="line">                <span class="hljs-comment">// 桶内数量+1</span></span><br><span class="line">                bucketCount[bitNumber]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-comment">// 桶内数字归位</span></span><br><span class="line">            <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; <span class="hljs-comment">// 已归位的数字下标</span></span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;</span><br><span class="line">                <span class="hljs-keyword">if</span> (bucketCount[i] &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 当前桶有数字</span></span><br><span class="line">                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; bucketCount[i]; j++) &#123; <span class="hljs-comment">// 遍历同一个桶的数字</span></span><br><span class="line">                        nums[k] = bucket[i][j];</span><br><span class="line">                        k++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="hljs-comment">// 桶数字清空</span></span><br><span class="line">                bucketCount[i] = <span class="hljs-number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-comment">// 位数左移</span></span><br><span class="line">            exp *= <span class="hljs-number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="hljs-keyword">var</span> gap = nums[i] - nums[i - <span class="hljs-number">1</span>];</span><br><span class="line">            <span class="hljs-keyword">if</span> (gap &gt; max) &#123;</span><br><span class="line">                max = gap;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">var</span> sort = <span class="hljs-keyword">new</span> RadixSort();</span><br><span class="line">        <span class="hljs-keyword">var</span> list = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">422</span>, <span class="hljs-number">803</span>, <span class="hljs-number">624</span>, <span class="hljs-number">586</span>, <span class="hljs-number">496</span>, <span class="hljs-number">717</span>, <span class="hljs-number">557</span>, <span class="hljs-number">328</span>, <span class="hljs-number">308</span>&#125;;</span><br><span class="line">        sort.sort(list);</span><br><span class="line">        System.out.println(Arrays.toString(list));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度: $O(n)$ ，严格来说是$O(log(n))$。$n$是待排序数组长度，在数据量小的情况下，最外层的while循环遍历次数可以认为是常数，内部嵌套的for循环次数为数组长度$n$，因此时间复杂度为$O(n)$；在数据量大的情况下，最外层的while循环次数为$O(log(n))$，内部嵌套的for循环次数依旧是$n$，因此时间复杂度为$O(nlog(n))$。</p><p>空间复杂度：$O(n)$。$n$是待排序数组长度，$bucket$的大小为$10*n$，$bucketCount$大小为$n$，因此总体空间复杂度为$O(n)$。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;基数排序又叫桶排序，是一种时间复杂度为$O(n)$的排序算法，但是相比于其他排序算法有$O(n)$的空间复杂度。&lt;/p&gt;
&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;p&gt;基数排序的核
      
    
    </summary>
    
      <category term="algorithm" scheme="https//www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="sort" scheme="https//www.ddhigh.com/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>算法篇-leetcode 131 分割回文串</title>
    <link href="https//www.ddhigh.com/2022/03/17/palindrome-partitioning.html"/>
    <id>https//www.ddhigh.com/2022/03/17/palindrome-partitioning.html</id>
    <published>2022-03-17T04:00:14.000Z</published>
    <updated>2022-12-30T11:23:38.177Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是 <strong>回文串</strong> 。返回 <code>s</code> 所有可能的分割方案。</p><p><strong>回文串</strong> 是正着读和反着读都一样的字符串。</p><p><strong>示例1</strong></p><figure class="highlight prolog hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="hljs-string">"aab"</span></span><br><span class="line">输出：[[<span class="hljs-string">"a"</span>,<span class="hljs-string">"a"</span>,<span class="hljs-string">"b"</span>],[<span class="hljs-string">"aa"</span>,<span class="hljs-string">"b"</span>]]</span><br></pre></td></tr></table></figure><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p><strong>题目要求</strong></p><ol><li>将字符串字符打散后，将其中的回文串添加到一个单独的List</li><li>第1步的所有List构成最后的答案</li></ol><p>可以看出，这是一个典型的回溯问题，考察有多少种方法可以组装最后的答案。</p><h4 id="方法一：直接回溯"><a href="#方法一：直接回溯" class="headerlink" title="方法一：直接回溯"></a>方法一：直接回溯</h4><p><strong>思路及算法</strong></p><p>回溯需要回答以下3个问题：</p><ol><li>回溯终止条件是什么？</li><li>回溯有哪些选择?</li><li>如何进入下一个选择？</li></ol><p>对于本题来说，我们需要将字符串打散，从中选择回文串添加到最终答案，因此，需要定义以下变量:  </p><ol><li>$index$, 记录当前选择的字符索引</li><li>$path$, 记录本次回文串选择情况</li><li>$answer$, 记录最终答案</li></ol><p>回答上面提出来的两个问题：</p><ol><li>回溯终止条件: $index==s.length()$，此时将$path$拷贝到$answer$，不可以直接添加，因为回溯存在撤回操作，必须断开$answer$和$path$的引用。</li><li>回溯有哪些选择：定义变量$right$, 遍历 $s[index,s.length())$，当$s[index,right]$是回文串时，将其加入$path$。</li><li>如何进入下一个选择：第2个问题满足条件的情况下，增加$index$然后再次递归即可。</li></ol><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * DFS回溯</span></span><br><span class="line"><span class="hljs-comment">     * 1. 回溯出口      index == s.length()</span></span><br><span class="line"><span class="hljs-comment">     * 2. 回溯递进      遍历[i,n)  如果s[i,j] 是回文串，则加入path，然后递归 s[i,j+1]</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> s</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; answer = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; path = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(answer, path, <span class="hljs-number">0</span>, s.length(), s);</span><br><span class="line">        <span class="hljs-keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(List&lt;List&lt;String&gt;&gt; answer, List&lt;String&gt; path, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> length, String s)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (index == length) &#123;</span><br><span class="line">            answer.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="hljs-keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">// 本次有什么选择?</span></span><br><span class="line">        <span class="hljs-comment">// j =&gt; [index,len)，检测s[index,j]是否回文，如果是，则加入path，最后撤销选择</span></span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = index; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (!isPalindrome(s, index, i)) &#123;</span><br><span class="line">                <span class="hljs-keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            path.add(s.substring(index, i + <span class="hljs-number">1</span>));</span><br><span class="line">            dfs(answer, path, i + <span class="hljs-number">1</span>, length, s);</span><br><span class="line">            path.remove(path.size() - <span class="hljs-number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (s.charAt(left) != s.charAt(right)) &#123;</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(N*2^n)$，每个位置的字符可以拆分也可以不拆分，因此时间复杂度是$O(2^n)$，判断每个子字符串是否为回文串需要$O(N)$的时间。</li><li>空间复杂度：$O(N*2^n)$，考虑$answer$，每个位置的字符可以拆分也可以不拆分，两种情况都需要占用空间，此部分空间是$O(2^n)$，而对于所有的答案都需要保存，此部分空间是$O(N)$.</li></ul><h4 id="方法二：记忆法回溯"><a href="#方法二：记忆法回溯" class="headerlink" title="方法二：记忆法回溯"></a>方法二：记忆法回溯</h4><p><strong>思路及算法</strong></p><p>在方法一的基础上添加$memo$保存$s[i,j]$是否为回文串，减少重复判断。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;</span><br><span class="line"> <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * DFS回溯</span></span><br><span class="line"><span class="hljs-comment">     * 1. 回溯出口      index == s.length()</span></span><br><span class="line"><span class="hljs-comment">     * 2. 回溯递进      遍历[i,n)  如果s[i,j] 是回文串，则加入path，然后递归 s[i,j+1]</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> s</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; answer = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; path = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Boolean[][] memo = <span class="hljs-keyword">new</span> Boolean[s.length()][s.length()];</span><br><span class="line">        dfs(memo, answer, path, <span class="hljs-number">0</span>, s.length(), s);</span><br><span class="line">        <span class="hljs-keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(Boolean[][] memo, List&lt;List&lt;String&gt;&gt; answer, List&lt;String&gt; path, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> length, String s)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (index == length) &#123;</span><br><span class="line">            answer.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="hljs-keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">// 本次有什么选择?</span></span><br><span class="line">        <span class="hljs-comment">// j =&gt; [index,len)，检测s[index,j]是否回文，如果是，则加入path，最后撤销选择</span></span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = index; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (!isPalindrome(memo, s, index, i)) &#123;</span><br><span class="line">                <span class="hljs-keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            path.add(s.substring(index, i + <span class="hljs-number">1</span>));</span><br><span class="line">            dfs(memo, answer, path, i + <span class="hljs-number">1</span>, length, s);</span><br><span class="line">            path.remove(path.size() - <span class="hljs-number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(Boolean[][] memo, String s, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (memo[left][right] != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> memo[left][right];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (s.charAt(left) != s.charAt(right)) &#123;</span><br><span class="line">                <span class="hljs-keyword">return</span> memo[left][right] = <span class="hljs-keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> memo[left][right] = <span class="hljs-keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(N*2^n)$，每个位置的字符可以拆分也可以不拆分，因此时间复杂度是$O(2^n)$，判断每个子字符串是否为回文串需要$O(N)$的时间，但是添加了记忆化搜索，每个子串至多搜索一次。</li><li>空间复杂度：$O(N*2^n)$，考虑$answer$，每个位置的字符可以拆分也可以不拆分，两种情况都需要占用空间，此部分空间是$O(2^n)$，而对于所有的答案都需要保存，此部分空间是$O(N)$.</li></ul><h4 id="方法三：DP-回溯"><a href="#方法三：DP-回溯" class="headerlink" title="方法三：DP+回溯"></a>方法三：DP+回溯</h4><p>我们可以利用DP通过提前计算好字符串的回文信息。</p><p><strong>思路和算法</strong></p><p>需要提前截取子字符串然后进行DP。那么问题来了，如何截取所有在子字符串？<br>我们可以定义如下双重循环：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>;right &lt; s.length(); right++) &#123;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;left&lt;= right; right++) &#123;</span><br><span class="line">        <span class="hljs-comment">// s[left,right] 就是所有的子字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>思考状态转移方程</strong></p><ol><li>定义$dp[i][j]$代表$s[i, j]$是否为回文串</li><li>当$s[left] == s[right]$可知字符串两端是相等的，需要考虑$left和right$的距离，通过穷举(笨办法)可知：<ol><li>$right - left = 0$时，$left$和$right$就是同一个字符，显然可以直接得到答案$true$</li><li>$right - left = 1$时，$left$和$right$是挨着的，比如$aa$，显然可以直接得到答案$true$</li><li>$right - right = 2$时，$left$和$right$中间夹了一个字符，比如$aba$，显然可以直接得到答案$true$</li><li>$right - right &gt; 2$ 时，不能直接看不出来了，需要进行状态转移，比如$aabaa$，当$s[0] == s[4]$时，我们需要看看$s[1,3]$是不是回文串，在本例中，由于$s[1,3]$是回文串，因此$s[0,4]$也是。</li></ol></li></ol><p>综上，DP方程如下：</p><p>$$<br>dp(i,j) = \begin{cases}<br>false, &amp; \text{if } s[i] \ne s[j] \<br>true, &amp; \text{if } s[i] = s[j] \&amp; j-i \le 2 \<br>dp[i+1][j-1], &amp; \text{if } j-i \gt 2<br>\end{cases}<br>$$</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * DP+DFS回溯</span></span><br><span class="line"><span class="hljs-comment">     * 1. DP处理 dp[i][j]是否为回文</span></span><br><span class="line"><span class="hljs-comment">     * 1.1 dp[i][i] = true</span></span><br><span class="line"><span class="hljs-comment">     * 1.2 dp[i][j] = s[i] == s[j] &amp;&amp; (dp[i+1][j-1] || j-i&lt;=2)</span></span><br><span class="line"><span class="hljs-comment">     * 2. 回溯</span></span><br><span class="line"><span class="hljs-comment">     * 2.1 回溯出口: index == s.length()</span></span><br><span class="line"><span class="hljs-comment">     * 2.2 回溯递进：j =&gt; [i,s.length())  if(dp[i][j])  添加子串，然后 dfs(index+1)</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> s</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> n = s.length();</span><br><span class="line">        <span class="hljs-keyword">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n][n];</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>; right &lt; n; right++) &#123;</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>; left &lt;= right; left++) &#123;</span><br><span class="line">                <span class="hljs-keyword">if</span> (s.charAt(left) == s.charAt(right)) &#123;</span><br><span class="line">                    <span class="hljs-keyword">if</span> (right - left &lt;= <span class="hljs-number">2</span>) &#123;</span><br><span class="line">                        dp[left][right] = <span class="hljs-keyword">true</span>;</span><br><span class="line">                    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                        dp[left][right] = dp[left + <span class="hljs-number">1</span>][right - <span class="hljs-number">1</span>]; <span class="hljs-comment">// 上一轮遍历过</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;String&gt;&gt; answer = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; path = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(answer, path, dp, <span class="hljs-number">0</span>, n, s);</span><br><span class="line">        <span class="hljs-keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(List&lt;List&lt;String&gt;&gt; answer, List&lt;String&gt; path, <span class="hljs-keyword">boolean</span>[][] dp, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> n, String s)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (index == n) &#123;</span><br><span class="line">            answer.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="hljs-keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> right = index; right &lt; n; right++) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (dp[index][right]) &#123;</span><br><span class="line">                path.add(s.substring(index, right + <span class="hljs-number">1</span>));</span><br><span class="line">                dfs(answer, path, dp, right + <span class="hljs-number">1</span>, n, s);</span><br><span class="line">                path.remove(path.size() - <span class="hljs-number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong><br>+时间复杂度：$O(2^n)$，计算$dp$需要$O(n^2)$,回溯需要$O(2^n)$。</p><ul><li>空间复杂度：$O(N*2^n)$，考虑$answer$，每个位置的字符可以拆分也可以不拆分，两种情况都需要占用空间，此部分空间是$O(2^n)$，而对于所有的答案都需要保存，此部分空间是$O(N)$;考虑$dp$，需要$O(n^2)$的空间</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个字符串 &lt;code&gt;s&lt;/code&gt;，请你将 &lt;code&gt;s&lt;/code&gt; 分割成一些子串，使每个子串都是 &lt;strong&gt;回文串&lt;
      
    
    </summary>
    
      <category term="algorithm" scheme="https//www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="binarysearch" scheme="https//www.ddhigh.com/tags/binarysearch/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode106——从中序与后序遍历序列构造二叉树</title>
    <link href="https//www.ddhigh.com/2022/02/08/construct-binary-tree-from-inorder-and-postorder-traversal.html"/>
    <id>https//www.ddhigh.com/2022/02/08/construct-binary-tree-from-inorder-and-postorder-traversal.html</id>
    <published>2022-02-08T12:24:19.000Z</published>
    <updated>2022-12-30T11:23:38.177Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。</p><p> <strong>示例 1:</strong></p><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：inorder = [<span class="hljs-number">9</span>,<span class="hljs-number">3</span>,<span class="hljs-number">15</span>,<span class="hljs-number">20</span>,<span class="hljs-number">7</span>], postorder = [<span class="hljs-number">9</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>,<span class="hljs-number">20</span>,<span class="hljs-number">3</span>]</span><br><span class="line">输出：[<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,null,null,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight inform7 hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：inorder = <span class="hljs-comment">[-1]</span>, postorder = <span class="hljs-comment">[-1]</span></span><br><span class="line">输出：<span class="hljs-comment">[-1]</span></span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal" target="_blank" rel="noopener">https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>核心是中序遍历的顺序是[左，根，右]，后序遍历是[左，右，根]。而同一颗树不管前/中/后序遍历，节点数是不变的。</p></blockquote><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 后序遍历顺序: 左右根</span></span><br><span class="line"><span class="hljs-comment">// 1. postorder最后一个元素为根</span></span><br><span class="line"><span class="hljs-comment">// 2. 遍历inorder查找根的index</span></span><br><span class="line"><span class="hljs-comment">// 3. inorder[:index]为左子树，inorder[index+1:]为右子树，左子树大小记为leftTreeSize</span></span><br><span class="line"><span class="hljs-comment">// 4. postorder[:leftTreeSize]为左子树，postorder[leftTreeSize:len(postorder)-1]是右子树</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buildTree</span><span class="hljs-params">(inorder []<span class="hljs-keyword">int</span>, postorder []<span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">TreeNode</span></span> &#123;</span><br><span class="line">n := <span class="hljs-built_in">len</span>(inorder)</span><br><span class="line"><span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> &amp;TreeNode&#123;Val: inorder[<span class="hljs-number">0</span>]&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 查找中序遍历根的index</span></span><br><span class="line">index := <span class="hljs-number">-1</span></span><br><span class="line">rootValue := postorder[<span class="hljs-built_in">len</span>(postorder)<span class="hljs-number">-1</span>]</span><br><span class="line"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(inorder); i++ &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> inorder[i] == rootValue &#123;</span><br><span class="line">index = i</span><br><span class="line"><span class="hljs-keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 分割数组</span></span><br><span class="line">leftTreeSize := <span class="hljs-built_in">len</span>(inorder[:index])</span><br><span class="line">root := &amp;TreeNode&#123;Val: rootValue&#125;</span><br><span class="line">root.Left = buildTree(inorder[:index], postorder[:leftTreeSize])</span><br><span class="line">root.Right = buildTree(inorder[index+<span class="hljs-number">1</span>:], postorder[leftTreeSize:<span class="hljs-built_in">len</span>(postorder)<span class="hljs-number">-1</span>])</span><br><span class="line"><span class="hljs-keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序
      
    
    </summary>
    
      <category term="algorithm" scheme="https//www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="tree" scheme="https//www.ddhigh.com/tags/tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode108——将有序数组转换为二叉搜索树</title>
    <link href="https//www.ddhigh.com/2022/02/08/convert-sorted-array-to-binary-search-tree.html"/>
    <id>https//www.ddhigh.com/2022/02/08/convert-sorted-array-to-binary-search-tree.html</id>
    <published>2022-02-08T12:24:19.000Z</published>
    <updated>2022-12-30T11:23:38.177Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。</p><p>高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg" alt="img"></p><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="hljs-number">-10</span>,<span class="hljs-number">-3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>]</span><br><span class="line">输出：[<span class="hljs-number">0</span>,<span class="hljs-number">-3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">-10</span>,null,<span class="hljs-number">5</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree.jpg" alt="img"></p><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>]</span><br><span class="line">输出：[<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]</span><br><span class="line">解释：[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>] 和 [<span class="hljs-number">3</span>,<span class="hljs-number">1</span>] 都是高度平衡二叉搜索树。</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>二叉树的中序遍历是升序，节点顺序为[左，根，右]</p></blockquote><ol><li>对于给定的数组，根据升序的性质，可知，中间节点为根节点，左半部分为左子树，右半部分为右子树</li><li>左半部分也是一颗完整的树，复用1的逻辑，因此用递归即可</li></ol><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="hljs-comment">// 升序数组是树的中序遍历结果，中间Index就是根，可以递归的还原为一个树</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">TreeNode</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> &amp;TreeNode&#123;Val: nums[<span class="hljs-number">0</span>]&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> helper(nums, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">helper</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>, start, end <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">TreeNode</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> start &gt; end &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 取得根</span></span><br><span class="line">rootIndex := (start + end) / <span class="hljs-number">2</span></span><br><span class="line">rootValue := nums[rootIndex]</span><br><span class="line">root := &amp;TreeNode&#123;Val: rootValue&#125;</span><br><span class="line">root.Left = helper(nums, start, rootIndex<span class="hljs-number">-1</span>)</span><br><span class="line">root.Right = helper(nums, rootIndex+<span class="hljs-number">1</span>, end)</span><br><span class="line"><span class="hljs-keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。&lt;/p&gt;
&lt;p&gt;高度平衡 二叉树是一棵满
      
    
    </summary>
    
      <category term="algorithm" scheme="https//www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="tree" scheme="https//www.ddhigh.com/tags/tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode109——有序链表转换二叉搜索树</title>
    <link href="https//www.ddhigh.com/2022/02/08/convert-sorted-list-to-binary-search-tree.html"/>
    <id>https//www.ddhigh.com/2022/02/08/convert-sorted-list-to-binary-search-tree.html</id>
    <published>2022-02-08T12:24:19.000Z</published>
    <updated>2022-12-30T11:23:38.177Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p><p><strong>示例:</strong></p><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给定的有序链表： [<span class="hljs-number">-10</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>],</span><br><span class="line"></span><br><span class="line">一个可能的答案是：[<span class="hljs-number">0</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">-10</span>, null, <span class="hljs-number">5</span>], 它可以表示下面这个高度平衡二叉搜索树：</span><br><span class="line"></span><br><span class="line">      <span class="hljs-number">0</span></span><br><span class="line">     / \</span><br><span class="line">   <span class="hljs-number">-3</span>   <span class="hljs-number">9</span></span><br><span class="line">   /   /</span><br><span class="line"> <span class="hljs-number">-10</span>  <span class="hljs-number">5</span></span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="转换为数组"><a href="#转换为数组" class="headerlink" title="转换为数组"></a>转换为数组</h3><blockquote><p>转换为数组后解法跟前面一道题一样。</p></blockquote><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="hljs-comment">// 链表转换为数组，复用108解法</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sortedListToBST</span><span class="hljs-params">(head *ListNode)</span> *<span class="hljs-title">TreeNode</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">list := listToArray(head)</span><br><span class="line"><span class="hljs-keyword">return</span> helper(list, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(list)<span class="hljs-number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">listToArray</span><span class="hljs-params">(head *ListNode)</span> []<span class="hljs-title">int</span></span> &#123;</span><br><span class="line">result := []<span class="hljs-keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="hljs-keyword">for</span> head != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">result = <span class="hljs-built_in">append</span>(result, head.Val)</span><br><span class="line">head = head.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">helper</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>, start, end <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">TreeNode</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> start &gt; end &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 取得根</span></span><br><span class="line">rootIndex := (start + end) / <span class="hljs-number">2</span></span><br><span class="line">rootValue := nums[rootIndex]</span><br><span class="line">root := &amp;TreeNode&#123;Val: rootValue&#125;</span><br><span class="line">root.Left = helper(nums, start, rootIndex<span class="hljs-number">-1</span>)</span><br><span class="line">root.Right = helper(nums, rootIndex+<span class="hljs-number">1</span>, end)</span><br><span class="line"><span class="hljs-keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表操作"><a href="#链表操作" class="headerlink" title="链表操作"></a>链表操作</h3><blockquote><p>我们遍历到中间节点后，将链表拆分为[左部分，中间点，右部分]即可复用逻辑，而且无额外空间占用</p></blockquote><p>单链表是无法直到中间点在哪里的，因此我们需要先遍历一次，获取链表长度，除以2就是中间的index。</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 1. 遍历一遍链表得到链表长度，算出中间节点index</span></span><br><span class="line"><span class="hljs-comment">// 2. 再次遍历链表，拆分为三段</span></span><br><span class="line"><span class="hljs-comment">// 1. 起点到中间节点的上一个节点：左子链表</span></span><br><span class="line"><span class="hljs-comment">// 2. 中间节点</span></span><br><span class="line"><span class="hljs-comment">// 3. 中间节点的下一个节点到链表末尾：右子链表</span></span><br><span class="line"><span class="hljs-comment">// 3. 将中间节点作为树根，利用左右子链表，递归构建左右子树，然后挂到根节点</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sortedListToBST</span><span class="hljs-params">(head *ListNode)</span> *<span class="hljs-title">TreeNode</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> helper(head)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">helper</span><span class="hljs-params">(head *ListNode)</span> *<span class="hljs-title">TreeNode</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> head.Next == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> &amp;TreeNode&#123;Val: head.Val&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 获取链表总长度</span></span><br><span class="line">length := <span class="hljs-number">0</span></span><br><span class="line">p := head</span><br><span class="line"><span class="hljs-keyword">for</span> p != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">length++</span><br><span class="line">p = p.Next</span><br><span class="line">&#125;</span><br><span class="line">middle := length / <span class="hljs-number">2</span> <span class="hljs-comment">// 取得中间点位置</span></span><br><span class="line"><span class="hljs-comment">// 再次遍历到中间点</span></span><br><span class="line"><span class="hljs-keyword">var</span> (</span><br><span class="line">prev = head      <span class="hljs-comment">// 指向中间点的上一个节点</span></span><br><span class="line">curr = head.Next <span class="hljs-comment">// 指向中间点</span></span><br><span class="line">)</span><br><span class="line"><span class="hljs-keyword">var</span> (</span><br><span class="line">left  *ListNode <span class="hljs-comment">// 左子链表头结点</span></span><br><span class="line">right *ListNode <span class="hljs-comment">// 右子链表头结点</span></span><br><span class="line">)</span><br><span class="line">index := <span class="hljs-number">0</span></span><br><span class="line"><span class="hljs-keyword">for</span> curr != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-comment">// index是prev的下标，因此定位到middle的前一个</span></span><br><span class="line"><span class="hljs-keyword">if</span> index == middle<span class="hljs-number">-1</span> &#123;</span><br><span class="line"><span class="hljs-comment">// 找到中点，将中点和右子链表连接打断</span></span><br><span class="line">right = curr.Next</span><br><span class="line">curr.Next = <span class="hljs-literal">nil</span></span><br><span class="line"><span class="hljs-comment">// 将左子链表和中点连接打断</span></span><br><span class="line">prev.Next = <span class="hljs-literal">nil</span></span><br><span class="line">left = head</span><br><span class="line"><span class="hljs-keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">prev = curr</span><br><span class="line">curr = curr.Next</span><br><span class="line">index++</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 此时我们拥有left,curr,right 三个链表，开始递归组合</span></span><br><span class="line">root := &amp;TreeNode&#123;Val: curr.Val&#125;</span><br><span class="line">root.Left = helper(left) <span class="hljs-comment">// 给你一条链表，给我构建一个树出来</span></span><br><span class="line">root.Right = helper(right)</span><br><span class="line"><span class="hljs-keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。&lt;/p&gt;
&lt;p&gt;本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左
      
    
    </summary>
    
      <category term="algorithm" scheme="https//www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="tree" scheme="https//www.ddhigh.com/tags/tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode107——二叉树的层序遍历 II</title>
    <link href="https//www.ddhigh.com/2022/02/06/binary-tree-level-order-traversal-ii.html"/>
    <id>https//www.ddhigh.com/2022/02/06/binary-tree-level-order-traversal-ii.html</id>
    <published>2022-02-06T12:24:19.000Z</published>
    <updated>2022-12-30T11:23:38.177Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你二叉树的根节点 <code>root</code> ，返回其节点值 <strong>自底向上的层序遍历</strong> 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt="img"></p><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,null,null,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]</span><br><span class="line">输出：[[<span class="hljs-number">15</span>,<span class="hljs-number">7</span>],[<span class="hljs-number">9</span>,<span class="hljs-number">20</span>],[<span class="hljs-number">3</span>]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="hljs-number">1</span>]</span><br><span class="line">输出：<span class="hljs-string">[[1]]</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7 hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = <span class="hljs-comment">[]</span></span><br><span class="line">输出：<span class="hljs-comment">[]</span></span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>直接用层序遍历即可，结果数组翻转之后就是答案</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// BFS正向遍历，最后翻转一下最终结果</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">levelOrderBottom</span><span class="hljs-params">(root *TreeNode)</span> [][]<span class="hljs-title">int</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> [][]<span class="hljs-keyword">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">answers := [][]<span class="hljs-keyword">int</span>&#123;&#125;</span><br><span class="line">queue := []*TreeNode&#123;root&#125;</span><br><span class="line"><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;</span><br><span class="line">size := <span class="hljs-built_in">len</span>(queue)</span><br><span class="line">tmp := queue</span><br><span class="line">queue = []*TreeNode&#123;&#125; <span class="hljs-comment">// 清空，存储下一层的节点</span></span><br><span class="line">level := []<span class="hljs-keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;</span><br><span class="line">node := tmp[<span class="hljs-number">0</span>]</span><br><span class="line">tmp = tmp[<span class="hljs-number">1</span>:]</span><br><span class="line">level = <span class="hljs-built_in">append</span>(level, node.Val)</span><br><span class="line"><span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">queue = <span class="hljs-built_in">append</span>(queue, node.Left)</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">queue = <span class="hljs-built_in">append</span>(queue, node.Right)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">answers = <span class="hljs-built_in">append</span>(answers, level)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="hljs-comment">// 翻转数组</span></span><br><span class="line">length := <span class="hljs-built_in">len</span>(answers)</span><br><span class="line"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; length/<span class="hljs-number">2</span>; i++ &#123;</span><br><span class="line">answers[i], answers[length<span class="hljs-number">-1</span>-i] = answers[length<span class="hljs-number">-1</span>-i], answers[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> answers</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你二叉树的根节点 &lt;code&gt;root&lt;/code&gt; ，返回其节点值 &lt;strong&gt;自底向上的层序遍历&lt;/strong&gt; 。 （即按从叶
      
    
    </summary>
    
      <category term="algorithm" scheme="https//www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="tree" scheme="https//www.ddhigh.com/tags/tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode103——二叉树的锯齿形层序遍历</title>
    <link href="https//www.ddhigh.com/2022/02/06/binary-tree-zigzag-level-order-traversal.html"/>
    <id>https//www.ddhigh.com/2022/02/06/binary-tree-zigzag-level-order-traversal.html</id>
    <published>2022-02-06T12:24:19.000Z</published>
    <updated>2022-12-30T11:23:38.177Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>锯齿形层序遍历</strong> 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt="img"></p><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,null,null,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]</span><br><span class="line">输出：[[<span class="hljs-number">3</span>],[<span class="hljs-number">20</span>,<span class="hljs-number">9</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="hljs-number">1</span>]</span><br><span class="line">输出：<span class="hljs-string">[[1]]</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7 hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = <span class="hljs-comment">[]</span></span><br><span class="line">输出：<span class="hljs-comment">[]</span></span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>用层序遍历的思路即可，不过偶数行需要将该行的值翻转。</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// BFS处理，记录遍历层数，当层数是奇数，翻转下本层元素</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">zigzagLevelOrder</span><span class="hljs-params">(root *TreeNode)</span> [][]<span class="hljs-title">int</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> [][]<span class="hljs-keyword">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">answers := [][]<span class="hljs-keyword">int</span>&#123;&#125;</span><br><span class="line">queue := []*TreeNode&#123;root&#125;</span><br><span class="line"><span class="hljs-keyword">for</span> level := <span class="hljs-number">1</span>; <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span>; level++ &#123;</span><br><span class="line">size := <span class="hljs-built_in">len</span>(queue)</span><br><span class="line">tmp := queue</span><br><span class="line">queue = []*TreeNode&#123;&#125; <span class="hljs-comment">// 清空，存储下一层的节点</span></span><br><span class="line">vals := []<span class="hljs-keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;</span><br><span class="line">node := tmp[<span class="hljs-number">0</span>]</span><br><span class="line">tmp = tmp[<span class="hljs-number">1</span>:]</span><br><span class="line">vals = <span class="hljs-built_in">append</span>(vals, node.Val)</span><br><span class="line"><span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">queue = <span class="hljs-built_in">append</span>(queue, node.Left)</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">queue = <span class="hljs-built_in">append</span>(queue, node.Right)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> level%<span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 偶数行，翻转vals</span></span><br><span class="line">length := <span class="hljs-built_in">len</span>(vals)</span><br><span class="line"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; length/<span class="hljs-number">2</span>; i++ &#123;</span><br><span class="line">vals[i], vals[length<span class="hljs-number">-1</span>-i] = vals[length<span class="hljs-number">-1</span>-i], vals[i] <span class="hljs-comment">// length-1是结束下标，-i就是同步往左逼近</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">answers = <span class="hljs-built_in">append</span>(answers, vals)</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> answers</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你二叉树的根节点 &lt;code&gt;root&lt;/code&gt; ，返回其节点值的 &lt;strong&gt;锯齿形层序遍历&lt;/strong&gt; 。（即先从左往右
      
    
    </summary>
    
      <category term="algorithm" scheme="https//www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="tree" scheme="https//www.ddhigh.com/tags/tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode105——从前序与中序遍历序列构造二叉树</title>
    <link href="https//www.ddhigh.com/2022/02/06/construct-binary-tree-from-preorder-and-inorder-traversal.html"/>
    <id>https//www.ddhigh.com/2022/02/06/construct-binary-tree-from-preorder-and-inorder-traversal.html</id>
    <published>2022-02-06T12:24:19.000Z</published>
    <updated>2022-12-30T11:23:38.177Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</p><p><strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt="img"></p><figure class="highlight nix hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="hljs-attr">preorder</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>], <span class="hljs-attr">inorder</span> = [<span class="hljs-number">9</span>,<span class="hljs-number">3</span>,<span class="hljs-number">15</span>,<span class="hljs-number">20</span>,<span class="hljs-number">7</span>]</span><br><span class="line">输出: [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight inform7 hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: preorder = <span class="hljs-comment">[-1]</span>, inorder = <span class="hljs-comment">[-1]</span></span><br><span class="line">输出: <span class="hljs-comment">[-1]</span></span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal" target="_blank" rel="noopener">https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>利用前序遍历和中序遍历性质</p><ol><li>前序遍历节点顺序如下[根，左，右]</li><li>中序遍历节点顺序如下[左，根，右]</li><li>前序遍历的左/右子树长度和中序遍历的左/右子树长度是相同的</li><li>由于这是同一颗树遍历来的，因此前序遍历的第0个元素和中序遍历的根节点是相同的。因此只要能定位中序遍历的根节点，将中序遍历数组拆分为左右两半后就可以了<ol><li>查找中序遍历的数组中值为前序遍历第0个元素节点的下标，记为<code>middle</code></li><li>此时中序遍历左子树节点列表为<code>[:middle]</code>，右子树节点列表为<code>[middle+1:]</code>，左子树长度为<code>len([:middle])</code>，记为<code>leftTreeSize</code></li><li>根据第3点可知，前序遍历的左子树节点列表为<code>[1:leftTreeSize+1]</code>,右子树节点为<code>[leftTreeSize+1:]</code></li></ol></li></ol><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 递归法</span></span><br><span class="line"><span class="hljs-comment">// 中序，左根右；前序根左右</span></span><br><span class="line"><span class="hljs-comment">// 1. 根据中序遍历找到根节点(值为preorder[0]的节点)</span></span><br><span class="line"><span class="hljs-comment">// 2. 中序遍历根节点左边的节点数和前序遍历的节点数是相同的，根据该性质可以将前序遍历拆分为两半</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buildTree</span><span class="hljs-params">(preorder []<span class="hljs-keyword">int</span>, inorder []<span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">TreeNode</span></span> &#123;</span><br><span class="line">n := <span class="hljs-built_in">len</span>(preorder)</span><br><span class="line"><span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">root := &amp;TreeNode&#123;Val: preorder[<span class="hljs-number">0</span>]&#125;</span><br><span class="line"><span class="hljs-comment">// 查找根节点在中序遍历的位置</span></span><br><span class="line">middle := <span class="hljs-number">0</span></span><br><span class="line"><span class="hljs-keyword">for</span> ; middle &lt; n; middle++ &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> inorder[middle] == preorder[<span class="hljs-number">0</span>] &#123;</span><br><span class="line"><span class="hljs-keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">leftTreeSize := <span class="hljs-built_in">len</span>(inorder[:middle])                                 <span class="hljs-comment">// 中序遍历的左半边就是左子树</span></span><br><span class="line">root.Left = buildTree(preorder[<span class="hljs-number">1</span>:leftTreeSize+<span class="hljs-number">1</span>], inorder[:middle])   <span class="hljs-comment">// 将前序遍历的左半边和中序的左半边递归构造左子树</span></span><br><span class="line">root.Right = buildTree(preorder[leftTreeSize+<span class="hljs-number">1</span>:], inorder[middle+<span class="hljs-number">1</span>:]) <span class="hljs-comment">// 将前序遍历的右半边和中序遍历的右半边构建右子树</span></span><br><span class="line"><span class="hljs-keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历
      
    
    </summary>
    
      <category term="algorithm" scheme="https//www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="tree" scheme="https//www.ddhigh.com/tags/tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode99——恢复二叉搜索树</title>
    <link href="https//www.ddhigh.com/2022/02/06/recover-binary-search-tree.html"/>
    <id>https//www.ddhigh.com/2022/02/06/recover-binary-search-tree.html</id>
    <published>2022-02-06T12:24:19.000Z</published>
    <updated>2022-12-30T11:23:38.177Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你二叉搜索树的根节点 root ，该树中的 恰好 两个节点的值被错误地交换。请在不改变其结构的情况下，恢复这棵树 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/28/recover1.jpg" alt="img"></p><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,null,null,<span class="hljs-number">2</span>]</span><br><span class="line">输出：[<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,null,null,<span class="hljs-number">2</span>]</span><br><span class="line">解释：<span class="hljs-number">3</span> 不能是 <span class="hljs-number">1</span> 的左孩子，因为 <span class="hljs-number">3</span> &gt; <span class="hljs-number">1</span> 。交换 <span class="hljs-number">1</span> 和 <span class="hljs-number">3</span> 使二叉搜索树有效。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/28/recover2.jpg" alt="img"></p><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,null,null,<span class="hljs-number">2</span>]</span><br><span class="line">输出：[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,null,null,<span class="hljs-number">3</span>]</span><br><span class="line">解释：<span class="hljs-number">2</span> 不能在 <span class="hljs-number">3</span> 的右子树中，因为 <span class="hljs-number">2</span> &lt; <span class="hljs-number">3</span> 。交换 <span class="hljs-number">2</span> 和 <span class="hljs-number">3</span> 使二叉搜索树有效。</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/recover-binary-search-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/recover-binary-search-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>中序遍历构造一个数组，根据二叉搜索树的性质，中序遍历是严格递增的</li><li>遍历该数组，找出<code>后一个值</code>小于<code>前一个值</code>的下标，根据这两个下标访问数组，可以得到两个错误值</li><li>遍历二叉树，根据第2步的两个值定位两个二叉树节点</li><li>交换两个节点的值</li></ol><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 1. 中序遍历构造一个数组</span></span><br><span class="line"><span class="hljs-comment">// 2. 检查数组顺序，定位有问题的下标</span></span><br><span class="line"><span class="hljs-comment">// 3. 中序遍历原来的树，定位指定下标的节点， 交换两个节点值</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">recoverTree</span><span class="hljs-params">(root *TreeNode)</span></span> &#123;</span><br><span class="line"><span class="hljs-comment">// 构造数组</span></span><br><span class="line"><span class="hljs-keyword">var</span> values []<span class="hljs-keyword">int</span></span><br><span class="line"><span class="hljs-keyword">var</span> valueGetter <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span></span><br><span class="line">valueGetter = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">valueGetter(root.Left)</span><br><span class="line">values = <span class="hljs-built_in">append</span>(values, root.Val)</span><br><span class="line">valueGetter(root.Right)</span><br><span class="line">&#125;</span><br><span class="line">valueGetter(root)</span><br><span class="line"><span class="hljs-comment">// 检查数组值顺序，如果比前面的小或者比后面的大</span></span><br><span class="line"><span class="hljs-keyword">var</span> (</span><br><span class="line">wrongIndex1 = <span class="hljs-number">-1</span></span><br><span class="line">wrongIndex2 = <span class="hljs-number">-1</span></span><br><span class="line">)</span><br><span class="line"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(values)<span class="hljs-number">-1</span>; i++ &#123;</span><br><span class="line"><span class="hljs-comment">// 如果比前面的小或者比后面的大</span></span><br><span class="line"><span class="hljs-keyword">if</span> values[i+<span class="hljs-number">1</span>] &lt; values[i] &#123;</span><br><span class="line">wrongIndex2 = i + <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-keyword">if</span> wrongIndex1 == <span class="hljs-number">-1</span> &#123;</span><br><span class="line">wrongIndex1 = i</span><br><span class="line">&#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 中序遍历，定位到wrongIndex1和wrongIndex2的节点，交换两者的值</span></span><br><span class="line"><span class="hljs-keyword">var</span> (</span><br><span class="line">locator    <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span></span><br><span class="line">wrongNode1 *TreeNode</span><br><span class="line">wrongNode2 *TreeNode</span><br><span class="line">)</span><br><span class="line">locator = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">locator(root.Left)</span><br><span class="line"><span class="hljs-keyword">if</span> root.Val == values[wrongIndex1] &#123; <span class="hljs-comment">// 根据值定位节点</span></span><br><span class="line">wrongNode1 = root</span><br><span class="line">&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> root.Val == values[wrongIndex2] &#123;</span><br><span class="line">wrongNode2 = root</span><br><span class="line">&#125;</span><br><span class="line">locator(root.Right)</span><br><span class="line">&#125;</span><br><span class="line">locator(root)</span><br><span class="line">wrongNode1.Val, wrongNode2.Val = wrongNode2.Val, wrongNode1.Val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你二叉搜索树的根节点 root ，该树中的 恰好 两个节点的值被错误地交换。请在不改变其结构的情况下，恢复这棵树 。&lt;/p&gt;
&lt;p&gt;&lt;st
      
    
    </summary>
    
      <category term="algorithm" scheme="https//www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="tree" scheme="https//www.ddhigh.com/tags/tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode95——不同的二叉搜索树 II</title>
    <link href="https//www.ddhigh.com/2022/02/06/unique-binary-search-trees-ii.html"/>
    <id>https//www.ddhigh.com/2022/02/06/unique-binary-search-trees-ii.html</id>
    <published>2022-02-06T12:24:19.000Z</published>
    <updated>2022-12-30T11:23:38.177Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数 <code>n</code> ，请你生成并返回所有由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的不同 <strong>二叉搜索树</strong> 。可以按 <strong>任意顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg" alt="img"></p><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="hljs-number">3</span></span><br><span class="line">输出：[[<span class="hljs-number">1</span>,null,<span class="hljs-number">2</span>,null,<span class="hljs-number">3</span>],[<span class="hljs-number">1</span>,null,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,null,null,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,null,<span class="hljs-number">1</span>]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p>输入：n = 1<br>输出：[[1]]</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-binary-search-trees-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>由于每个节点都可以成为根节点，因此遍历1~n，i为遍历参数名称，此时可以构造如下树<ol><li>1~i-1为左子树</li><li>i为根节点</li><li>i+1~n为右子树</li></ol></li><li>递归的调用步骤1可以得到所有的组合</li></ol><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generateTrees</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span> []*<span class="hljs-title">TreeNode</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> generate(<span class="hljs-number">1</span>, n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 生成start ~ end的数列表</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generate</span><span class="hljs-params">(start, end <span class="hljs-keyword">int</span>)</span> []*<span class="hljs-title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="hljs-comment">// 非法条件拦截</span></span><br><span class="line"><span class="hljs-keyword">if</span> start &gt; end &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> []*TreeNode&#123;<span class="hljs-literal">nil</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line">allNodes := []*TreeNode&#123;&#125;</span><br><span class="line"><span class="hljs-comment">// 遍历n</span></span><br><span class="line"><span class="hljs-keyword">for</span> i := start; i &lt;= end; i++ &#123;</span><br><span class="line">        <span class="hljs-comment">// start ~ i-1可以构造左子树节点</span></span><br><span class="line">leftTrees := generate(start, i<span class="hljs-number">-1</span>)</span><br><span class="line">        <span class="hljs-comment">// i+1 ~ end可以构造右子树节点</span></span><br><span class="line">rightTrees := generate(i+<span class="hljs-number">1</span>, end)</span><br><span class="line"><span class="hljs-keyword">for</span> _, left := <span class="hljs-keyword">range</span> leftTrees &#123;</span><br><span class="line"><span class="hljs-keyword">for</span> _, right := <span class="hljs-keyword">range</span> rightTrees &#123;</span><br><span class="line">                <span class="hljs-comment">// 组装左根右节点</span></span><br><span class="line">root := &amp;TreeNode&#123;Val: i&#125;</span><br><span class="line">root.Left = left</span><br><span class="line">root.Right = right</span><br><span class="line">allNodes = <span class="hljs-built_in">append</span>(allNodes, root)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> allNodes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个整数 &lt;code&gt;n&lt;/code&gt; ，请你生成并返回所有由 &lt;code&gt;n&lt;/code&gt; 个节点组成且节点值从 &lt;code&gt;1&lt;/c
      
    
    </summary>
    
      <category term="algorithm" scheme="https//www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="tree" scheme="https//www.ddhigh.com/tags/tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode98——验证二叉搜索树</title>
    <link href="https//www.ddhigh.com/2022/02/06/validate-binary-search-tree.html"/>
    <id>https//www.ddhigh.com/2022/02/06/validate-binary-search-tree.html</id>
    <published>2022-02-06T12:24:19.000Z</published>
    <updated>2022-12-30T11:23:38.177Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p><p><strong>有效</strong> 二叉搜索树定义如下：</p><p>节点的左子树只包含 <strong>小于</strong> 当前节点的数。<br>节点的右子树只包含 <strong>大于</strong> 当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg" alt="img"></p><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg" alt="img"></p><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,null,null,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>]</span><br><span class="line">输出：false</span><br><span class="line">解释：根节点的值是 <span class="hljs-number">5</span> ，但是右子节点的值是 <span class="hljs-number">4</span> 。</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/validate-binary-search-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/validate-binary-search-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>直接用中序遍历即可。中序遍历可以保证后一个值一定比前一个值大。</p><p>中序遍历处理顺序：左-&gt;根-&gt;右</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 中序遍历，值如果都是升序就满足要求</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(root *TreeNode)</span> <span class="hljs-title">bool</span></span> &#123;</span><br><span class="line">  <span class="hljs-keyword">var</span> (</span><br><span class="line">lastValue = math.MinInt64 <span class="hljs-comment">// 上一个值，初始化时保证是最小值即可，这样只要树节点有值就能大于该值</span></span><br><span class="line">helper    <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span> <span class="hljs-title">bool</span> // 判断指定节点是否大于<span class="hljs-title">lastValue</span></span></span><br><span class="line">)</span><br><span class="line">helper = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span> <span class="hljs-title">bool</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 节点为空，直接返回true</span></span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> !helper(root.Left) &#123; <span class="hljs-comment">// 如果左子树不满足要求则返回false</span></span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> root.Val &lt;= lastValue &#123; <span class="hljs-comment">// 如果当前节点&lt;=上一个节点，则不满足要求（中序遍历本节点一定大于上一个节点）</span></span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">lastValue = root.Val <span class="hljs-comment">// 更新上一个节点</span></span><br><span class="line"><span class="hljs-keyword">if</span> !helper(root.Right) &#123; <span class="hljs-comment">// 检查右子树</span></span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> helper(root)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有效&lt;/strong&gt; 二叉搜索树定义
      
    
    </summary>
    
      <category term="algorithm" scheme="https//www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="tree" scheme="https//www.ddhigh.com/tags/tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode328——奇偶链表</title>
    <link href="https//www.ddhigh.com/2022/02/05/odd-even-linked-list.html"/>
    <id>https//www.ddhigh.com/2022/02/05/odd-even-linked-list.html</id>
    <published>2022-02-05T12:24:19.000Z</published>
    <updated>2022-12-30T11:23:38.177Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定单链表的头节点 head ，将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后返回重新排序的列表。</p><p>第一个节点的索引被认为是 奇数 ， 第二个节点的索引为 偶数 ，以此类推。</p><p>请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致。</p><p>你必须在 O(1) 的额外空间复杂度和 O(n) 的时间复杂度下解决这个问题。</p><p><strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/10/oddeven-linked-list.jpg" alt="img"></p><figure class="highlight accesslog hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: head = <span class="hljs-string">[1,2,3,4,5]</span></span><br><span class="line">输出: <span class="hljs-string">[1,3,5,2,4]</span></span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/10/oddeven2-linked-list.jpg" alt="img"></p><figure class="highlight accesslog hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: head = <span class="hljs-string">[2,1,3,5,6,4,7]</span></span><br><span class="line">输出: <span class="hljs-string">[2,3,6,7,1,5,4]</span></span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/odd-even-linked-list" target="_blank" rel="noopener">https://leetcode-cn.com/problems/odd-even-linked-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/odd-even-linked-list" target="_blank" rel="noopener">https://leetcode-cn.com/problems/odd-even-linked-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>定义2个链表，<code>odd为奇数链表</code>，<code>even为偶数链表</code></li><li>遍历原链表，根据奇偶位置插入<code>odd</code>或者<code>even</code></li><li>连接<code>odd</code>和<code>even</code></li></ol><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 1. 定义以下节点</span></span><br><span class="line"><span class="hljs-comment">//    1. 偶链表头节点，移动节点</span></span><br><span class="line"><span class="hljs-comment">//    2. 奇链表头结点，移动节点</span></span><br><span class="line"><span class="hljs-comment">// 2. 奇链表尾节点.Next = 偶链表头结点</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">oddEvenList</span><span class="hljs-params">(head *ListNode)</span> *<span class="hljs-title">ListNode</span></span> &#123;</span><br><span class="line"><span class="hljs-comment">// 0,1,2个节点时直接返回</span></span><br><span class="line"><span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> || head.Next == <span class="hljs-literal">nil</span> || head.Next.Next == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> head</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> (</span><br><span class="line">oddHead  *ListNode</span><br><span class="line">oddMove  *ListNode</span><br><span class="line">evenHead *ListNode</span><br><span class="line">evenMove *ListNode</span><br><span class="line">)</span><br><span class="line">p := head</span><br><span class="line"><span class="hljs-keyword">for</span> p != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-comment">// 连接奇数节点</span></span><br><span class="line"><span class="hljs-keyword">if</span> oddHead == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">oddHead = p</span><br><span class="line">oddMove = p</span><br><span class="line">&#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">oddMove.Next = p</span><br><span class="line">oddMove = oddMove.Next</span><br><span class="line">&#125;</span><br><span class="line">p = p.Next</span><br><span class="line"><span class="hljs-comment">// 连接偶数节点</span></span><br><span class="line"><span class="hljs-keyword">if</span> p != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> evenHead == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">evenHead = p</span><br><span class="line">evenMove = p</span><br><span class="line">&#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">evenMove.Next = p</span><br><span class="line">evenMove = evenMove.Next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 移动到下一个奇数节点</span></span><br><span class="line"><span class="hljs-keyword">if</span> p != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">p = p.Next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 断开原来的连接</span></span><br><span class="line">oddMove.Next = <span class="hljs-literal">nil</span></span><br><span class="line">evenMove.Next = <span class="hljs-literal">nil</span></span><br><span class="line"></span><br><span class="line">oddMove.Next = evenHead</span><br><span class="line"><span class="hljs-keyword">return</span> oddHead</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定单链表的头节点 head ，将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后返回重新排序的列表。&lt;/p&gt;
&lt;p&gt;第一个节点的
      
    
    </summary>
    
      <category term="algorithm" scheme="https//www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="linklist" scheme="https//www.ddhigh.com/tags/linklist/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode142——环形链表2</title>
    <link href="https//www.ddhigh.com/2022/02/05/linked-list-cycle-ii.html"/>
    <id>https//www.ddhigh.com/2022/02/05/linked-list-cycle-ii.html</id>
    <published>2022-02-05T12:14:56.000Z</published>
    <updated>2022-12-30T11:23:38.177Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>不允许修改 链表。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-4</span>], pos = <span class="hljs-number">1</span></span><br><span class="line">输出：返回索引为 <span class="hljs-number">1</span> 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], pos = <span class="hljs-number">0</span></span><br><span class="line">输出：返回索引为 <span class="hljs-number">0</span> 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/linked-list-cycle-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>参考上一篇<a href="/2022/02/05/linked-list-cycle.md">环形链表</a>，可以利用哈希表存储节点，当再次遇到该节点时，该节点就是成环点。</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 1. 遍历节点存入map</span></span><br><span class="line"><span class="hljs-comment">// 2. 如果节点已存在，则该节点是成环节点</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">detectCycle</span><span class="hljs-params">(head *ListNode)</span> *<span class="hljs-title">ListNode</span></span> &#123;</span><br><span class="line">m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[*ListNode]<span class="hljs-keyword">struct</span>&#123;&#125;)</span><br><span class="line">p := head</span><br><span class="line"><span class="hljs-keyword">for</span> p != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> _, ok := m[p]; ok &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line">m[p] = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">p = p.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><ol><li>快指针走2步，慢指针走1步</li><li>快慢指针相遇时，慢指针走了<code>s</code>个节点，快指针走了<code>2s</code>，同时快指针比慢指针多走了<code>N</code>圈，设环形区间长度为<code>b</code>,因此<code>2s = s+nb</code>，因此<code>s=nb</code>，也就是快慢指针相遇时慢指针走过的距离刚好是环的倍数。</li><li>新起指针指向头结点，和慢指针一起向后走，两点相遇时新指针走了a，慢指针走了a+nb，此时新指针和慢指针相遇，新指针指向成环点</li></ol><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">detectCycle</span><span class="hljs-params">(head *ListNode)</span> *<span class="hljs-title">ListNode</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> || head.Next == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">fast := head</span><br><span class="line">slow := head</span><br><span class="line"><span class="hljs-keyword">for</span> fast != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">slow = slow.Next</span><br><span class="line">fast = fast.Next</span><br><span class="line"><span class="hljs-keyword">if</span> fast != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">fast = fast.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> fast == slow &#123;</span><br><span class="line"><span class="hljs-comment">// 快慢相遇，新起指针指向节点，然后和慢指针一起走，两者相遇点就是成环点</span></span><br><span class="line">ptr := head</span><br><span class="line"><span class="hljs-keyword">for</span> ptr != slow &#123;</span><br><span class="line">ptr = ptr.Next</span><br><span class="line">slow = slow.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> ptr</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。&lt;/p&gt;
&lt;p&gt;如果链表中有某个节点，可以通过连续跟踪 nex
      
    
    </summary>
    
      <category term="algorithm" scheme="https//www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="linklist" scheme="https//www.ddhigh.com/tags/linklist/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode141——环形链表</title>
    <link href="https//www.ddhigh.com/2022/02/05/linked-list-cycle.html"/>
    <id>https//www.ddhigh.com/2022/02/05/linked-list-cycle.html</id>
    <published>2022-02-05T12:09:35.000Z</published>
    <updated>2022-12-30T11:23:38.177Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个链表的头节点 head ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环 ，则返回 true 。 否则，返回 false 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-4</span>], pos = <span class="hljs-number">1</span></span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], pos = <span class="hljs-number">0</span></span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/linked-list-cycle" target="_blank" rel="noopener">https://leetcode-cn.com/problems/linked-list-cycle</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="哈希表法"><a href="#哈希表法" class="headerlink" title="哈希表法"></a>哈希表法</h3><p>利用哈希表存储访问过的节点，如果遍历时节点在哈希表，则有环。</p><blockquote><p>Go语言中map的value为struct可以不占用存储空间。</p></blockquote><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(head *ListNode)</span> <span class="hljs-title">bool</span></span> &#123;</span><br><span class="line">    m := <span class="hljs-keyword">map</span>[*ListNode]<span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    <span class="hljs-keyword">for</span> head != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> _, ok := m[head]; ok &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        m[head] = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        head = head.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快慢指针法"><a href="#快慢指针法" class="headerlink" title="快慢指针法"></a>快慢指针法</h3><ol><li>快指针每次走两步，慢指针走一步，如果相遇则存在环</li></ol><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(head *ListNode)</span> <span class="hljs-title">bool</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> || head.Next == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">fast := head</span><br><span class="line">slow := head</span><br><span class="line"><span class="hljs-keyword">for</span> fast != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">slow = slow.Next</span><br><span class="line">fast = fast.Next <span class="hljs-comment">// 快指针走1步</span></span><br><span class="line"><span class="hljs-keyword">if</span> fast != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">fast = fast.Next <span class="hljs-comment">// 快指针再走1步</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> fast == slow &#123; <span class="hljs-comment">// 相遇了</span></span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个链表的头节点 head ，判断链表中是否有环。&lt;/p&gt;
&lt;p&gt;如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表
      
    
    </summary>
    
      <category term="algorithm" scheme="https//www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="linklist" scheme="https//www.ddhigh.com/tags/linklist/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode92——反转链表 II</title>
    <link href="https//www.ddhigh.com/2022/02/05/reverse-linked-list-ii.html"/>
    <id>https//www.ddhigh.com/2022/02/05/reverse-linked-list-ii.html</id>
    <published>2022-02-05T11:00:00.000Z</published>
    <updated>2022-12-30T11:23:38.177Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。</p><p><strong>示例 1：</strong><br><img src="https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg" alt="示例1"></p><p>输入：head = [1,2,3,4,5], left = 2, right = 4<br>输出：[1,4,3,2,5]</p><p><strong>示例 2：</strong></p><p>输入：head = [5], left = 1, right = 1<br>输出：[5]</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/reverse-linked-list-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-linked-list-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="转数组"><a href="#转数组" class="headerlink" title="转数组"></a>转数组</h3><blockquote><p>大部分的链表题只要未要求原节点上操作，都可以转数组处理，缺点是空间复杂度会额外增加达到O(n)。</p><ol><li>将原链表按顺序转为数组</li><li>遍历数组，翻转left ~ right之间的数组，此处用双指针即可<ol><li>定义left和right指针，交换left和right的值</li><li>两个指针同时向中间移动，left++,right–</li></ol></li><li>将数组构造为链表返回</li></ol></blockquote><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 数组法</span></span><br><span class="line"><span class="hljs-comment">// 1. 链表转换为数组</span></span><br><span class="line"><span class="hljs-comment">// 2. 翻转left ~ right的数据</span></span><br><span class="line"><span class="hljs-comment">// 3. 重新构造链表</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseBetween</span><span class="hljs-params">(head *ListNode, left <span class="hljs-keyword">int</span>, right <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">ListNode</span></span> &#123;</span><br><span class="line">array := convertListToArray(head)</span><br><span class="line">reverseArrayPart(array, left<span class="hljs-number">-1</span>, right<span class="hljs-number">-1</span>)</span><br><span class="line"><span class="hljs-keyword">return</span> buildLinkList(array)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 翻转数组指定区间</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseArrayPart</span><span class="hljs-params">(array []<span class="hljs-keyword">int</span>, left, right <span class="hljs-keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">for</span> left &lt; right &#123;</span><br><span class="line">array[left], array[right] = array[right], array[left]</span><br><span class="line">left++</span><br><span class="line">right--</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 链表构造为数组</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">convertListToArray</span><span class="hljs-params">(head *ListNode)</span> []<span class="hljs-title">int</span></span> &#123;</span><br><span class="line">array := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>)</span><br><span class="line"><span class="hljs-keyword">for</span> head != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">array = <span class="hljs-built_in">append</span>(array, head.Val)</span><br><span class="line">head = head.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> array</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表操作"><a href="#链表操作" class="headerlink" title="链表操作"></a>链表操作</h3><blockquote><p>链表相关的操作主要是要掌握定位任意节点的指针。</p></blockquote><ol><li>定位以下节点<ol><li>leftPrev: 翻转区间开始节点的上一个节点，最终要连接翻转后的头节点，所以需要保留</li><li>rightNext: 翻转区间结束节点的后一个节点，最终要连接到最终链表，所以需要保留</li><li>left和right节点，翻转开始和翻转结束节点</li></ol></li><li>定义子函数翻转left和right，返回right，翻转思路如下<ol><li>定义prev和curr指针，prev初始指向null，curr指向head</li><li>开始迭代，迭代结束条件curr不等于rightNode<ol><li>保存curr的下一个节点<code>next:=curr.Next</code></li><li>此时我们有3个节点的指针，prev,curr,next</li><li>当前节点指向上一个,<code>curr.Next=prev</code></li><li>prev上一个节点指针后移,<code>prev=curr</code></li><li>curr后移,<code>curr=next</code></li></ol></li><li>迭代结束后将<code>curr</code>指向上一个节点<code>curr.Next=prev</code></li></ol></li><li>按以下顺序连接所有节点：leftPrev -&gt; right -&gt; left -&gt; rightNext，边界情况如下：<ol><li>left是头结点，此时leftPrevNode是空，最终结果链表right节点成为新头结点</li><li>right是尾节点，此时rightNextNode是空，无需特殊处理</li><li>left == right，无需翻转</li></ol></li></ol><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseBetween</span><span class="hljs-params">(head *ListNode, left <span class="hljs-keyword">int</span>, right <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">ListNode</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> left == right &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> head</span><br><span class="line">&#125;</span><br><span class="line">leftPrevNode, leftNode, rightNode, rightNextNode := locateNodes(head, left<span class="hljs-number">-1</span>, right<span class="hljs-number">-1</span>)</span><br><span class="line">rightNode = reverse(leftNode, rightNode)</span><br><span class="line"><span class="hljs-comment">// left是头节点，链表连接顺序，right,left,rightNext</span></span><br><span class="line"><span class="hljs-keyword">if</span> leftPrevNode == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">leftNode.Next = rightNextNode</span><br><span class="line"><span class="hljs-keyword">return</span> rightNode</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 正常连接，连接顺序 leftPrevNode-&gt;right-&gt;left-&gt;rightNextNode</span></span><br><span class="line">leftPrevNode.Next = rightNode</span><br><span class="line">leftNode.Next = rightNextNode</span><br><span class="line"><span class="hljs-keyword">return</span> head</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 翻转left ~ right之间的节点</span></span><br><span class="line"><span class="hljs-comment">// 迭代翻转即可</span></span><br><span class="line"><span class="hljs-comment">// p 指向当前节点</span></span><br><span class="line"><span class="hljs-comment">// prev 指向上一个节点</span></span><br><span class="line"><span class="hljs-comment">// next指向p的next节点</span></span><br><span class="line"><span class="hljs-comment">// 如果p == rightNode则结束翻转并返回right</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverse</span><span class="hljs-params">(leftNode *ListNode, rightNode *ListNode)</span> *<span class="hljs-title">ListNode</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">var</span> (</span><br><span class="line">prev *ListNode</span><br><span class="line">p    = leftNode</span><br><span class="line">)</span><br><span class="line"><span class="hljs-keyword">for</span> p != rightNode &#123;</span><br><span class="line">next := p.Next</span><br><span class="line">p.Next = prev <span class="hljs-comment">// p 指向 上一个节点</span></span><br><span class="line">prev = p      <span class="hljs-comment">// 上一个节点后移</span></span><br><span class="line">p = next      <span class="hljs-comment">// p后移</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// p 此时向rightNode，需要连接p和上一个节点</span></span><br><span class="line">p.Next = prev</span><br><span class="line"><span class="hljs-keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 定位</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">locateNodes</span><span class="hljs-params">(head *ListNode, left, right <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(*ListNode, *ListNode, *ListNode, *ListNode)</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">var</span> (</span><br><span class="line">index         = <span class="hljs-number">0</span></span><br><span class="line">prevNode      *ListNode</span><br><span class="line">leftPrevNode  *ListNode</span><br><span class="line">leftNode      *ListNode</span><br><span class="line">rightNode     *ListNode</span><br><span class="line">rightNextNode *ListNode</span><br><span class="line">)</span><br><span class="line"><span class="hljs-keyword">for</span> head != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-comment">// 找到左节点</span></span><br><span class="line"><span class="hljs-keyword">if</span> index == left &#123;</span><br><span class="line">leftPrevNode = prevNode</span><br><span class="line">leftNode = head</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 找到右节点</span></span><br><span class="line"><span class="hljs-keyword">if</span> index == right &#123;</span><br><span class="line">rightNode = head</span><br><span class="line">rightNextNode = head.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 指针移动</span></span><br><span class="line">index++</span><br><span class="line">prevNode = head</span><br><span class="line">head = head.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> leftPrevNode, leftNode, rightNode, rightNextNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &amp;lt;= right 。请你反转从位置 left 到
      
    
    </summary>
    
      <category term="algorithm" scheme="https//www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="linklist" scheme="https//www.ddhigh.com/tags/linklist/"/>
    
  </entry>
  
  <entry>
    <title>算法篇——二分查找</title>
    <link href="https//www.ddhigh.com/2021/12/29/algo-binarysearch.html"/>
    <id>https//www.ddhigh.com/2021/12/29/algo-binarysearch.html</id>
    <published>2021-12-29T10:32:50.000Z</published>
    <updated>2022-12-30T11:23:38.177Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章将学习/复习常用算法和数据结构。希望能够深入浅出的将复杂的知识讲清楚、说明白。</p><p>本文介绍第一个基础算法：二分查找。二分查找算法可以在<code>有序</code>的数组中快速查询指定值。</p><ul><li>要求：有序数组</li><li>时间复杂度：O(logN)</li><li>空间复杂度：O(1)</li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>大家应该玩过数字猜大小的游戏，接下来看看实际过程。</p><p>主持人从1~10选择1个数字，参与者每次猜1个数字，主持人给出提示正确/大了/小了。次数最少的获胜。</p><h3 id="线性查找"><a href="#线性查找" class="headerlink" title="线性查找"></a>线性查找</h3><blockquote><ul><li>主持人选定数字5。</li><li>参与者：10</li><li>主持人：大了</li><li>参与者：9</li><li>主持人：大了</li><li>参与者：8</li><li>主持人：大了</li><li>…</li><li>参与者：5</li><li>主持人：正确</li></ul></blockquote><p>参与者采用线性报数方式，从最大的数字开始报，每次减1直到猜中。上面的例子主持人选的数字是5，参与者猜了6次（10,9,8,7,6,5)。效率是O(N)。</p><p>主持人的<code>大了/小了</code>提示没有利用上，这肯定不是效率最高的方法。</p><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><blockquote><ul><li>主持人选定数字8。</li><li>参与者：5</li><li>主持人：小了</li><li>参与者：7</li><li>主持人：小了</li><li>参与者：8</li><li>主持人：正确</li></ul></blockquote><p>参与者根据主持人的<code>大了/小了</code>提示每次调整猜测范围直到猜中。上面的例子中主持人选的数字是8，参与者猜了3次：</p><ol><li>(0+10)/2 =&gt; 5，小了，所以下一次应该猜 比5大的数字，从 5 ~ 10继续猜</li><li>(5+10)/2 =&gt; 7(8也可以)，小了，所以下一次继续猜比7大的数字，从7~10继续猜</li><li>(7+10)/2 =&gt; 8(9也可以)，正确</li></ol><p>可以看到二分查找法每次都能过滤掉1半的数据，达到了O(logN)的时间复杂度</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>给定一个有序数组，返回指定值的索引，如果有序数组不存在该值，返回-1。</p><p>思路：</p><ol><li>找中间值，(0 + 数组最后一位的所以)/2得到中间值的位置，然后对比中间值和目标值大小</li><li>如果目标值比中间值小，那么目标值在数组前半部分，应该继续查找 0 ~ 数组中间索引-1的这部分</li><li>如果目标值比中间值大，那么目标值在数组后半部分，应该继续查找 数组中间索引+1 ~ 数组结尾的这部分</li></ol><blockquote><p>为什么继续查找时中间索引要+1或者-1移动？</p><p>因为中间值已经比对过了，不满足条件，所以可以直接跳过中间值往前面后者后面一个位置继续查找</p></blockquote><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">fmt.Println(search([]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;, <span class="hljs-number">5</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">search</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>, target <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;</span><br><span class="line">begin := <span class="hljs-number">0</span></span><br><span class="line">end := <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-keyword">for</span> begin &lt;= end &#123; <span class="hljs-comment">// 开始位置不能超过结束位置，超过证明所以数据都查过了</span></span><br><span class="line">midIndex := (begin + end) / <span class="hljs-number">2</span> <span class="hljs-comment">// 中间索引</span></span><br><span class="line">midValue := nums[midIndex]    <span class="hljs-comment">// 中间值</span></span><br><span class="line">fmt.Printf(<span class="hljs-string">"check pos(%v) value(%v)\n"</span>, midIndex, midValue)</span><br><span class="line"><span class="hljs-keyword">if</span> target &lt; midValue &#123; <span class="hljs-comment">// 目标值比中间值小，所以在左边，将end移动到中间索引-1</span></span><br><span class="line">end = midIndex - <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> target &gt; midValue &#123; <span class="hljs-comment">// 右半边，begin移动到中间索引+1</span></span><br><span class="line">begin = midIndex + <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 相等</span></span><br><span class="line"><span class="hljs-keyword">return</span> midIndex</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下</p><figure class="highlight smali hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">check pos(3) value(4)</span><br><span class="line">check pos(5) value(6)</span><br><span class="line">check pos(4) value(5)</span><br><span class="line">4</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本系列文章将学习/复习常用算法和数据结构。希望能够深入浅出的将复杂的知识讲清楚、说明白。&lt;/p&gt;
&lt;p&gt;本文介绍第一个基础算法：二分查找。二分查找算法可以在&lt;code&gt;有序&lt;/code&gt;的数组中快速查询指定值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;要求：有序数组&lt;/li&gt;
&lt;li&gt;时
      
    
    </summary>
    
      <category term="algorithm" scheme="https//www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="binarysearch" scheme="https//www.ddhigh.com/tags/binarysearch/"/>
    
  </entry>
  
  <entry>
    <title>gomonkey私有方法打桩</title>
    <link href="https//www.ddhigh.com/2021/09/18/gomonkey-private-method-stub.html"/>
    <id>https//www.ddhigh.com/2021/09/18/gomonkey-private-method-stub.html</id>
    <published>2021-09-18T07:38:23.000Z</published>
    <updated>2022-12-30T11:23:38.177Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ApplyMethod基于反射实现，无法对私有方法打桩，本文将解决这一问题。</p></blockquote><h2 id="被测代码"><a href="#被测代码" class="headerlink" title="被测代码"></a>被测代码</h2><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">type</span> Dao <span class="hljs-keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 私有方法</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *Dao)</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;</span><br><span class="line">   <span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">"failed"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Method 公有方法</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *Dao)</span> <span class="hljs-title">Method</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;</span><br><span class="line">   <span class="hljs-keyword">return</span> d.method1()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>method1</code>是私有方法，使用<code>ApplyMethod</code>无法打桩</li></ul><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDao_Method</span><span class="hljs-params">(t *testing.T)</span></span> &#123;</span><br><span class="line">   <span class="hljs-comment">// 基于ApplyFunc可以读取到私有方法的地址并进行替换</span></span><br><span class="line">   g := gomonkey.ApplyFunc((*Dao).method1, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(_ *Dao)</span> <span class="hljs-title">error</span></span> &#123;</span><br><span class="line">      <span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">"打桩返回的错误"</span>)</span><br><span class="line">   &#125;)</span><br><span class="line">   <span class="hljs-keyword">defer</span> g.Reset()</span><br><span class="line"></span><br><span class="line">   d := Dao&#123;&#125;</span><br><span class="line">   fmt.Println(d.Method())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h2><p>执行时需要添加<code>-gcflags=-l</code>禁止内联(内联后函数地址发生变化，某些函数会直接转化为语句调用)</p><figure class="highlight asciidoc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-section">=== RUN   TestDao_Method</span></span><br><span class="line">打桩返回的错误</span><br><span class="line"><span class="hljs-bullet">--- </span>PASS: TestDao<span class="hljs-emphasis">_Method (0.00s)</span></span><br><span class="line"><span class="hljs-emphasis">PASS</span></span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>执行测试命令时添加<code>-gcflags=-l</code></li><li><code></code>gomonkey.ApplyFunc<code>需要传递</code>(*Dao).method1`(结构体指针对应的函数)</li><li>被测方法的接收器必须是<code>结构体指针</code>(因为第2步是传递指针)<figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *Dao)</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;</span><br><span class="line">   <span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">"failed"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;ApplyMethod基于反射实现，无法对私有方法打桩，本文将解决这一问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;被测代码&quot;&gt;&lt;a href=&quot;#被测代码&quot; class=&quot;headerlink&quot; title=&quot;被测代码&quot;&gt;&lt;/a&gt;被
      
    
    </summary>
    
      <category term="backend" scheme="https//www.ddhigh.com/categories/backend/"/>
    
      <category term="go" scheme="https//www.ddhigh.com/categories/backend/go/"/>
    
    
      <category term="testing" scheme="https//www.ddhigh.com/tags/testing/"/>
    
  </entry>
  
  <entry>
    <title>PlanUML指南</title>
    <link href="https//www.ddhigh.com/2021/06/04/plantuml-tutorial.html"/>
    <id>https//www.ddhigh.com/2021/06/04/plantuml-tutorial.html</id>
    <published>2021-06-04T07:17:06.000Z</published>
    <updated>2022-12-30T11:23:38.177Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p><strong>统一建模语言</strong>（英语：Unified Modeling Language，缩写 UML）是非专利的第三代<a href="https://zh.wikipedia.org/w/index.php?title=对象建模语言&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">建模</a>和<a href="https://zh.wikipedia.org/wiki/规约语言" target="_blank" rel="noopener">规约语言</a>。UML是一种开放的方法，用于说明、可视化、构建和编写一个正在开发的、面向对象的、软件密集系统的制品的开放方法</p></blockquote><p>编写UML的软件很多，但是基本是可视化的，需要手动编写，本文主要介绍基于文本的UML编写工具——PlantUML。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>PlantUML有以下依赖：</p><ol><li>graphviz</li><li>jdk</li><li>Jetbrains IDE插件(可选，本文推荐)</li></ol><h3 id="安装graphviz"><a href="#安装graphviz" class="headerlink" title="安装graphviz"></a>安装graphviz</h3><p>本文使用<code>Homebrew</code>安装<code>graphviz</code>，终端执行以下命令安装<code>graphviz</code>。</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install graphviz</span><br></pre></td></tr></table></figure><p>安装完毕后查看版本信息。</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dot -v</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight vim hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dot - graphviz <span class="hljs-keyword">version</span> <span class="hljs-number">2.47</span>.<span class="hljs-number">0</span> (<span class="hljs-number">20210316.0004</span>)</span><br><span class="line">libdir = <span class="hljs-string">"/usr/local/Cellar/graphviz/2.47.0/lib/graphviz"</span></span><br><span class="line">Activated plugin library: libgvplugin_dot_layout.<span class="hljs-number">6</span>.dylib</span><br><span class="line">Using layou<span class="hljs-variable">t:</span> <span class="hljs-keyword">do</span><span class="hljs-variable">t:dot_layout</span></span><br><span class="line">Activated plugin library: libgvplugin_core.<span class="hljs-number">6</span>.dylib</span><br><span class="line">Using render: <span class="hljs-keyword">do</span><span class="hljs-variable">t:core</span></span><br><span class="line">Using device: <span class="hljs-keyword">do</span><span class="hljs-variable">t:dot</span>:core</span><br><span class="line">The plugin configuration <span class="hljs-keyword">file</span>:</span><br><span class="line">/usr/local/Cellar/graphviz/<span class="hljs-number">2.47</span>.<span class="hljs-number">0</span>/lib/graphviz/config6</span><br><span class="line">was successfully loaded.</span><br><span class="line"> render:  cairo dot dot_json fig gd json json0 <span class="hljs-keyword">map</span> mp pic pov <span class="hljs-keyword">ps</span> quartz svg tk visio vml vrml xdot xdot_json</span><br><span class="line"> layout:  circo dot fdp neato nop nop1 nop2 osage patchwork sfdp twopi</span><br><span class="line"> textlayout:  textlayout</span><br><span class="line"> device:  bmp canon cgimage <span class="hljs-keyword">cmap</span> cmapx cmapx_np dot dot_json eps exr fig gd gd2 gif <span class="hljs-keyword">gv</span> icns ico <span class="hljs-keyword">imap</span> imap_np ismap jp2 jpe jpeg jpg json json0 mp pct pdf pic pict plain plain-ext png pov <span class="hljs-keyword">ps</span> ps2 psd sgi svg svgz tga tif tiff tk vdx vml vmlz vrml wbmp webp xdot xdot1.<span class="hljs-number">2</span> xdot1.<span class="hljs-number">4</span> xdot_json</span><br><span class="line"> loadimage:  (lib) bmp eps gd gd2 gif jpe jpeg jpg pdf png <span class="hljs-keyword">ps</span> svg webp xbm</span><br></pre></td></tr></table></figure><h3 id="jdk"><a href="#jdk" class="headerlink" title="jdk"></a>jdk</h3><p>本文使用<code>Homebrew</code>安装<code>openjdk</code>即可，终端执行以下命令安装<code>openjdk</code>。</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install openjdk</span><br></pre></td></tr></table></figure><p>安装完毕后查看版本信息。</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openjdk version <span class="hljs-string">"11.0.10"</span> <span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-19</span></span><br><span class="line">OpenJDK Runtime Environment (build <span class="hljs-number">11.0</span><span class="hljs-number">.10</span>+<span class="hljs-number">9</span>)</span><br><span class="line">OpenJDK <span class="hljs-number">64</span>-Bit Server VM (build <span class="hljs-number">11.0</span><span class="hljs-number">.10</span>+<span class="hljs-number">9</span>, mixed mode)</span><br></pre></td></tr></table></figure><h3 id="Jetbrains-IDE插件安装"><a href="#Jetbrains-IDE插件安装" class="headerlink" title="Jetbrains IDE插件安装"></a>Jetbrains IDE插件安装</h3><p>本文以<code>Goland</code>为例。</p><ol><li><p>打开IDE设置，打开<code>Plugins</code>窗口，搜索<code>PlantUML integration</code></p></li><li><p>安装完毕后重启IDE</p></li><li><p>打开IDE设置，搜索<code>plantuml</code>，确保<code>Remote rendering</code>已关闭</p></li></ol><p><img src="https://static.ddhigh.com/blog//2021/06/04/1622792407142095000.png" alt="image-20210604154007098"></p><h2 id="PlantUML语法"><a href="#PlantUML语法" class="headerlink" title="PlantUML语法"></a>PlantUML语法</h2><p>以最常用的时序图、类图、流程图、组件图举例。</p><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><h4 id="Get-Started"><a href="#Get-Started" class="headerlink" title="Get Started"></a>Get Started</h4><ol><li>IDE新建一个空项目，打开项目之后，右键新建文件</li></ol><p><img src="https://static.ddhigh.com/blog//2021/06/04/1622791752260150000.png" alt="image-20210604152912197"></p><ol start="2"><li>选择<code>Sequence</code></li></ol><p><img src="https://static.ddhigh.com/blog//2021/06/04/1622791775795758000.png" alt="image-20210604152935751"></p><ol start="3"><li>PlantUML菜单项说明</li></ol><p><img src="https://static.ddhigh.com/blog//2021/06/04/1622793009802684000.png" alt="image-20210604155009752"></p><ol start="4"><li>以微信网页授权为例编写时序图。</li></ol><figure class="highlight less hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-variable">@startuml</span></span><br><span class="line">'<span class="hljs-attribute">https</span>:<span class="hljs-comment">//plantuml.com/sequence-diagram</span></span><br><span class="line"></span><br><span class="line">'启用自动编号</span><br><span class="line">autonumber</span><br><span class="line">'生命线自动激活</span><br><span class="line">autoactivate on</span><br><span class="line"></span><br><span class="line">actor 用户</span><br><span class="line"></span><br><span class="line">用户 -&gt; 应用服务器: 获取用户信息</span><br><span class="line">应用服务器 -&gt; 微信服务器: 跳转授权链接:(appid,scope,callback)</span><br><span class="line">微信服务器 -&gt; 用户: 请求用户授权</span><br><span class="line">return 允许授权</span><br><span class="line">return 返回授权code</span><br><span class="line">应用服务器 -&gt; 微信服务器: 获取用户access_token(appid,secret,code)</span><br><span class="line">return 返回access_token+openid</span><br><span class="line">应用服务器 -&gt; 微信服务器: 获取用户信息(openid,access_token)</span><br><span class="line">return 用户信息</span><br><span class="line">return 用户信息</span><br><span class="line"></span><br><span class="line"><span class="hljs-variable">@enduml</span></span><br></pre></td></tr></table></figure><ol start="5"><li>渲染效果</li></ol><p><img src="https://static.ddhigh.com/blog//2021/06/04/1622792350734661000.png" alt="image-20210604153910674"></p><h4 id="语法说明"><a href="#语法说明" class="headerlink" title="语法说明"></a>语法说明</h4><h5 id="标记声明"><a href="#标记声明" class="headerlink" title="标记声明"></a>标记声明</h5><figure class="highlight less hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-variable">@startuml</span>和<span class="hljs-variable">@enduml</span>是PlantUML的开始结束标记，无需更改。</span><br><span class="line">autonumber 打开启动编号，也就是每个步骤之前都有数字编号，打开之后整个流程更加清晰</span><br><span class="line">autoactivate on 打开生命线自动激活，需要配合<span class="hljs-built_in">`return`</span>使用</span><br><span class="line">actor 用户 声明<span class="hljs-built_in">`用户`</span>的类型是actor(行为人)</span><br></pre></td></tr></table></figure><h5 id="时序声明"><a href="#时序声明" class="headerlink" title="时序声明"></a>时序声明</h5><ul><li>使用<code>-&gt;</code>来声明一个时序操作，<code>:</code>后面可以附加消息</li><li>使用<code>return</code>来返回消息给调用者</li></ul><h5 id="声明参与者"><a href="#声明参与者" class="headerlink" title="声明参与者"></a>声明参与者</h5><p>默认情况下参与者为矩形，无法看出实际类型。实际应用中，会有数据库、消息队列等等参与者，使用以下关键字来改变参与者的图例。</p><figure class="highlight routeros hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">actor 用户</span><br><span class="line">database 数据库</span><br><span class="line">queue 消息队列</span><br></pre></td></tr></table></figure><p><img src="https://static.ddhigh.com/blog//2021/06/04/1622792920216896000.png" alt="image-20210604154840162"></p><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p>类图是UML中非常重要的一种类型，能够在实际编码之前为我们提供OOP的详细设计。</p><h4 id="Get-Started-1"><a href="#Get-Started-1" class="headerlink" title="Get Started"></a>Get Started</h4><ol><li>IDE新建一个空项目，打开项目之后，右键新建文件</li></ol><p><img src="https://static.ddhigh.com/blog//2021/06/04/1622791752260150000.png" alt="image-20210604152912197"></p><ol start="2"><li>选择<code>Class</code></li></ol><p><img src="https://static.ddhigh.com/blog/2021/06/04/1622793181374871000.png" alt="image-20210604155301322"></p><ol start="3"><li>以一个上传类为例编写类图</li></ol><figure class="highlight asciidoc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line"><span class="hljs-emphasis">'https://plantuml.com/class-diagram</span></span><br><span class="line"><span class="hljs-emphasis"></span></span><br><span class="line"><span class="hljs-emphasis">namespace com.ddhigh.uploader &#123;</span></span><br><span class="line"><span class="hljs-emphasis"> interface Uploader &#123;</span></span><br><span class="line"><span class="hljs-emphasis">  + String Upload(String filename) Throws IOException</span></span><br><span class="line"><span class="hljs-emphasis"> &#125;</span></span><br><span class="line"><span class="hljs-emphasis"></span></span><br><span class="line"><span class="hljs-emphasis"> namespace qiniu &#123;</span></span><br><span class="line"><span class="hljs-emphasis">  class QiniuUploader implements Uploader &#123;</span></span><br><span class="line"><span class="hljs-emphasis">- client: qiniu.Client</span></span><br><span class="line"><span class="hljs-emphasis">--</span></span><br><span class="line"><span class="hljs-emphasis">+ String Upload(String filename) Throws IOException</span></span><br><span class="line"><span class="hljs-emphasis">  &#125;</span></span><br><span class="line"><span class="hljs-emphasis">  QiniuUploader *-- qiniu.Client</span></span><br><span class="line"><span class="hljs-emphasis"> &#125;</span></span><br><span class="line"><span class="hljs-emphasis"></span></span><br><span class="line"><span class="hljs-emphasis"> package aliyun &#123;</span></span><br><span class="line"><span class="hljs-emphasis">  class AliyunUploader implements Uploader &#123;</span></span><br><span class="line"><span class="hljs-emphasis">- client: aliyun.Client</span></span><br><span class="line"><span class="hljs-emphasis">--</span></span><br><span class="line"><span class="hljs-emphasis">+ String Upload(String filename) Throws IOException</span></span><br><span class="line"><span class="hljs-emphasis">  &#125;</span></span><br><span class="line"><span class="hljs-emphasis">  AliyunUploader *-- aliyun.Client</span></span><br><span class="line"><span class="hljs-emphasis"> &#125;</span></span><br><span class="line"><span class="hljs-emphasis"></span></span><br><span class="line"><span class="hljs-emphasis"> class UploaderFacade &#123;</span></span><br><span class="line"><span class="hljs-emphasis">  - uploaders: List&lt;Uploader&gt;</span></span><br><span class="line"><span class="hljs-emphasis">  --</span></span><br><span class="line"><span class="hljs-emphasis">  + List&lt;String&gt; Upload(String filename) Throws IOException</span></span><br><span class="line"><span class="hljs-emphasis"> &#125;</span></span><br><span class="line"><span class="hljs-emphasis"> UploaderFacade o-- Uploader</span></span><br><span class="line"><span class="hljs-emphasis">&#125;</span></span><br><span class="line"><span class="hljs-emphasis"></span></span><br><span class="line"><span class="hljs-emphasis">@enduml</span></span><br></pre></td></tr></table></figure><ol start="4"><li>渲染效果</li></ol><p><img src="https://static.ddhigh.com/blog/2021/06/04/1622793501066543000.png" alt="image-20210604155821009"></p><h5 id="语法说明-1"><a href="#语法说明-1" class="headerlink" title="语法说明"></a>语法说明</h5><h5 id="包"><a href="#包" class="headerlink" title="包"></a>包</h5><p>建议使用<code>namespace</code>关键字声明包，<code>package</code>声明的包内的类名必须全局唯一(无视package)，而<code>namespace</code>只要求该<code>namespace</code>内唯一即可。</p><h5 id="class-interface"><a href="#class-interface" class="headerlink" title="class/interface"></a>class/interface</h5><p>与实际编程语言几乎无差别，比如上面例子中采用的是java语法。</p><h5 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h5><p>PlantUML支持3种可见性：</p><ul><li><code>-</code> 私有级别 <code>private</code></li><li><code>#</code> 保护级别 <code>protected</code></li><li><code>+</code> 公有级别 <code>public</code></li></ul><h5 id="元素关系"><a href="#元素关系" class="headerlink" title="元素关系"></a>元素关系</h5><p>PlantUML主要有以下3种关系：</p><ol><li>扩展: 包含<code>implements</code>和<code>extends</code></li><li>聚合: 使用<code>o--</code>，<code>左边</code>的包含<code>右边</code>的</li><li>组合: 使用<code>*--</code>,<code>左边</code>的依赖<code>右边</code>的</li></ol><blockquote><p>组合和聚合的区别：(以上面的图为例)</p><ol><li>组合：QiniuUploader必须依赖Client才能提供上传功能，组合一般是1对1的。</li><li>聚合：UploadFacade可以依赖多个Uploader实例，也可以依赖0个实例(只是这时候不会有文件上传了)，聚合一般是1对多的。</li></ol></blockquote><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p>在梳理复杂业务逻辑时，善用流程图能帮我们更加清晰地梳理清楚，也方便我们和其他人员进行沟通（非开发人员基本看不懂代码）。</p><h4 id="Get-Started-2"><a href="#Get-Started-2" class="headerlink" title="Get Started"></a>Get Started</h4><ol><li>IDE新建一个空项目，打开项目之后，右键新建文件</li></ol><p><img src="https://static.ddhigh.com/blog//2021/06/04/1622791752260150000.png" alt="image-20210604152912197"></p><ol start="2"><li>新建<code>Activity</code>类型文件</li></ol><p><img src="https://static.ddhigh.com/blog/2021/06/04/1622794169645334000.png" alt="image-20210604160929588"></p><ol start="3"><li>下面以一个<code>授权获取用户openid并插入数据库，然后查询用户好友进行消息推送</code>的场景编写流程图</li></ol><figure class="highlight less hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-variable">@startuml</span></span><br><span class="line">'<span class="hljs-attribute">https</span>:<span class="hljs-comment">//plantuml.com/activity-diagram-beta</span></span><br><span class="line"></span><br><span class="line">start</span><br><span class="line">:使用code,appid,secret请求微信服务器获取access_token和openid;</span><br><span class="line">:使用<span class="hljs-selector-tag">access_token</span>和<span class="hljs-selector-tag">openid</span>请求微信服务器获取用户信息;</span><br><span class="line">:查询数据库<span class="hljs-selector-tag">openid</span>是否存在;</span><br><span class="line"><span class="hljs-selector-tag">if</span> (数据库查询失败?) <span class="hljs-selector-tag">then</span> (是)</span><br><span class="line"><span class="hljs-selector-tag">stop</span></span><br><span class="line"><span class="hljs-selector-tag">elseif</span> (用户已存在?) <span class="hljs-selector-tag">then</span> (是)</span><br><span class="line">:更新用户信息;</span><br><span class="line"><span class="hljs-selector-tag">else</span> (否)</span><br><span class="line">:新建用户并绑定<span class="hljs-selector-tag">openid</span>;</span><br><span class="line"><span class="hljs-selector-tag">endif</span></span><br><span class="line"></span><br><span class="line">:获取用户好友列表;</span><br><span class="line"><span class="hljs-selector-tag">while</span>(好友列表遍历完成?) <span class="hljs-selector-tag">is</span> (否)</span><br><span class="line">:推送消息给好友;</span><br><span class="line"><span class="hljs-selector-tag">endwhile</span>(是)</span><br><span class="line"><span class="hljs-selector-tag">stop</span></span><br><span class="line"></span><br><span class="line">@<span class="hljs-selector-tag">enduml</span></span><br></pre></td></tr></table></figure><ol start="4"><li>渲染效果</li></ol><p><img src="https://static.ddhigh.com/blog/2021/06/04/1622794522917043000.png" alt="image-20210604161522881"></p><h4 id="语法说明-2"><a href="#语法说明-2" class="headerlink" title="语法说明"></a>语法说明</h4><ul><li><p>开始和结束: 使用<code>start</code>和<code>stop</code></p></li><li><p>处理语句: 使用<code>:</code>和<code>;</code>包裹该流程</p></li><li>条件判断: 使用<code>if</code>,<code>elseif</code>,<code>else</code>,<code>endif</code>,<code>then</code></li><li>循环语句: 使用<code>while</code>,<code>is</code>,<code>endwhile</code>编写</li></ul><h3 id="组件图"><a href="#组件图" class="headerlink" title="组件图"></a>组件图</h3><p>现阶段组件化MVVM框架大行其道，具有代表性的有<code>Vue</code>,<code>React</code>和<code>Angular</code>。我们可以使用组件图来绘制组件关系，简单易懂。</p><h5 id="Get-Started-3"><a href="#Get-Started-3" class="headerlink" title="Get Started"></a>Get Started</h5><ol><li>IDE新建一个空项目，打开项目之后，右键新建文件</li></ol><p><img src="https://static.ddhigh.com/blog//2021/06/04/1622791752260150000.png" alt="image-20210604152912197"></p><ol start="2"><li>选择<code>Component</code></li></ol><p><img src="https://static.ddhigh.com/blog/2021/06/04/1622794820895677000.png" alt="image-20210604162020830"></p><ol start="3"><li>以微信首页聊天列表为例绘制组件关系图</li></ol><figure class="highlight less hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-variable">@startuml</span></span><br><span class="line">'<span class="hljs-attribute">https</span>:<span class="hljs-comment">//plantuml.com/component-diagram</span></span><br><span class="line"></span><br><span class="line">package widgets &#123;</span><br><span class="line"> <span class="hljs-selector-attr">[SearchBar]</span> <span class="hljs-selector-tag">--</span>&gt; <span class="hljs-selector-attr">[Text]</span></span><br><span class="line"> <span class="hljs-selector-attr">[SearchBar]</span> <span class="hljs-selector-tag">--</span>&gt; <span class="hljs-selector-attr">[Icon]</span></span><br><span class="line"> <span class="hljs-selector-attr">[NavigationBar]</span> <span class="hljs-selector-tag">--</span>&gt; <span class="hljs-selector-attr">[Text]</span></span><br><span class="line"> <span class="hljs-selector-attr">[NavigationBar]</span> <span class="hljs-selector-tag">--</span>&gt; <span class="hljs-selector-attr">[Icon]</span></span><br><span class="line"> </span><br><span class="line"> <span class="hljs-selector-attr">[ListView]</span> <span class="hljs-selector-tag">--</span>&gt; <span class="hljs-selector-attr">[ListItem]</span></span><br><span class="line"> <span class="hljs-selector-attr">[ListItem]</span> <span class="hljs-selector-tag">--</span>&gt; <span class="hljs-selector-attr">[Image]</span></span><br><span class="line"> <span class="hljs-selector-attr">[ListItem]</span> <span class="hljs-selector-tag">--</span>&gt; <span class="hljs-selector-attr">[Text]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package routes &#123;</span><br><span class="line"> <span class="hljs-selector-attr">[Home]</span> <span class="hljs-selector-tag">--</span>&gt; <span class="hljs-selector-attr">[NavigationBar]</span></span><br><span class="line"> <span class="hljs-selector-attr">[Home]</span> <span class="hljs-selector-tag">--</span>&gt; <span class="hljs-selector-attr">[SearchBar]</span></span><br><span class="line"> <span class="hljs-selector-attr">[Home]</span> <span class="hljs-selector-tag">--</span>&gt; <span class="hljs-selector-attr">[ListView]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-variable">@enduml</span></span><br></pre></td></tr></table></figure><ol start="4"><li>渲染效果</li></ol><p><img src="https://static.ddhigh.com/blog/2021/06/04/1622795518286015000.png" alt="image-20210604162521451"></p><blockquote><p>依赖关系如下：</p><ul><li>首页: 导航栏, 搜索框，列表</li><li>导航栏: 文本，图标</li><li>搜索框: 文本，图标</li><li>列表: 列表项</li><li>列表项: 文本，图片</li></ul></blockquote><h5 id="语法说明-3"><a href="#语法说明-3" class="headerlink" title="语法说明"></a>语法说明</h5><ul><li>package 声明包，同一个包内的组件是类似地位</li><li><code>[组件名]</code>声明组件，<code>组件名</code>在单个文件内是唯一的</li><li><code>--&gt;</code> 声明依赖关系，<code>左边</code>依赖<code>右边</code></li></ul><p>(完)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;统一建模语言&lt;/strong&gt;（英语：Unified Modeling Language，缩写 U
      
    
    </summary>
    
      <category term="devtools" scheme="https//www.ddhigh.com/categories/devtools/"/>
    
    
  </entry>
  
  <entry>
    <title>Golang程序设计——函数</title>
    <link href="https//www.ddhigh.com/2021/03/17/golang-function.html"/>
    <id>https//www.ddhigh.com/2021/03/17/golang-function.html</id>
    <published>2021-03-17T02:22:36.000Z</published>
    <updated>2022-12-30T11:23:38.177Z</updated>
    
    <content type="html"><![CDATA[<p>本文学习Go语言函数知识。函数是基本的代码块，用于执行一个任务。在Go语言中，函数可以接收数量不固定的参数，也可以返回多个结果。</p><h2 id="函数结构"><a href="#函数结构" class="headerlink" title="函数结构"></a>函数结构</h2><p>在编程领域，函数向编译器和开发者提供了有关的信息，这些信息指明了函数该接收什么样的输入以及会产生什么样的输出。这些信息是通过函数第一行提供的，第一行称为函数签名。</p><p>Go语言声明函数语法如下：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> 函数名称<span class="hljs-params">(参数名 参数类型)</span> <span class="hljs-params">(返回值名称 返回值类型)</span></span> &#123;</span><br><span class="line">  <span class="hljs-comment">// 函数体</span></span><br><span class="line">  <span class="hljs-keyword">return</span>语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>参数名在参数类型前面，如<code>a int</code>，这一点和其他语言是不同的</li><li>函数参数数量可以不固定，但是只允许最后一个参数数量不固定，而且必须是同种类型</li><li>返回值名称不是必须的，但是参数名是必须写的</li><li>有返回值的函数，函数体内必须包含return语句</li></ol><p>示例：函数定义与调用</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum</span><span class="hljs-params">(a, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="hljs-string">"1+2=%d\n"</span>, sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Go语言中，如果多个参数或多个返回值类型相同，只需要在最后一个参数或返回值声明类型。</p><p>例如下面的函数签名在Go语言中是合法的。</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum2</span><span class="hljs-params">(a, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(c, d <span class="hljs-keyword">int</span>)</span></span></span><br></pre></td></tr></table></figure><h2 id="不定参数函数"><a href="#不定参数函数" class="headerlink" title="不定参数函数"></a>不定参数函数</h2><p>不定参数也就是数量不固定的参数。例如C语言中的printf函数就是一个典型的不定参数函数。Go语言支持不定参数函数，但是不定参数的类型必须相同。要声明不定参数，需要使用3个点(…)。</p><p>示例：不定参数的加法函数</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum</span><span class="hljs-params">(nums ...<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;</span><br><span class="line">total := <span class="hljs-number">0</span></span><br><span class="line"><span class="hljs-keyword">for</span> _, n := <span class="hljs-keyword">range</span> nums &#123;</span><br><span class="line">total += n</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> total</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="hljs-string">"1+2+3+4=%d\n"</span>, sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在sum函数中，nums是一个包含所有参数的切片。</p><h2 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h2><h3 id="多返回值"><a href="#多返回值" class="headerlink" title="多返回值"></a>多返回值</h3><p>在Go语言中，函数能声明多个返回值，在这种情况下，return可以返回多个结果。函数调用者可通过多变量声明接收多个返回值。</p><p>示例：多返回值函数</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> (</span><br><span class="line"><span class="hljs-string">"errors"</span></span><br><span class="line"><span class="hljs-string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">div</span><span class="hljs-params">(a, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, error)</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> b == <span class="hljs-number">0</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, errors.New(<span class="hljs-string">"b is zero"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> a / b, <span class="hljs-literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">ret, err := div(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>)</span><br><span class="line"><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="hljs-keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="hljs-string">"2/1=%d\n"</span>, ret)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="命名返回值"><a href="#命名返回值" class="headerlink" title="命名返回值"></a>命名返回值</h3><p>命名返回值让函数能够在返回前将返回值赋给命名变量，这种设计有利于提高程序可读性。要指定命名返回值，可在函数签名的返回值类型前面添加变量名。</p><p>示例：命名返回值函数</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> (</span><br><span class="line"><span class="hljs-string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum</span><span class="hljs-params">(a, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(total <span class="hljs-keyword">int</span>)</span></span> &#123;</span><br><span class="line">total = a + b</span><br><span class="line"><span class="hljs-keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="hljs-string">"1+2=%d\n"</span>, sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用命名返回值后，return关键字可以单独出现，当然，return关键字继续返回结果值也是合法的。</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum</span><span class="hljs-params">(a, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(total <span class="hljs-keyword">int</span>)</span></span> &#123;</span><br><span class="line">total = a + b</span><br><span class="line"><span class="hljs-keyword">return</span> total</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><p>在Go语言中，函数是一种数据类型，可以将函数赋值给变量、或者作为参数传递，也可以作为返回值返回。</p><p>示例：将函数作为变量、参数、返回值。</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line"><span class="hljs-comment">// 函数作为变量</span></span><br><span class="line">sum := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(a, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="hljs-string">"1+1=%d\n"</span>, sum(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>))</span><br><span class="line"><span class="hljs-comment">// 函数作为参数</span></span><br><span class="line">sum2(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(total <span class="hljs-keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="hljs-string">"1+1=%d\n"</span>, total)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="hljs-comment">// 函数作为返回值</span></span><br><span class="line">totalFn := sum3(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)</span><br><span class="line">fmt.Printf(<span class="hljs-string">"1+1=%d\n"</span>, totalFn())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum2</span><span class="hljs-params">(a, b <span class="hljs-keyword">int</span>, callback <span class="hljs-keyword">func</span>(<span class="hljs-keyword">int</span>)</span>)</span> &#123;</span><br><span class="line">total := a + b</span><br><span class="line">callback(total)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum3</span><span class="hljs-params">(a, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匿名函数、闭包、延迟执行函数"><a href="#匿名函数、闭包、延迟执行函数" class="headerlink" title="匿名函数、闭包、延迟执行函数"></a>匿名函数、闭包、延迟执行函数</h2><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>匿名函数指没有名称的函数，只有函数签名（参数和返回值声明）和函数体，匿名函数经常用于回调、闭包、临时函数等。</p><p>示例：利用匿名函数实现事件总线。</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">emitter := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span>)</span></span><br><span class="line">addEventListener(emitter, <span class="hljs-string">"event1"</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="hljs-string">"event1 called"</span>)</span><br><span class="line">&#125;)</span><br><span class="line">emit(emitter, <span class="hljs-string">"event2"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 添加事件监听器</span></span><br><span class="line"><span class="hljs-comment">// emitter 事件总线</span></span><br><span class="line"><span class="hljs-comment">// event 事件名</span></span><br><span class="line"><span class="hljs-comment">// callback 回调函数</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addEventListener</span><span class="hljs-params">(emitter <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">func</span>()</span>, <span class="hljs-title">event</span> <span class="hljs-title">string</span>, <span class="hljs-title">callback</span> <span class="hljs-title">func</span><span class="hljs-params">()</span>)</span> &#123;</span><br><span class="line">emitter[event] = callback</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 触发事件</span></span><br><span class="line"><span class="hljs-comment">// emitter 事件总线</span></span><br><span class="line"><span class="hljs-comment">// event 事件名</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">emit</span><span class="hljs-params">(emitter <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">func</span>()</span>, <span class="hljs-title">event</span> <span class="hljs-title">string</span>)</span> &#123;</span><br><span class="line">callback, ok := emitter[event]</span><br><span class="line"><span class="hljs-keyword">if</span> ok &#123;</span><br><span class="line">callback()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main函数调用addEventListener时传入的第三个函数即为匿名函数。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包可以理解为定义在一个函数内部的函数。在本质上，闭包是函数和其引用环境的组合体。引用环境即使在外部函数执行结束也不会被回收，因此可以利用闭包保存保存执行环境。</p><p>示例：利用闭包提供唯一ID生成器。</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">s1 := sequenceId()</span><br><span class="line">s2 := sequenceId()</span><br><span class="line">fmt.Printf(<span class="hljs-string">"s1 -&gt; %v\n"</span>, s1())</span><br><span class="line">fmt.Printf(<span class="hljs-string">"s1 -&gt; %v\n"</span>, s1())</span><br><span class="line">fmt.Printf(<span class="hljs-string">"s2 -&gt; %v\n"</span>, s2())</span><br><span class="line">fmt.Printf(<span class="hljs-string">"s2 -&gt; %v\n"</span>, s2())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sequenceId</span><span class="hljs-params">()</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">var</span> id <span class="hljs-keyword">int</span></span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;</span><br><span class="line">id++</span><br><span class="line"><span class="hljs-keyword">return</span> id</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1 -&gt; <span class="hljs-number">1</span></span><br><span class="line">s1 -&gt; <span class="hljs-number">2</span></span><br><span class="line">s2 -&gt; <span class="hljs-number">1</span></span><br><span class="line">s2 -&gt; <span class="hljs-number">2</span></span><br></pre></td></tr></table></figure><p>函数sequenceId定义了一个局部变量id，并返回了一个子函数，子函数内部访问了外部的id，因此这构成一个典型的闭包。在前面的内容中我们学习过变量作用域，内部总是可以访问外部的变量或常量，而外部无法访问内部的变量或常量。此外，由于变量id被子函数使用，因此在sequenceId函数返回后，id也不会被销毁。</p><p>每调用一次sequenceId函数都会返回一个新的子函数以及对应的id，因此s1和s2之间的输出互不影响。</p><blockquote><p>注意：由于闭包会导致被引用的变量无法销毁，因此需要注意使用，避免产生内存泄漏。</p></blockquote><h3 id="延迟执行函数"><a href="#延迟执行函数" class="headerlink" title="延迟执行函数"></a>延迟执行函数</h3><p>在实际编程中往往会打开一些资源，例如文件、网络连接等等，这些资源在使用完毕时（无论是正常关闭或者函数异常）需要主动关闭，当函数的结束分支太多或者逻辑比较复杂时容易发生忘记关闭的情况导致资源泄漏。</p><p>Go语言提供了defer关键字用来延迟执行一个函数，一般使用该函数延迟关闭资源。多个defer语句会按照先进后出的方式执行，也就是最后声明的最先执行，典型的栈结构。</p><p>示例：defer执行顺序。</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">defer</span> f1()</span><br><span class="line"><span class="hljs-keyword">defer</span> f2()</span><br><span class="line">fmt.Println(<span class="hljs-string">"call main"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="hljs-string">"call f1"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">"defer call f2"</span>)</span><br><span class="line">fmt.Println(<span class="hljs-string">"call f2"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">call</span> <span class="hljs-keyword">main</span></span><br><span class="line"><span class="hljs-keyword">call</span> f2</span><br><span class="line">defer <span class="hljs-keyword">call</span> f2</span><br><span class="line"><span class="hljs-keyword">call</span> f1</span><br></pre></td></tr></table></figure><ol><li><p>第一行输出call main是因为main函数中只有一个非defer语句，因此call main最先执行</p></li><li><p>第二行输出call f2是因为f2函数内部有一个非defer语句</p></li><li><p>第三行输出defer call f2是因为f2函数的fmt.Println(“call f2”)执行完毕后才能执行defer</p></li><li><p>第四行输出call f1是因为defer f1()最先声明因此最后执行</p></li></ol><p>示例：基于defer和闭包构造一个函数执行耗时记录器。</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> (</span><br><span class="line"><span class="hljs-string">"fmt"</span></span><br><span class="line"><span class="hljs-string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;</span><br><span class="line">Name <span class="hljs-keyword">string</span></span><br><span class="line">Age  <span class="hljs-keyword">int</span></span><br><span class="line">Sex  <span class="hljs-keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">defer</span> spendTime()()</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">fmt.Println(<span class="hljs-string">"call main"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">spendTime</span><span class="hljs-params">()</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">startAt := time.Now()</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">fmt.Println(time.Since(startAt))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">call</span> <span class="hljs-keyword">main</span></span><br><span class="line"><span class="hljs-number">1.002345498</span>s</span><br></pre></td></tr></table></figure><p>spendTime()会返回一个闭包，因此定义defer时会初始化startAt为当前时间，defer执行时会执行闭包函数得到函数耗时。main函数为了测试方便休眠了一秒钟，因此可以看到输出是超过1秒的。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文介绍了如何在Go语言中使用函数。包括不定参数函数、多返回值和命名返回值函数以及将函数作为类型使用的方法，最后介绍了匿名函数、闭包和延迟执行函数。接下来的内容中将介绍Go语言中的结构体。</p><p><img src="https://static.ddhigh.com/blog/2021-03-09-162926-2.png" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文学习Go语言函数知识。函数是基本的代码块，用于执行一个任务。在Go语言中，函数可以接收数量不固定的参数，也可以返回多个结果。&lt;/p&gt;
&lt;h2 id=&quot;函数结构&quot;&gt;&lt;a href=&quot;#函数结构&quot; class=&quot;headerlink&quot; title=&quot;函数结构&quot;&gt;&lt;/a&gt;函数
      
    
    </summary>
    
      <category term="backend" scheme="https//www.ddhigh.com/categories/backend/"/>
    
      <category term="go" scheme="https//www.ddhigh.com/categories/backend/go/"/>
    
    
  </entry>
  
  <entry>
    <title>Golang程序设计——数据容器</title>
    <link href="https//www.ddhigh.com/2021/03/09/golang-data-container.html"/>
    <id>https//www.ddhigh.com/2021/03/09/golang-data-container.html</id>
    <published>2021-03-09T08:21:34.000Z</published>
    <updated>2022-12-30T11:23:38.177Z</updated>
    
    <content type="html"><![CDATA[<p>本文学习Go语言数据容器、包括数组、切片和映射。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是一个数据集合，常用于存储用数字索引的同类型数据。Go语言的数组调用函数时使用的是值传递，因此形参会拷贝一份实参的值。</p><p>在Go语言中，声明数组需要同时指定长度和数据类型，数组长度是其类型的一部分，因此<code>[5]int</code>和<code>[1]int</code>是两种类型。</p><p>Go语言可以对数组进行写入、读取、删除、遍历等操作。</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line"><span class="hljs-comment">// 声明数组并指明长度，不初始化，因此a的5个元素为int类型的零值（0）</span></span><br><span class="line"><span class="hljs-keyword">var</span> a [<span class="hljs-number">5</span>]<span class="hljs-keyword">int</span></span><br><span class="line"><span class="hljs-comment">// 声明数组并指明长度，并初始化4个元素，因此b的最后1个元素为int类型零值（0）</span></span><br><span class="line"><span class="hljs-keyword">var</span> b = [<span class="hljs-number">5</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;</span><br><span class="line"><span class="hljs-comment">// 声明数组，不指明长度，编译器会根据值数量推导长度为4</span></span><br><span class="line"><span class="hljs-keyword">var</span> c = [...]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;</span><br><span class="line"><span class="hljs-comment">// 数组写入</span></span><br><span class="line">a[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span></span><br><span class="line">a[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-comment">// 数组读取</span></span><br><span class="line">fmt.Printf(<span class="hljs-string">"a[0]=%d\n"</span>, a[<span class="hljs-number">0</span>])</span><br><span class="line"><span class="hljs-comment">// 数组删除（赋零值）</span></span><br><span class="line">a[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span></span><br><span class="line"><span class="hljs-comment">// 数组的遍历</span></span><br><span class="line"><span class="hljs-keyword">for</span> index, value := <span class="hljs-keyword">range</span> c &#123;</span><br><span class="line">fmt.Printf(<span class="hljs-string">"c[%d]=%d\n"</span>, index, value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 输出b</span></span><br><span class="line">fmt.Printf(<span class="hljs-string">"b=%v\n"</span>, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><h3 id="使用切片"><a href="#使用切片" class="headerlink" title="使用切片"></a>使用切片</h3><p>在Go语言中，数组是一个重要的类型，但是使用切片的情况更多。切片是底层数组中的一个连续片段，因此数组支持的特性切片也全部支持，必须顺序遍历、通过索引访问元素等等。</p><p>为何使用切片的情况更多呢？主要是因为Go语言的数组不支持自动扩容，而且不支持删除元素，更重要的是Go语言数组是值类型，切片是引用类型，在向函数传参时切片拥有更好的性能。</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line"><span class="hljs-comment">// 声明一个大小为0的int类型切片</span></span><br><span class="line"><span class="hljs-keyword">var</span> a = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>)</span><br><span class="line"><span class="hljs-comment">// 添加三个元素</span></span><br><span class="line">a = <span class="hljs-built_in">append</span>(a, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</span><br><span class="line">fmt.Println(a)</span><br><span class="line"><span class="hljs-comment">// 遍历元素</span></span><br><span class="line"><span class="hljs-keyword">for</span> index, value := <span class="hljs-keyword">range</span> a &#123;</span><br><span class="line">fmt.Printf(<span class="hljs-string">"a[%d]=%d\n"</span>, index, value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 声明一个大小为4的切片</span></span><br><span class="line"><span class="hljs-keyword">var</span> b = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">4</span>)</span><br><span class="line"><span class="hljs-comment">// 将a的元素复制到b</span></span><br><span class="line"><span class="hljs-built_in">copy</span>(b, a)</span><br><span class="line"><span class="hljs-comment">// 删除指定下标的元素</span></span><br><span class="line">a = <span class="hljs-built_in">append</span>(a[:<span class="hljs-number">1</span>], a[<span class="hljs-number">2</span>:]...)</span><br><span class="line">fmt.Printf(<span class="hljs-string">"a=%v\n"</span>, a)</span><br><span class="line">fmt.Printf(<span class="hljs-string">"b=%v\n"</span>, b)</span><br><span class="line"><span class="hljs-comment">// 使用值初始化切片</span></span><br><span class="line"><span class="hljs-keyword">var</span> c = []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;</span><br><span class="line">fmt.Printf(<span class="hljs-string">"c=%v\n"</span>, c)</span><br><span class="line"><span class="hljs-comment">// 只定义，不初始化切片</span></span><br><span class="line"><span class="hljs-keyword">var</span> d []<span class="hljs-keyword">int</span></span><br><span class="line">d = <span class="hljs-built_in">append</span>(d, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</span><br><span class="line">fmt.Printf(<span class="hljs-string">"d=%v\n"</span>, d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明切片可以不使用make初始化，append也不会报错。</p><h3 id="运行时结构"><a href="#运行时结构" class="headerlink" title="运行时结构"></a>运行时结构</h3><p>切片运行时结构如下：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">type</span> slice <span class="hljs-keyword">struct</span> &#123;</span><br><span class="line">array unsafe.Pointer</span><br><span class="line"><span class="hljs-built_in">len</span>   <span class="hljs-keyword">int</span></span><br><span class="line"><span class="hljs-built_in">cap</span>   <span class="hljs-keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>array是底层数组</p></li><li><p>len是数组大小，可以通过len函数获取</p></li><li><p>cap是数组容量，可以通过cap函数获取</p></li></ol><p>make函数创建切片有两种写法：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">// 1</span></span><br><span class="line"><span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>) <span class="hljs-comment">// 2</span></span><br></pre></td></tr></table></figure><ol><li><p>声明了一个长度为0的切片，此时len为0，cap也为0</p></li><li><p>声明一个长度为0，容量为8的切片，此时len为0，cap为8</p></li></ol><h3 id="追加元素"><a href="#追加元素" class="headerlink" title="追加元素"></a>追加元素</h3><p>Go语言提供append函数追加元素到切片中，append会在必要时扩容底层数组。扩容规则如下：</p><ol><li><p>新容量小于1024时，每次扩容2倍。例如现有容量为2，扩容后为4</p></li><li><p>新容量大于1024时，每次扩容1.25倍。例如现有容量为1024，扩容后为1280</p></li></ol><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line"><span class="hljs-comment">// 直接使用值初始化切片</span></span><br><span class="line"><span class="hljs-keyword">var</span> a = []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;</span><br><span class="line">a = <span class="hljs-built_in">append</span>(a, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>)</span><br><span class="line"><span class="hljs-keyword">var</span> b = []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">9</span>, <span class="hljs-number">10</span>&#125;</span><br><span class="line"><span class="hljs-comment">// 追加b的全部元素到a</span></span><br><span class="line">a = <span class="hljs-built_in">append</span>(a, b...)</span><br><span class="line">fmt.Printf(<span class="hljs-string">"a=%v\n"</span>, a)</span><br><span class="line">fmt.Printf(<span class="hljs-string">"b=%v\n"</span>, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="范围操作符"><a href="#范围操作符" class="headerlink" title="范围操作符"></a>范围操作符</h3><p>切片支持取范围操作，新切片和原切片共享底层数组，因此对切片的修改会同时影响两个切片。</p><p>范围操作符语法如下：a[begin:end]，左闭右开区间。因此a[1:10]包含a切片索引为1~9的元素。</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line"><span class="hljs-comment">// 直接使用值初始化切片</span></span><br><span class="line"><span class="hljs-keyword">var</span> a = []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> b = a[<span class="hljs-number">1</span>:<span class="hljs-number">10</span>]</span><br><span class="line">fmt.Println(b)</span><br><span class="line"><span class="hljs-comment">// 修改新切片元素</span></span><br><span class="line">b[<span class="hljs-number">0</span>] = <span class="hljs-number">11</span></span><br><span class="line">fmt.Println(a)</span><br><span class="line">fmt.Println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到修改b索引为0的元素为11之后，a切片也同时受到影响。</p><p>范围操作符的切片这一点在编程中要特别注意！</p><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>利用范围操作符和append函数可以删除指定的切片元素。</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line"><span class="hljs-comment">// 直接使用值初始化切片</span></span><br><span class="line"><span class="hljs-keyword">var</span> a = []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;</span><br><span class="line"><span class="hljs-comment">// 删除第2个元素</span></span><br><span class="line">a = <span class="hljs-built_in">append</span>(a[:<span class="hljs-number">1</span>], a[<span class="hljs-number">2</span>:]...)</span><br><span class="line">fmt.Println(a)</span><br><span class="line"><span class="hljs-comment">// 删除第2、3个元素</span></span><br><span class="line">a = []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;</span><br><span class="line">a = <span class="hljs-built_in">append</span>(a[:<span class="hljs-number">1</span>], a[<span class="hljs-number">3</span>:]...)</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复制元素"><a href="#复制元素" class="headerlink" title="复制元素"></a>复制元素</h3><p>通过copy函数可以复制切片的全部或部分元素。在复制切片之前，需要声明好目标切片并设置len。</p><p><em>len<strong>必须大于</strong>0**，否则将不会复制任何元素。</em></p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line"><span class="hljs-comment">// 直接使用值初始化切片</span></span><br><span class="line"><span class="hljs-keyword">var</span> a = []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> b = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>)</span><br><span class="line"><span class="hljs-built_in">copy</span>(b, a)</span><br><span class="line">fmt.Println(b)</span><br><span class="line"><span class="hljs-keyword">var</span> c = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">8</span>)</span><br><span class="line"><span class="hljs-built_in">copy</span>(c, a[<span class="hljs-number">9</span>:<span class="hljs-number">10</span>])</span><br><span class="line">fmt.Println(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出如下：</p><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[]</span><br><span class="line">[<span class="hljs-number">10</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>]</span><br></pre></td></tr></table></figure><p>可以看到切片b没有任何值，切片c成功复制了a的最后一个元素。</p><h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>映射也叫字典、哈希表，数组和切片是通过数字索引访问的顺序集合，而映射是通过键来访问的无序集合。映射在查找方面非常高效，有着O(1)的时间复杂度，是非常常用的数据结构。</p><h3 id="使用映射"><a href="#使用映射" class="headerlink" title="使用映射"></a>使用映射</h3><p>映射必须初始化之后才能使用，这一点和切片不同。</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line"><span class="hljs-comment">// 使用make初始化映射</span></span><br><span class="line"><span class="hljs-keyword">var</span> a = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>)</span><br><span class="line">a[<span class="hljs-string">"zhangsan"</span>] = <span class="hljs-number">18</span></span><br><span class="line">a[<span class="hljs-string">"lisi"</span>] = <span class="hljs-number">28</span></span><br><span class="line">fmt.Printf(<span class="hljs-string">"a=%v\n"</span>, a)</span><br><span class="line"><span class="hljs-comment">// 使用值初始化映射</span></span><br><span class="line"><span class="hljs-keyword">var</span> b = <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>&#123;</span><br><span class="line"><span class="hljs-string">"zhangsan"</span>: <span class="hljs-number">18</span>,</span><br><span class="line"><span class="hljs-string">"lisi"</span>:     <span class="hljs-number">28</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="hljs-string">"b=%v\n"</span>, b)</span><br><span class="line"><span class="hljs-comment">// 遍历映射</span></span><br><span class="line"><span class="hljs-keyword">for</span> key, value := <span class="hljs-keyword">range</span> b &#123;</span><br><span class="line">fmt.Printf(<span class="hljs-string">"%s=%d\n"</span>, key, value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是未初始化映射的使用</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">var</span> a <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span></span><br><span class="line">a[<span class="hljs-string">"zhangsan"</span>] = <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> a &#123;</span><br><span class="line">fmt.Printf(<span class="hljs-string">"%s=%d\n"</span>, k, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序会产生运行时错误：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">panic</span>: assignment to entry in <span class="hljs-literal">nil</span> <span class="hljs-keyword">map</span></span><br><span class="line">goroutine <span class="hljs-number">1</span> [running]:</span><br><span class="line">main.main()</span><br><span class="line">/Users/example/<span class="hljs-keyword">go</span>/src/<span class="hljs-keyword">go</span>-microservice-inaction/src/<span class="hljs-number">2.1</span>/main.<span class="hljs-keyword">go</span>:<span class="hljs-number">7</span> +<span class="hljs-number">0x5d</span></span><br></pre></td></tr></table></figure><h3 id="运行时结构-1"><a href="#运行时结构-1" class="headerlink" title="运行时结构"></a>运行时结构</h3><p>映射的运行时结构如下：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">type</span> hmap <span class="hljs-keyword">struct</span> &#123;</span><br><span class="line">count      <span class="hljs-keyword">int</span></span><br><span class="line">flags      <span class="hljs-keyword">uint8</span></span><br><span class="line">B          <span class="hljs-keyword">uint8</span></span><br><span class="line">noverflow  <span class="hljs-keyword">uint16</span></span><br><span class="line">hash0      <span class="hljs-keyword">uint32</span></span><br><span class="line">buckets    unsafe.Pointer</span><br><span class="line">oldbuckets unsafe.Pointer</span><br><span class="line">nevacuate  <span class="hljs-keyword">uintptr</span></span><br><span class="line">extra      *mapextra</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>部分字段说明如下：</p><ol><li><p>count是目前映射的键值对数量</p></li><li><p>B是映射的容量，对数。例如B为8，则映射容量为28=256</p></li><li><p>buckets中存储具体的键值对</p></li><li><p>oldbuckets在扩容中会使用到</p></li><li><p>nevacuate 扩容进度指示器</p></li></ol><p>当装载因子超过6.5时，映射将发生扩容操作。装载因子计算公式：count/2B。例如当前为为166，此时装载因子为166/28=0.6484375，继续插入元素时，装载因子变为167/28= 0.65234375，此时会触发自动扩容。</p><p>每次扩容会增加1倍的空间，同时会对已存在的键值对进行渐进式迁移（一次迁移一小部分）。</p><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><p>Go语言映射添加元素和其他语言类似，使用[]语法即可。</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> m = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>)</span><br><span class="line">m[<span class="hljs-string">"name"</span>] = <span class="hljs-number">18</span></span><br></pre></td></tr></table></figure><p>添加元素时运行时会自动处理扩容和键值对迁移，无需用户程序关心。</p><h3 id="删除元素-1"><a href="#删除元素-1" class="headerlink" title="删除元素"></a>删除元素</h3><p>要从映射中删除元素，需要使用delete函数。</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> m = <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>&#123;</span><br><span class="line">  <span class="hljs-string">"zhangsan"</span>:<span class="hljs-number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-built_in">delete</span>(m, <span class="hljs-string">"zhangsan"</span>)</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本章介绍了Go语言常用的数据容器，其中对切片和映射的底层原理进行了简单介绍。Go语言通过内置切片和映射解决了C语言需要手动实现这两种常用数据结构的问题，提高了开发效率。在下一章将介绍Go语言的函数。</p><p><img src="https://static.ddhigh.com/blog/2021-03-09-162926-2.png" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文学习Go语言数据容器、包括数组、切片和映射。&lt;/p&gt;
&lt;h2 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h2&gt;&lt;p&gt;数组是一个数据集合，常用于存储用数字索引的同类型数据。Go语言的数组调用函数
      
    
    </summary>
    
      <category term="backend" scheme="https//www.ddhigh.com/categories/backend/"/>
    
      <category term="go" scheme="https//www.ddhigh.com/categories/backend/go/"/>
    
    
  </entry>
  
</feed>
