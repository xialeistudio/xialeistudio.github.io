<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>每天进步一点点</title>
  
  <subtitle>Coding Change Anything</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https//www.ddhigh.com/"/>
  <updated>2022-12-31T07:31:44.552Z</updated>
  <id>https//www.ddhigh.com/</id>
  
  <author>
    <name>xialeistudio</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>原地哈希算法</title>
    <link href="https//www.ddhigh.com/2022/12/31/cyclic-sort.html"/>
    <id>https//www.ddhigh.com/2022/12/31/cyclic-sort.html</id>
    <published>2022-12-31T06:16:32.000Z</published>
    <updated>2022-12-31T07:31:44.552Z</updated>
    
    <content type="html"><![CDATA[<p>原地哈希算法(Cyclic Sort)主要应用在值都在$[0,n]$的数组$nums$中，此时可以将$nums[i]$作为索引，放回原数组，当然，由于程序上索引是从0开始，因此可以将$nums[i]$放到$nums[nums[i]-1]$的位置上。</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>Leetcode <a href="https://leetcode.cn/problems/missing-number/" target="_blank" rel="noopener">268. 丢失的数字</a></p><p>给定一个包含 <code>[0, n]</code> 中 <code>n</code> 个数的数组 <code>nums</code> ，找出 <code>[0, n]</code> 这个范围内没有出现在数组中的那个数。</p><p><strong>示例 1：</strong></p><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]</span><br><span class="line">输出：<span class="hljs-number">2</span></span><br><span class="line">解释：n = <span class="hljs-number">3</span>，因为有 <span class="hljs-number">3</span> 个数字，所以所有的数字都在范围 [<span class="hljs-number">0</span>,<span class="hljs-number">3</span>] 内。<span class="hljs-number">2</span> 是丢失的数字，因为它没有出现在 nums 中。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]</span><br><span class="line">输出：<span class="hljs-number">2</span></span><br><span class="line">解释：n = <span class="hljs-number">2</span>，因为有 <span class="hljs-number">2</span> 个数字，所以所有的数字都在范围 [<span class="hljs-number">0</span>,<span class="hljs-number">2</span>] 内。<span class="hljs-number">2</span> 是丢失的数字，因为它没有出现在 nums 中。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="hljs-number">9</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]</span><br><span class="line">输出：<span class="hljs-number">8</span></span><br><span class="line">解释：n = <span class="hljs-number">9</span>，因为有 <span class="hljs-number">9</span> 个数字，所以所有的数字都在范围 [<span class="hljs-number">0</span>,<span class="hljs-number">9</span>] 内。<span class="hljs-number">8</span> 是丢失的数字，因为它没有出现在 nums 中。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="hljs-number">0</span>]</span><br><span class="line">输出：<span class="hljs-number">1</span></span><br><span class="line">解释：n = <span class="hljs-number">1</span>，因为有 <span class="hljs-number">1</span> 个数字，所以所有的数字都在范围 [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>] 内。<span class="hljs-number">1</span> 是丢失的数字，因为它没有出现在 nums 中。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 104</code></li><li><code>0 &lt;= nums[i] &lt;= n</code></li><li><code>nums</code> 中的所有数字都 <strong>独一无二</strong></li></ul><p><strong>进阶：</strong>你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题?</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>用哈希表可以解答，但是空间复杂度达到了$O(n)$，没有利用到值都在$[0,n]$这个已知条件。所以我们用原地哈希解答本题。</p><ol><li>遍历数组，如果$nums[i]-1&gt;=0$ 且$nums[i] != nums[nums[i]-1]$，证明$nums[i]$未归位，我们将$i$和$nums[i]-1$处的数字交换，此步骤要一直循环到$nums[i]-1$越界或者$nums[i]$归位</li><li>重新遍历数组，如果$nums[i] != i+1$，证明当前位置的$nums[i]$是错的，也就是缺少本来应该放到这个位置的数字，所以答案也就呼之欲出了。</li></ol><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">// 原地哈希</span></span><br><span class="line">        <span class="hljs-comment">// 1. 将nums[i] 放到 nums[nums[i]-1]的位置</span></span><br><span class="line">        <span class="hljs-comment">// 2. 重新遍历，如果 nums[i] != i+1 则缺失i+1数字</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">missingNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">                <span class="hljs-comment">// 数字归位</span></span><br><span class="line">                <span class="hljs-comment">// 如nums[i]为2，那么最终需要放到1号索引</span></span><br><span class="line">                <span class="hljs-keyword">while</span> (nums[i] - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i] != nums[nums[i] - <span class="hljs-number">1</span>]) &#123;</span><br><span class="line">                    swap(nums, i, nums[i] - <span class="hljs-number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-comment">// 数字已归位，查询哪个数字的值和位置不匹配，不匹配的就是缺失的数字</span></span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">                <span class="hljs-keyword">if</span> (nums[i] != i + <span class="hljs-number">1</span>) &#123;</span><br><span class="line">                    <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">            <span class="hljs-keyword">var</span> temp = nums[i];</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            nums[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(n)$。$n$是数组长度，每个元素会被一次性移动归位，此后不再移动，因此每个元素的访问次数是常数，而总共需要访问$n$个数字。</p><p>空间复杂度：$O(1)$。复用题目给定的$nums$空间作为哈希表，未引入额外空间。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原地哈希算法(Cyclic Sort)主要应用在值都在$[0,n]$的数组$nums$中，此时可以将$nums[i]$作为索引，放回原数组，当然，由于程序上索引是从0开始，因此可以将$nums[i]$放到$nums[nums[i]-1]$的位置上。&lt;/p&gt;
&lt;h2 id=&quot;
      
    
    </summary>
    
      <category term="algorithm" scheme="https//www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="leetcode" scheme="https//www.ddhigh.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>厄拉多塞筛素数筛选算法</title>
    <link href="https//www.ddhigh.com/2022/12/31/eratosthenes-sieve.html"/>
    <id>https//www.ddhigh.com/2022/12/31/eratosthenes-sieve.html</id>
    <published>2022-12-31T06:13:45.000Z</published>
    <updated>2022-12-31T07:31:44.556Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>厄拉多塞筛算法（Eratosthenes Sieve）是一种求素数的方法，由古希腊数学家厄拉多塞提出。它的原理是，给定一个数 n，从 2 开始依次将 $\sqrt n$ 以内的素数的倍数标记为合数，标记完成后，剩余未被标记的数为素数（从 2 开始）。如此可省去检查每个数的步骤，使筛选素数的过程更加简单。</p></blockquote><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>厄拉多塞筛算法具体步骤如下：</p><ol><li>读取输入的数 n，将 2 到 n 的所有整数记录在表中</li><li>从 2 开始，划去表中所有 2 的倍数</li><li>由小到大寻找表中下一个未被划去的整数，再划去表中所有该整数的倍数</li><li>重复第（3）步，直到找到的整数大于$\sqrt n$为止</li><li>表中所有未被划去的整数均为素数</li></ol><p>朴素的素数筛选算法如下：对给定的数字$i$，设定数字$j$从$2$遍历到$\sqrt i$，如果中间$i$能整除$j$，则$i$不是素数。该方法的时间复杂度为$O(n\sqrt n)$ ,$n$是数组长度，外层循环需要遍历$n$次，内层循环需要遍历$\sqrt n$次。</p><p>而厄拉多塞筛算法的时间复杂度为$O(n log(log(n)))$。</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>这是一张来自<a href="https://zh.wikipedia.org/wiki/%E5%9F%83%E6%8B%89%E6%89%98%E6%96%AF%E7%89%B9%E5%B0%BC%E7%AD%9B%E6%B3%95" target="_blank" rel="noopener">维基百科</a>的算法示意图。</p><p><img src="https://static.ddhigh.com/algorithm/Sieve_of_Eratosthenes_animation.gif" alt="算法示例"></p><ol><li>先从2开始遍历，将2的倍数(2,4,6,8,…)标记为为非素数</li><li>继续遍历，当前数字是素数时，继续将当前数字的倍数标记为非素数</li><li>直到所有数字标记完，重新标记数组，未被标记的就是素数</li></ol><h2 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h2><p>Leetcode <a href="https://leetcode.cn/problems/count-primes/" target="_blank" rel="noopener">204. 计数质数</a></p><p>给定整数 <code>n</code> ，返回 <em>所有小于非负整数 <code>n</code> 的质数的数量</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="hljs-number">10</span></span><br><span class="line">输出：<span class="hljs-number">4</span></span><br><span class="line">解释：小于 <span class="hljs-number">10</span> 的质数一共有 <span class="hljs-number">4</span> 个, 它们是 <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span> 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="hljs-number">0</span></span><br><span class="line">输出：<span class="hljs-number">0</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="hljs-number">1</span></span><br><span class="line">输出：<span class="hljs-number">0</span></span><br></pre></td></tr></table></figure><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">// 厄拉多塞筛素数筛选算法</span></span><br><span class="line">        <span class="hljs-comment">// 1. 准备O(n)的数组，标识数字是否是质数，初始情况下全部是质数</span></span><br><span class="line">        <span class="hljs-comment">// 2. 从2开始遍历到sqrt(n),如果数字是质数，则i*i开始，后面i的倍数全是合数</span></span><br><span class="line">        <span class="hljs-comment">// 3. 从[2,n)筛选质数并统计</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countPrimes</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) &#123;</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">var</span> isPrime = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n];</span><br><span class="line">            Arrays.fill(isPrime, <span class="hljs-keyword">true</span>);</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i * i &lt; n; i++) &#123; <span class="hljs-comment">// 遍历一半即可</span></span><br><span class="line">                <span class="hljs-keyword">if</span> (isPrime[i]) &#123; <span class="hljs-comment">// 如果是质数，则将i平方开始的所有i的倍数设为合数</span></span><br><span class="line">                    <span class="hljs-comment">// 任意素数x的倍数有：2x, 3x, 4x, ..., x*x, (x+1)*x, ...</span></span><br><span class="line">                    <span class="hljs-comment">// 任意小于x*x的倍数都被之前的素数筛过滤过，如：2 过滤 2x, 4x, ...，3 过滤 3x, ...</span></span><br><span class="line">                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i * i; j &lt; n; j += i) &#123;</span><br><span class="line">                        isPrime[j] = <span class="hljs-keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="hljs-keyword">if</span> (isPrime[i]) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>时间复杂度: $O(nlog(log(n)))$。时间复杂度证明过程有点复杂，我暂时还没消化。</p><p>空间复杂度：$O(n)$。需要长度为$n$的数组标记是否素数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;厄拉多塞筛算法（Eratosthenes Sieve）是一种求素数的方法，由古希腊数学家厄拉多塞提出。它的原理是，给定一个数 n，从 2 开始依次将 $\sqrt n$ 以内的素数的倍数标记为合数，标记完成后，剩余未被标记的数为素数（从 2 开始）
      
    
    </summary>
    
      <category term="algorithm" scheme="https//www.ddhigh.com/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>博耶-摩尔多数投票算法</title>
    <link href="https//www.ddhigh.com/2022/12/31/boyer-moore-majority-vote-algorithm.html"/>
    <id>https//www.ddhigh.com/2022/12/31/boyer-moore-majority-vote-algorithm.html</id>
    <published>2022-12-31T06:13:06.000Z</published>
    <updated>2022-12-31T07:31:44.552Z</updated>
    
    <content type="html"><![CDATA[<p>来自<a href="https://zh.m.wikipedia.org/zh-hans/%E5%A4%9A%E6%95%B0%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">维基百科</a>的解释：</p><blockquote><p><strong>博耶-摩尔多数投票算法</strong>（英语：Boyer–Moore majority vote algorithm）,中文常作<strong>多数投票算法</strong>、<strong>摩尔投票算法</strong>等，是一种用来寻找一组元素中占多数元素的常数空间级<a href="https://zh.m.wikipedia.org/wiki/时间复杂度" target="_blank" rel="noopener">时间复杂度</a>算法。这一算法由<a href="https://zh.m.wikipedia.org/w/index.php?title=罗伯特·S·博耶&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">罗伯特·S·博耶</a>（英语：<a href="https://en.wikipedia.org/wiki/Robert_S._Boyer" target="_blank" rel="noopener">Robert S. Boyer</a>）和<a href="https://zh.m.wikipedia.org/w/index.php?title=J_Strother_Moore&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">J·斯特罗瑟·摩尔</a>（英语：<a href="https://en.wikipedia.org/wiki/J_Strother_Moore" target="_blank" rel="noopener">J Strother Moore</a>）在1981年发表<a href="https://zh.m.wikipedia.org/zh-hans/多数投票算法#cite_note-bm-1" target="_blank" rel="noopener">[1]</a>，也是<a href="https://zh.m.wikipedia.org/w/index.php?title=Streaming_algorithm&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">处理数据流</a>（英语：<a href="https://en.wikipedia.org/wiki/streaming_algorithm" target="_blank" rel="noopener">streaming algorithm</a>）的一种典型算法。</p></blockquote><p>简单来说，博耶-摩尔多数投票算法用来寻找数组中的多数元素，相比于用哈希表存储元素和次数使用$O(n)$的时间复杂度来说，该投票算法使用$O(1)$的空间复杂度。</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>摩尔投票算法分为投票-校验两个阶段。投票阶段会统计候选人的票数，遍历数组，如果当前数字和当前候选人不相等，则该候选人票数-1，当候选人票数归0时，需要更换候选人为当前数字；在校验阶段，需要重新遍历数字，并将值等于候选人的数字计数，遍历结束后，比如计数满足要求，则候选人满足要求。</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>比如[A,A, A, B,C]这组元素，我们需要筛选数量超过一半的数字。</p><p>首先我们定A为候选人，然后遍历数组，遇到B时A有3个，由于A!=B，因此A结果为2，再和C比较，犹豫A!=C，因此A结尾为1，遍历结束，A是投票阶段的候选人；再遍历数组，统计A的数量为3，超过一半(5/2)，因此A是票数最高的元素。</p><h2 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h2><p>Leetcode <a href="https://leetcode.cn/problems/majority-element-ii/" target="_blank" rel="noopener">229. 多数元素 II</a></p><p>给定一个大小为 <em>n</em> 的整数数组，找出其中所有出现超过 <code>⌊ n/3 ⌋</code> 次的元素。</p><p><strong>示例 1：</strong></p><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]</span><br><span class="line">输出：[<span class="hljs-number">3</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7 hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="hljs-comment">[1]</span></span><br><span class="line">输出：<span class="hljs-comment">[1]</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]</span><br><span class="line">输出：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题目要求找出所有出现次数超过<code>n/3</code>次的元素，由于摩尔投票算法空间复杂度是常数，因此需要预先定义候选人个数。</p><p>设出现次数超过<code>n/3</code>次的元素有$x$个，以下是求解$x$的过程：<br>$$<br>\begin{equation}\label{eqn:1}<br>\begin{aligned}<br>&amp; 假设刚好是n/3个 \<br>&amp; \because x * n/3 = n \<br>&amp; \therefore x=3 \<br>&amp; 而实际上题目要求次数 &gt; n/3 \<br>&amp; \therefore x &lt; 3 \<br>&amp; \therefore x = 2<br>\end{aligned}<br>\end{equation}<br>$$<br>所以本题最多能选择2个候选人。</p><ol><li>不妨设两个候选人$candidate1$和$candidate2$，$count1$和$count2$都是0</li><li>遍历数组，如果当前$nums[i]==candidate1$，则$count1++$，否则$count1–$，对$candidate2$同样处理</li><li>如果遍历过程中$count1$或$count2$为0，则更新对应的候选人为$nums[i]$</li><li>投票阶段结束，进入重新计数校验阶段，我们留下了$candidate1$和$candidate2$，再次遍历数组，如果值和这两个候选人相同，则对应的$count$增加</li><li>如果$count&gt;nums.length/3$，则将当前候选人加入答案</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">// 摩尔投票法</span></span><br><span class="line">        <span class="hljs-comment">// 1. 因为题目要求超过 n/3 的数字，因此最多有2个数字</span></span><br><span class="line">        <span class="hljs-comment">// 2. 投票阶段，初始化2个数字，以及count</span></span><br><span class="line">        <span class="hljs-comment">// 3. 遍历nums，如果和num1相等，则count1++，如果和num2相等，则count2++，否则票数--</span></span><br><span class="line">        <span class="hljs-comment">// 4. 如果num1的count1为0，则num1为当前num</span></span><br><span class="line">        <span class="hljs-comment">// 5. 校验阶段</span></span><br><span class="line">        <span class="hljs-comment">// 6. 统计num1和num2的次数，看看是否&gt;n/3</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">majorityElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">            <span class="hljs-keyword">var</span> answer = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">                <span class="hljs-keyword">return</span> Collections.emptyList();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">int</span> candidate1 = nums[<span class="hljs-number">0</span>], count1 = <span class="hljs-number">0</span>;</span><br><span class="line">            <span class="hljs-keyword">int</span> candidate2 = nums[<span class="hljs-number">0</span>], count2 = <span class="hljs-number">0</span>;</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;</span><br><span class="line">                <span class="hljs-comment">// 增加1的票数</span></span><br><span class="line">                <span class="hljs-keyword">if</span> (num == candidate1) &#123;</span><br><span class="line">                    count1++;</span><br><span class="line">                    <span class="hljs-keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="hljs-comment">// 增加2的票数</span></span><br><span class="line">                <span class="hljs-keyword">if</span> (num == candidate2) &#123;</span><br><span class="line">                    count2++;</span><br><span class="line">                    <span class="hljs-keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="hljs-comment">// 1票数不足，更新候选人1</span></span><br><span class="line">                <span class="hljs-keyword">if</span> (count1 == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">                    candidate1 = num;</span><br><span class="line">                    count1++;</span><br><span class="line">                    <span class="hljs-keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="hljs-comment">// 2票数不足，更新候选人2</span></span><br><span class="line">                <span class="hljs-keyword">if</span> (count2 == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">                    candidate2 = num;</span><br><span class="line">                    count2++;</span><br><span class="line">                    <span class="hljs-keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="hljs-comment">// 票数相减</span></span><br><span class="line">                count1--;</span><br><span class="line">                count2--;</span><br><span class="line">            &#125;</span><br><span class="line">            count1 = <span class="hljs-number">0</span>;</span><br><span class="line">            count2 = <span class="hljs-number">0</span>;</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> num : nums) &#123;</span><br><span class="line">                <span class="hljs-keyword">if</span> (num == candidate1) &#123;</span><br><span class="line">                    count1++;</span><br><span class="line">                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num == candidate2) &#123;</span><br><span class="line">                    count2++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">if</span> (count1 &gt; nums.length / <span class="hljs-number">3</span>) &#123;</span><br><span class="line">                answer.add(candidate1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">if</span> (count2 &gt; nums.length / <span class="hljs-number">3</span>) &#123;</span><br><span class="line">                answer.add(candidate2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">return</span> answer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(n)$, $n$是数组长度，需要遍历两次。</p><p>空间复杂度: $O(1)$，只需要常数项额外空间。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;来自&lt;a href=&quot;https://zh.m.wikipedia.org/zh-hans/%E5%A4%9A%E6%95%B0%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;维基百科
      
    
    </summary>
    
      <category term="algorithm" scheme="https//www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="leetcode" scheme="https//www.ddhigh.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>基数排序算法</title>
    <link href="https//www.ddhigh.com/2022/12/30/radix-sort.html"/>
    <id>https//www.ddhigh.com/2022/12/30/radix-sort.html</id>
    <published>2022-12-30T10:57:38.000Z</published>
    <updated>2022-12-31T07:31:44.552Z</updated>
    
    <content type="html"><![CDATA[<p>基数排序又叫桶排序，是一种时间复杂度为$O(n)$的排序算法，但是相比于其他排序算法有$O(n)$的空间复杂度。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>基数排序的核心思路如下：</p><ol><li>准备0~9的10个桶，根据数字当前比较位的值来决定放入哪个桶。如当前比较个位，则数字13应该放入索引为3的桶中；当前比较百位，则123应该放入索引为1的桶中。</li><li>当所有数字全部放入桶之后，遍历0~9这10个桶，然后依次将数字保存到待排序数组，因为桶是有序的，所以本轮放回去的数字是有序的。</li><li>当前比较的位数左移，比如本轮比较个位，下一轮应该比较百位。</li><li>重复步骤1~3。</li></ol><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>现在我们来看一个实际例子。</p><p>待排序数字：717, 328, 803, 422, 586, 944, 557, 308, 496, 624</p><h3 id="第1轮比较个位"><a href="#第1轮比较个位" class="headerlink" title="第1轮比较个位"></a>第1轮比较个位</h3><p>直接按照个位放入桶中。</p><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td></td><td></td><td>422</td><td>803</td><td>624</td><td></td><td>586</td><td>717</td><td>328</td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td>496</td><td>557</td><td>308</td></tr></tbody></table><p>按照从左到右，从上到下的原则将数字归位：422,803,624,586,496,717,557,328,308</p><h3 id="第2轮比较十位"><a href="#第2轮比较十位" class="headerlink" title="第2轮比较十位"></a>第2轮比较十位</h3><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td>803</td><td>717</td><td>422</td><td></td><td></td><td>557</td><td></td><td></td><td>586</td><td>496</td></tr><tr><td>308</td><td></td><td>624</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td>328</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>按照从左到右，从上到下的原则将数字归位：803,308,717,422,624,328,557,586,496</p><h3 id="第3轮比较百位"><a href="#第3轮比较百位" class="headerlink" title="第3轮比较百位"></a>第3轮比较百位</h3><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td></td><td></td><td></td><td>308</td><td>422</td><td>557</td><td>624</td><td>717</td><td>803</td><td></td></tr><tr><td></td><td></td><td></td><td>328</td><td>496</td><td>586</td><td></td><td></td><td></td></tr></tbody></table><p>按照从左到右，从上到下的原则将数字归位：308,328,422,496,557,586,624,717,803</p><p>可以发现，比较的轮次由数组中最大的数字决定，以上面的例子来说，如果还存在一个1234数字，那么需要比较4轮才可以完成排序。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RadixSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 基数排序</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (nums.length &lt;= <span class="hljs-number">1</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">var</span> max = Arrays.stream(nums).max().getAsInt();</span><br><span class="line">        <span class="hljs-comment">// 当前处理位数</span></span><br><span class="line">        <span class="hljs-keyword">var</span> exp = <span class="hljs-number">1</span>;</span><br><span class="line">        <span class="hljs-comment">// 桶</span></span><br><span class="line">        <span class="hljs-keyword">var</span> bucket = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>][nums.length];</span><br><span class="line">        <span class="hljs-comment">// 记录每个桶有几个数字</span></span><br><span class="line">        <span class="hljs-keyword">var</span> bucketCount = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];</span><br><span class="line">        <span class="hljs-keyword">while</span> (max &gt;= exp) &#123;</span><br><span class="line">            <span class="hljs-comment">// 求得每个数字当前位数的值</span></span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> num : nums) &#123;</span><br><span class="line">                <span class="hljs-comment">// 求得当前位余数</span></span><br><span class="line">                <span class="hljs-keyword">var</span> bitNumber = (num / exp) % <span class="hljs-number">10</span>;</span><br><span class="line">                <span class="hljs-comment">// 放入桶, index是桶的index，在同一个桶的数字需要index来标识位置</span></span><br><span class="line">                <span class="hljs-keyword">var</span> index = bucketCount[bitNumber];</span><br><span class="line">                bucket[bitNumber][index] = num;</span><br><span class="line">                <span class="hljs-comment">// 桶内数量+1</span></span><br><span class="line">                bucketCount[bitNumber]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-comment">// 桶内数字归位</span></span><br><span class="line">            <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; <span class="hljs-comment">// 已归位的数字下标</span></span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;</span><br><span class="line">                <span class="hljs-keyword">if</span> (bucketCount[i] &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 当前桶有数字</span></span><br><span class="line">                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; bucketCount[i]; j++) &#123; <span class="hljs-comment">// 遍历同一个桶的数字</span></span><br><span class="line">                        nums[k] = bucket[i][j];</span><br><span class="line">                        k++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="hljs-comment">// 桶数字清空</span></span><br><span class="line">                bucketCount[i] = <span class="hljs-number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-comment">// 位数左移</span></span><br><span class="line">            exp *= <span class="hljs-number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="hljs-keyword">var</span> gap = nums[i] - nums[i - <span class="hljs-number">1</span>];</span><br><span class="line">            <span class="hljs-keyword">if</span> (gap &gt; max) &#123;</span><br><span class="line">                max = gap;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">var</span> sort = <span class="hljs-keyword">new</span> RadixSort();</span><br><span class="line">        <span class="hljs-keyword">var</span> list = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">422</span>, <span class="hljs-number">803</span>, <span class="hljs-number">624</span>, <span class="hljs-number">586</span>, <span class="hljs-number">496</span>, <span class="hljs-number">717</span>, <span class="hljs-number">557</span>, <span class="hljs-number">328</span>, <span class="hljs-number">308</span>&#125;;</span><br><span class="line">        sort.sort(list);</span><br><span class="line">        System.out.println(Arrays.toString(list));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度: $O(n)$ ，严格来说是$O(log(n))$。$n$是待排序数组长度，在数据量小的情况下，最外层的while循环遍历次数可以认为是常数，内部嵌套的for循环次数为数组长度$n$，因此时间复杂度为$O(n)$；在数据量大的情况下，最外层的while循环次数为$O(log(n))$，内部嵌套的for循环次数依旧是$n$，因此时间复杂度为$O(nlog(n))$。</p><p>空间复杂度：$O(n)$。$n$是待排序数组长度，$bucket$的大小为$10*n$，$bucketCount$大小为$n$，因此总体空间复杂度为$O(n)$。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;基数排序又叫桶排序，是一种时间复杂度为$O(n)$的排序算法，但是相比于其他排序算法有$O(n)$的空间复杂度。&lt;/p&gt;
&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;p&gt;基数排序的核
      
    
    </summary>
    
      <category term="algorithm" scheme="https//www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="leetcode" scheme="https//www.ddhigh.com/tags/leetcode/"/>
    
      <category term="sort" scheme="https//www.ddhigh.com/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>算法篇-leetcode 131 分割回文串</title>
    <link href="https//www.ddhigh.com/2022/03/17/palindrome-partitioning.html"/>
    <id>https//www.ddhigh.com/2022/03/17/palindrome-partitioning.html</id>
    <published>2022-03-17T04:00:14.000Z</published>
    <updated>2022-12-31T07:31:44.552Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是 <strong>回文串</strong> 。返回 <code>s</code> 所有可能的分割方案。</p><p><strong>回文串</strong> 是正着读和反着读都一样的字符串。</p><p><strong>示例1</strong></p><figure class="highlight prolog hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="hljs-string">"aab"</span></span><br><span class="line">输出：[[<span class="hljs-string">"a"</span>,<span class="hljs-string">"a"</span>,<span class="hljs-string">"b"</span>],[<span class="hljs-string">"aa"</span>,<span class="hljs-string">"b"</span>]]</span><br></pre></td></tr></table></figure><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p><strong>题目要求</strong></p><ol><li>将字符串字符打散后，将其中的回文串添加到一个单独的List</li><li>第1步的所有List构成最后的答案</li></ol><p>可以看出，这是一个典型的回溯问题，考察有多少种方法可以组装最后的答案。</p><h4 id="方法一：直接回溯"><a href="#方法一：直接回溯" class="headerlink" title="方法一：直接回溯"></a>方法一：直接回溯</h4><p><strong>思路及算法</strong></p><p>回溯需要回答以下3个问题：</p><ol><li>回溯终止条件是什么？</li><li>回溯有哪些选择?</li><li>如何进入下一个选择？</li></ol><p>对于本题来说，我们需要将字符串打散，从中选择回文串添加到最终答案，因此，需要定义以下变量:  </p><ol><li>$index$, 记录当前选择的字符索引</li><li>$path$, 记录本次回文串选择情况</li><li>$answer$, 记录最终答案</li></ol><p>回答上面提出来的两个问题：</p><ol><li>回溯终止条件: $index==s.length()$，此时将$path$拷贝到$answer$，不可以直接添加，因为回溯存在撤回操作，必须断开$answer$和$path$的引用。</li><li>回溯有哪些选择：定义变量$right$, 遍历 $s[index,s.length())$，当$s[index,right]$是回文串时，将其加入$path$。</li><li>如何进入下一个选择：第2个问题满足条件的情况下，增加$index$然后再次递归即可。</li></ol><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * DFS回溯</span></span><br><span class="line"><span class="hljs-comment">     * 1. 回溯出口      index == s.length()</span></span><br><span class="line"><span class="hljs-comment">     * 2. 回溯递进      遍历[i,n)  如果s[i,j] 是回文串，则加入path，然后递归 s[i,j+1]</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> s</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; answer = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; path = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(answer, path, <span class="hljs-number">0</span>, s.length(), s);</span><br><span class="line">        <span class="hljs-keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(List&lt;List&lt;String&gt;&gt; answer, List&lt;String&gt; path, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> length, String s)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (index == length) &#123;</span><br><span class="line">            answer.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="hljs-keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">// 本次有什么选择?</span></span><br><span class="line">        <span class="hljs-comment">// j =&gt; [index,len)，检测s[index,j]是否回文，如果是，则加入path，最后撤销选择</span></span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = index; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (!isPalindrome(s, index, i)) &#123;</span><br><span class="line">                <span class="hljs-keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            path.add(s.substring(index, i + <span class="hljs-number">1</span>));</span><br><span class="line">            dfs(answer, path, i + <span class="hljs-number">1</span>, length, s);</span><br><span class="line">            path.remove(path.size() - <span class="hljs-number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (s.charAt(left) != s.charAt(right)) &#123;</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(N*2^n)$，每个位置的字符可以拆分也可以不拆分，因此时间复杂度是$O(2^n)$，判断每个子字符串是否为回文串需要$O(N)$的时间。</li><li>空间复杂度：$O(N*2^n)$，考虑$answer$，每个位置的字符可以拆分也可以不拆分，两种情况都需要占用空间，此部分空间是$O(2^n)$，而对于所有的答案都需要保存，此部分空间是$O(N)$.</li></ul><h4 id="方法二：记忆法回溯"><a href="#方法二：记忆法回溯" class="headerlink" title="方法二：记忆法回溯"></a>方法二：记忆法回溯</h4><p><strong>思路及算法</strong></p><p>在方法一的基础上添加$memo$保存$s[i,j]$是否为回文串，减少重复判断。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;</span><br><span class="line"> <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * DFS回溯</span></span><br><span class="line"><span class="hljs-comment">     * 1. 回溯出口      index == s.length()</span></span><br><span class="line"><span class="hljs-comment">     * 2. 回溯递进      遍历[i,n)  如果s[i,j] 是回文串，则加入path，然后递归 s[i,j+1]</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> s</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; answer = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; path = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Boolean[][] memo = <span class="hljs-keyword">new</span> Boolean[s.length()][s.length()];</span><br><span class="line">        dfs(memo, answer, path, <span class="hljs-number">0</span>, s.length(), s);</span><br><span class="line">        <span class="hljs-keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(Boolean[][] memo, List&lt;List&lt;String&gt;&gt; answer, List&lt;String&gt; path, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> length, String s)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (index == length) &#123;</span><br><span class="line">            answer.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="hljs-keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">// 本次有什么选择?</span></span><br><span class="line">        <span class="hljs-comment">// j =&gt; [index,len)，检测s[index,j]是否回文，如果是，则加入path，最后撤销选择</span></span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = index; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (!isPalindrome(memo, s, index, i)) &#123;</span><br><span class="line">                <span class="hljs-keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            path.add(s.substring(index, i + <span class="hljs-number">1</span>));</span><br><span class="line">            dfs(memo, answer, path, i + <span class="hljs-number">1</span>, length, s);</span><br><span class="line">            path.remove(path.size() - <span class="hljs-number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(Boolean[][] memo, String s, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (memo[left][right] != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> memo[left][right];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (s.charAt(left) != s.charAt(right)) &#123;</span><br><span class="line">                <span class="hljs-keyword">return</span> memo[left][right] = <span class="hljs-keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> memo[left][right] = <span class="hljs-keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(N*2^n)$，每个位置的字符可以拆分也可以不拆分，因此时间复杂度是$O(2^n)$，判断每个子字符串是否为回文串需要$O(N)$的时间，但是添加了记忆化搜索，每个子串至多搜索一次。</li><li>空间复杂度：$O(N*2^n)$，考虑$answer$，每个位置的字符可以拆分也可以不拆分，两种情况都需要占用空间，此部分空间是$O(2^n)$，而对于所有的答案都需要保存，此部分空间是$O(N)$.</li></ul><h4 id="方法三：DP-回溯"><a href="#方法三：DP-回溯" class="headerlink" title="方法三：DP+回溯"></a>方法三：DP+回溯</h4><p>我们可以利用DP通过提前计算好字符串的回文信息。</p><p><strong>思路和算法</strong></p><p>需要提前截取子字符串然后进行DP。那么问题来了，如何截取所有在子字符串？<br>我们可以定义如下双重循环：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>;right &lt; s.length(); right++) &#123;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;left&lt;= right; right++) &#123;</span><br><span class="line">        <span class="hljs-comment">// s[left,right] 就是所有的子字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>思考状态转移方程</strong></p><ol><li>定义$dp[i][j]$代表$s[i, j]$是否为回文串</li><li>当$s[left] == s[right]$可知字符串两端是相等的，需要考虑$left和right$的距离，通过穷举(笨办法)可知：<ol><li>$right - left = 0$时，$left$和$right$就是同一个字符，显然可以直接得到答案$true$</li><li>$right - left = 1$时，$left$和$right$是挨着的，比如$aa$，显然可以直接得到答案$true$</li><li>$right - right = 2$时，$left$和$right$中间夹了一个字符，比如$aba$，显然可以直接得到答案$true$</li><li>$right - right &gt; 2$ 时，不能直接看不出来了，需要进行状态转移，比如$aabaa$，当$s[0] == s[4]$时，我们需要看看$s[1,3]$是不是回文串，在本例中，由于$s[1,3]$是回文串，因此$s[0,4]$也是。</li></ol></li></ol><p>综上，DP方程如下：</p><p>$$<br>dp(i,j) = \begin{cases}<br>false, &amp; \text{if } s[i] \ne s[j] \<br>true, &amp; \text{if } s[i] = s[j] \&amp; j-i \le 2 \<br>dp[i+1][j-1], &amp; \text{if } j-i \gt 2<br>\end{cases}<br>$$</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * DP+DFS回溯</span></span><br><span class="line"><span class="hljs-comment">     * 1. DP处理 dp[i][j]是否为回文</span></span><br><span class="line"><span class="hljs-comment">     * 1.1 dp[i][i] = true</span></span><br><span class="line"><span class="hljs-comment">     * 1.2 dp[i][j] = s[i] == s[j] &amp;&amp; (dp[i+1][j-1] || j-i&lt;=2)</span></span><br><span class="line"><span class="hljs-comment">     * 2. 回溯</span></span><br><span class="line"><span class="hljs-comment">     * 2.1 回溯出口: index == s.length()</span></span><br><span class="line"><span class="hljs-comment">     * 2.2 回溯递进：j =&gt; [i,s.length())  if(dp[i][j])  添加子串，然后 dfs(index+1)</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> s</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> n = s.length();</span><br><span class="line">        <span class="hljs-keyword">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n][n];</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>; right &lt; n; right++) &#123;</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>; left &lt;= right; left++) &#123;</span><br><span class="line">                <span class="hljs-keyword">if</span> (s.charAt(left) == s.charAt(right)) &#123;</span><br><span class="line">                    <span class="hljs-keyword">if</span> (right - left &lt;= <span class="hljs-number">2</span>) &#123;</span><br><span class="line">                        dp[left][right] = <span class="hljs-keyword">true</span>;</span><br><span class="line">                    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                        dp[left][right] = dp[left + <span class="hljs-number">1</span>][right - <span class="hljs-number">1</span>]; <span class="hljs-comment">// 上一轮遍历过</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;String&gt;&gt; answer = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; path = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(answer, path, dp, <span class="hljs-number">0</span>, n, s);</span><br><span class="line">        <span class="hljs-keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(List&lt;List&lt;String&gt;&gt; answer, List&lt;String&gt; path, <span class="hljs-keyword">boolean</span>[][] dp, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> n, String s)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (index == n) &#123;</span><br><span class="line">            answer.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="hljs-keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> right = index; right &lt; n; right++) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (dp[index][right]) &#123;</span><br><span class="line">                path.add(s.substring(index, right + <span class="hljs-number">1</span>));</span><br><span class="line">                dfs(answer, path, dp, right + <span class="hljs-number">1</span>, n, s);</span><br><span class="line">                path.remove(path.size() - <span class="hljs-number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong><br>+时间复杂度：$O(2^n)$，计算$dp$需要$O(n^2)$,回溯需要$O(2^n)$。</p><ul><li>空间复杂度：$O(N*2^n)$，考虑$answer$，每个位置的字符可以拆分也可以不拆分，两种情况都需要占用空间，此部分空间是$O(2^n)$，而对于所有的答案都需要保存，此部分空间是$O(N)$;考虑$dp$，需要$O(n^2)$的空间</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个字符串 &lt;code&gt;s&lt;/code&gt;，请你将 &lt;code&gt;s&lt;/code&gt; 分割成一些子串，使每个子串都是 &lt;strong&gt;回文串&lt;
      
    
    </summary>
    
      <category term="algorithm" scheme="https//www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="leetcode" scheme="https//www.ddhigh.com/tags/leetcode/"/>
    
      <category term="binarysearch" scheme="https//www.ddhigh.com/tags/binarysearch/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode106——从中序与后序遍历序列构造二叉树</title>
    <link href="https//www.ddhigh.com/2022/02/08/construct-binary-tree-from-inorder-and-postorder-traversal.html"/>
    <id>https//www.ddhigh.com/2022/02/08/construct-binary-tree-from-inorder-and-postorder-traversal.html</id>
    <published>2022-02-08T12:24:19.000Z</published>
    <updated>2022-12-31T07:31:44.552Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。</p><p> <strong>示例 1:</strong></p><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：inorder = [<span class="hljs-number">9</span>,<span class="hljs-number">3</span>,<span class="hljs-number">15</span>,<span class="hljs-number">20</span>,<span class="hljs-number">7</span>], postorder = [<span class="hljs-number">9</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>,<span class="hljs-number">20</span>,<span class="hljs-number">3</span>]</span><br><span class="line">输出：[<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,null,null,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight inform7 hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：inorder = <span class="hljs-comment">[-1]</span>, postorder = <span class="hljs-comment">[-1]</span></span><br><span class="line">输出：<span class="hljs-comment">[-1]</span></span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal" target="_blank" rel="noopener">https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>核心是中序遍历的顺序是[左，根，右]，后序遍历是[左，右，根]。而同一颗树不管前/中/后序遍历，节点数是不变的。</p></blockquote><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 后序遍历顺序: 左右根</span></span><br><span class="line"><span class="hljs-comment">// 1. postorder最后一个元素为根</span></span><br><span class="line"><span class="hljs-comment">// 2. 遍历inorder查找根的index</span></span><br><span class="line"><span class="hljs-comment">// 3. inorder[:index]为左子树，inorder[index+1:]为右子树，左子树大小记为leftTreeSize</span></span><br><span class="line"><span class="hljs-comment">// 4. postorder[:leftTreeSize]为左子树，postorder[leftTreeSize:len(postorder)-1]是右子树</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buildTree</span><span class="hljs-params">(inorder []<span class="hljs-keyword">int</span>, postorder []<span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">TreeNode</span></span> &#123;</span><br><span class="line">n := <span class="hljs-built_in">len</span>(inorder)</span><br><span class="line"><span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> &amp;TreeNode&#123;Val: inorder[<span class="hljs-number">0</span>]&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 查找中序遍历根的index</span></span><br><span class="line">index := <span class="hljs-number">-1</span></span><br><span class="line">rootValue := postorder[<span class="hljs-built_in">len</span>(postorder)<span class="hljs-number">-1</span>]</span><br><span class="line"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(inorder); i++ &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> inorder[i] == rootValue &#123;</span><br><span class="line">index = i</span><br><span class="line"><span class="hljs-keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 分割数组</span></span><br><span class="line">leftTreeSize := <span class="hljs-built_in">len</span>(inorder[:index])</span><br><span class="line">root := &amp;TreeNode&#123;Val: rootValue&#125;</span><br><span class="line">root.Left = buildTree(inorder[:index], postorder[:leftTreeSize])</span><br><span class="line">root.Right = buildTree(inorder[index+<span class="hljs-number">1</span>:], postorder[leftTreeSize:<span class="hljs-built_in">len</span>(postorder)<span class="hljs-number">-1</span>])</span><br><span class="line"><span class="hljs-keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序
      
    
    </summary>
    
      <category term="algorithm" scheme="https//www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="leetcode" scheme="https//www.ddhigh.com/tags/leetcode/"/>
    
      <category term="tree" scheme="https//www.ddhigh.com/tags/tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode108——将有序数组转换为二叉搜索树</title>
    <link href="https//www.ddhigh.com/2022/02/08/convert-sorted-array-to-binary-search-tree.html"/>
    <id>https//www.ddhigh.com/2022/02/08/convert-sorted-array-to-binary-search-tree.html</id>
    <published>2022-02-08T12:24:19.000Z</published>
    <updated>2022-12-31T07:31:44.552Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。</p><p>高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg" alt="img"></p><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="hljs-number">-10</span>,<span class="hljs-number">-3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>]</span><br><span class="line">输出：[<span class="hljs-number">0</span>,<span class="hljs-number">-3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">-10</span>,null,<span class="hljs-number">5</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree.jpg" alt="img"></p><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>]</span><br><span class="line">输出：[<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]</span><br><span class="line">解释：[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>] 和 [<span class="hljs-number">3</span>,<span class="hljs-number">1</span>] 都是高度平衡二叉搜索树。</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>二叉树的中序遍历是升序，节点顺序为[左，根，右]</p></blockquote><ol><li>对于给定的数组，根据升序的性质，可知，中间节点为根节点，左半部分为左子树，右半部分为右子树</li><li>左半部分也是一颗完整的树，复用1的逻辑，因此用递归即可</li></ol><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="hljs-comment">// 升序数组是树的中序遍历结果，中间Index就是根，可以递归的还原为一个树</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">TreeNode</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> &amp;TreeNode&#123;Val: nums[<span class="hljs-number">0</span>]&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> helper(nums, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">helper</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>, start, end <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">TreeNode</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> start &gt; end &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 取得根</span></span><br><span class="line">rootIndex := (start + end) / <span class="hljs-number">2</span></span><br><span class="line">rootValue := nums[rootIndex]</span><br><span class="line">root := &amp;TreeNode&#123;Val: rootValue&#125;</span><br><span class="line">root.Left = helper(nums, start, rootIndex<span class="hljs-number">-1</span>)</span><br><span class="line">root.Right = helper(nums, rootIndex+<span class="hljs-number">1</span>, end)</span><br><span class="line"><span class="hljs-keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。&lt;/p&gt;
&lt;p&gt;高度平衡 二叉树是一棵满
      
    
    </summary>
    
      <category term="algorithm" scheme="https//www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="leetcode" scheme="https//www.ddhigh.com/tags/leetcode/"/>
    
      <category term="tree" scheme="https//www.ddhigh.com/tags/tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode109——有序链表转换二叉搜索树</title>
    <link href="https//www.ddhigh.com/2022/02/08/convert-sorted-list-to-binary-search-tree.html"/>
    <id>https//www.ddhigh.com/2022/02/08/convert-sorted-list-to-binary-search-tree.html</id>
    <published>2022-02-08T12:24:19.000Z</published>
    <updated>2022-12-31T07:31:44.552Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p><p><strong>示例:</strong></p><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给定的有序链表： [<span class="hljs-number">-10</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>],</span><br><span class="line"></span><br><span class="line">一个可能的答案是：[<span class="hljs-number">0</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">-10</span>, null, <span class="hljs-number">5</span>], 它可以表示下面这个高度平衡二叉搜索树：</span><br><span class="line"></span><br><span class="line">      <span class="hljs-number">0</span></span><br><span class="line">     / \</span><br><span class="line">   <span class="hljs-number">-3</span>   <span class="hljs-number">9</span></span><br><span class="line">   /   /</span><br><span class="line"> <span class="hljs-number">-10</span>  <span class="hljs-number">5</span></span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="转换为数组"><a href="#转换为数组" class="headerlink" title="转换为数组"></a>转换为数组</h3><blockquote><p>转换为数组后解法跟前面一道题一样。</p></blockquote><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="hljs-comment">// 链表转换为数组，复用108解法</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sortedListToBST</span><span class="hljs-params">(head *ListNode)</span> *<span class="hljs-title">TreeNode</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">list := listToArray(head)</span><br><span class="line"><span class="hljs-keyword">return</span> helper(list, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(list)<span class="hljs-number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">listToArray</span><span class="hljs-params">(head *ListNode)</span> []<span class="hljs-title">int</span></span> &#123;</span><br><span class="line">result := []<span class="hljs-keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="hljs-keyword">for</span> head != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">result = <span class="hljs-built_in">append</span>(result, head.Val)</span><br><span class="line">head = head.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">helper</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>, start, end <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">TreeNode</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> start &gt; end &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 取得根</span></span><br><span class="line">rootIndex := (start + end) / <span class="hljs-number">2</span></span><br><span class="line">rootValue := nums[rootIndex]</span><br><span class="line">root := &amp;TreeNode&#123;Val: rootValue&#125;</span><br><span class="line">root.Left = helper(nums, start, rootIndex<span class="hljs-number">-1</span>)</span><br><span class="line">root.Right = helper(nums, rootIndex+<span class="hljs-number">1</span>, end)</span><br><span class="line"><span class="hljs-keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表操作"><a href="#链表操作" class="headerlink" title="链表操作"></a>链表操作</h3><blockquote><p>我们遍历到中间节点后，将链表拆分为[左部分，中间点，右部分]即可复用逻辑，而且无额外空间占用</p></blockquote><p>单链表是无法直到中间点在哪里的，因此我们需要先遍历一次，获取链表长度，除以2就是中间的index。</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 1. 遍历一遍链表得到链表长度，算出中间节点index</span></span><br><span class="line"><span class="hljs-comment">// 2. 再次遍历链表，拆分为三段</span></span><br><span class="line"><span class="hljs-comment">// 1. 起点到中间节点的上一个节点：左子链表</span></span><br><span class="line"><span class="hljs-comment">// 2. 中间节点</span></span><br><span class="line"><span class="hljs-comment">// 3. 中间节点的下一个节点到链表末尾：右子链表</span></span><br><span class="line"><span class="hljs-comment">// 3. 将中间节点作为树根，利用左右子链表，递归构建左右子树，然后挂到根节点</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sortedListToBST</span><span class="hljs-params">(head *ListNode)</span> *<span class="hljs-title">TreeNode</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> helper(head)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">helper</span><span class="hljs-params">(head *ListNode)</span> *<span class="hljs-title">TreeNode</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> head.Next == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> &amp;TreeNode&#123;Val: head.Val&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 获取链表总长度</span></span><br><span class="line">length := <span class="hljs-number">0</span></span><br><span class="line">p := head</span><br><span class="line"><span class="hljs-keyword">for</span> p != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">length++</span><br><span class="line">p = p.Next</span><br><span class="line">&#125;</span><br><span class="line">middle := length / <span class="hljs-number">2</span> <span class="hljs-comment">// 取得中间点位置</span></span><br><span class="line"><span class="hljs-comment">// 再次遍历到中间点</span></span><br><span class="line"><span class="hljs-keyword">var</span> (</span><br><span class="line">prev = head      <span class="hljs-comment">// 指向中间点的上一个节点</span></span><br><span class="line">curr = head.Next <span class="hljs-comment">// 指向中间点</span></span><br><span class="line">)</span><br><span class="line"><span class="hljs-keyword">var</span> (</span><br><span class="line">left  *ListNode <span class="hljs-comment">// 左子链表头结点</span></span><br><span class="line">right *ListNode <span class="hljs-comment">// 右子链表头结点</span></span><br><span class="line">)</span><br><span class="line">index := <span class="hljs-number">0</span></span><br><span class="line"><span class="hljs-keyword">for</span> curr != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-comment">// index是prev的下标，因此定位到middle的前一个</span></span><br><span class="line"><span class="hljs-keyword">if</span> index == middle<span class="hljs-number">-1</span> &#123;</span><br><span class="line"><span class="hljs-comment">// 找到中点，将中点和右子链表连接打断</span></span><br><span class="line">right = curr.Next</span><br><span class="line">curr.Next = <span class="hljs-literal">nil</span></span><br><span class="line"><span class="hljs-comment">// 将左子链表和中点连接打断</span></span><br><span class="line">prev.Next = <span class="hljs-literal">nil</span></span><br><span class="line">left = head</span><br><span class="line"><span class="hljs-keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">prev = curr</span><br><span class="line">curr = curr.Next</span><br><span class="line">index++</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 此时我们拥有left,curr,right 三个链表，开始递归组合</span></span><br><span class="line">root := &amp;TreeNode&#123;Val: curr.Val&#125;</span><br><span class="line">root.Left = helper(left) <span class="hljs-comment">// 给你一条链表，给我构建一个树出来</span></span><br><span class="line">root.Right = helper(right)</span><br><span class="line"><span class="hljs-keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。&lt;/p&gt;
&lt;p&gt;本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左
      
    
    </summary>
    
      <category term="algorithm" scheme="https//www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="leetcode" scheme="https//www.ddhigh.com/tags/leetcode/"/>
    
      <category term="tree" scheme="https//www.ddhigh.com/tags/tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode107——二叉树的层序遍历 II</title>
    <link href="https//www.ddhigh.com/2022/02/06/binary-tree-level-order-traversal-ii.html"/>
    <id>https//www.ddhigh.com/2022/02/06/binary-tree-level-order-traversal-ii.html</id>
    <published>2022-02-06T12:24:19.000Z</published>
    <updated>2022-12-31T07:31:44.552Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你二叉树的根节点 <code>root</code> ，返回其节点值 <strong>自底向上的层序遍历</strong> 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt="img"></p><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,null,null,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]</span><br><span class="line">输出：[[<span class="hljs-number">15</span>,<span class="hljs-number">7</span>],[<span class="hljs-number">9</span>,<span class="hljs-number">20</span>],[<span class="hljs-number">3</span>]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="hljs-number">1</span>]</span><br><span class="line">输出：<span class="hljs-string">[[1]]</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7 hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = <span class="hljs-comment">[]</span></span><br><span class="line">输出：<span class="hljs-comment">[]</span></span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>直接用层序遍历即可，结果数组翻转之后就是答案</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// BFS正向遍历，最后翻转一下最终结果</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">levelOrderBottom</span><span class="hljs-params">(root *TreeNode)</span> [][]<span class="hljs-title">int</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> [][]<span class="hljs-keyword">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">answers := [][]<span class="hljs-keyword">int</span>&#123;&#125;</span><br><span class="line">queue := []*TreeNode&#123;root&#125;</span><br><span class="line"><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;</span><br><span class="line">size := <span class="hljs-built_in">len</span>(queue)</span><br><span class="line">tmp := queue</span><br><span class="line">queue = []*TreeNode&#123;&#125; <span class="hljs-comment">// 清空，存储下一层的节点</span></span><br><span class="line">level := []<span class="hljs-keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;</span><br><span class="line">node := tmp[<span class="hljs-number">0</span>]</span><br><span class="line">tmp = tmp[<span class="hljs-number">1</span>:]</span><br><span class="line">level = <span class="hljs-built_in">append</span>(level, node.Val)</span><br><span class="line"><span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">queue = <span class="hljs-built_in">append</span>(queue, node.Left)</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">queue = <span class="hljs-built_in">append</span>(queue, node.Right)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">answers = <span class="hljs-built_in">append</span>(answers, level)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="hljs-comment">// 翻转数组</span></span><br><span class="line">length := <span class="hljs-built_in">len</span>(answers)</span><br><span class="line"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; length/<span class="hljs-number">2</span>; i++ &#123;</span><br><span class="line">answers[i], answers[length<span class="hljs-number">-1</span>-i] = answers[length<span class="hljs-number">-1</span>-i], answers[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> answers</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你二叉树的根节点 &lt;code&gt;root&lt;/code&gt; ，返回其节点值 &lt;strong&gt;自底向上的层序遍历&lt;/strong&gt; 。 （即按从叶
      
    
    </summary>
    
      <category term="algorithm" scheme="https//www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="leetcode" scheme="https//www.ddhigh.com/tags/leetcode/"/>
    
      <category term="tree" scheme="https//www.ddhigh.com/tags/tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode103——二叉树的锯齿形层序遍历</title>
    <link href="https//www.ddhigh.com/2022/02/06/binary-tree-zigzag-level-order-traversal.html"/>
    <id>https//www.ddhigh.com/2022/02/06/binary-tree-zigzag-level-order-traversal.html</id>
    <published>2022-02-06T12:24:19.000Z</published>
    <updated>2022-12-31T07:31:44.552Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>锯齿形层序遍历</strong> 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt="img"></p><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,null,null,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]</span><br><span class="line">输出：[[<span class="hljs-number">3</span>],[<span class="hljs-number">20</span>,<span class="hljs-number">9</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="hljs-number">1</span>]</span><br><span class="line">输出：<span class="hljs-string">[[1]]</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7 hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = <span class="hljs-comment">[]</span></span><br><span class="line">输出：<span class="hljs-comment">[]</span></span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>用层序遍历的思路即可，不过偶数行需要将该行的值翻转。</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// BFS处理，记录遍历层数，当层数是奇数，翻转下本层元素</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">zigzagLevelOrder</span><span class="hljs-params">(root *TreeNode)</span> [][]<span class="hljs-title">int</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> [][]<span class="hljs-keyword">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">answers := [][]<span class="hljs-keyword">int</span>&#123;&#125;</span><br><span class="line">queue := []*TreeNode&#123;root&#125;</span><br><span class="line"><span class="hljs-keyword">for</span> level := <span class="hljs-number">1</span>; <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span>; level++ &#123;</span><br><span class="line">size := <span class="hljs-built_in">len</span>(queue)</span><br><span class="line">tmp := queue</span><br><span class="line">queue = []*TreeNode&#123;&#125; <span class="hljs-comment">// 清空，存储下一层的节点</span></span><br><span class="line">vals := []<span class="hljs-keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;</span><br><span class="line">node := tmp[<span class="hljs-number">0</span>]</span><br><span class="line">tmp = tmp[<span class="hljs-number">1</span>:]</span><br><span class="line">vals = <span class="hljs-built_in">append</span>(vals, node.Val)</span><br><span class="line"><span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">queue = <span class="hljs-built_in">append</span>(queue, node.Left)</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">queue = <span class="hljs-built_in">append</span>(queue, node.Right)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> level%<span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 偶数行，翻转vals</span></span><br><span class="line">length := <span class="hljs-built_in">len</span>(vals)</span><br><span class="line"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; length/<span class="hljs-number">2</span>; i++ &#123;</span><br><span class="line">vals[i], vals[length<span class="hljs-number">-1</span>-i] = vals[length<span class="hljs-number">-1</span>-i], vals[i] <span class="hljs-comment">// length-1是结束下标，-i就是同步往左逼近</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">answers = <span class="hljs-built_in">append</span>(answers, vals)</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> answers</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你二叉树的根节点 &lt;code&gt;root&lt;/code&gt; ，返回其节点值的 &lt;strong&gt;锯齿形层序遍历&lt;/strong&gt; 。（即先从左往右
      
    
    </summary>
    
      <category term="algorithm" scheme="https//www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="leetcode" scheme="https//www.ddhigh.com/tags/leetcode/"/>
    
      <category term="tree" scheme="https//www.ddhigh.com/tags/tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode105——从前序与中序遍历序列构造二叉树</title>
    <link href="https//www.ddhigh.com/2022/02/06/construct-binary-tree-from-preorder-and-inorder-traversal.html"/>
    <id>https//www.ddhigh.com/2022/02/06/construct-binary-tree-from-preorder-and-inorder-traversal.html</id>
    <published>2022-02-06T12:24:19.000Z</published>
    <updated>2022-12-31T07:31:44.552Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</p><p><strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt="img"></p><figure class="highlight nix hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="hljs-attr">preorder</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>], <span class="hljs-attr">inorder</span> = [<span class="hljs-number">9</span>,<span class="hljs-number">3</span>,<span class="hljs-number">15</span>,<span class="hljs-number">20</span>,<span class="hljs-number">7</span>]</span><br><span class="line">输出: [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight inform7 hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: preorder = <span class="hljs-comment">[-1]</span>, inorder = <span class="hljs-comment">[-1]</span></span><br><span class="line">输出: <span class="hljs-comment">[-1]</span></span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal" target="_blank" rel="noopener">https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>利用前序遍历和中序遍历性质</p><ol><li>前序遍历节点顺序如下[根，左，右]</li><li>中序遍历节点顺序如下[左，根，右]</li><li>前序遍历的左/右子树长度和中序遍历的左/右子树长度是相同的</li><li>由于这是同一颗树遍历来的，因此前序遍历的第0个元素和中序遍历的根节点是相同的。因此只要能定位中序遍历的根节点，将中序遍历数组拆分为左右两半后就可以了<ol><li>查找中序遍历的数组中值为前序遍历第0个元素节点的下标，记为<code>middle</code></li><li>此时中序遍历左子树节点列表为<code>[:middle]</code>，右子树节点列表为<code>[middle+1:]</code>，左子树长度为<code>len([:middle])</code>，记为<code>leftTreeSize</code></li><li>根据第3点可知，前序遍历的左子树节点列表为<code>[1:leftTreeSize+1]</code>,右子树节点为<code>[leftTreeSize+1:]</code></li></ol></li></ol><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 递归法</span></span><br><span class="line"><span class="hljs-comment">// 中序，左根右；前序根左右</span></span><br><span class="line"><span class="hljs-comment">// 1. 根据中序遍历找到根节点(值为preorder[0]的节点)</span></span><br><span class="line"><span class="hljs-comment">// 2. 中序遍历根节点左边的节点数和前序遍历的节点数是相同的，根据该性质可以将前序遍历拆分为两半</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buildTree</span><span class="hljs-params">(preorder []<span class="hljs-keyword">int</span>, inorder []<span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">TreeNode</span></span> &#123;</span><br><span class="line">n := <span class="hljs-built_in">len</span>(preorder)</span><br><span class="line"><span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">root := &amp;TreeNode&#123;Val: preorder[<span class="hljs-number">0</span>]&#125;</span><br><span class="line"><span class="hljs-comment">// 查找根节点在中序遍历的位置</span></span><br><span class="line">middle := <span class="hljs-number">0</span></span><br><span class="line"><span class="hljs-keyword">for</span> ; middle &lt; n; middle++ &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> inorder[middle] == preorder[<span class="hljs-number">0</span>] &#123;</span><br><span class="line"><span class="hljs-keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">leftTreeSize := <span class="hljs-built_in">len</span>(inorder[:middle])                                 <span class="hljs-comment">// 中序遍历的左半边就是左子树</span></span><br><span class="line">root.Left = buildTree(preorder[<span class="hljs-number">1</span>:leftTreeSize+<span class="hljs-number">1</span>], inorder[:middle])   <span class="hljs-comment">// 将前序遍历的左半边和中序的左半边递归构造左子树</span></span><br><span class="line">root.Right = buildTree(preorder[leftTreeSize+<span class="hljs-number">1</span>:], inorder[middle+<span class="hljs-number">1</span>:]) <span class="hljs-comment">// 将前序遍历的右半边和中序遍历的右半边构建右子树</span></span><br><span class="line"><span class="hljs-keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历
      
    
    </summary>
    
      <category term="algorithm" scheme="https//www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="leetcode" scheme="https//www.ddhigh.com/tags/leetcode/"/>
    
      <category term="tree" scheme="https//www.ddhigh.com/tags/tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode99——恢复二叉搜索树</title>
    <link href="https//www.ddhigh.com/2022/02/06/recover-binary-search-tree.html"/>
    <id>https//www.ddhigh.com/2022/02/06/recover-binary-search-tree.html</id>
    <published>2022-02-06T12:24:19.000Z</published>
    <updated>2022-12-31T07:31:44.552Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你二叉搜索树的根节点 root ，该树中的 恰好 两个节点的值被错误地交换。请在不改变其结构的情况下，恢复这棵树 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/28/recover1.jpg" alt="img"></p><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,null,null,<span class="hljs-number">2</span>]</span><br><span class="line">输出：[<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,null,null,<span class="hljs-number">2</span>]</span><br><span class="line">解释：<span class="hljs-number">3</span> 不能是 <span class="hljs-number">1</span> 的左孩子，因为 <span class="hljs-number">3</span> &gt; <span class="hljs-number">1</span> 。交换 <span class="hljs-number">1</span> 和 <span class="hljs-number">3</span> 使二叉搜索树有效。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/28/recover2.jpg" alt="img"></p><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,null,null,<span class="hljs-number">2</span>]</span><br><span class="line">输出：[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,null,null,<span class="hljs-number">3</span>]</span><br><span class="line">解释：<span class="hljs-number">2</span> 不能在 <span class="hljs-number">3</span> 的右子树中，因为 <span class="hljs-number">2</span> &lt; <span class="hljs-number">3</span> 。交换 <span class="hljs-number">2</span> 和 <span class="hljs-number">3</span> 使二叉搜索树有效。</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/recover-binary-search-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/recover-binary-search-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>中序遍历构造一个数组，根据二叉搜索树的性质，中序遍历是严格递增的</li><li>遍历该数组，找出<code>后一个值</code>小于<code>前一个值</code>的下标，根据这两个下标访问数组，可以得到两个错误值</li><li>遍历二叉树，根据第2步的两个值定位两个二叉树节点</li><li>交换两个节点的值</li></ol><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 1. 中序遍历构造一个数组</span></span><br><span class="line"><span class="hljs-comment">// 2. 检查数组顺序，定位有问题的下标</span></span><br><span class="line"><span class="hljs-comment">// 3. 中序遍历原来的树，定位指定下标的节点， 交换两个节点值</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">recoverTree</span><span class="hljs-params">(root *TreeNode)</span></span> &#123;</span><br><span class="line"><span class="hljs-comment">// 构造数组</span></span><br><span class="line"><span class="hljs-keyword">var</span> values []<span class="hljs-keyword">int</span></span><br><span class="line"><span class="hljs-keyword">var</span> valueGetter <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span></span><br><span class="line">valueGetter = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">valueGetter(root.Left)</span><br><span class="line">values = <span class="hljs-built_in">append</span>(values, root.Val)</span><br><span class="line">valueGetter(root.Right)</span><br><span class="line">&#125;</span><br><span class="line">valueGetter(root)</span><br><span class="line"><span class="hljs-comment">// 检查数组值顺序，如果比前面的小或者比后面的大</span></span><br><span class="line"><span class="hljs-keyword">var</span> (</span><br><span class="line">wrongIndex1 = <span class="hljs-number">-1</span></span><br><span class="line">wrongIndex2 = <span class="hljs-number">-1</span></span><br><span class="line">)</span><br><span class="line"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(values)<span class="hljs-number">-1</span>; i++ &#123;</span><br><span class="line"><span class="hljs-comment">// 如果比前面的小或者比后面的大</span></span><br><span class="line"><span class="hljs-keyword">if</span> values[i+<span class="hljs-number">1</span>] &lt; values[i] &#123;</span><br><span class="line">wrongIndex2 = i + <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-keyword">if</span> wrongIndex1 == <span class="hljs-number">-1</span> &#123;</span><br><span class="line">wrongIndex1 = i</span><br><span class="line">&#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 中序遍历，定位到wrongIndex1和wrongIndex2的节点，交换两者的值</span></span><br><span class="line"><span class="hljs-keyword">var</span> (</span><br><span class="line">locator    <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span></span><br><span class="line">wrongNode1 *TreeNode</span><br><span class="line">wrongNode2 *TreeNode</span><br><span class="line">)</span><br><span class="line">locator = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">locator(root.Left)</span><br><span class="line"><span class="hljs-keyword">if</span> root.Val == values[wrongIndex1] &#123; <span class="hljs-comment">// 根据值定位节点</span></span><br><span class="line">wrongNode1 = root</span><br><span class="line">&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> root.Val == values[wrongIndex2] &#123;</span><br><span class="line">wrongNode2 = root</span><br><span class="line">&#125;</span><br><span class="line">locator(root.Right)</span><br><span class="line">&#125;</span><br><span class="line">locator(root)</span><br><span class="line">wrongNode1.Val, wrongNode2.Val = wrongNode2.Val, wrongNode1.Val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你二叉搜索树的根节点 root ，该树中的 恰好 两个节点的值被错误地交换。请在不改变其结构的情况下，恢复这棵树 。&lt;/p&gt;
&lt;p&gt;&lt;st
      
    
    </summary>
    
      <category term="algorithm" scheme="https//www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="leetcode" scheme="https//www.ddhigh.com/tags/leetcode/"/>
    
      <category term="tree" scheme="https//www.ddhigh.com/tags/tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode95——不同的二叉搜索树 II</title>
    <link href="https//www.ddhigh.com/2022/02/06/unique-binary-search-trees-ii.html"/>
    <id>https//www.ddhigh.com/2022/02/06/unique-binary-search-trees-ii.html</id>
    <published>2022-02-06T12:24:19.000Z</published>
    <updated>2022-12-31T07:31:44.552Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数 <code>n</code> ，请你生成并返回所有由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的不同 <strong>二叉搜索树</strong> 。可以按 <strong>任意顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg" alt="img"></p><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="hljs-number">3</span></span><br><span class="line">输出：[[<span class="hljs-number">1</span>,null,<span class="hljs-number">2</span>,null,<span class="hljs-number">3</span>],[<span class="hljs-number">1</span>,null,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,null,null,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,null,<span class="hljs-number">1</span>]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p>输入：n = 1<br>输出：[[1]]</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-binary-search-trees-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>由于每个节点都可以成为根节点，因此遍历1~n，i为遍历参数名称，此时可以构造如下树<ol><li>1~i-1为左子树</li><li>i为根节点</li><li>i+1~n为右子树</li></ol></li><li>递归的调用步骤1可以得到所有的组合</li></ol><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generateTrees</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span> []*<span class="hljs-title">TreeNode</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> generate(<span class="hljs-number">1</span>, n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 生成start ~ end的数列表</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generate</span><span class="hljs-params">(start, end <span class="hljs-keyword">int</span>)</span> []*<span class="hljs-title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="hljs-comment">// 非法条件拦截</span></span><br><span class="line"><span class="hljs-keyword">if</span> start &gt; end &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> []*TreeNode&#123;<span class="hljs-literal">nil</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line">allNodes := []*TreeNode&#123;&#125;</span><br><span class="line"><span class="hljs-comment">// 遍历n</span></span><br><span class="line"><span class="hljs-keyword">for</span> i := start; i &lt;= end; i++ &#123;</span><br><span class="line">        <span class="hljs-comment">// start ~ i-1可以构造左子树节点</span></span><br><span class="line">leftTrees := generate(start, i<span class="hljs-number">-1</span>)</span><br><span class="line">        <span class="hljs-comment">// i+1 ~ end可以构造右子树节点</span></span><br><span class="line">rightTrees := generate(i+<span class="hljs-number">1</span>, end)</span><br><span class="line"><span class="hljs-keyword">for</span> _, left := <span class="hljs-keyword">range</span> leftTrees &#123;</span><br><span class="line"><span class="hljs-keyword">for</span> _, right := <span class="hljs-keyword">range</span> rightTrees &#123;</span><br><span class="line">                <span class="hljs-comment">// 组装左根右节点</span></span><br><span class="line">root := &amp;TreeNode&#123;Val: i&#125;</span><br><span class="line">root.Left = left</span><br><span class="line">root.Right = right</span><br><span class="line">allNodes = <span class="hljs-built_in">append</span>(allNodes, root)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> allNodes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个整数 &lt;code&gt;n&lt;/code&gt; ，请你生成并返回所有由 &lt;code&gt;n&lt;/code&gt; 个节点组成且节点值从 &lt;code&gt;1&lt;/c
      
    
    </summary>
    
      <category term="algorithm" scheme="https//www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="leetcode" scheme="https//www.ddhigh.com/tags/leetcode/"/>
    
      <category term="tree" scheme="https//www.ddhigh.com/tags/tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode98——验证二叉搜索树</title>
    <link href="https//www.ddhigh.com/2022/02/06/validate-binary-search-tree.html"/>
    <id>https//www.ddhigh.com/2022/02/06/validate-binary-search-tree.html</id>
    <published>2022-02-06T12:24:19.000Z</published>
    <updated>2022-12-31T07:31:44.552Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p><p><strong>有效</strong> 二叉搜索树定义如下：</p><p>节点的左子树只包含 <strong>小于</strong> 当前节点的数。<br>节点的右子树只包含 <strong>大于</strong> 当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg" alt="img"></p><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg" alt="img"></p><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,null,null,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>]</span><br><span class="line">输出：false</span><br><span class="line">解释：根节点的值是 <span class="hljs-number">5</span> ，但是右子节点的值是 <span class="hljs-number">4</span> 。</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/validate-binary-search-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/validate-binary-search-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>直接用中序遍历即可。中序遍历可以保证后一个值一定比前一个值大。</p><p>中序遍历处理顺序：左-&gt;根-&gt;右</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 中序遍历，值如果都是升序就满足要求</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(root *TreeNode)</span> <span class="hljs-title">bool</span></span> &#123;</span><br><span class="line">  <span class="hljs-keyword">var</span> (</span><br><span class="line">lastValue = math.MinInt64 <span class="hljs-comment">// 上一个值，初始化时保证是最小值即可，这样只要树节点有值就能大于该值</span></span><br><span class="line">helper    <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span> <span class="hljs-title">bool</span> // 判断指定节点是否大于<span class="hljs-title">lastValue</span></span></span><br><span class="line">)</span><br><span class="line">helper = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span> <span class="hljs-title">bool</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 节点为空，直接返回true</span></span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> !helper(root.Left) &#123; <span class="hljs-comment">// 如果左子树不满足要求则返回false</span></span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> root.Val &lt;= lastValue &#123; <span class="hljs-comment">// 如果当前节点&lt;=上一个节点，则不满足要求（中序遍历本节点一定大于上一个节点）</span></span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">lastValue = root.Val <span class="hljs-comment">// 更新上一个节点</span></span><br><span class="line"><span class="hljs-keyword">if</span> !helper(root.Right) &#123; <span class="hljs-comment">// 检查右子树</span></span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> helper(root)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有效&lt;/strong&gt; 二叉搜索树定义
      
    
    </summary>
    
      <category term="algorithm" scheme="https//www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="leetcode" scheme="https//www.ddhigh.com/tags/leetcode/"/>
    
      <category term="tree" scheme="https//www.ddhigh.com/tags/tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode102--二叉树的层序遍历</title>
    <link href="https//www.ddhigh.com/2022/02/05/binary-tree-level-order-traversal.html"/>
    <id>https//www.ddhigh.com/2022/02/05/binary-tree-level-order-traversal.html</id>
    <published>2022-02-05T16:00:00.000Z</published>
    <updated>2022-12-31T07:31:44.552Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。    </p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt="img"></p><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,null,null,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]</span><br><span class="line">输出：[[<span class="hljs-number">3</span>],[<span class="hljs-number">9</span>,<span class="hljs-number">20</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="hljs-number">1</span>]</span><br><span class="line">输出：<span class="hljs-string">[[1]]</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7 hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = <span class="hljs-comment">[]</span></span><br><span class="line">输出：<span class="hljs-comment">[]</span></span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-level-order-traversal</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>层序遍历直接用广度有限遍历即可。</p><ol><li>用两个队列存储本层节点<code>tmp</code>和下一层节点<code>queue</code>（可以简化处理清理，避免一个队列操作时即弹出又插入的问题）</li><li>获取队列长度，将<code>queue</code>复制到<code>tmp</code>,清空本层节点变量(<code>queue</code>)</li><li>tmp不断出队即可，出队时把后代节点插入<code>queue</code></li></ol><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// BFS遍历即可</span></span><br><span class="line"><span class="hljs-comment">// 用队列处理，需要注意的是，每次处理一层，每层的大小就是队列的大小，可以准备两个队列，一个用来存储本层，一个用来存储下一层</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">levelOrder</span><span class="hljs-params">(root *TreeNode)</span> [][]<span class="hljs-title">int</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> [][]<span class="hljs-keyword">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">answers := [][]<span class="hljs-keyword">int</span>&#123;&#125;</span><br><span class="line">queue := []*TreeNode&#123;root&#125;</span><br><span class="line"><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;</span><br><span class="line">size := <span class="hljs-built_in">len</span>(queue)</span><br><span class="line">tmp := queue</span><br><span class="line">queue = []*TreeNode&#123;&#125; <span class="hljs-comment">// 清空，存储下一层的节点</span></span><br><span class="line">level := []<span class="hljs-keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;</span><br><span class="line">node := tmp[<span class="hljs-number">0</span>]</span><br><span class="line">tmp = tmp[<span class="hljs-number">1</span>:]</span><br><span class="line">level = <span class="hljs-built_in">append</span>(level, node.Val)</span><br><span class="line"><span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">queue = <span class="hljs-built_in">append</span>(queue, node.Left)</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">queue = <span class="hljs-built_in">append</span>(queue, node.Right)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">answers = <span class="hljs-built_in">append</span>(answers, level)</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> answers</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你二叉树的根节点 &lt;code&gt;root&lt;/code&gt; ，返回其节点值的 &lt;strong&gt;层序遍历&lt;/strong&gt; 。 （即逐层地，从左到
      
    
    </summary>
    
      <category term="algorithm" scheme="https//www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="leetcode" scheme="https//www.ddhigh.com/tags/leetcode/"/>
    
      <category term="tree" scheme="https//www.ddhigh.com/tags/tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode328——奇偶链表</title>
    <link href="https//www.ddhigh.com/2022/02/05/odd-even-linked-list.html"/>
    <id>https//www.ddhigh.com/2022/02/05/odd-even-linked-list.html</id>
    <published>2022-02-05T12:24:19.000Z</published>
    <updated>2022-12-31T07:31:44.552Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定单链表的头节点 head ，将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后返回重新排序的列表。</p><p>第一个节点的索引被认为是 奇数 ， 第二个节点的索引为 偶数 ，以此类推。</p><p>请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致。</p><p>你必须在 O(1) 的额外空间复杂度和 O(n) 的时间复杂度下解决这个问题。</p><p><strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/10/oddeven-linked-list.jpg" alt="img"></p><figure class="highlight accesslog hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: head = <span class="hljs-string">[1,2,3,4,5]</span></span><br><span class="line">输出: <span class="hljs-string">[1,3,5,2,4]</span></span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/10/oddeven2-linked-list.jpg" alt="img"></p><figure class="highlight accesslog hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: head = <span class="hljs-string">[2,1,3,5,6,4,7]</span></span><br><span class="line">输出: <span class="hljs-string">[2,3,6,7,1,5,4]</span></span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/odd-even-linked-list" target="_blank" rel="noopener">https://leetcode-cn.com/problems/odd-even-linked-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/odd-even-linked-list" target="_blank" rel="noopener">https://leetcode-cn.com/problems/odd-even-linked-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>定义2个链表，<code>odd为奇数链表</code>，<code>even为偶数链表</code></li><li>遍历原链表，根据奇偶位置插入<code>odd</code>或者<code>even</code></li><li>连接<code>odd</code>和<code>even</code></li></ol><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 1. 定义以下节点</span></span><br><span class="line"><span class="hljs-comment">//    1. 偶链表头节点，移动节点</span></span><br><span class="line"><span class="hljs-comment">//    2. 奇链表头结点，移动节点</span></span><br><span class="line"><span class="hljs-comment">// 2. 奇链表尾节点.Next = 偶链表头结点</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">oddEvenList</span><span class="hljs-params">(head *ListNode)</span> *<span class="hljs-title">ListNode</span></span> &#123;</span><br><span class="line"><span class="hljs-comment">// 0,1,2个节点时直接返回</span></span><br><span class="line"><span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> || head.Next == <span class="hljs-literal">nil</span> || head.Next.Next == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> head</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> (</span><br><span class="line">oddHead  *ListNode</span><br><span class="line">oddMove  *ListNode</span><br><span class="line">evenHead *ListNode</span><br><span class="line">evenMove *ListNode</span><br><span class="line">)</span><br><span class="line">p := head</span><br><span class="line"><span class="hljs-keyword">for</span> p != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-comment">// 连接奇数节点</span></span><br><span class="line"><span class="hljs-keyword">if</span> oddHead == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">oddHead = p</span><br><span class="line">oddMove = p</span><br><span class="line">&#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">oddMove.Next = p</span><br><span class="line">oddMove = oddMove.Next</span><br><span class="line">&#125;</span><br><span class="line">p = p.Next</span><br><span class="line"><span class="hljs-comment">// 连接偶数节点</span></span><br><span class="line"><span class="hljs-keyword">if</span> p != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> evenHead == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">evenHead = p</span><br><span class="line">evenMove = p</span><br><span class="line">&#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">evenMove.Next = p</span><br><span class="line">evenMove = evenMove.Next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 移动到下一个奇数节点</span></span><br><span class="line"><span class="hljs-keyword">if</span> p != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">p = p.Next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 断开原来的连接</span></span><br><span class="line">oddMove.Next = <span class="hljs-literal">nil</span></span><br><span class="line">evenMove.Next = <span class="hljs-literal">nil</span></span><br><span class="line"></span><br><span class="line">oddMove.Next = evenHead</span><br><span class="line"><span class="hljs-keyword">return</span> oddHead</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定单链表的头节点 head ，将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后返回重新排序的列表。&lt;/p&gt;
&lt;p&gt;第一个节点的
      
    
    </summary>
    
      <category term="algorithm" scheme="https//www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="leetcode" scheme="https//www.ddhigh.com/tags/leetcode/"/>
    
      <category term="linklist" scheme="https//www.ddhigh.com/tags/linklist/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode142——环形链表2</title>
    <link href="https//www.ddhigh.com/2022/02/05/linked-list-cycle-ii.html"/>
    <id>https//www.ddhigh.com/2022/02/05/linked-list-cycle-ii.html</id>
    <published>2022-02-05T12:14:56.000Z</published>
    <updated>2022-12-31T07:31:44.552Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>不允许修改 链表。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-4</span>], pos = <span class="hljs-number">1</span></span><br><span class="line">输出：返回索引为 <span class="hljs-number">1</span> 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], pos = <span class="hljs-number">0</span></span><br><span class="line">输出：返回索引为 <span class="hljs-number">0</span> 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/linked-list-cycle-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>参考上一篇<a href="/2022/02/05/linked-list-cycle.md">环形链表</a>，可以利用哈希表存储节点，当再次遇到该节点时，该节点就是成环点。</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 1. 遍历节点存入map</span></span><br><span class="line"><span class="hljs-comment">// 2. 如果节点已存在，则该节点是成环节点</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">detectCycle</span><span class="hljs-params">(head *ListNode)</span> *<span class="hljs-title">ListNode</span></span> &#123;</span><br><span class="line">m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[*ListNode]<span class="hljs-keyword">struct</span>&#123;&#125;)</span><br><span class="line">p := head</span><br><span class="line"><span class="hljs-keyword">for</span> p != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> _, ok := m[p]; ok &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line">m[p] = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">p = p.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><ol><li>快指针走2步，慢指针走1步</li><li>快慢指针相遇时，慢指针走了<code>s</code>个节点，快指针走了<code>2s</code>，同时快指针比慢指针多走了<code>N</code>圈，设环形区间长度为<code>b</code>,因此<code>2s = s+nb</code>，因此<code>s=nb</code>，也就是快慢指针相遇时慢指针走过的距离刚好是环的倍数。</li><li>新起指针指向头结点，和慢指针一起向后走，两点相遇时新指针走了a，慢指针走了a+nb，此时新指针和慢指针相遇，新指针指向成环点</li></ol><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">detectCycle</span><span class="hljs-params">(head *ListNode)</span> *<span class="hljs-title">ListNode</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> || head.Next == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">fast := head</span><br><span class="line">slow := head</span><br><span class="line"><span class="hljs-keyword">for</span> fast != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">slow = slow.Next</span><br><span class="line">fast = fast.Next</span><br><span class="line"><span class="hljs-keyword">if</span> fast != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">fast = fast.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> fast == slow &#123;</span><br><span class="line"><span class="hljs-comment">// 快慢相遇，新起指针指向节点，然后和慢指针一起走，两者相遇点就是成环点</span></span><br><span class="line">ptr := head</span><br><span class="line"><span class="hljs-keyword">for</span> ptr != slow &#123;</span><br><span class="line">ptr = ptr.Next</span><br><span class="line">slow = slow.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> ptr</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。&lt;/p&gt;
&lt;p&gt;如果链表中有某个节点，可以通过连续跟踪 nex
      
    
    </summary>
    
      <category term="algorithm" scheme="https//www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="leetcode" scheme="https//www.ddhigh.com/tags/leetcode/"/>
    
      <category term="linklist" scheme="https//www.ddhigh.com/tags/linklist/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode141——环形链表</title>
    <link href="https//www.ddhigh.com/2022/02/05/linked-list-cycle.html"/>
    <id>https//www.ddhigh.com/2022/02/05/linked-list-cycle.html</id>
    <published>2022-02-05T12:09:35.000Z</published>
    <updated>2022-12-31T07:31:44.552Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个链表的头节点 head ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环 ，则返回 true 。 否则，返回 false 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-4</span>], pos = <span class="hljs-number">1</span></span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], pos = <span class="hljs-number">0</span></span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/linked-list-cycle" target="_blank" rel="noopener">https://leetcode-cn.com/problems/linked-list-cycle</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="哈希表法"><a href="#哈希表法" class="headerlink" title="哈希表法"></a>哈希表法</h3><p>利用哈希表存储访问过的节点，如果遍历时节点在哈希表，则有环。</p><blockquote><p>Go语言中map的value为struct可以不占用存储空间。</p></blockquote><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(head *ListNode)</span> <span class="hljs-title">bool</span></span> &#123;</span><br><span class="line">    m := <span class="hljs-keyword">map</span>[*ListNode]<span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    <span class="hljs-keyword">for</span> head != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> _, ok := m[head]; ok &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        m[head] = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        head = head.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快慢指针法"><a href="#快慢指针法" class="headerlink" title="快慢指针法"></a>快慢指针法</h3><ol><li>快指针每次走两步，慢指针走一步，如果相遇则存在环</li></ol><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(head *ListNode)</span> <span class="hljs-title">bool</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> || head.Next == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">fast := head</span><br><span class="line">slow := head</span><br><span class="line"><span class="hljs-keyword">for</span> fast != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">slow = slow.Next</span><br><span class="line">fast = fast.Next <span class="hljs-comment">// 快指针走1步</span></span><br><span class="line"><span class="hljs-keyword">if</span> fast != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">fast = fast.Next <span class="hljs-comment">// 快指针再走1步</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> fast == slow &#123; <span class="hljs-comment">// 相遇了</span></span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个链表的头节点 head ，判断链表中是否有环。&lt;/p&gt;
&lt;p&gt;如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表
      
    
    </summary>
    
      <category term="algorithm" scheme="https//www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="leetcode" scheme="https//www.ddhigh.com/tags/leetcode/"/>
    
      <category term="linklist" scheme="https//www.ddhigh.com/tags/linklist/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode92——反转链表 II</title>
    <link href="https//www.ddhigh.com/2022/02/05/reverse-linked-list-ii.html"/>
    <id>https//www.ddhigh.com/2022/02/05/reverse-linked-list-ii.html</id>
    <published>2022-02-05T11:00:00.000Z</published>
    <updated>2022-12-31T07:31:44.552Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。</p><p><strong>示例 1：</strong><br><img src="https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg" alt="示例1"></p><p>输入：head = [1,2,3,4,5], left = 2, right = 4<br>输出：[1,4,3,2,5]</p><p><strong>示例 2：</strong></p><p>输入：head = [5], left = 1, right = 1<br>输出：[5]</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/reverse-linked-list-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-linked-list-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="转数组"><a href="#转数组" class="headerlink" title="转数组"></a>转数组</h3><blockquote><p>大部分的链表题只要未要求原节点上操作，都可以转数组处理，缺点是空间复杂度会额外增加达到O(n)。</p><ol><li>将原链表按顺序转为数组</li><li>遍历数组，翻转left ~ right之间的数组，此处用双指针即可<ol><li>定义left和right指针，交换left和right的值</li><li>两个指针同时向中间移动，left++,right–</li></ol></li><li>将数组构造为链表返回</li></ol></blockquote><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 数组法</span></span><br><span class="line"><span class="hljs-comment">// 1. 链表转换为数组</span></span><br><span class="line"><span class="hljs-comment">// 2. 翻转left ~ right的数据</span></span><br><span class="line"><span class="hljs-comment">// 3. 重新构造链表</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseBetween</span><span class="hljs-params">(head *ListNode, left <span class="hljs-keyword">int</span>, right <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">ListNode</span></span> &#123;</span><br><span class="line">array := convertListToArray(head)</span><br><span class="line">reverseArrayPart(array, left<span class="hljs-number">-1</span>, right<span class="hljs-number">-1</span>)</span><br><span class="line"><span class="hljs-keyword">return</span> buildLinkList(array)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 翻转数组指定区间</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseArrayPart</span><span class="hljs-params">(array []<span class="hljs-keyword">int</span>, left, right <span class="hljs-keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">for</span> left &lt; right &#123;</span><br><span class="line">array[left], array[right] = array[right], array[left]</span><br><span class="line">left++</span><br><span class="line">right--</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 链表构造为数组</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">convertListToArray</span><span class="hljs-params">(head *ListNode)</span> []<span class="hljs-title">int</span></span> &#123;</span><br><span class="line">array := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>)</span><br><span class="line"><span class="hljs-keyword">for</span> head != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">array = <span class="hljs-built_in">append</span>(array, head.Val)</span><br><span class="line">head = head.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> array</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表操作"><a href="#链表操作" class="headerlink" title="链表操作"></a>链表操作</h3><blockquote><p>链表相关的操作主要是要掌握定位任意节点的指针。</p></blockquote><ol><li>定位以下节点<ol><li>leftPrev: 翻转区间开始节点的上一个节点，最终要连接翻转后的头节点，所以需要保留</li><li>rightNext: 翻转区间结束节点的后一个节点，最终要连接到最终链表，所以需要保留</li><li>left和right节点，翻转开始和翻转结束节点</li></ol></li><li>定义子函数翻转left和right，返回right，翻转思路如下<ol><li>定义prev和curr指针，prev初始指向null，curr指向head</li><li>开始迭代，迭代结束条件curr不等于rightNode<ol><li>保存curr的下一个节点<code>next:=curr.Next</code></li><li>此时我们有3个节点的指针，prev,curr,next</li><li>当前节点指向上一个,<code>curr.Next=prev</code></li><li>prev上一个节点指针后移,<code>prev=curr</code></li><li>curr后移,<code>curr=next</code></li></ol></li><li>迭代结束后将<code>curr</code>指向上一个节点<code>curr.Next=prev</code></li></ol></li><li>按以下顺序连接所有节点：leftPrev -&gt; right -&gt; left -&gt; rightNext，边界情况如下：<ol><li>left是头结点，此时leftPrevNode是空，最终结果链表right节点成为新头结点</li><li>right是尾节点，此时rightNextNode是空，无需特殊处理</li><li>left == right，无需翻转</li></ol></li></ol><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseBetween</span><span class="hljs-params">(head *ListNode, left <span class="hljs-keyword">int</span>, right <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">ListNode</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> left == right &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> head</span><br><span class="line">&#125;</span><br><span class="line">leftPrevNode, leftNode, rightNode, rightNextNode := locateNodes(head, left<span class="hljs-number">-1</span>, right<span class="hljs-number">-1</span>)</span><br><span class="line">rightNode = reverse(leftNode, rightNode)</span><br><span class="line"><span class="hljs-comment">// left是头节点，链表连接顺序，right,left,rightNext</span></span><br><span class="line"><span class="hljs-keyword">if</span> leftPrevNode == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">leftNode.Next = rightNextNode</span><br><span class="line"><span class="hljs-keyword">return</span> rightNode</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 正常连接，连接顺序 leftPrevNode-&gt;right-&gt;left-&gt;rightNextNode</span></span><br><span class="line">leftPrevNode.Next = rightNode</span><br><span class="line">leftNode.Next = rightNextNode</span><br><span class="line"><span class="hljs-keyword">return</span> head</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 翻转left ~ right之间的节点</span></span><br><span class="line"><span class="hljs-comment">// 迭代翻转即可</span></span><br><span class="line"><span class="hljs-comment">// p 指向当前节点</span></span><br><span class="line"><span class="hljs-comment">// prev 指向上一个节点</span></span><br><span class="line"><span class="hljs-comment">// next指向p的next节点</span></span><br><span class="line"><span class="hljs-comment">// 如果p == rightNode则结束翻转并返回right</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverse</span><span class="hljs-params">(leftNode *ListNode, rightNode *ListNode)</span> *<span class="hljs-title">ListNode</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">var</span> (</span><br><span class="line">prev *ListNode</span><br><span class="line">p    = leftNode</span><br><span class="line">)</span><br><span class="line"><span class="hljs-keyword">for</span> p != rightNode &#123;</span><br><span class="line">next := p.Next</span><br><span class="line">p.Next = prev <span class="hljs-comment">// p 指向 上一个节点</span></span><br><span class="line">prev = p      <span class="hljs-comment">// 上一个节点后移</span></span><br><span class="line">p = next      <span class="hljs-comment">// p后移</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// p 此时向rightNode，需要连接p和上一个节点</span></span><br><span class="line">p.Next = prev</span><br><span class="line"><span class="hljs-keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 定位</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">locateNodes</span><span class="hljs-params">(head *ListNode, left, right <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(*ListNode, *ListNode, *ListNode, *ListNode)</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">var</span> (</span><br><span class="line">index         = <span class="hljs-number">0</span></span><br><span class="line">prevNode      *ListNode</span><br><span class="line">leftPrevNode  *ListNode</span><br><span class="line">leftNode      *ListNode</span><br><span class="line">rightNode     *ListNode</span><br><span class="line">rightNextNode *ListNode</span><br><span class="line">)</span><br><span class="line"><span class="hljs-keyword">for</span> head != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-comment">// 找到左节点</span></span><br><span class="line"><span class="hljs-keyword">if</span> index == left &#123;</span><br><span class="line">leftPrevNode = prevNode</span><br><span class="line">leftNode = head</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 找到右节点</span></span><br><span class="line"><span class="hljs-keyword">if</span> index == right &#123;</span><br><span class="line">rightNode = head</span><br><span class="line">rightNextNode = head.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 指针移动</span></span><br><span class="line">index++</span><br><span class="line">prevNode = head</span><br><span class="line">head = head.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> leftPrevNode, leftNode, rightNode, rightNextNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &amp;lt;= right 。请你反转从位置 left 到
      
    
    </summary>
    
      <category term="algorithm" scheme="https//www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="leetcode" scheme="https//www.ddhigh.com/tags/leetcode/"/>
    
      <category term="linklist" scheme="https//www.ddhigh.com/tags/linklist/"/>
    
  </entry>
  
  <entry>
    <title>算法篇——二分查找</title>
    <link href="https//www.ddhigh.com/2021/12/29/algo-binarysearch.html"/>
    <id>https//www.ddhigh.com/2021/12/29/algo-binarysearch.html</id>
    <published>2021-12-29T10:32:50.000Z</published>
    <updated>2022-12-31T07:31:44.552Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章将学习/复习常用算法和数据结构。希望能够深入浅出的将复杂的知识讲清楚、说明白。</p><p>本文介绍第一个基础算法：二分查找。二分查找算法可以在<code>有序</code>的数组中快速查询指定值。</p><ul><li>要求：有序数组</li><li>时间复杂度：O(logN)</li><li>空间复杂度：O(1)</li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>大家应该玩过数字猜大小的游戏，接下来看看实际过程。</p><p>主持人从1~10选择1个数字，参与者每次猜1个数字，主持人给出提示正确/大了/小了。次数最少的获胜。</p><h3 id="线性查找"><a href="#线性查找" class="headerlink" title="线性查找"></a>线性查找</h3><blockquote><ul><li>主持人选定数字5。</li><li>参与者：10</li><li>主持人：大了</li><li>参与者：9</li><li>主持人：大了</li><li>参与者：8</li><li>主持人：大了</li><li>…</li><li>参与者：5</li><li>主持人：正确</li></ul></blockquote><p>参与者采用线性报数方式，从最大的数字开始报，每次减1直到猜中。上面的例子主持人选的数字是5，参与者猜了6次（10,9,8,7,6,5)。效率是O(N)。</p><p>主持人的<code>大了/小了</code>提示没有利用上，这肯定不是效率最高的方法。</p><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><blockquote><ul><li>主持人选定数字8。</li><li>参与者：5</li><li>主持人：小了</li><li>参与者：7</li><li>主持人：小了</li><li>参与者：8</li><li>主持人：正确</li></ul></blockquote><p>参与者根据主持人的<code>大了/小了</code>提示每次调整猜测范围直到猜中。上面的例子中主持人选的数字是8，参与者猜了3次：</p><ol><li>(0+10)/2 =&gt; 5，小了，所以下一次应该猜 比5大的数字，从 5 ~ 10继续猜</li><li>(5+10)/2 =&gt; 7(8也可以)，小了，所以下一次继续猜比7大的数字，从7~10继续猜</li><li>(7+10)/2 =&gt; 8(9也可以)，正确</li></ol><p>可以看到二分查找法每次都能过滤掉1半的数据，达到了O(logN)的时间复杂度</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>给定一个有序数组，返回指定值的索引，如果有序数组不存在该值，返回-1。</p><p>思路：</p><ol><li>找中间值，(0 + 数组最后一位的所以)/2得到中间值的位置，然后对比中间值和目标值大小</li><li>如果目标值比中间值小，那么目标值在数组前半部分，应该继续查找 0 ~ 数组中间索引-1的这部分</li><li>如果目标值比中间值大，那么目标值在数组后半部分，应该继续查找 数组中间索引+1 ~ 数组结尾的这部分</li></ol><blockquote><p>为什么继续查找时中间索引要+1或者-1移动？</p><p>因为中间值已经比对过了，不满足条件，所以可以直接跳过中间值往前面后者后面一个位置继续查找</p></blockquote><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">fmt.Println(search([]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;, <span class="hljs-number">5</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">search</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>, target <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;</span><br><span class="line">begin := <span class="hljs-number">0</span></span><br><span class="line">end := <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-keyword">for</span> begin &lt;= end &#123; <span class="hljs-comment">// 开始位置不能超过结束位置，超过证明所以数据都查过了</span></span><br><span class="line">midIndex := (begin + end) / <span class="hljs-number">2</span> <span class="hljs-comment">// 中间索引</span></span><br><span class="line">midValue := nums[midIndex]    <span class="hljs-comment">// 中间值</span></span><br><span class="line">fmt.Printf(<span class="hljs-string">"check pos(%v) value(%v)\n"</span>, midIndex, midValue)</span><br><span class="line"><span class="hljs-keyword">if</span> target &lt; midValue &#123; <span class="hljs-comment">// 目标值比中间值小，所以在左边，将end移动到中间索引-1</span></span><br><span class="line">end = midIndex - <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> target &gt; midValue &#123; <span class="hljs-comment">// 右半边，begin移动到中间索引+1</span></span><br><span class="line">begin = midIndex + <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 相等</span></span><br><span class="line"><span class="hljs-keyword">return</span> midIndex</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下</p><figure class="highlight smali hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">check pos(3) value(4)</span><br><span class="line">check pos(5) value(6)</span><br><span class="line">check pos(4) value(5)</span><br><span class="line">4</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本系列文章将学习/复习常用算法和数据结构。希望能够深入浅出的将复杂的知识讲清楚、说明白。&lt;/p&gt;
&lt;p&gt;本文介绍第一个基础算法：二分查找。二分查找算法可以在&lt;code&gt;有序&lt;/code&gt;的数组中快速查询指定值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;要求：有序数组&lt;/li&gt;
&lt;li&gt;时
      
    
    </summary>
    
      <category term="algorithm" scheme="https//www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="binarysearch" scheme="https//www.ddhigh.com/tags/binarysearch/"/>
    
  </entry>
  
</feed>
