<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xia Lei</title>
  
  <subtitle>Learning &amp; Sharing</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.ddhigh.com/"/>
  <updated>2023-05-05T02:52:12.002Z</updated>
  <id>https://www.ddhigh.com/</id>
  
  <author>
    <name>xialeistudio</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>How to build a Finite State Machine to help business workflow</title>
    <link href="https://www.ddhigh.com/2023/05/04/how-to-build-a-Finite-State-Machine-to-help-business-workflow.html"/>
    <id>https://www.ddhigh.com/2023/05/04/how-to-build-a-Finite-State-Machine-to-help-business-workflow.html</id>
    <published>2023-05-04T09:16:00.000Z</published>
    <updated>2023-05-05T02:52:12.002Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>This is the first article written in English. In this article, I’ll share how to build a Finite State Machine(FSM) to help business workflow transition, such as auditing.</p><blockquote><p>A <strong>finite-state machine</strong> (<strong>FSM</strong>) or <strong>finite-state automaton</strong> (<strong>FSA</strong>, plural: <em>automata</em>), <strong>finite automaton</strong>, or simply a <strong>state machine</strong>, is a mathematical <a href="https://en.wikipedia.org/wiki/Model_of_computation" target="_blank" rel="noopener">model of computation</a>. It is an <a href="https://en.wikipedia.org/wiki/Abstract_machine" target="_blank" rel="noopener">abstract machine</a> that can be in exactly one of a finite number of <em><a href="https://en.wikipedia.org/wiki/State_(computer_science" target="_blank" rel="noopener">states</a>)</em> at any given time. The FSM can change from one state to another in response to some <a href="https://en.wikipedia.org/wiki/Input_(computer_science" target="_blank" rel="noopener">inputs</a>); the change from one state to another is called a <em>transition</em></p><p><strong><em>Wikipedia</em></strong> - <strong><a href="https://en.wikipedia.org/wiki/Finite-state_machine" target="_blank" rel="noopener">Finite-state machine</a></strong></p></blockquote><a id="more"></a><h2 id="Situation"><a href="#Situation" class="headerlink" title="Situation"></a>Situation</h2><p>Imaging you are working at a E-Commercial company, if you want to publish a new product to production environment, you need to submit a <strong>AuditRequest</strong> first, then your manager will accept or reject this AuditRequest. If your manager accept, you can publish your product, so anyone can see it.</p><p>In this case, the state of the product transited many times, show as the following graph.</p><pre class="mermaid">stateDiagramdirection LR[*] --&gt; UnpublishedUnpublished --&gt; Auditing: Apply auditingAuditing --&gt; AuditAccepted: AcceptAuditing --&gt; AuditRejected: RejectAuditAccepted --&gt; Published: PublishAuditRejected --&gt; [*]Published --&gt; [*]</pre><h2 id="Definition-of-Terms"><a href="#Definition-of-Terms" class="headerlink" title="Definition of Terms"></a>Definition of Terms</h2><ul><li>FromState: the current state of an entity. In the example above, at the beginning, the state is <strong>Unpublished</strong>.</li><li>Event: the event to transit to next state. There is an <strong>Apply auditing</strong> event triggered by you.</li><li>ToState: the next state.  There is an <strong>Auditing</strong> state.</li><li>Action: action to execute. This action will change the state of the product from <strong>FromState</strong> and <strong>ToState</strong>, and action allows to do more things such as sending a HTTP request to an audit platform.</li><li>Transition: A record represents from <strong>FromState</strong> to <strong>ToState</strong> through <strong>Event</strong> with <strong>Action</strong>.</li></ul><h2 id="Implementing"><a href="#Implementing" class="headerlink" title="Implementing"></a>Implementing</h2><p>How to implement this FSM? Essentially, we can think of it as a directed cyclic graph, each Node is a state, each edge is a event. So we can use some data structure and algorithm of graph to implement this. </p><p>The following are the implementation steps:</p><ol><li>Config the state machine, usually we can query the all the transitions from database, so we can config it freely.</li><li>Make a <code>Map&lt;FromState, Map&lt;Event, Pair&lt;ToState, List&lt;Action&gt;&gt;&gt;&gt;</code> map, it represents the graph.</li><li>Query current state of product and event, we can get event name from <strong>requestURI</strong>.</li><li>Find the next <code>Pair</code> in Map, by current state and event.</li></ol><p>The following is the implementation of the java language.</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// Action.java</span></span><br><span class="line"><span class="hljs-keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@FunctionalInterface</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Action</span> </span>{</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// ApplyAuditAction.java</span></span><br><span class="line"><span class="hljs-keyword">package</span> org.example.actions;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> org.example.Action;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// send http request to apply an audit</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApplyAuditAction</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Action</span> </span>{</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="hljs-string">"mock send HTTP request"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// AuditController.java</span></span><br><span class="line"><span class="hljs-keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuditController</span> </span>{</span><br><span class="line">    Repository repository;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">apply</span><span class="hljs-params">(<span class="hljs-keyword">int</span> productId)</span> </span>{</span><br><span class="line">        <span class="hljs-keyword">try</span> {</span><br><span class="line">            <span class="hljs-keyword">var</span> product = repository.findProduct(productId);</span><br><span class="line">            <span class="hljs-keyword">var</span> transitions = repository.findAllByTypeId(product.typeId);</span><br><span class="line">            <span class="hljs-keyword">var</span> stateMachine = <span class="hljs-keyword">new</span> StateMachine(transitions);</span><br><span class="line">            stateMachine.transit(product, Event.ApplyAudit);</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-string">"succeed"</span>;</span><br><span class="line">        } <span class="hljs-keyword">catch</span> (RuntimeException e) {</span><br><span class="line">            <span class="hljs-keyword">return</span> e.getMessage();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Event.java</span></span><br><span class="line"><span class="hljs-keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">enum</span> Event {</span><br><span class="line">        ApplyAudit,</span><br><span class="line">        AcceptAudit,</span><br><span class="line">        RejectAudit,</span><br><span class="line">        Publish</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Pair.java</span></span><br><span class="line"><span class="hljs-keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">F</span>, <span class="hljs-title">S</span>&gt; </span>{</span><br><span class="line">    <span class="hljs-keyword">public</span> F first;</span><br><span class="line">    <span class="hljs-keyword">public</span> S second;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pair</span><span class="hljs-params">(F first, S second)</span> </span>{</span><br><span class="line">        <span class="hljs-keyword">this</span>.first = first;</span><br><span class="line">        <span class="hljs-keyword">this</span>.second = second;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Product.java</span></span><br><span class="line"><span class="hljs-keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Product</span> </span>{</span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> id;</span><br><span class="line">    <span class="hljs-keyword">public</span> State state;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> typeId;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Repository.java</span></span><br><span class="line"><span class="hljs-keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// a simple definition of Repository, you need to implement</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Repository</span> </span>{</span><br><span class="line">    <span class="hljs-function">List&lt;Transition&gt; <span class="hljs-title">findAllByTypeId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> typeId)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function">Product <span class="hljs-title">findProduct</span><span class="hljs-params">(<span class="hljs-keyword">int</span> productId)</span></span>;</span><br><span class="line">}</span><br><span class="line"><span class="hljs-comment">// State.java</span></span><br><span class="line"><span class="hljs-keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">enum</span> State {</span><br><span class="line">    Unpublished,</span><br><span class="line">    Auditing,</span><br><span class="line">    AuditAccepted,</span><br><span class="line">    AuditRejected,</span><br><span class="line">    Published</span><br><span class="line">}</span><br><span class="line"><span class="hljs-comment">// StateMachine.java</span></span><br><span class="line"><span class="hljs-keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> org.example.actions.ApplyAuditAction;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="hljs-keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="hljs-keyword">import</span> java.util.List;</span><br><span class="line"><span class="hljs-keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StateMachine</span> </span>{</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;String, Action&gt; actionMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;() {{</span><br><span class="line">        put(<span class="hljs-string">"applyAudit"</span>, <span class="hljs-keyword">new</span> ApplyAuditAction());</span><br><span class="line">    }};</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;State, Map&lt;Event, Pair&lt;State, List&lt;Action&gt;&gt;&gt;&gt; graph;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StateMachine</span><span class="hljs-params">(List&lt;Transition&gt; transitions)</span> </span>{</span><br><span class="line">        graph = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> transition : transitions) {</span><br><span class="line">            addTransition(transition);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addTransition</span><span class="hljs-params">(Transition transition)</span> </span>{</span><br><span class="line">        graph.putIfAbsent(transition.fromState, <span class="hljs-keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">        graph.get(transition.fromState).put(transition.event, <span class="hljs-keyword">new</span> Pair&lt;&gt;(transition.toState, makeActions(transition.actions)));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;Action&gt; <span class="hljs-title">makeActions</span><span class="hljs-params">(String action)</span> </span>{</span><br><span class="line">        <span class="hljs-keyword">var</span> actionNames = action.split(<span class="hljs-string">","</span>); <span class="hljs-comment">// use comma to split multi actions</span></span><br><span class="line">        <span class="hljs-keyword">return</span> Arrays.stream(actionNames).map(actionMap::get).toList();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">transit</span><span class="hljs-params">(Product product, Event event)</span> </span>{</span><br><span class="line">        <span class="hljs-keyword">if</span> (!graph.containsKey(product.state)) {</span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"Product state not found"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="hljs-keyword">if</span> (!graph.get(product.state).containsKey(event)) {</span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"Event not found"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="hljs-keyword">var</span> next = graph.get(product.state).get(event);</span><br><span class="line">        <span class="hljs-comment">// modify product state</span></span><br><span class="line">        product.state = next.first;</span><br><span class="line">        <span class="hljs-comment">// execute actions</span></span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> action : next.second) {</span><br><span class="line">            action.run();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Transition.java</span></span><br><span class="line"><span class="hljs-keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Transition</span> </span>{</span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> id;</span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> typeId; <span class="hljs-comment">// represents the type of a product</span></span><br><span class="line">    <span class="hljs-keyword">public</span> State fromState;</span><br><span class="line">    <span class="hljs-keyword">public</span> Event event;</span><br><span class="line">    <span class="hljs-keyword">public</span> State toState;</span><br><span class="line">    <span class="hljs-keyword">public</span> String actions;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>By using a configurable FSM, you can easily modify the workflow by modifying database record, no code editing.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li><strong><em>Wikipedia</em></strong> - <strong><a href="https://en.wikipedia.org/wiki/Finite-state_machine" target="_blank" rel="noopener">Finite-state machine</a></strong></li></ol></body></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;This is the first article written in English. In this article, I’ll share how to build a Finite State Machine(FSM) to help business workflow transition, such as auditing.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A &lt;strong&gt;finite-state machine&lt;/strong&gt; (&lt;strong&gt;FSM&lt;/strong&gt;) or &lt;strong&gt;finite-state automaton&lt;/strong&gt; (&lt;strong&gt;FSA&lt;/strong&gt;, plural: &lt;em&gt;automata&lt;/em&gt;), &lt;strong&gt;finite automaton&lt;/strong&gt;, or simply a &lt;strong&gt;state machine&lt;/strong&gt;, is a mathematical &lt;a href=&quot;https://en.wikipedia.org/wiki/Model_of_computation&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;model of computation&lt;/a&gt;. It is an &lt;a href=&quot;https://en.wikipedia.org/wiki/Abstract_machine&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;abstract machine&lt;/a&gt; that can be in exactly one of a finite number of &lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/State_(computer_science&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;states&lt;/a&gt;)&lt;/em&gt; at any given time. The FSM can change from one state to another in response to some &lt;a href=&quot;https://en.wikipedia.org/wiki/Input_(computer_science&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;inputs&lt;/a&gt;); the change from one state to another is called a &lt;em&gt;transition&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Wikipedia&lt;/em&gt;&lt;/strong&gt; - &lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite-state_machine&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Finite-state machine&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;/body&gt;&lt;/html&gt;
    
    </summary>
    
      <category term="engineering" scheme="https://www.ddhigh.com/categories/engineering/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL、Redis、Aurora读书笔记</title>
    <link href="https://www.ddhigh.com/2023/05/03/reading-note.html"/>
    <id>https://www.ddhigh.com/2023/05/03/reading-note.html</id>
    <published>2023-05-03T07:07:05.000Z</published>
    <updated>2023-05-05T02:52:12.002Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>本文分享一下五一期间的读书感悟，包括MySQL、Redis、Aurora。</p><a id="more"></a><h2 id="优化Redis主线程负载"><a href="#优化Redis主线程负载" class="headerlink" title="优化Redis主线程负载"></a>优化Redis主线程负载</h2><ol><li><p>网络IO可以多线程处理，将请求包体和文件描述符投递到一个<strong>request</strong>队列，参考结构如下</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Request</span> </span>{</span><br><span class="line">  <span class="hljs-keyword">byte</span>[] req;</span><br><span class="line">  <span class="hljs-keyword">int</span> fd;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>主线程轮询<strong>request</strong>队列，取出<strong>req</strong>数据并按照以往方式准备响应<strong>resp</strong>，再次投递到一个<strong>response</strong>队列，参考结构如下</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Response</span> </span>{</span><br><span class="line">  <span class="hljs-keyword">byte</span>[] req;</span><br><span class="line">  <span class="hljs-keyword">int</span> fd;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>网络IO线程轮询<strong>response</strong>队列，将数据发往指定<strong>fd</strong></p></li></ol><p>优点：</p><ul><li>解耦业务线程和IO线程，充分利用多线程能力</li><li>基于单线程+队列保证Redis业务线程仍然是单线程，无需同步/互斥逻辑</li></ul><p>缺点：</p><ul><li>需要维护两个额外队列，当请求激增，主线程处理不过来会造成数据积压</li></ul><h2 id="MySQL事务过程"><a href="#MySQL事务过程" class="headerlink" title="MySQL事务过程"></a>MySQL事务过程</h2><ol><li>从磁盘加载数据到bufferpool</li><li>写入并Flush undo日志 (顺序磁盘IO)</li><li>修改bufferpool中的数据</li><li>写入redo日志，不flush(无磁盘IO)</li><li>如果有其他数据参与，重复步骤1…4</li><li>设置所有redo日志为prepare状态</li><li>写入并Flush binlog(顺序磁盘IO)</li><li>Flush redo日志（顺序磁盘IO）</li><li>提交事务</li></ol><h2 id="MySQL-double-write"><a href="#MySQL-double-write" class="headerlink" title="MySQL double-write"></a>MySQL double-write</h2><blockquote><p>关于IO的最小单位：</p><p>　　1. 数据库IO的最小单位是16K（MySQL默认，oracle是8K）</p><p>　　2. 文件系统IO的最小单位是4K（也有1K的）</p><p>　　3. 磁盘IO的最小单位是512字节</p><p>因此，存在IO写入导致page损坏的风险：</p><p><img src="https://static.ddhigh.com/blog/2023/05/03/1683100294373935000.png" alt="img"> </p><p><strong><em><a href="https://home.cnblogs.com/u/geaozhang/" target="_blank" rel="noopener">GeaoZhang</a></em></strong> - <a href="https://www.cnblogs.com/geaozhang/p/7241744.html" target="_blank" rel="noopener">InnoDB关键特性之double write</a></p></blockquote><p>上述例子中，一个脏页只有前面一半落盘了，后面一半还是老数据，所以这一个16K脏页数据无效。</p><h3 id="redo日志无法恢复"><a href="#redo日志无法恢复" class="headerlink" title="redo日志无法恢复"></a>redo日志无法恢复</h3><p>redo日志记录对数据页的物理修改，但是现在出现的问题是页本身无效，redo日志也无法恢复。具体原因如下：</p><ol><li>数据文件上有一个老页面，加载到内存之后，内存也有一个老页面</li><li>修改内存数据，比如把某脏页第2个字节改为1， redo日志记录把该页第2个字节改为1</li><li>当InnoDB刷新脏页出现刷一半的问题时，数据文件上的老页面已经无效了（一半是新的，一半是旧的），跟内存修改时的老页面不一致，redo日志无法应用</li></ol><h3 id="double-write流程"><a href="#double-write流程" class="headerlink" title="double-write流程"></a>double-write流程</h3><p><img src="https://static.ddhigh.com/blog/2023/05/03/1683100403081956000.png" alt="img"></p><ol><li>脏页刷新时，拷贝到内存中的doublewrite buffer（大小2MB）</li><li>将doublewrite buffer分两次写入共享表空间文件（每次1MB，顺序IO，速度快）</li><li>将doublewrite buffer数据写入数据文件（随机磁盘IO）</li></ol><p>本质上优点类似WAL(Write-Ahead-Log)，通过先顺序写入文件，再随机磁盘IO落盘。</p><h3 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h3><p>回到最开始的问题，InnoDB恢复时可以通过校验和发现数据文件中的脏页数据无效（对比脏页计算出来的校验和和磁盘上的校验和），此时可以通过共享表空间文件找到该页最近的数据，复制到数据文件，再应用redo日志，完成恢复</p><h2 id="Aurora"><a href="#Aurora" class="headerlink" title="Aurora"></a>Aurora</h2><p>Aurora是Amazon研发的分布式MySQL，随着数据库上云，传统数据库的磁盘IO瓶颈已经变为了数据计算层和存储曾之间的IO瓶颈。换句话说，由于SSD的广泛使用，磁盘IO本身基本不是瓶颈。</p><p>Aurora的主要优点如下：</p><ul><li>使用一个独立部署、能容忍错误并且能自动修改的分布式存储服务（跨数据中心），保证数据库不受存储层的可用性影响</li><li>不同数据库计算节点之间以及数据库存储节点之间，网络IO只有redolog（没有binlog）</li><li>将耗时的串行操作尽量拆解为异步操作，减少延迟</li></ul><h3 id="术语定义"><a href="#术语定义" class="headerlink" title="术语定义"></a>术语定义</h3><ul><li>计算节点：安装数据库软件的节点</li><li>存储节点：存储数据的节点</li></ul><h3 id="传统MySQL分布式架构"><a href="#传统MySQL分布式架构" class="headerlink" title="传统MySQL分布式架构"></a>传统MySQL分布式架构</h3><p><img src="https://static.ddhigh.com/blog/2023/05/03/1683099089289616000.PNG" alt="原MySQL负载"></p><p>可以看到MySQL节点之间同步了非常多的数据，而由于MySQL的分层架构，数据库层和存储引擎层是分离的，导致binlog和redolog两份日志出现，实际上这两份日志的功能本质上是一样的，提供数据镜像和数据恢复。</p><h3 id="Aurora的网络IO"><a href="#Aurora的网络IO" class="headerlink" title="Aurora的网络IO"></a>Aurora的网络IO</h3><p>Aurora极大减少了网络IO，节点之间真正传输的只有redolog和表的元数据，下图是Aurora的网络IO</p><p><img src="https://static.ddhigh.com/blog/2023/05/03/1683099365972619000.PNG" alt="Aurora优化负载"></p><p>一个数据写入流程如下：</p><ol><li>存储节点接收到redo日志，写入本地内存队列（无磁盘IO）</li><li>将redo日志持久化到磁盘，并返回响应给计算节点（顺序磁盘IO）</li><li>整理记录，并检查是否有因为一些操作丢失导致的记录差异。</li><li>基于gossip解析和其他节点对齐数据</li><li>应用redo日志记录，将数据变更应用到数据页（随机磁盘IO）</li><li>定期将日志和新页面备份到S3</li><li>定期进行垃圾回收，清理掉无用的旧版本数据，释放存储空间</li><li>定期进行CRC校验， 修复损坏数据</li></ol><p>只有1/2步会影响计算节点，其他步骤全部是异步的，这是高性能的保证</p><h3 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h3><p>redo日志关联了（LSN，Log Sequence Number），LSN的概念和MySQL一致，当节点丢失数据时，可以通过gossip和其他节点对比LSN并补齐丢失的数据。</p><p>而当需要进行故障恢复时，Aurora首先会保证所有节点上的数据一致，通过使用LSN来实现，Aurora会选出一个保证可用的最高LSN，称为VCL（Volume Complete LSN），任何LSN高于VCL的日志记录会被截断。Aurora还规定只有某些特定的LSN可以作为截断点，称为CPL（Consistency Point LSNs），另外定义了VDL（Volume Durable LSN）为小于等于VCL的最大CPL。</p><p>简单例子：当前日志的LSN已经达到了1007，但数据库定义CPL为900，1000，1100这些特定值。那么&gt;1000的LSN数据会被截断，所以，最终VCL是1000。实际流程如下：</p><ol><li>每个数据库层事务被切分成多个有序且可被原子操作的小事务（mini-transactions，MTRs）</li><li>每个MTR由多个连续的log record组成。</li><li>一个MTR的最后一个log record被认为是一个CPL。</li></ol><h3 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h3><blockquote><ul><li>Writes：当数据库收到一批log日志的write quorum的确认后，就会向前推进当前的VDL。在每一时刻，会有很多事务在同时进行，数据库会为每个日志分配一个唯一有序的LSN，同时LSN要小于当前VDL和LAL（LSN Allocation Lmit）的和。这段话翻译有些生硬，其实就是为了防止前台操作太快，后台存储系统处理不过来，LSN不能超前VDL太多，其差值最大为LAL，目前设置为10M。同时，为了解决每个分片可能存在的日志丢失问题，每个日志都有一个向前的回链（像是一个反向链表），通过向前回溯，以及Gossip交互，可以为各个节点构建一个完整的日志记录，称之为SCL（Segement Complete LSN），也即所有日志到达了所有节点的最大LSN。</li><li>Commits：Aurora的事务提交是完全异步的。工作线程收到commit请求，在一个等待commit的事务列表中记录它的commit LSN，然后就继续处理其它请求。有一个专门的线程在VDL推进时，判断列表中有哪些LSN小于等于VDL，然后将这些事务的应答推回给还在等待的客户端。</li><li>Reads：Aurora和很多其它数据库一样，数据页会放在缓存中，命中丢失时才会做一次IO请求，当缓存满时，系统会根据特定的算法汰换数据页。Aurora不一样的是，它要求在缓存中的page LSN一定要大于等于VDL。从而保证在这个数据页中所有请求都已经写到log，且可以通过VDL始终获取到最新的持久化数据。也因此，正常的读取只需要读一个满足条件的分片就足够了。</li><li>Replicas：在Aurora中，一个存储磁盘可以挂载一个writer和最多15个read副本。增加一个read副本不会对性能有什么影响。为了加快响应，写请求生成的日志流也会被发送到所有读副本中去。如果这个写请求涉及到当前缓存中的某个数据页，那就把这个请求更新到数据页中，否则就直接丢弃了。这里读副本消费请求是异步的，需要遵循两条规则：一是会更新到数据页的请求，其LSN需要小于等于VDL。二是mini-transaction的修改需要原子性的写入缓存，以保障数据一致性。</li></ul><p><strong><em>Hotlink Qiu</em></strong> - <a href="https://hotlinkqiu.github.io/2019/08/15/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E7%A0%94%E7%A9%B6%E2%80%94%E2%80%94Aurora/" target="_blank" rel="noopener">分布式存储研究——Aurora</a></p></blockquote><h3 id="数据恢复-1"><a href="#数据恢复-1" class="headerlink" title="数据恢复"></a>数据恢复</h3><p>和MySQL不同，Aurora的数据恢复是后台化的，在存储层即可完成，无需停机。恢复完成后，需要进行quorum读(从其他副本取出保证可用的数据)，同时进行VDL计算，截断&gt;VDL的数据，这些操作都可以在后台进行，不影响前台响应延迟。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://hotlinkqiu.github.io/2019/08/15/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E7%A0%94%E7%A9%B6%E2%80%94%E2%80%94Aurora/" target="_blank" rel="noopener">分布式存储研究——Aurora</a></li><li><a href="https://www.cnblogs.com/geaozhang/p/7241744.html" target="_blank" rel="noopener">InnoDB关键特性之double write</a></li></ul></body></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;本文分享一下五一期间的读书感悟，包括MySQL、Redis、Aurora。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
    
    </summary>
    
      <category term="engineering" scheme="https://www.ddhigh.com/categories/engineering/"/>
    
    
  </entry>
  
  <entry>
    <title>修复M1使用gomonkey提示permission defined错误</title>
    <link href="https://www.ddhigh.com/2023/04/20/fix-gomonkey-permission-defined.html"/>
    <id>https://www.ddhigh.com/2023/04/20/fix-gomonkey-permission-defined.html</id>
    <published>2023-04-20T04:00:00.000Z</published>
    <updated>2023-05-05T02:52:12.002Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>Go单元测试在M1上使用<code>github.com/agiledragon/gomonkey/v2 v2.9.0</code>包提示<code>permission defined</code>。<br>网上查阅消息得知是由于内存安全导致，不能同时对内存进行写和执行</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>下面分享一种比较简单的方法，需要修改本地的go源码。</p><p>修改<a href="mailto:`go/pkg/mod/github.com/agiledragon/gomonkey/v2@v2.9.0">`go/pkg/mod/github.com/agiledragon/gomonkey/v2@v2.9.0</a>/modify_binary_darwin.go<code>的</code>modifyBinary`方法。<br>将<br></p><figure class="highlight go hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err := mprotectCrossPage(target, <span class="hljs-built_in">len</span>(bytes), syscall.PROT_READ|syscall.PROT_WRITE|syscall.PROT_EXEC)</span><br></pre></td></tr></tbody></table></figure><br>修改为<br><figure class="highlight go hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err := mprotectCrossPage(target, <span class="hljs-built_in">len</span>(bytes), syscall.PROT_READ|syscall.PROT_WRITE)</span><br></pre></td></tr></tbody></table></figure><p></p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;Go单元测试在M1上使用&lt;code&gt;github.com/agiledragon/gomo
      
    
    </summary>
    
      <category term="engineering" scheme="https://www.ddhigh.com/categories/engineering/"/>
    
    
  </entry>
  
  <entry>
    <title>拓补排序</title>
    <link href="https://www.ddhigh.com/2023/02/10/topological-sorting.html"/>
    <id>https://www.ddhigh.com/2023/02/10/topological-sorting.html</id>
    <published>2023-02-10T04:00:00.000Z</published>
    <updated>2023-05-05T02:52:12.002Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><blockquote><p> 在计算机科学领域，有向图的拓扑排序或拓扑测序是对其顶点的一种线性排序，使得对于从顶点$u$到顶点$v$的每个有向边$uv$, $u$在排序中都在$v$之前。</p><p>例如，图形的顶点可以表示要执行的任务，并且边可以表示一个任务必须在另一个任务之前执行的约束；在这个应用中，拓扑排序只是一个有效的任务顺序。</p><p>当且仅当图中没有定向环时（即有向无环图），才有可能进行拓扑排序。</p><p>任何有向无环图至少有一个拓扑排序。</p></blockquote><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ol><li>遍历有向边，构造u-&gt;v边中v的入度表，可使用哈希存储入度</li><li>将入度为0的节点入队</li><li>队列节点不断出队，出队时减小被更新节点的入度，如果被更新节点入度为0，则该节点入队</li><li>重复以上过程，最终可以得到一个从入度为0到最终节点的序列，这就是拓补排序算法。</li></ol><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>Leetcode <a href="https://leetcode.cn/problems/course-schedule-ii/description/" target="_blank" rel="noopener">210. 课程表2</a></p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 生成邻接表 &lt;当前节点，后置节点&gt;</span></span><br><span class="line">    <span class="hljs-comment">// 进行BFS拓补排序，由最低依赖的开始写入答案</span></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] findOrder(<span class="hljs-keyword">int</span> numCourses, <span class="hljs-keyword">int</span>[][] prerequisites) {</span><br><span class="line">        Set&lt;Integer&gt;[] graph = <span class="hljs-keyword">new</span> HashSet[numCourses];</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numCourses; i++) {</span><br><span class="line">            graph[i] = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        }</span><br><span class="line">        <span class="hljs-comment">// 入度</span></span><br><span class="line">        <span class="hljs-keyword">int</span>[] inDegree = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[numCourses];</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] p : prerequisites) {</span><br><span class="line">            <span class="hljs-keyword">int</span> current = p[<span class="hljs-number">0</span>];</span><br><span class="line">            <span class="hljs-keyword">int</span> pre = p[<span class="hljs-number">1</span>];</span><br><span class="line">            graph[pre].add(current);</span><br><span class="line">            inDegree[current]++;</span><br><span class="line">        }</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numCourses; i++) {</span><br><span class="line">            <span class="hljs-keyword">if</span> (inDegree[i] == <span class="hljs-number">0</span>) {</span><br><span class="line">                queue.offer(i);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="hljs-keyword">int</span>[] answer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[numCourses];</span><br><span class="line">        <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">while</span> (!queue.isEmpty()) {</span><br><span class="line">            <span class="hljs-comment">// 弹出课程</span></span><br><span class="line">            <span class="hljs-keyword">int</span> course = queue.remove();</span><br><span class="line">            answer[index++] = course;</span><br><span class="line">            <span class="hljs-comment">// 遍历邻接表，减掉入度，入度归0时入队</span></span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> target : graph[course]) {</span><br><span class="line">                inDegree[target]--;</span><br><span class="line">                <span class="hljs-keyword">if</span> (inDegree[target] == <span class="hljs-number">0</span>) {</span><br><span class="line">                    queue.offer(target);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="hljs-keyword">return</span> index &gt;= numCourses ? answer : <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>复杂度分析</strong></p><p>时间复杂度：$O(n)$ ,$n$是课程数量</p><p>空间复杂度：$O(n)$，$n$是课程数量</p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;blockquote&gt;
&lt;p&gt; 在计算机科学领域，有向图的拓扑排序或拓扑测序是对其顶点的一种线性排序，使得对于从顶点$u$到顶点$v$的每个有向边$uv$, $u$在排序中都在$v$之前。&lt;/p&gt;
&lt;p&gt;例如，图形的顶点可以表示
      
    
    </summary>
    
      <category term="algorithm" scheme="https://www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="leetcode" scheme="https://www.ddhigh.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>水塘抽样算法</title>
    <link href="https://www.ddhigh.com/2023/01/19/reservoir-sampling.html"/>
    <id>https://www.ddhigh.com/2023/01/19/reservoir-sampling.html</id>
    <published>2023-01-19T15:34:44.000Z</published>
    <updated>2023-05-05T02:52:12.002Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>下面是<a href="https://zh.wikipedia.org/zh-mo/%E6%B0%B4%E5%A1%98%E6%8A%BD%E6%A8%A3" target="_blank" rel="noopener">维基百科水塘抽样</a>的说明。</p><blockquote><p> 水塘抽样是一系列的随机算法，其目的在于从包含 $n$个项目的集合  中选取$k$ 个样本，其中 $n$为一很大或未知的数量，尤其适用于不能把所有 $n$ 个项目都存放到内存的情况。</p></blockquote><p>本文分享在随机数据流中等概率抽取target的水塘抽样算法。</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ol><li>定义$count$计数变量</li><li>遍历给定的数据流，如果当前数字等于$target$, $count$+1</li><li>在$[0, count]$产生随机数，如果等于$count$，则抽样成功</li></ol><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>Leetcode <a href="https://leetcode.cn/problems/random-pick-index/" target="_blank" rel="noopener">398. 随机数索引</a></p><p><strong>代码</strong></p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">// 哈希表保存&lt;值,List&lt;下标&gt;&gt;</span></span><br><span class="line">        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] nums;</span><br><span class="line">        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Random random;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Solution</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">            <span class="hljs-keyword">this</span>.nums = nums;</span><br><span class="line">            <span class="hljs-keyword">this</span>.random = <span class="hljs-keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">// 水塘抽样</span></span><br><span class="line">        <span class="hljs-comment">// 统计target count,随机数%count 为0时重置index</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pick</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target)</span> </span>{</span><br><span class="line">            <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;</span><br><span class="line">            <span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>;</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line">                <span class="hljs-keyword">if</span> (nums[i] == target) {</span><br><span class="line">                    count++;</span><br><span class="line">                    <span class="hljs-keyword">if</span> (random.nextInt() % count == <span class="hljs-number">0</span>) {</span><br><span class="line">                        index = i;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="hljs-keyword">return</span> index;</span><br><span class="line">        }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>复杂度分析</strong></p><p>时间复杂度：$O(n)$,$n$是$nums$长度，需要遍历一次$nums$</p><p>空间复杂度：$O(1)$,严格来说，java默认使用浅拷贝，因此$nums$不会有额外空间占用。</p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;下面是&lt;a href=&quot;https://zh.wikipedia.org/zh-mo/%E6%B0%B4%E5%A1%98%E6%8A%BD%E6%A8%A3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;
      
    
    </summary>
    
      <category term="algorithm" scheme="https://www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="leetcode" scheme="https://www.ddhigh.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>时间差计算算法</title>
    <link href="https://www.ddhigh.com/2023/01/19/time-difference.html"/>
    <id>https://www.ddhigh.com/2023/01/19/time-difference.html</id>
    <published>2023-01-19T15:27:14.000Z</published>
    <updated>2023-05-05T02:52:12.002Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>本文分享如何解决计算时间差类的问题。</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ol><li>首先需要将时间转化为数字，比如23:59，可以转化为23*60+59</li><li>然后根据数字从小到大排序，此时从<code>[0, n]</code>处的数据有序，可以遍历该区间计算差值</li><li>需要注意的是，由于时间的特殊性，比如<code>23:59</code>下一分会归0，因此还需要比如<code>0</code>处和<code>n</code>处的时间差</li></ol><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>Leetcode <a href="https://leetcode.cn/problems/minimum-time-difference/" target="_blank" rel="noopener">539. 最小时间差</a></p><p><strong>代码</strong></p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">// 模拟</span></span><br><span class="line">        <span class="hljs-comment">// 时间字符串转化为数字</span></span><br><span class="line">        <span class="hljs-comment">// 排序，线性遍历，然后再比较第一个和最后一个的差值</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findMinDifference</span><span class="hljs-params">(List&lt;String&gt; timePoints)</span> </span>{</span><br><span class="line">            <span class="hljs-comment">// 24小时总共1440个可能，超过1440，直接返回0（存在重复时间点）</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (timePoints.size() &gt; <span class="hljs-number">1440</span>) {</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="hljs-keyword">var</span> array = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[timePoints.size()];</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; timePoints.size(); i++) {</span><br><span class="line">                <span class="hljs-keyword">var</span> str = timePoints.get(i);</span><br><span class="line">                array[i] = Integer.parseInt(str.substring(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>)) * <span class="hljs-number">60</span> + Integer.parseInt(str.substring(<span class="hljs-number">3</span>));</span><br><span class="line">            }</span><br><span class="line">            Arrays.sort(array);</span><br><span class="line">            <span class="hljs-keyword">var</span> answer = Integer.MAX_VALUE;</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; array.length; i++) {</span><br><span class="line">                answer = Math.min(answer, array[i] - array[i - <span class="hljs-number">1</span>]);</span><br><span class="line">            }</span><br><span class="line">            <span class="hljs-comment">// 和首尾差值比较</span></span><br><span class="line">            <span class="hljs-keyword">return</span> Math.min(answer, array[<span class="hljs-number">0</span>] + <span class="hljs-number">1440</span> - array[array.length - <span class="hljs-number">1</span>]);</span><br><span class="line">        }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>复杂度分析</strong></p><p>时间复杂度：$O(nlogn)$,$n$是序列长度，主要是排序的时间。</p><p>空间复杂度：$O(n)$,$n$是序列长度。</p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;本文分享如何解决计算时间差类的问题。&lt;/p&gt;
&lt;h2 id=&quot;算法&quot;&gt;&lt;a href=&quot;#算法&quot; class=&quot;headerlink&quot; title=&quot;算法&quot;&gt;&lt;/a&gt;算法&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;首先需要将时间转化为数字，
      
    
    </summary>
    
      <category term="algorithm" scheme="https://www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="leetcode" scheme="https://www.ddhigh.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>滑动窗口算法</title>
    <link href="https://www.ddhigh.com/2023/01/19/slide-window-algorithm.html"/>
    <id>https://www.ddhigh.com/2023/01/19/slide-window-algorithm.html</id>
    <published>2023-01-19T15:16:29.000Z</published>
    <updated>2023-05-05T02:52:12.002Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>滑动窗口算法是查找连续区间常用的算法之一。</p><p>本文分享滑动窗口算法的通用框架。</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ol><li>定义$left$和$right$双指针，代表窗口的左边界和右边界</li><li>当$right$小于给定区间大小时，我们可以进行操作。</li><li>在扩大窗口时，需要加当前新加入的数据进行处理</li><li>当当前窗口内数据不满足条件时，右移$left$指针缩小窗口</li><li>计算$[left,right]$之间的数据，和最佳答案比较并更新最佳答案</li><li>右移$right$</li></ol><p>下面是滑动窗口通用框架的java语言实现。</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">while</span>(right &lt; 上界) {</span><br><span class="line">  将right处数据加入窗口</span><br><span class="line">  <span class="hljs-keyword">while</span>(窗口数据不符合要求) {</span><br><span class="line">    移除left数据</span><br><span class="line">    left++</span><br><span class="line">  }</span><br><span class="line">  根据当前right和left计算最佳答案并更新</span><br><span class="line">  right++</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>Leetcode <a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/" target="_blank" rel="noopener">3. 无重复字符的最长子串</a></p><p><strong>思路</strong></p><p>基于算法框架的思路如下：</p><ol><li>定义$left$和$right$双指针，代表窗口的左边界和右边界，再定义<code>HashMap&lt;Character, Integer&gt;</code>存储窗口内的字符和数量(可以使用长度为<code>128</code>的字符数组代替，省去操作hashmap的开销。</li><li>当$right$小于$s.length()$时，我们可以进行操作。</li><li>在扩大窗口时，将$s.charAt(right)$加入<code>HashMap</code></li><li>当<code>HashMap.get(s.charAt(right)&gt;1)</code>，此时$right$处字符重复，需要收缩左边界，$left$处的字符数量-1，右移$left$</li><li>计算$[left,right]$之间的数据，和最佳答案比较并更新最佳答案</li></ol><p><strong>代码</strong></p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{</span><br><span class="line">    <span class="hljs-comment">// 滑动窗口</span></span><br><span class="line">        <span class="hljs-comment">// 定义left,right, hashmap&lt;char,int&gt;</span></span><br><span class="line">        <span class="hljs-comment">// 循环条件 right&lt;s.length()</span></span><br><span class="line">        <span class="hljs-comment">// right字符入map</span></span><br><span class="line">        <span class="hljs-comment">// while刚才入的字符重复，map移除left的字符，left++</span></span><br><span class="line">        <span class="hljs-comment">// 计算长度</span></span><br><span class="line">        <span class="hljs-comment">// right++</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>{</span><br><span class="line">            <span class="hljs-keyword">var</span> left = <span class="hljs-number">0</span>;</span><br><span class="line">            <span class="hljs-keyword">var</span> right = <span class="hljs-number">0</span>;</span><br><span class="line">            <span class="hljs-keyword">var</span> answer = <span class="hljs-number">0</span>;</span><br><span class="line">            <span class="hljs-keyword">var</span> map = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">128</span>];</span><br><span class="line">            <span class="hljs-keyword">while</span> (right &lt; s.length()) {</span><br><span class="line">                <span class="hljs-keyword">var</span> rightChar = s.charAt(right);</span><br><span class="line">                map[rightChar]++;</span><br><span class="line">                <span class="hljs-comment">// 窗口有重复字符，收缩左边界</span></span><br><span class="line">                <span class="hljs-keyword">while</span> (map[rightChar] &gt; <span class="hljs-number">1</span>) {</span><br><span class="line">                    <span class="hljs-keyword">var</span> leftChar = s.charAt(left);</span><br><span class="line">                    map[leftChar]--;</span><br><span class="line">                    left++;</span><br><span class="line">                }</span><br><span class="line">                answer = Math.max(answer, right - left + <span class="hljs-number">1</span>);</span><br><span class="line">                right++;</span><br><span class="line">            }</span><br><span class="line">            <span class="hljs-keyword">return</span> answer;</span><br><span class="line">        }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>复杂度分析</strong></p><p>时间复杂度：$O(n)$, $n$是字符串长度，每个字符至多访问2次。</p><p>空间复杂度: $O(1)$，只需常数项空间。</p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;滑动窗口算法是查找连续区间常用的算法之一。&lt;/p&gt;
&lt;p&gt;本文分享滑动窗口算法的通用框架。&lt;/p&gt;
&lt;h2 id=&quot;算法&quot;&gt;&lt;a href=&quot;#算法&quot; class=&quot;headerlink&quot; title=&quot;算法&quot;&gt;&lt;/a&gt;算法
      
    
    </summary>
    
      <category term="algorithm" scheme="https://www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="leetcode" scheme="https://www.ddhigh.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>字符串子序列检测算法</title>
    <link href="https://www.ddhigh.com/2023/01/05/subsequence-checking-algorithm.html"/>
    <id>https://www.ddhigh.com/2023/01/05/subsequence-checking-algorithm.html</id>
    <published>2023-01-05T04:36:10.000Z</published>
    <updated>2023-05-05T02:52:12.002Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>本文分享一种检测一个字符串是否为另一个字符串子序列的算法。</p><p>子序列的定义：</p><p>若字符串$s1$可以由字符串$s2$删除某些字符得到，则$s1$是$s2$的子序列。换句话说，若$s1$的所有字符都在$s2$中且顺序一致，则$s1$是$s2$的子序列。</p><p>例如：</p><p>a是aaa的子序列，adf是abcdef的子序列，但是cba不是abc的子序列（因为字符顺序变了）。</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ol><li>声明$s1$的下标变量$strIndex$，若$s2$有$s1$的该字符，则$strIndex+1$</li><li>若遍历过程中$strIndex$和$s1$的长度相等，则证明$s1$所有字符都在$s2$中，返回$s1$是$s2$在子序列</li><li>遍历结束仍未返回，证明$s1$不是$s2$的子序列</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSubsequent</span><span class="hljs-params">(String str, String str1)</span> </span>{</span><br><span class="line">            <span class="hljs-keyword">var</span> strIndex = <span class="hljs-number">0</span>;</span><br><span class="line">            <span class="hljs-comment">// 逐字符遍历</span></span><br><span class="line">            <span class="hljs-comment">// 如果字符想通，则strIndex++</span></span><br><span class="line">            <span class="hljs-comment">// 如果strIndex到达末尾，则证明str是子序列</span></span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; str1.length(); i++) {</span><br><span class="line">                <span class="hljs-keyword">if</span> (str.charAt(strIndex) == str1.charAt(i)) {</span><br><span class="line">                    strIndex++;</span><br><span class="line">                }</span><br><span class="line">                <span class="hljs-keyword">if</span> (strIndex == str.length()) {</span><br><span class="line">                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>复杂度分析</strong></p><p>时间复杂度：$O(n)$,$n$是$str1$的长度。</p><p>空间复杂度：$O(1)$。</p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;本文分享一种检测一个字符串是否为另一个字符串子序列的算法。&lt;/p&gt;
&lt;p&gt;子序列的定义：&lt;/p&gt;
&lt;p&gt;若字符串$s1$可以由字符串$s2$删除某些字符得到，则$s1$是$s2$的子序列。换句话说，若$s1$的所有字符都在$
      
    
    </summary>
    
      <category term="algorithm" scheme="https://www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="leetcode" scheme="https://www.ddhigh.com/tags/leetcode/"/>
    
      <category term="string" scheme="https://www.ddhigh.com/tags/string/"/>
    
  </entry>
  
  <entry>
    <title>计算数字二进制位中1的个数</title>
    <link href="https://www.ddhigh.com/2023/01/05/counting-bit1-of-binary-number.html"/>
    <id>https://www.ddhigh.com/2023/01/05/counting-bit1-of-binary-number.html</id>
    <published>2023-01-05T04:35:00.000Z</published>
    <updated>2023-05-05T02:52:12.002Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>本文分享一种计算给定数字二进制表示中有多少个1的算法。</p><p>位运算对于非硬件相关的开发者来说可能用的比较少，朴素做法是将数字转换为二进制字符串，然后遍历该字符串得到1的个数。</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ol><li>通过右移我们可以访问到数字的指定比特</li><li>将该比特与1进行按位与<code>&amp;</code>，结果为1则证明当前比特位是1，计数器+1</li></ol><p>根据给定数字的数据类型可以确定需要位移的次数，对于<code>int</code>来说，4个字节，因此需要右移32次，而对于<code>long</code>来说，8个字节，需要右移64次。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getBit1Count</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>{</span><br><span class="line">              <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;</span><br><span class="line">              <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++) {</span><br><span class="line">                  <span class="hljs-keyword">if</span> (((num &gt;&gt; i) &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) {</span><br><span class="line">                      count++;</span><br><span class="line">                  }</span><br><span class="line">              }</span><br><span class="line">              <span class="hljs-keyword">return</span> count;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>复杂度分析</strong></p><p>时间复杂度：$O(1)$，不管多大的数字，只需要右移32次。</p><p>空间复杂度：$O(1)$，无需额外空间。</p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;本文分享一种计算给定数字二进制表示中有多少个1的算法。&lt;/p&gt;
&lt;p&gt;位运算对于非硬件相关的开发者来说可能用的比较少，朴素做法是将数字转换为二进制字符串，然后遍历该字符串得到1的个数。&lt;/p&gt;
&lt;h2 id=&quot;算法&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="algorithm" scheme="https://www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="leetcode" scheme="https://www.ddhigh.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>解析字符串中的数字</title>
    <link href="https://www.ddhigh.com/2023/01/03/parse-number-in-string.html"/>
    <id>https://www.ddhigh.com/2023/01/03/parse-number-in-string.html</id>
    <published>2023-01-03T14:36:49.000Z</published>
    <updated>2023-05-05T02:52:12.002Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>本文分享一种如何在字符串中解析数字的算法。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>解析字符串中的数字需要判断当前是否是数字字符，以及如何处理连续的数字字符。</p><p>本文使用while循环来解析数字，之所以不使用for循环，是笔者认为while循环操控力比for循环要好。</p><p>while循环解析方法如下：</p><ol><li>如果当前字符是数字，则开启内部while循环</li><li>内部while循环退出条件为当前字符不是数字</li><li>内部循环操作为读取当前数字，然后加上一个数字乘以10</li><li>内部循环退出后，我们就得到一个连续的数字</li></ol><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>Leetcode <a href="https://leetcode.cn/problems/check-if-numbers-are-ascending-in-a-sentence/" target="_blank" rel="noopener">2042. 检查句子中的数字是否递增</a></p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">// 提取字符串中的数字，判断是否严格递增</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">areNumbersAscending</span><span class="hljs-params">(String s)</span> </span>{</span><br><span class="line">            <span class="hljs-comment">// 定义上一个数字，初始化为最小的数字</span></span><br><span class="line">            <span class="hljs-keyword">var</span> lastNumber = Integer.MIN_VALUE;</span><br><span class="line">            <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;</span><br><span class="line">            <span class="hljs-keyword">while</span> (i &lt; s.length()) {</span><br><span class="line">                <span class="hljs-keyword">if</span> (Character.isDigit(s.charAt(i))) { <span class="hljs-comment">// 当前是数字，继续处理</span></span><br><span class="line">                    <span class="hljs-keyword">var</span> number = <span class="hljs-number">0</span>;</span><br><span class="line">                    <span class="hljs-comment">// 核心代码</span></span><br><span class="line">                    <span class="hljs-keyword">while</span> (i &lt; s.length() &amp;&amp; Character.isDigit(s.charAt(i))) { <span class="hljs-comment">// 字符串没越界而且当前字符是数字字符</span></span><br><span class="line">                        number = number * <span class="hljs-number">10</span> + (s.charAt(i) - <span class="hljs-string">'0'</span>); <span class="hljs-comment">// (s.charAt(i) - '0') 就是利用ASCII码表直接得到数字值，不需要再做parseInt</span></span><br><span class="line">                        i++; <span class="hljs-comment">// 坐标后移</span></span><br><span class="line">                    }</span><br><span class="line">                    <span class="hljs-keyword">if</span> (number &lt;= lastNumber) { <span class="hljs-comment">// 如果当前数字&lt;=上一个数字，证明不是严格递增，return false</span></span><br><span class="line">                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="hljs-comment">// number &gt; lastNumber，更新lastNumber</span></span><br><span class="line">                    lastNumber = number;</span><br><span class="line">                }</span><br><span class="line">                <span class="hljs-comment">// i后移</span></span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p><strong>复杂度分析</strong></p><p>时间复杂度：$O(n)$，每个字符访问一次。<br>空间复杂度:$O(1)$，仅需常数项额外变量。</p><p><strong>注意</strong></p><p>时间复杂度就是分析随着数据量增大，算法执行次数的变化。本题虽然有两重循环，有些同学可能无脑以为时间复杂度是$O(n^2)$，实际上是不对的。可以发现每个字符串最多访问一次，所以复杂度是$O(n)$。</p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;本文分享一种如何在字符串中解析数字的算法。&lt;/p&gt;
&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;p&gt;解析字符串中的数字需要判断当前是
      
    
    </summary>
    
      <category term="algorithm" scheme="https://www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="leetcode" scheme="https://www.ddhigh.com/tags/leetcode/"/>
    
      <category term="string" scheme="https://www.ddhigh.com/tags/string/"/>
    
  </entry>
  
  <entry>
    <title>查找第N大的数</title>
    <link href="https://www.ddhigh.com/2023/01/03/nth-maximum-number.html"/>
    <id>https://www.ddhigh.com/2023/01/03/nth-maximum-number.html</id>
    <published>2023-01-03T04:22:08.000Z</published>
    <updated>2023-05-05T02:52:12.002Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>在给定的序列中查找第N大的数，朴素做法是对序列排序，然后根据索引直接查询，时间复杂度为$O(nlogn)$。</p><p>本文介绍一种在$O(n)$的时间复杂度查询第N大的数的算法。</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>算法思路就是定义标志变量，然后遍历数组，根据标志变量和当前数组变量的大小更新标志变量，最后根据情况返回标志变量。</p><h2 id="示例：查找第2大的数"><a href="#示例：查找第2大的数" class="headerlink" title="示例：查找第2大的数"></a>示例：查找第2大的数</h2><p>定义$first$和$second$分别存储最大和次大，然后遍历数组时更新即可。</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 查找第二大的数字</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecondMaximumNumber</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">secondMaximumNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">        <span class="hljs-comment">// 最大数</span></span><br><span class="line">        <span class="hljs-keyword">var</span> first = Integer.MIN_VALUE;</span><br><span class="line">        <span class="hljs-comment">// 次大数</span></span><br><span class="line">        <span class="hljs-keyword">var</span> second = Integer.MIN_VALUE;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> num : nums) {</span><br><span class="line">            <span class="hljs-comment">// 当前数字比最大数还大，最大数更新为当前数字，原来的最大数更新为第2大</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (num &gt;= first) {</span><br><span class="line">                second = first;</span><br><span class="line">                first = num;</span><br><span class="line">            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num &gt;= second) { <span class="hljs-comment">// 当前数字小于最大，但是大于第2大，更新第2大</span></span><br><span class="line">                second = num;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="hljs-keyword">return</span> second;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="hljs-keyword">var</span> nums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]{<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">5</span>};</span><br><span class="line">        <span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> SecondMaximumNumber();</span><br><span class="line">        System.out.println(s.secondMaximumNumber(nums));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="示例：查找第3大的数"><a href="#示例：查找第3大的数" class="headerlink" title="示例：查找第3大的数"></a>示例：查找第3大的数</h2><p>Leetcode: <a href="https://leetcode.cn/problems/third-maximum-number/" target="_blank" rel="noopener">第三大的数</a></p><p>原理和查第2大的数想通，定义$first$,$second$,$third$三个变量，然后遍历$nums$</p><ol><li>若$num &gt; first$，则$second$赋值给$third$，$first$赋值给$second$,$num$赋值给$first$</li><li>若$num &lt; first$且 $num &gt; second$，则$second$赋值给$third$，$num$赋值给$second$</li><li>若$num &lt; second$且$num &gt; third$，则$num$赋值给$third$</li></ol><p>最后根据题意返回$third$或者$first$即可。</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution3</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">// 三个变量</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">thirdMax</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">            <span class="hljs-keyword">var</span> first = Long.MIN_VALUE;</span><br><span class="line">            <span class="hljs-keyword">var</span> second = first;</span><br><span class="line">            <span class="hljs-keyword">var</span> third = second;</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> num : nums) {</span><br><span class="line">                <span class="hljs-keyword">if</span> (num &gt; first) { <span class="hljs-comment">// 如果num&gt;最大值，原来的最大变次大，原来的次大变三大, 当前边最大</span></span><br><span class="line">                    third = second;</span><br><span class="line">                    second = first;</span><br><span class="line">                    first = num;</span><br><span class="line">                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num &lt; first &amp;&amp; num &gt; second) { <span class="hljs-comment">// 小于最大，但是大于第二, 第二变第三，当前边第二</span></span><br><span class="line">                    third = second;</span><br><span class="line">                    second = num;</span><br><span class="line">                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num &lt; second &amp;&amp; num &gt; third) { <span class="hljs-comment">// 小于第二，但是大于第三</span></span><br><span class="line">                    third = num;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) (third == Long.MIN_VALUE ? first : third);</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>时间复杂度:$O(n)$，$n$是数组长度，仅需遍历一次。</p><p>空间复杂度: $O(1)$，仅需使用3个变量。</p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;在给定的序列中查找第N大的数，朴素做法是对序列排序，然后根据索引直接查询，时间复杂度为$O(nlogn)$。&lt;/p&gt;
&lt;p&gt;本文介绍一种在$O(n)$的时间复杂度查询第N大的数的算法。&lt;/p&gt;
&lt;h2 id=&quot;算法&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="algorithm" scheme="https://www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="leetcode" scheme="https://www.ddhigh.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>洗牌算法</title>
    <link href="https://www.ddhigh.com/2023/01/03/shuffle-algorithm.html"/>
    <id>https://www.ddhigh.com/2023/01/03/shuffle-algorithm.html</id>
    <published>2023-01-03T04:05:44.000Z</published>
    <updated>2023-05-05T02:52:12.002Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>洗牌算法用来将给定的序列打乱，可以认为是排序的反操作。</p><h2 id="正确性判断"><a href="#正确性判断" class="headerlink" title="正确性判断"></a>正确性判断</h2><p>对于包含$n$个元素的序列，其全排列有$n!$种。如果<strong>序列打乱的结果为$n!$种且每种序列出现的概率相同</strong>，则是正确的洗牌算法。</p><h2 id="Fisher–Yates-洗牌算法"><a href="#Fisher–Yates-洗牌算法" class="headerlink" title="Fisher–Yates 洗牌算法"></a>Fisher–Yates 洗牌算法</h2><blockquote><p>以下算法说明摘自: <a href="https://gaohaoyang.github.io/2016/10/16/shuffle-algorithm/" target="_blank" rel="noopener">https://gaohaoyang.github.io/2016/10/16/shuffle-algorithm/</a></p><p>Fisher–Yates shuffle 的原始版本，最初描述在 1938 年的 Ronald Fisher和 Frank Yates 写的书中，书名为《Statistical tables for biological, agricultural and medical research》。他们使用纸和笔去描述了这个算法，并使用了一个随机数表来提供随机数。它给出了 1 到 N 的数字的的随机排列，具体步骤如下：</p><ol><li>写下从 1 到 N 的数字</li><li>取一个从 1 到剩下的数字（包括这个数字）的随机数 k</li><li>从低位开始，得到第 k 个数字（这个数字还没有被取出），把它写在独立的一个列表的最后一位</li><li>重复第 2 步，直到所有的数字都被取出</li><li>第 3 步写出的这个序列，现在就是原始数字的随机排列</li></ol><p>已经证明如果第 2 步取出的数字是真随机的，那么最后得到的排序一定也是。</p></blockquote><h2 id="正确性证明"><a href="#正确性证明" class="headerlink" title="正确性证明"></a>正确性证明</h2><p>正确的洗牌算法要保证每个数字出现在每个位置的概率一样。我们来看看Fisher–Yates洗牌算法是否正确。</p><p>假设现在有1,2,3,4,5五个数字。</p><ol><li>首先在<code>1-5</code>随机一个数，假设是<code>4</code>，随机概率为<code>1/5</code></li><li>再次从<code>1,2,3,5</code>中随机一个数，假设是<code>5</code>，随机概率为<code>1/4</code>，但是<code>5</code>在第一步没被选上的概率是<code>4/5</code>，因此总体概率是<code>1/4*4/5</code>还是<code>1/5</code></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shuffle</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>{</span><br><span class="line"><span class="hljs-keyword">var</span> n = nums.length;</span><br><span class="line">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {</span><br><span class="line">  <span class="hljs-keyword">int</span> newIndex = i + random.nextInt(n - i); <span class="hljs-comment">// 在i之后的下标随机，可以保证不会随机到i前面的</span></span><br><span class="line">    <span class="hljs-keyword">int</span> temp = nums[i];</span><br><span class="line">    nums[i] = nums[newIndex];</span><br><span class="line">    nums[newIndex] = temp;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>时间复杂度: $O(n)$，$n$是数组长度，只需要遍历一次。</p><p>空间复杂度：$O(1)$，仅需常数项空间。</p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;洗牌算法用来将给定的序列打乱，可以认为是排序的反操作。&lt;/p&gt;
&lt;h2 id=&quot;正确性判断&quot;&gt;&lt;a href=&quot;#正确性判断&quot; class=&quot;headerlink&quot; title=&quot;正确性判断&quot;&gt;&lt;/a&gt;正确性判断&lt;/h2&gt;&lt;
      
    
    </summary>
    
      <category term="algorithm" scheme="https://www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="leetcode" scheme="https://www.ddhigh.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>原地哈希算法</title>
    <link href="https://www.ddhigh.com/2022/12/31/cyclic-sort.html"/>
    <id>https://www.ddhigh.com/2022/12/31/cyclic-sort.html</id>
    <published>2022-12-31T06:16:32.000Z</published>
    <updated>2023-05-05T02:52:12.002Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>原地哈希算法(Cyclic Sort)主要应用在值都在$[0,n]$的数组$nums$中，此时可以将$nums[i]$作为索引，放回原数组，当然，由于程序上索引是从0开始，因此可以将$nums[i]$放到$nums[nums[i]-1]$的位置上。</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>Leetcode <a href="https://leetcode.cn/problems/missing-number/" target="_blank" rel="noopener">268. 丢失的数字</a></p><p>给定一个包含 <code>[0, n]</code> 中 <code>n</code> 个数的数组 <code>nums</code> ，找出 <code>[0, n]</code> 这个范围内没有出现在数组中的那个数。</p><p><strong>示例 1：</strong></p><figure class="highlight angelscript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]</span><br><span class="line">输出：<span class="hljs-number">2</span></span><br><span class="line">解释：n = <span class="hljs-number">3</span>，因为有 <span class="hljs-number">3</span> 个数字，所以所有的数字都在范围 [<span class="hljs-number">0</span>,<span class="hljs-number">3</span>] 内。<span class="hljs-number">2</span> 是丢失的数字，因为它没有出现在 nums 中。</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight angelscript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]</span><br><span class="line">输出：<span class="hljs-number">2</span></span><br><span class="line">解释：n = <span class="hljs-number">2</span>，因为有 <span class="hljs-number">2</span> 个数字，所以所有的数字都在范围 [<span class="hljs-number">0</span>,<span class="hljs-number">2</span>] 内。<span class="hljs-number">2</span> 是丢失的数字，因为它没有出现在 nums 中。</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight angelscript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="hljs-number">9</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]</span><br><span class="line">输出：<span class="hljs-number">8</span></span><br><span class="line">解释：n = <span class="hljs-number">9</span>，因为有 <span class="hljs-number">9</span> 个数字，所以所有的数字都在范围 [<span class="hljs-number">0</span>,<span class="hljs-number">9</span>] 内。<span class="hljs-number">8</span> 是丢失的数字，因为它没有出现在 nums 中。</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 4：</strong></p><figure class="highlight angelscript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="hljs-number">0</span>]</span><br><span class="line">输出：<span class="hljs-number">1</span></span><br><span class="line">解释：n = <span class="hljs-number">1</span>，因为有 <span class="hljs-number">1</span> 个数字，所以所有的数字都在范围 [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>] 内。<span class="hljs-number">1</span> 是丢失的数字，因为它没有出现在 nums 中。</span><br></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 104</code></li><li><code>0 &lt;= nums[i] &lt;= n</code></li><li><code>nums</code> 中的所有数字都 <strong>独一无二</strong></li></ul><p><strong>进阶：</strong>你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题?</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>用哈希表可以解答，但是空间复杂度达到了$O(n)$，没有利用到值都在$[0,n]$这个已知条件。所以我们用原地哈希解答本题。</p><ol><li>遍历数组，如果$nums[i]-1&gt;=0$ 且$nums[i] != nums[nums[i]-1]$，证明$nums[i]$未归位，我们将$i$和$nums[i]-1$处的数字交换，此步骤要一直循环到$nums[i]-1$越界或者$nums[i]$归位</li><li>重新遍历数组，如果$nums[i] != i+1$，证明当前位置的$nums[i]$是错的，也就是缺少本来应该放到这个位置的数字，所以答案也就呼之欲出了。</li></ol><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">// 原地哈希</span></span><br><span class="line">        <span class="hljs-comment">// 1. 将nums[i] 放到 nums[nums[i]-1]的位置</span></span><br><span class="line">        <span class="hljs-comment">// 2. 重新遍历，如果 nums[i] != i+1 则缺失i+1数字</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">missingNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line">                <span class="hljs-comment">// 数字归位</span></span><br><span class="line">                <span class="hljs-comment">// 如nums[i]为2，那么最终需要放到1号索引</span></span><br><span class="line">                <span class="hljs-keyword">while</span> (nums[i] - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i] != nums[nums[i] - <span class="hljs-number">1</span>]) {</span><br><span class="line">                    swap(nums, i, nums[i] - <span class="hljs-number">1</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="hljs-comment">// 数字已归位，查询哪个数字的值和位置不匹配，不匹配的就是缺失的数字</span></span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line">                <span class="hljs-keyword">if</span> (nums[i] != i + <span class="hljs-number">1</span>) {</span><br><span class="line">                    <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>{</span><br><span class="line">            <span class="hljs-keyword">var</span> temp = nums[i];</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            nums[j] = temp;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>时间复杂度：$O(n)$。$n$是数组长度，每个元素会被一次性移动归位，此后不再移动，因此每个元素的访问次数是常数，而总共需要访问$n$个数字。</p><p>空间复杂度：$O(1)$。复用题目给定的$nums$空间作为哈希表，未引入额外空间。</p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;原地哈希算法(Cyclic Sort)主要应用在值都在$[0,n]$的数组$nums$中，此时可以将$nums[i]$作为索引，放回原数组，当然，由于程序上索引是从0开始，因此可以将$nums[i]$放到$nums[nums
      
    
    </summary>
    
      <category term="algorithm" scheme="https://www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="leetcode" scheme="https://www.ddhigh.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>厄拉多塞筛素数筛选算法</title>
    <link href="https://www.ddhigh.com/2022/12/31/eratosthenes-sieve.html"/>
    <id>https://www.ddhigh.com/2022/12/31/eratosthenes-sieve.html</id>
    <published>2022-12-31T06:13:45.000Z</published>
    <updated>2023-05-05T02:52:12.002Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><blockquote><p>厄拉多塞筛算法（Eratosthenes Sieve）是一种求素数的方法，由古希腊数学家厄拉多塞提出。它的原理是，给定一个数 n，从 2 开始依次将 $\sqrt n$ 以内的素数的倍数标记为合数，标记完成后，剩余未被标记的数为素数（从 2 开始）。如此可省去检查每个数的步骤，使筛选素数的过程更加简单。</p></blockquote><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>厄拉多塞筛算法具体步骤如下：</p><ol><li>读取输入的数 n，将 2 到 n 的所有整数记录在表中</li><li>从 2 开始，划去表中所有 2 的倍数</li><li>由小到大寻找表中下一个未被划去的整数，再划去表中所有该整数的倍数</li><li>重复第（3）步，直到找到的整数大于$\sqrt n$为止</li><li>表中所有未被划去的整数均为素数</li></ol><p>朴素的素数筛选算法如下：对给定的数字$i$，设定数字$j$从$2$遍历到$\sqrt i$，如果中间$i$能整除$j$，则$i$不是素数。该方法的时间复杂度为$O(n\sqrt n)$ ,$n$是数组长度，外层循环需要遍历$n$次，内层循环需要遍历$\sqrt n$次。</p><p>而厄拉多塞筛算法的时间复杂度为$O(n log(log(n)))$。</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>这是一张来自<a href="https://zh.wikipedia.org/wiki/%E5%9F%83%E6%8B%89%E6%89%98%E6%96%AF%E7%89%B9%E5%B0%BC%E7%AD%9B%E6%B3%95" target="_blank" rel="noopener">维基百科</a>的算法示意图。</p><p><img src="https://static.ddhigh.com/algorithm/Sieve_of_Eratosthenes_animation.gif" alt="算法示例"></p><ol><li>先从2开始遍历，将2的倍数(2,4,6,8,…)标记为为非素数</li><li>继续遍历，当前数字是素数时，继续将当前数字的倍数标记为非素数</li><li>直到所有数字标记完，重新标记数组，未被标记的就是素数</li></ol><h2 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h2><p>Leetcode <a href="https://leetcode.cn/problems/count-primes/" target="_blank" rel="noopener">204. 计数质数</a></p><p>给定整数 <code>n</code> ，返回 <em>所有小于非负整数 <code>n</code> 的质数的数量</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight angelscript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="hljs-number">10</span></span><br><span class="line">输出：<span class="hljs-number">4</span></span><br><span class="line">解释：小于 <span class="hljs-number">10</span> 的质数一共有 <span class="hljs-number">4</span> 个, 它们是 <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span> 。</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight angelscript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="hljs-number">0</span></span><br><span class="line">输出：<span class="hljs-number">0</span></span><br></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight angelscript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="hljs-number">1</span></span><br><span class="line">输出：<span class="hljs-number">0</span></span><br></pre></td></tr></tbody></table></figure><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution2</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">// 厄拉多塞筛素数筛选算法</span></span><br><span class="line">        <span class="hljs-comment">// 1. 准备O(n)的数组，标识数字是否是质数，初始情况下全部是质数</span></span><br><span class="line">        <span class="hljs-comment">// 2. 从2开始遍历到sqrt(n),如果数字是质数，则i*i开始，后面i的倍数全是合数</span></span><br><span class="line">        <span class="hljs-comment">// 3. 从[2,n)筛选质数并统计</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countPrimes</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{</span><br><span class="line">            <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) {</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="hljs-keyword">var</span> isPrime = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n];</span><br><span class="line">            Arrays.fill(isPrime, <span class="hljs-keyword">true</span>);</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i * i &lt; n; i++) { <span class="hljs-comment">// 遍历一半即可</span></span><br><span class="line">                <span class="hljs-keyword">if</span> (isPrime[i]) { <span class="hljs-comment">// 如果是质数，则将i平方开始的所有i的倍数设为合数</span></span><br><span class="line">                    <span class="hljs-comment">// 任意素数x的倍数有：2x, 3x, 4x, ..., x*x, (x+1)*x, ...</span></span><br><span class="line">                    <span class="hljs-comment">// 任意小于x*x的倍数都被之前的素数筛过滤过，如：2 过滤 2x, 4x, ...，3 过滤 3x, ...</span></span><br><span class="line">                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i * i; j &lt; n; j += i) {</span><br><span class="line">                        isPrime[j] = <span class="hljs-keyword">false</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++) {</span><br><span class="line">                <span class="hljs-keyword">if</span> (isPrime[i]) {</span><br><span class="line">                    count++;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="hljs-keyword">return</span> count;</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>时间复杂度: $O(nlog(log(n)))$。时间复杂度证明过程有点复杂，我暂时还没消化。</p><p>空间复杂度：$O(n)$。需要长度为$n$的数组标记是否素数。</p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;blockquote&gt;
&lt;p&gt;厄拉多塞筛算法（Eratosthenes Sieve）是一种求素数的方法，由古希腊数学家厄拉多塞提出。它的原理是，给定一个数 n，从 2 开始依次将 $\sqrt n$ 以内的素数的倍数标记为合数，
      
    
    </summary>
    
      <category term="algorithm" scheme="https://www.ddhigh.com/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>博耶-摩尔多数投票算法</title>
    <link href="https://www.ddhigh.com/2022/12/31/boyer-moore-majority-vote-algorithm.html"/>
    <id>https://www.ddhigh.com/2022/12/31/boyer-moore-majority-vote-algorithm.html</id>
    <published>2022-12-31T06:13:06.000Z</published>
    <updated>2023-05-05T02:52:12.002Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>来自<a href="https://zh.m.wikipedia.org/zh-hans/%E5%A4%9A%E6%95%B0%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">维基百科</a>的解释：</p><blockquote><p><strong>博耶-摩尔多数投票算法</strong>（英语：Boyer–Moore majority vote algorithm）,中文常作<strong>多数投票算法</strong>、<strong>摩尔投票算法</strong>等，是一种用来寻找一组元素中占多数元素的常数空间级<a href="https://zh.m.wikipedia.org/wiki/时间复杂度" target="_blank" rel="noopener">时间复杂度</a>算法。这一算法由<a href="https://zh.m.wikipedia.org/w/index.php?title=罗伯特·S·博耶&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">罗伯特·S·博耶</a>（英语：<a href="https://en.wikipedia.org/wiki/Robert_S._Boyer" target="_blank" rel="noopener">Robert S. Boyer</a>）和<a href="https://zh.m.wikipedia.org/w/index.php?title=J_Strother_Moore&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">J·斯特罗瑟·摩尔</a>（英语：<a href="https://en.wikipedia.org/wiki/J_Strother_Moore" target="_blank" rel="noopener">J Strother Moore</a>）在1981年发表<a href="https://zh.m.wikipedia.org/zh-hans/多数投票算法#cite_note-bm-1" target="_blank" rel="noopener">[1]</a>，也是<a href="https://zh.m.wikipedia.org/w/index.php?title=Streaming_algorithm&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">处理数据流</a>（英语：<a href="https://en.wikipedia.org/wiki/streaming_algorithm" target="_blank" rel="noopener">streaming algorithm</a>）的一种典型算法。</p></blockquote><p>简单来说，博耶-摩尔多数投票算法用来寻找数组中的多数元素，相比于用哈希表存储元素和次数使用$O(n)$的时间复杂度来说，该投票算法使用$O(1)$的空间复杂度。</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>摩尔投票算法分为投票-校验两个阶段。投票阶段会统计候选人的票数，遍历数组，如果当前数字和当前候选人不相等，则该候选人票数-1，当候选人票数归0时，需要更换候选人为当前数字；在校验阶段，需要重新遍历数字，并将值等于候选人的数字计数，遍历结束后，比如计数满足要求，则候选人满足要求。</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>比如[A,A, A, B,C]这组元素，我们需要筛选数量超过一半的数字。</p><p>首先我们定A为候选人，然后遍历数组，遇到B时A有3个，由于A!=B，因此A结果为2，再和C比较，犹豫A!=C，因此A结尾为1，遍历结束，A是投票阶段的候选人；再遍历数组，统计A的数量为3，超过一半(5/2)，因此A是票数最高的元素。</p><h2 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h2><p>Leetcode <a href="https://leetcode.cn/problems/majority-element-ii/" target="_blank" rel="noopener">229. 多数元素 II</a></p><p>给定一个大小为 <em>n</em> 的整数数组，找出其中所有出现超过 <code>⌊ n/3 ⌋</code> 次的元素。</p><p><strong>示例 1：</strong></p><figure class="highlight angelscript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]</span><br><span class="line">输出：[<span class="hljs-number">3</span>]</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight angelscript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="hljs-number">1</span>]</span><br><span class="line">输出：[<span class="hljs-number">1</span>]</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight angelscript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]</span><br><span class="line">输出：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]</span><br></pre></td></tr></tbody></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题目要求找出所有出现次数超过<code>n/3</code>次的元素，由于摩尔投票算法空间复杂度是常数，因此需要预先定义候选人个数。</p><p>设出现次数超过<code>n/3</code>次的元素有$x$个，以下是求解$x$的过程：<br>$$<br>\begin{equation}\label{eqn:1}<br>\begin{aligned}<br>&amp; 假设刚好是n/3个 \<br>&amp; \because x * n/3 = n \<br>&amp; \therefore x=3 \<br>&amp; 而实际上题目要求次数 &gt; n/3 \<br>&amp; \therefore x &lt; 3 \<br>&amp; \therefore x = 2<br>\end{aligned}<br>\end{equation}<br>$$<br>所以本题最多能选择2个候选人。</p><ol><li>不妨设两个候选人$candidate1$和$candidate2$，$count1$和$count2$都是0</li><li>遍历数组，如果当前$nums[i]==candidate1$，则$count1++$，否则$count1–$，对$candidate2$同样处理</li><li>如果遍历过程中$count1$或$count2$为0，则更新对应的候选人为$nums[i]$</li><li>投票阶段结束，进入重新计数校验阶段，我们留下了$candidate1$和$candidate2$，再次遍历数组，如果值和这两个候选人相同，则对应的$count$增加</li><li>如果$count&gt;nums.length/3$，则将当前候选人加入答案</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution2</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">// 摩尔投票法</span></span><br><span class="line">        <span class="hljs-comment">// 1. 因为题目要求超过 n/3 的数字，因此最多有2个数字</span></span><br><span class="line">        <span class="hljs-comment">// 2. 投票阶段，初始化2个数字，以及count</span></span><br><span class="line">        <span class="hljs-comment">// 3. 遍历nums，如果和num1相等，则count1++，如果和num2相等，则count2++，否则票数--</span></span><br><span class="line">        <span class="hljs-comment">// 4. 如果num1的count1为0，则num1为当前num</span></span><br><span class="line">        <span class="hljs-comment">// 5. 校验阶段</span></span><br><span class="line">        <span class="hljs-comment">// 6. 统计num1和num2的次数，看看是否&gt;n/3</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">majorityElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">            <span class="hljs-keyword">var</span> answer = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) {</span><br><span class="line">                <span class="hljs-keyword">return</span> Collections.emptyList();</span><br><span class="line">            }</span><br><span class="line">            <span class="hljs-keyword">int</span> candidate1 = nums[<span class="hljs-number">0</span>], count1 = <span class="hljs-number">0</span>;</span><br><span class="line">            <span class="hljs-keyword">int</span> candidate2 = nums[<span class="hljs-number">0</span>], count2 = <span class="hljs-number">0</span>;</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) {</span><br><span class="line">                <span class="hljs-comment">// 增加1的票数</span></span><br><span class="line">                <span class="hljs-keyword">if</span> (num == candidate1) {</span><br><span class="line">                    count1++;</span><br><span class="line">                    <span class="hljs-keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="hljs-comment">// 增加2的票数</span></span><br><span class="line">                <span class="hljs-keyword">if</span> (num == candidate2) {</span><br><span class="line">                    count2++;</span><br><span class="line">                    <span class="hljs-keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="hljs-comment">// 1票数不足，更新候选人1</span></span><br><span class="line">                <span class="hljs-keyword">if</span> (count1 == <span class="hljs-number">0</span>) {</span><br><span class="line">                    candidate1 = num;</span><br><span class="line">                    count1++;</span><br><span class="line">                    <span class="hljs-keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="hljs-comment">// 2票数不足，更新候选人2</span></span><br><span class="line">                <span class="hljs-keyword">if</span> (count2 == <span class="hljs-number">0</span>) {</span><br><span class="line">                    candidate2 = num;</span><br><span class="line">                    count2++;</span><br><span class="line">                    <span class="hljs-keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="hljs-comment">// 票数相减</span></span><br><span class="line">                count1--;</span><br><span class="line">                count2--;</span><br><span class="line">            }</span><br><span class="line">            count1 = <span class="hljs-number">0</span>;</span><br><span class="line">            count2 = <span class="hljs-number">0</span>;</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> num : nums) {</span><br><span class="line">                <span class="hljs-keyword">if</span> (num == candidate1) {</span><br><span class="line">                    count1++;</span><br><span class="line">                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num == candidate2) {</span><br><span class="line">                    count2++;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="hljs-keyword">if</span> (count1 &gt; nums.length / <span class="hljs-number">3</span>) {</span><br><span class="line">                answer.add(candidate1);</span><br><span class="line">            }</span><br><span class="line">            <span class="hljs-keyword">if</span> (count2 &gt; nums.length / <span class="hljs-number">3</span>) {</span><br><span class="line">                answer.add(candidate2);</span><br><span class="line">            }</span><br><span class="line">            <span class="hljs-keyword">return</span> answer;</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>时间复杂度：$O(n)$, $n$是数组长度，需要遍历两次。</p><p>空间复杂度: $O(1)$，只需要常数项额外空间。</p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;来自&lt;a href=&quot;https://zh.m.wikipedia.org/zh-hans/%E5%A4%9A%E6%95%B0%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95&quot; target=&quot;_b
      
    
    </summary>
    
      <category term="algorithm" scheme="https://www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="leetcode" scheme="https://www.ddhigh.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>基数排序算法</title>
    <link href="https://www.ddhigh.com/2022/12/30/radix-sort.html"/>
    <id>https://www.ddhigh.com/2022/12/30/radix-sort.html</id>
    <published>2022-12-30T10:57:38.000Z</published>
    <updated>2023-05-05T02:52:12.002Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>基数排序又叫桶排序，是一种时间复杂度为$O(n)$的排序算法，但是相比于其他排序算法有$O(n)$的空间复杂度。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>基数排序的核心思路如下：</p><ol><li>准备0~9的10个桶，根据数字当前比较位的值来决定放入哪个桶。如当前比较个位，则数字13应该放入索引为3的桶中；当前比较百位，则123应该放入索引为1的桶中。</li><li>当所有数字全部放入桶之后，遍历0~9这10个桶，然后依次将数字保存到待排序数组，因为桶是有序的，所以本轮放回去的数字是有序的。</li><li>当前比较的位数左移，比如本轮比较个位，下一轮应该比较百位。</li><li>重复步骤1~3。</li></ol><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>现在我们来看一个实际例子。</p><p>待排序数字：717, 328, 803, 422, 586, 944, 557, 308, 496, 624</p><h3 id="第1轮比较个位"><a href="#第1轮比较个位" class="headerlink" title="第1轮比较个位"></a>第1轮比较个位</h3><p>直接按照个位放入桶中。</p><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td></td><td></td><td>422</td><td>803</td><td>624</td><td></td><td>586</td><td>717</td><td>328</td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td>496</td><td>557</td><td>308</td></tr></tbody></table><p>按照从左到右，从上到下的原则将数字归位：422,803,624,586,496,717,557,328,308</p><h3 id="第2轮比较十位"><a href="#第2轮比较十位" class="headerlink" title="第2轮比较十位"></a>第2轮比较十位</h3><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td>803</td><td>717</td><td>422</td><td></td><td></td><td>557</td><td></td><td></td><td>586</td><td>496</td></tr><tr><td>308</td><td></td><td>624</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td>328</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>按照从左到右，从上到下的原则将数字归位：803,308,717,422,624,328,557,586,496</p><h3 id="第3轮比较百位"><a href="#第3轮比较百位" class="headerlink" title="第3轮比较百位"></a>第3轮比较百位</h3><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td></td><td></td><td></td><td>308</td><td>422</td><td>557</td><td>624</td><td>717</td><td>803</td><td></td></tr><tr><td></td><td></td><td></td><td>328</td><td>496</td><td>586</td><td></td><td></td><td></td></tr></tbody></table><p>按照从左到右，从上到下的原则将数字归位：308,328,422,496,557,586,624,717,803</p><p>可以发现，比较的轮次由数组中最大的数字决定，以上面的例子来说，如果还存在一个1234数字，那么需要比较4轮才可以完成排序。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RadixSort</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 基数排序</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">        <span class="hljs-keyword">if</span> (nums.length &lt;= <span class="hljs-number">1</span>) {</span><br><span class="line">            <span class="hljs-keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="hljs-keyword">var</span> max = Arrays.stream(nums).max().getAsInt();</span><br><span class="line">        <span class="hljs-comment">// 当前处理位数</span></span><br><span class="line">        <span class="hljs-keyword">var</span> exp = <span class="hljs-number">1</span>;</span><br><span class="line">        <span class="hljs-comment">// 桶</span></span><br><span class="line">        <span class="hljs-keyword">var</span> bucket = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>][nums.length];</span><br><span class="line">        <span class="hljs-comment">// 记录每个桶有几个数字</span></span><br><span class="line">        <span class="hljs-keyword">var</span> bucketCount = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];</span><br><span class="line">        <span class="hljs-keyword">while</span> (max &gt;= exp) {</span><br><span class="line">            <span class="hljs-comment">// 求得每个数字当前位数的值</span></span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> num : nums) {</span><br><span class="line">                <span class="hljs-comment">// 求得当前位余数</span></span><br><span class="line">                <span class="hljs-keyword">var</span> bitNumber = (num / exp) % <span class="hljs-number">10</span>;</span><br><span class="line">                <span class="hljs-comment">// 放入桶, index是桶的index，在同一个桶的数字需要index来标识位置</span></span><br><span class="line">                <span class="hljs-keyword">var</span> index = bucketCount[bitNumber];</span><br><span class="line">                bucket[bitNumber][index] = num;</span><br><span class="line">                <span class="hljs-comment">// 桶内数量+1</span></span><br><span class="line">                bucketCount[bitNumber]++;</span><br><span class="line">            }</span><br><span class="line">            <span class="hljs-comment">// 桶内数字归位</span></span><br><span class="line">            <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; <span class="hljs-comment">// 已归位的数字下标</span></span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {</span><br><span class="line">                <span class="hljs-keyword">if</span> (bucketCount[i] &gt; <span class="hljs-number">0</span>) { <span class="hljs-comment">// 当前桶有数字</span></span><br><span class="line">                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; bucketCount[i]; j++) { <span class="hljs-comment">// 遍历同一个桶的数字</span></span><br><span class="line">                        nums[k] = bucket[i][j];</span><br><span class="line">                        k++;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="hljs-comment">// 桶数字清空</span></span><br><span class="line">                bucketCount[i] = <span class="hljs-number">0</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="hljs-comment">// 位数左移</span></span><br><span class="line">            exp *= <span class="hljs-number">10</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++) {</span><br><span class="line">            <span class="hljs-keyword">var</span> gap = nums[i] - nums[i - <span class="hljs-number">1</span>];</span><br><span class="line">            <span class="hljs-keyword">if</span> (gap &gt; max) {</span><br><span class="line">                max = gap;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="hljs-keyword">var</span> sort = <span class="hljs-keyword">new</span> RadixSort();</span><br><span class="line">        <span class="hljs-keyword">var</span> list = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]{<span class="hljs-number">422</span>, <span class="hljs-number">803</span>, <span class="hljs-number">624</span>, <span class="hljs-number">586</span>, <span class="hljs-number">496</span>, <span class="hljs-number">717</span>, <span class="hljs-number">557</span>, <span class="hljs-number">328</span>, <span class="hljs-number">308</span>};</span><br><span class="line">        sort.sort(list);</span><br><span class="line">        System.out.println(Arrays.toString(list));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>时间复杂度: $O(n)$ ，严格来说是$O(log(n))$。$n$是待排序数组长度，在数据量小的情况下，最外层的while循环遍历次数可以认为是常数，内部嵌套的for循环次数为数组长度$n$，因此时间复杂度为$O(n)$；在数据量大的情况下，最外层的while循环次数为$O(log(n))$，内部嵌套的for循环次数依旧是$n$，因此时间复杂度为$O(nlog(n))$。</p><p>空间复杂度：$O(n)$。$n$是待排序数组长度，$bucket$的大小为$10*n$，$bucketCount$大小为$n$，因此总体空间复杂度为$O(n)$。</p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;基数排序又叫桶排序，是一种时间复杂度为$O(n)$的排序算法，但是相比于其他排序算法有$O(n)$的空间复杂度。&lt;/p&gt;
&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="algorithm" scheme="https://www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="leetcode" scheme="https://www.ddhigh.com/tags/leetcode/"/>
    
      <category term="sort" scheme="https://www.ddhigh.com/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>算法篇-leetcode 131 分割回文串</title>
    <link href="https://www.ddhigh.com/2022/03/17/palindrome-partitioning.html"/>
    <id>https://www.ddhigh.com/2022/03/17/palindrome-partitioning.html</id>
    <published>2022-03-17T04:00:14.000Z</published>
    <updated>2023-05-05T02:52:12.002Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是 <strong>回文串</strong> 。返回 <code>s</code> 所有可能的分割方案。</p><p><strong>回文串</strong> 是正着读和反着读都一样的字符串。</p><p><strong>示例1</strong></p><figure class="highlight prolog hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="hljs-string">"aab"</span></span><br><span class="line">输出：[[<span class="hljs-string">"a"</span>,<span class="hljs-string">"a"</span>,<span class="hljs-string">"b"</span>],[<span class="hljs-string">"aa"</span>,<span class="hljs-string">"b"</span>]]</span><br></pre></td></tr></tbody></table></figure><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p><strong>题目要求</strong></p><ol><li>将字符串字符打散后，将其中的回文串添加到一个单独的List</li><li>第1步的所有List构成最后的答案</li></ol><p>可以看出，这是一个典型的回溯问题，考察有多少种方法可以组装最后的答案。</p><h4 id="方法一：直接回溯"><a href="#方法一：直接回溯" class="headerlink" title="方法一：直接回溯"></a>方法一：直接回溯</h4><p><strong>思路及算法</strong></p><p>回溯需要回答以下3个问题：</p><ol><li>回溯终止条件是什么？</li><li>回溯有哪些选择?</li><li>如何进入下一个选择？</li></ol><p>对于本题来说，我们需要将字符串打散，从中选择回文串添加到最终答案，因此，需要定义以下变量:  </p><ol><li>$index$, 记录当前选择的字符索引</li><li>$path$, 记录本次回文串选择情况</li><li>$answer$, 记录最终答案</li></ol><p>回答上面提出来的两个问题：</p><ol><li>回溯终止条件: $index==s.length()$，此时将$path$拷贝到$answer$，不可以直接添加，因为回溯存在撤回操作，必须断开$answer$和$path$的引用。</li><li>回溯有哪些选择：定义变量$right$, 遍历 $s[index,s.length())$，当$s[index,right]$是回文串时，将其加入$path$。</li><li>如何进入下一个选择：第2个问题满足条件的情况下，增加$index$然后再次递归即可。</li></ol><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * DFS回溯</span></span><br><span class="line"><span class="hljs-comment">     * 1. 回溯出口      index == s.length()</span></span><br><span class="line"><span class="hljs-comment">     * 2. 回溯递进      遍历[i,n)  如果s[i,j] 是回文串，则加入path，然后递归 s[i,j+1]</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> s</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) {</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; answer = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; path = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(answer, path, <span class="hljs-number">0</span>, s.length(), s);</span><br><span class="line">        <span class="hljs-keyword">return</span> answer;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(List&lt;List&lt;String&gt;&gt; answer, List&lt;String&gt; path, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> length, String s)</span> </span>{</span><br><span class="line">        <span class="hljs-keyword">if</span> (index == length) {</span><br><span class="line">            answer.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="hljs-keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="hljs-comment">// 本次有什么选择?</span></span><br><span class="line">        <span class="hljs-comment">// j =&gt; [index,len)，检测s[index,j]是否回文，如果是，则加入path，最后撤销选择</span></span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = index; i &lt; length; i++) {</span><br><span class="line">            <span class="hljs-keyword">if</span> (!isPalindrome(s, index, i)) {</span><br><span class="line">                <span class="hljs-keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            path.add(s.substring(index, i + <span class="hljs-number">1</span>));</span><br><span class="line">            dfs(answer, path, i + <span class="hljs-number">1</span>, length, s);</span><br><span class="line">            path.remove(path.size() - <span class="hljs-number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>{</span><br><span class="line">        <span class="hljs-keyword">while</span> (left &lt; right) {</span><br><span class="line">            <span class="hljs-keyword">if</span> (s.charAt(left) != s.charAt(right)) {</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">            }</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        }</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(N*2^n)$，每个位置的字符可以拆分也可以不拆分，因此时间复杂度是$O(2^n)$，判断每个子字符串是否为回文串需要$O(N)$的时间。</li><li>空间复杂度：$O(N*2^n)$，考虑$answer$，每个位置的字符可以拆分也可以不拆分，两种情况都需要占用空间，此部分空间是$O(2^n)$，而对于所有的答案都需要保存，此部分空间是$O(N)$.</li></ul><h4 id="方法二：记忆法回溯"><a href="#方法二：记忆法回溯" class="headerlink" title="方法二：记忆法回溯"></a>方法二：记忆法回溯</h4><p><strong>思路及算法</strong></p><p>在方法一的基础上添加$memo$保存$s[i,j]$是否为回文串，减少重复判断。</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{</span><br><span class="line"> <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * DFS回溯</span></span><br><span class="line"><span class="hljs-comment">     * 1. 回溯出口      index == s.length()</span></span><br><span class="line"><span class="hljs-comment">     * 2. 回溯递进      遍历[i,n)  如果s[i,j] 是回文串，则加入path，然后递归 s[i,j+1]</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> s</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) {</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; answer = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; path = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Boolean[][] memo = <span class="hljs-keyword">new</span> Boolean[s.length()][s.length()];</span><br><span class="line">        dfs(memo, answer, path, <span class="hljs-number">0</span>, s.length(), s);</span><br><span class="line">        <span class="hljs-keyword">return</span> answer;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(Boolean[][] memo, List&lt;List&lt;String&gt;&gt; answer, List&lt;String&gt; path, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> length, String s)</span> </span>{</span><br><span class="line">        <span class="hljs-keyword">if</span> (index == length) {</span><br><span class="line">            answer.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="hljs-keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="hljs-comment">// 本次有什么选择?</span></span><br><span class="line">        <span class="hljs-comment">// j =&gt; [index,len)，检测s[index,j]是否回文，如果是，则加入path，最后撤销选择</span></span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = index; i &lt; length; i++) {</span><br><span class="line">            <span class="hljs-keyword">if</span> (!isPalindrome(memo, s, index, i)) {</span><br><span class="line">                <span class="hljs-keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            path.add(s.substring(index, i + <span class="hljs-number">1</span>));</span><br><span class="line">            dfs(memo, answer, path, i + <span class="hljs-number">1</span>, length, s);</span><br><span class="line">            path.remove(path.size() - <span class="hljs-number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(Boolean[][] memo, String s, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>{</span><br><span class="line">        <span class="hljs-keyword">if</span> (memo[left][right] != <span class="hljs-keyword">null</span>) {</span><br><span class="line">            <span class="hljs-keyword">return</span> memo[left][right];</span><br><span class="line">        }</span><br><span class="line">        <span class="hljs-keyword">while</span> (left &lt; right) {</span><br><span class="line">            <span class="hljs-keyword">if</span> (s.charAt(left) != s.charAt(right)) {</span><br><span class="line">                <span class="hljs-keyword">return</span> memo[left][right] = <span class="hljs-keyword">false</span>;</span><br><span class="line">            }</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        }</span><br><span class="line">        <span class="hljs-keyword">return</span> memo[left][right] = <span class="hljs-keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(N*2^n)$，每个位置的字符可以拆分也可以不拆分，因此时间复杂度是$O(2^n)$，判断每个子字符串是否为回文串需要$O(N)$的时间，但是添加了记忆化搜索，每个子串至多搜索一次。</li><li>空间复杂度：$O(N*2^n)$，考虑$answer$，每个位置的字符可以拆分也可以不拆分，两种情况都需要占用空间，此部分空间是$O(2^n)$，而对于所有的答案都需要保存，此部分空间是$O(N)$.</li></ul><h4 id="方法三：DP-回溯"><a href="#方法三：DP-回溯" class="headerlink" title="方法三：DP+回溯"></a>方法三：DP+回溯</h4><p>我们可以利用DP通过提前计算好字符串的回文信息。</p><p><strong>思路和算法</strong></p><p>需要提前截取子字符串然后进行DP。那么问题来了，如何截取所有在子字符串？<br>我们可以定义如下双重循环：<br></p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>;right &lt; s.length(); right++) {</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;left&lt;= right; right++) {</span><br><span class="line">        <span class="hljs-comment">// s[left,right] 就是所有的子字符串</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p><strong>思考状态转移方程</strong></p><ol><li>定义$dp[i][j]$代表$s[i, j]$是否为回文串</li><li>当$s[left] == s[right]$可知字符串两端是相等的，需要考虑$left和right$的距离，通过穷举(笨办法)可知：<ol><li>$right - left = 0$时，$left$和$right$就是同一个字符，显然可以直接得到答案$true$</li><li>$right - left = 1$时，$left$和$right$是挨着的，比如$aa$，显然可以直接得到答案$true$</li><li>$right - right = 2$时，$left$和$right$中间夹了一个字符，比如$aba$，显然可以直接得到答案$true$</li><li>$right - right &gt; 2$ 时，不能直接看不出来了，需要进行状态转移，比如$aabaa$，当$s[0] == s[4]$时，我们需要看看$s[1,3]$是不是回文串，在本例中，由于$s[1,3]$是回文串，因此$s[0,4]$也是。</li></ol></li></ol><p>综上，DP方程如下：</p><p>$$<br>dp(i,j) = \begin{cases}<br>false, &amp; \text{if } s[i] \ne s[j] \<br>true, &amp; \text{if } s[i] = s[j] \&amp; j-i \le 2 \<br>dp[i+1][j-1], &amp; \text{if } j-i \gt 2<br>\end{cases}<br>$$</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * DP+DFS回溯</span></span><br><span class="line"><span class="hljs-comment">     * 1. DP处理 dp[i][j]是否为回文</span></span><br><span class="line"><span class="hljs-comment">     * 1.1 dp[i][i] = true</span></span><br><span class="line"><span class="hljs-comment">     * 1.2 dp[i][j] = s[i] == s[j] &amp;&amp; (dp[i+1][j-1] || j-i&lt;=2)</span></span><br><span class="line"><span class="hljs-comment">     * 2. 回溯</span></span><br><span class="line"><span class="hljs-comment">     * 2.1 回溯出口: index == s.length()</span></span><br><span class="line"><span class="hljs-comment">     * 2.2 回溯递进：j =&gt; [i,s.length())  if(dp[i][j])  添加子串，然后 dfs(index+1)</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> s</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) {</span><br><span class="line">        <span class="hljs-keyword">int</span> n = s.length();</span><br><span class="line">        <span class="hljs-keyword">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n][n];</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>; right &lt; n; right++) {</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>; left &lt;= right; left++) {</span><br><span class="line">                <span class="hljs-keyword">if</span> (s.charAt(left) == s.charAt(right)) {</span><br><span class="line">                    <span class="hljs-keyword">if</span> (right - left &lt;= <span class="hljs-number">2</span>) {</span><br><span class="line">                        dp[left][right] = <span class="hljs-keyword">true</span>;</span><br><span class="line">                    } <span class="hljs-keyword">else</span> {</span><br><span class="line">                        dp[left][right] = dp[left + <span class="hljs-number">1</span>][right - <span class="hljs-number">1</span>]; <span class="hljs-comment">// 上一轮遍历过</span></span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;String&gt;&gt; answer = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; path = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(answer, path, dp, <span class="hljs-number">0</span>, n, s);</span><br><span class="line">        <span class="hljs-keyword">return</span> answer;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(List&lt;List&lt;String&gt;&gt; answer, List&lt;String&gt; path, <span class="hljs-keyword">boolean</span>[][] dp, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> n, String s)</span> </span>{</span><br><span class="line">        <span class="hljs-keyword">if</span> (index == n) {</span><br><span class="line">            answer.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="hljs-keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> right = index; right &lt; n; right++) {</span><br><span class="line">            <span class="hljs-keyword">if</span> (dp[index][right]) {</span><br><span class="line">                path.add(s.substring(index, right + <span class="hljs-number">1</span>));</span><br><span class="line">                dfs(answer, path, dp, right + <span class="hljs-number">1</span>, n, s);</span><br><span class="line">                path.remove(path.size() - <span class="hljs-number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>复杂度分析</strong><br>+时间复杂度：$O(2^n)$，计算$dp$需要$O(n^2)$,回溯需要$O(2^n)$。</p><ul><li>空间复杂度：$O(N*2^n)$，考虑$answer$，每个位置的字符可以拆分也可以不拆分，两种情况都需要占用空间，此部分空间是$O(2^n)$，而对于所有的答案都需要保存，此部分空间是$O(N)$;考虑$dp$，需要$O(n^2)$的空间</li></ul></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个字符串 &lt;code&gt;s&lt;/code&gt;，请你将 &lt;code&gt;s&lt;/code&gt; 分割成
      
    
    </summary>
    
      <category term="algorithm" scheme="https://www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="leetcode" scheme="https://www.ddhigh.com/tags/leetcode/"/>
    
      <category term="binarysearch" scheme="https://www.ddhigh.com/tags/binarysearch/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode106——从中序与后序遍历序列构造二叉树</title>
    <link href="https://www.ddhigh.com/2022/02/08/construct-binary-tree-from-inorder-and-postorder-traversal.html"/>
    <id>https://www.ddhigh.com/2022/02/08/construct-binary-tree-from-inorder-and-postorder-traversal.html</id>
    <published>2022-02-08T12:24:19.000Z</published>
    <updated>2023-05-05T02:52:12.002Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。</p><p> <strong>示例 1:</strong></p><figure class="highlight angelscript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：inorder = [<span class="hljs-number">9</span>,<span class="hljs-number">3</span>,<span class="hljs-number">15</span>,<span class="hljs-number">20</span>,<span class="hljs-number">7</span>], postorder = [<span class="hljs-number">9</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>,<span class="hljs-number">20</span>,<span class="hljs-number">3</span>]</span><br><span class="line">输出：[<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 2:</strong></p><figure class="highlight angelscript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：inorder = [<span class="hljs-number">-1</span>], postorder = [<span class="hljs-number">-1</span>]</span><br><span class="line">输出：[<span class="hljs-number">-1</span>]</span><br></pre></td></tr></tbody></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal" target="_blank" rel="noopener">https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>核心是中序遍历的顺序是[左，根，右]，后序遍历是[左，右，根]。而同一颗树不管前/中/后序遍历，节点数是不变的。</p></blockquote><figure class="highlight go hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 后序遍历顺序: 左右根</span></span><br><span class="line"><span class="hljs-comment">// 1. postorder最后一个元素为根</span></span><br><span class="line"><span class="hljs-comment">// 2. 遍历inorder查找根的index</span></span><br><span class="line"><span class="hljs-comment">// 3. inorder[:index]为左子树，inorder[index+1:]为右子树，左子树大小记为leftTreeSize</span></span><br><span class="line"><span class="hljs-comment">// 4. postorder[:leftTreeSize]为左子树，postorder[leftTreeSize:len(postorder)-1]是右子树</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buildTree</span><span class="hljs-params">(inorder []<span class="hljs-keyword">int</span>, postorder []<span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">TreeNode</span></span> {</span><br><span class="line">n := <span class="hljs-built_in">len</span>(inorder)</span><br><span class="line"><span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> {</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span></span><br><span class="line">}</span><br><span class="line"><span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span> {</span><br><span class="line"><span class="hljs-keyword">return</span> &amp;TreeNode{Val: inorder[<span class="hljs-number">0</span>]}</span><br><span class="line">}</span><br><span class="line"><span class="hljs-comment">// 查找中序遍历根的index</span></span><br><span class="line">index := <span class="hljs-number">-1</span></span><br><span class="line">rootValue := postorder[<span class="hljs-built_in">len</span>(postorder)<span class="hljs-number">-1</span>]</span><br><span class="line"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(inorder); i++ {</span><br><span class="line"><span class="hljs-keyword">if</span> inorder[i] == rootValue {</span><br><span class="line">index = i</span><br><span class="line"><span class="hljs-keyword">break</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="hljs-comment">// 分割数组</span></span><br><span class="line">leftTreeSize := <span class="hljs-built_in">len</span>(inorder[:index])</span><br><span class="line">root := &amp;TreeNode{Val: rootValue}</span><br><span class="line">root.Left = buildTree(inorder[:index], postorder[:leftTreeSize])</span><br><span class="line">root.Right = buildTree(inorder[index+<span class="hljs-number">1</span>:], postorder[leftTreeSize:<span class="hljs-built_in">len</span>(postorder)<span class="hljs-number">-1</span>])</span><br><span class="line"><span class="hljs-keyword">return</span> root</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树
      
    
    </summary>
    
      <category term="algorithm" scheme="https://www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="leetcode" scheme="https://www.ddhigh.com/tags/leetcode/"/>
    
      <category term="tree" scheme="https://www.ddhigh.com/tags/tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode108——将有序数组转换为二叉搜索树</title>
    <link href="https://www.ddhigh.com/2022/02/08/convert-sorted-array-to-binary-search-tree.html"/>
    <id>https://www.ddhigh.com/2022/02/08/convert-sorted-array-to-binary-search-tree.html</id>
    <published>2022-02-08T12:24:19.000Z</published>
    <updated>2023-05-05T02:52:12.002Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。</p><p>高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg" alt="img"></p><figure class="highlight angelscript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="hljs-number">-10</span>,<span class="hljs-number">-3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>]</span><br><span class="line">输出：[<span class="hljs-number">0</span>,<span class="hljs-number">-3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">-10</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">5</span>]</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree.jpg" alt="img"></p><figure class="highlight angelscript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>]</span><br><span class="line">输出：[<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]</span><br><span class="line">解释：[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>] 和 [<span class="hljs-number">3</span>,<span class="hljs-number">1</span>] 都是高度平衡二叉搜索树。</span><br></pre></td></tr></tbody></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>二叉树的中序遍历是升序，节点顺序为[左，根，右]</p></blockquote><ol><li>对于给定的数组，根据升序的性质，可知，中间节点为根节点，左半部分为左子树，右半部分为右子树</li><li>左半部分也是一颗完整的树，复用1的逻辑，因此用递归即可</li></ol><figure class="highlight go hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="hljs-comment">// 升序数组是树的中序遍历结果，中间Index就是根，可以递归的还原为一个树</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">TreeNode</span></span> {</span><br><span class="line"><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span> {</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span></span><br><span class="line">}</span><br><span class="line"><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span> {</span><br><span class="line"><span class="hljs-keyword">return</span> &amp;TreeNode{Val: nums[<span class="hljs-number">0</span>]}</span><br><span class="line">}</span><br><span class="line"><span class="hljs-keyword">return</span> helper(nums, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">helper</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>, start, end <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">TreeNode</span></span> {</span><br><span class="line"><span class="hljs-keyword">if</span> start &gt; end {</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span></span><br><span class="line">}</span><br><span class="line"><span class="hljs-comment">// 取得根</span></span><br><span class="line">rootIndex := (start + end) / <span class="hljs-number">2</span></span><br><span class="line">rootValue := nums[rootIndex]</span><br><span class="line">root := &amp;TreeNode{Val: rootValue}</span><br><span class="line">root.Left = helper(nums, start, rootIndex<span class="hljs-number">-1</span>)</span><br><span class="line">root.Right = helper(nums, rootIndex+<span class="hljs-number">1</span>, end)</span><br><span class="line"><span class="hljs-keyword">return</span> root</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二
      
    
    </summary>
    
      <category term="algorithm" scheme="https://www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="leetcode" scheme="https://www.ddhigh.com/tags/leetcode/"/>
    
      <category term="tree" scheme="https://www.ddhigh.com/tags/tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode109——有序链表转换二叉搜索树</title>
    <link href="https://www.ddhigh.com/2022/02/08/convert-sorted-list-to-binary-search-tree.html"/>
    <id>https://www.ddhigh.com/2022/02/08/convert-sorted-list-to-binary-search-tree.html</id>
    <published>2022-02-08T12:24:19.000Z</published>
    <updated>2023-05-05T02:52:12.002Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p><p><strong>示例:</strong></p><figure class="highlight angelscript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给定的有序链表： [<span class="hljs-number">-10</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>],</span><br><span class="line"></span><br><span class="line">一个可能的答案是：[<span class="hljs-number">0</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">-10</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">5</span>], 它可以表示下面这个高度平衡二叉搜索树：</span><br><span class="line"></span><br><span class="line">      <span class="hljs-number">0</span></span><br><span class="line">     / \</span><br><span class="line">   <span class="hljs-number">-3</span>   <span class="hljs-number">9</span></span><br><span class="line">   /   /</span><br><span class="line"> <span class="hljs-number">-10</span>  <span class="hljs-number">5</span></span><br></pre></td></tr></tbody></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="转换为数组"><a href="#转换为数组" class="headerlink" title="转换为数组"></a>转换为数组</h3><blockquote><p>转换为数组后解法跟前面一道题一样。</p></blockquote><figure class="highlight go hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="hljs-comment">// 链表转换为数组，复用108解法</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sortedListToBST</span><span class="hljs-params">(head *ListNode)</span> *<span class="hljs-title">TreeNode</span></span> {</span><br><span class="line"><span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> {</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span></span><br><span class="line">}</span><br><span class="line">list := listToArray(head)</span><br><span class="line"><span class="hljs-keyword">return</span> helper(list, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(list)<span class="hljs-number">-1</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">listToArray</span><span class="hljs-params">(head *ListNode)</span> []<span class="hljs-title">int</span></span> {</span><br><span class="line">result := []<span class="hljs-keyword">int</span>{}</span><br><span class="line"><span class="hljs-keyword">for</span> head != <span class="hljs-literal">nil</span> {</span><br><span class="line">result = <span class="hljs-built_in">append</span>(result, head.Val)</span><br><span class="line">head = head.Next</span><br><span class="line">}</span><br><span class="line"><span class="hljs-keyword">return</span> result</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">helper</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>, start, end <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">TreeNode</span></span> {</span><br><span class="line"><span class="hljs-keyword">if</span> start &gt; end {</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span></span><br><span class="line">}</span><br><span class="line"><span class="hljs-comment">// 取得根</span></span><br><span class="line">rootIndex := (start + end) / <span class="hljs-number">2</span></span><br><span class="line">rootValue := nums[rootIndex]</span><br><span class="line">root := &amp;TreeNode{Val: rootValue}</span><br><span class="line">root.Left = helper(nums, start, rootIndex<span class="hljs-number">-1</span>)</span><br><span class="line">root.Right = helper(nums, rootIndex+<span class="hljs-number">1</span>, end)</span><br><span class="line"><span class="hljs-keyword">return</span> root</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="链表操作"><a href="#链表操作" class="headerlink" title="链表操作"></a>链表操作</h3><blockquote><p>我们遍历到中间节点后，将链表拆分为[左部分，中间点，右部分]即可复用逻辑，而且无额外空间占用</p></blockquote><p>单链表是无法直到中间点在哪里的，因此我们需要先遍历一次，获取链表长度，除以2就是中间的index。</p><figure class="highlight go hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 1. 遍历一遍链表得到链表长度，算出中间节点index</span></span><br><span class="line"><span class="hljs-comment">// 2. 再次遍历链表，拆分为三段</span></span><br><span class="line"><span class="hljs-comment">// 1. 起点到中间节点的上一个节点：左子链表</span></span><br><span class="line"><span class="hljs-comment">// 2. 中间节点</span></span><br><span class="line"><span class="hljs-comment">// 3. 中间节点的下一个节点到链表末尾：右子链表</span></span><br><span class="line"><span class="hljs-comment">// 3. 将中间节点作为树根，利用左右子链表，递归构建左右子树，然后挂到根节点</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sortedListToBST</span><span class="hljs-params">(head *ListNode)</span> *<span class="hljs-title">TreeNode</span></span> {</span><br><span class="line"><span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> {</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span></span><br><span class="line">}</span><br><span class="line"><span class="hljs-keyword">return</span> helper(head)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">helper</span><span class="hljs-params">(head *ListNode)</span> *<span class="hljs-title">TreeNode</span></span> {</span><br><span class="line"><span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> {</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span></span><br><span class="line">}</span><br><span class="line"><span class="hljs-keyword">if</span> head.Next == <span class="hljs-literal">nil</span> {</span><br><span class="line"><span class="hljs-keyword">return</span> &amp;TreeNode{Val: head.Val}</span><br><span class="line">}</span><br><span class="line"><span class="hljs-comment">// 获取链表总长度</span></span><br><span class="line">length := <span class="hljs-number">0</span></span><br><span class="line">p := head</span><br><span class="line"><span class="hljs-keyword">for</span> p != <span class="hljs-literal">nil</span> {</span><br><span class="line">length++</span><br><span class="line">p = p.Next</span><br><span class="line">}</span><br><span class="line">middle := length / <span class="hljs-number">2</span> <span class="hljs-comment">// 取得中间点位置</span></span><br><span class="line"><span class="hljs-comment">// 再次遍历到中间点</span></span><br><span class="line"><span class="hljs-keyword">var</span> (</span><br><span class="line">prev = head      <span class="hljs-comment">// 指向中间点的上一个节点</span></span><br><span class="line">curr = head.Next <span class="hljs-comment">// 指向中间点</span></span><br><span class="line">)</span><br><span class="line"><span class="hljs-keyword">var</span> (</span><br><span class="line">left  *ListNode <span class="hljs-comment">// 左子链表头结点</span></span><br><span class="line">right *ListNode <span class="hljs-comment">// 右子链表头结点</span></span><br><span class="line">)</span><br><span class="line">index := <span class="hljs-number">0</span></span><br><span class="line"><span class="hljs-keyword">for</span> curr != <span class="hljs-literal">nil</span> {</span><br><span class="line"><span class="hljs-comment">// index是prev的下标，因此定位到middle的前一个</span></span><br><span class="line"><span class="hljs-keyword">if</span> index == middle<span class="hljs-number">-1</span> {</span><br><span class="line"><span class="hljs-comment">// 找到中点，将中点和右子链表连接打断</span></span><br><span class="line">right = curr.Next</span><br><span class="line">curr.Next = <span class="hljs-literal">nil</span></span><br><span class="line"><span class="hljs-comment">// 将左子链表和中点连接打断</span></span><br><span class="line">prev.Next = <span class="hljs-literal">nil</span></span><br><span class="line">left = head</span><br><span class="line"><span class="hljs-keyword">break</span></span><br><span class="line">}</span><br><span class="line">prev = curr</span><br><span class="line">curr = curr.Next</span><br><span class="line">index++</span><br><span class="line">}</span><br><span class="line"><span class="hljs-comment">// 此时我们拥有left,curr,right 三个链表，开始递归组合</span></span><br><span class="line">root := &amp;TreeNode{Val: curr.Val}</span><br><span class="line">root.Left = helper(left) <span class="hljs-comment">// 给你一条链表，给我构建一个树出来</span></span><br><span class="line">root.Right = helper(right)</span><br><span class="line"><span class="hljs-keyword">return</span> root</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。&lt;/p&gt;
&lt;p&gt;本题
      
    
    </summary>
    
      <category term="algorithm" scheme="https://www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="leetcode" scheme="https://www.ddhigh.com/tags/leetcode/"/>
    
      <category term="tree" scheme="https://www.ddhigh.com/tags/tree/"/>
    
  </entry>
  
</feed>
