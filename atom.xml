<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>每天进步一点点</title>
  
  <subtitle>Coding Change Anything</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https//www.ddhigh.com/"/>
  <updated>2022-02-06T11:56:58.658Z</updated>
  <id>https//www.ddhigh.com/</id>
  
  <author>
    <name>xialeistudio</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode107——二叉树的层序遍历 II</title>
    <link href="https//www.ddhigh.com/2022/02/06/binary-tree-level-order-traversal-ii.html"/>
    <id>https//www.ddhigh.com/2022/02/06/binary-tree-level-order-traversal-ii.html</id>
    <published>2022-02-06T12:24:19.000Z</published>
    <updated>2022-02-06T11:56:58.658Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你二叉树的根节点 <code>root</code> ，返回其节点值 <strong>自底向上的层序遍历</strong> 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt="img"></p><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,null,null,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]</span><br><span class="line">输出：[[<span class="hljs-number">15</span>,<span class="hljs-number">7</span>],[<span class="hljs-number">9</span>,<span class="hljs-number">20</span>],[<span class="hljs-number">3</span>]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="hljs-number">1</span>]</span><br><span class="line">输出：<span class="hljs-string">[[1]]</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7 hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = <span class="hljs-comment">[]</span></span><br><span class="line">输出：<span class="hljs-comment">[]</span></span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>直接用层序遍历即可，结果数组翻转之后就是答案</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// BFS正向遍历，最后翻转一下最终结果</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">levelOrderBottom</span><span class="hljs-params">(root *TreeNode)</span> [][]<span class="hljs-title">int</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> [][]<span class="hljs-keyword">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">answers := [][]<span class="hljs-keyword">int</span>&#123;&#125;</span><br><span class="line">queue := []*TreeNode&#123;root&#125;</span><br><span class="line"><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;</span><br><span class="line">size := <span class="hljs-built_in">len</span>(queue)</span><br><span class="line">tmp := queue</span><br><span class="line">queue = []*TreeNode&#123;&#125; <span class="hljs-comment">// 清空，存储下一层的节点</span></span><br><span class="line">level := []<span class="hljs-keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;</span><br><span class="line">node := tmp[<span class="hljs-number">0</span>]</span><br><span class="line">tmp = tmp[<span class="hljs-number">1</span>:]</span><br><span class="line">level = <span class="hljs-built_in">append</span>(level, node.Val)</span><br><span class="line"><span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">queue = <span class="hljs-built_in">append</span>(queue, node.Left)</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">queue = <span class="hljs-built_in">append</span>(queue, node.Right)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">answers = <span class="hljs-built_in">append</span>(answers, level)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="hljs-comment">// 翻转数组</span></span><br><span class="line">length := <span class="hljs-built_in">len</span>(answers)</span><br><span class="line"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; length/<span class="hljs-number">2</span>; i++ &#123;</span><br><span class="line">answers[i], answers[length<span class="hljs-number">-1</span>-i] = answers[length<span class="hljs-number">-1</span>-i], answers[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> answers</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你二叉树的根节点 &lt;code&gt;root&lt;/code&gt; ，返回其节点值 &lt;strong&gt;自底向上的层序遍历&lt;/strong&gt; 。 （即按从叶
      
    
    </summary>
    
      <category term="algorithm" scheme="https//www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="tree" scheme="https//www.ddhigh.com/tags/tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode103——二叉树的锯齿形层序遍历</title>
    <link href="https//www.ddhigh.com/2022/02/06/binary-tree-zigzag-level-order-traversal.html"/>
    <id>https//www.ddhigh.com/2022/02/06/binary-tree-zigzag-level-order-traversal.html</id>
    <published>2022-02-06T12:24:19.000Z</published>
    <updated>2022-02-06T11:56:58.658Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>锯齿形层序遍历</strong> 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt="img"></p><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,null,null,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]</span><br><span class="line">输出：[[<span class="hljs-number">3</span>],[<span class="hljs-number">20</span>,<span class="hljs-number">9</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="hljs-number">1</span>]</span><br><span class="line">输出：<span class="hljs-string">[[1]]</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7 hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = <span class="hljs-comment">[]</span></span><br><span class="line">输出：<span class="hljs-comment">[]</span></span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>用层序遍历的思路即可，不过偶数行需要将该行的值翻转。</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// BFS处理，记录遍历层数，当层数是奇数，翻转下本层元素</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">zigzagLevelOrder</span><span class="hljs-params">(root *TreeNode)</span> [][]<span class="hljs-title">int</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> [][]<span class="hljs-keyword">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">answers := [][]<span class="hljs-keyword">int</span>&#123;&#125;</span><br><span class="line">queue := []*TreeNode&#123;root&#125;</span><br><span class="line"><span class="hljs-keyword">for</span> level := <span class="hljs-number">1</span>; <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span>; level++ &#123;</span><br><span class="line">size := <span class="hljs-built_in">len</span>(queue)</span><br><span class="line">tmp := queue</span><br><span class="line">queue = []*TreeNode&#123;&#125; <span class="hljs-comment">// 清空，存储下一层的节点</span></span><br><span class="line">vals := []<span class="hljs-keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;</span><br><span class="line">node := tmp[<span class="hljs-number">0</span>]</span><br><span class="line">tmp = tmp[<span class="hljs-number">1</span>:]</span><br><span class="line">vals = <span class="hljs-built_in">append</span>(vals, node.Val)</span><br><span class="line"><span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">queue = <span class="hljs-built_in">append</span>(queue, node.Left)</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">queue = <span class="hljs-built_in">append</span>(queue, node.Right)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> level%<span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 偶数行，翻转vals</span></span><br><span class="line">length := <span class="hljs-built_in">len</span>(vals)</span><br><span class="line"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; length/<span class="hljs-number">2</span>; i++ &#123;</span><br><span class="line">vals[i], vals[length<span class="hljs-number">-1</span>-i] = vals[length<span class="hljs-number">-1</span>-i], vals[i] <span class="hljs-comment">// length-1是结束下标，-i就是同步往左逼近</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">answers = <span class="hljs-built_in">append</span>(answers, vals)</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> answers</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你二叉树的根节点 &lt;code&gt;root&lt;/code&gt; ，返回其节点值的 &lt;strong&gt;锯齿形层序遍历&lt;/strong&gt; 。（即先从左往右
      
    
    </summary>
    
      <category term="algorithm" scheme="https//www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="tree" scheme="https//www.ddhigh.com/tags/tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode99——恢复二叉搜索树</title>
    <link href="https//www.ddhigh.com/2022/02/06/construct-binary-tree-from-preorder-and-inorder-traversal.html"/>
    <id>https//www.ddhigh.com/2022/02/06/construct-binary-tree-from-preorder-and-inorder-traversal.html</id>
    <published>2022-02-06T12:24:19.000Z</published>
    <updated>2022-02-06T11:56:58.658Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</p><p><strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt="img"></p><figure class="highlight nix hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="hljs-attr">preorder</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>], <span class="hljs-attr">inorder</span> = [<span class="hljs-number">9</span>,<span class="hljs-number">3</span>,<span class="hljs-number">15</span>,<span class="hljs-number">20</span>,<span class="hljs-number">7</span>]</span><br><span class="line">输出: [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight inform7 hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: preorder = <span class="hljs-comment">[-1]</span>, inorder = <span class="hljs-comment">[-1]</span></span><br><span class="line">输出: <span class="hljs-comment">[-1]</span></span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal" target="_blank" rel="noopener">https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>利用前序遍历和中序遍历性质</p><ol><li>前序遍历节点顺序如下[根，左，右]</li><li>中序遍历节点顺序如下[左，根，右]</li><li>前序遍历的左/右子树长度和中序遍历的左/右子树长度是相同的</li><li>由于这是同一颗树遍历来的，因此前序遍历的第0个元素和中序遍历的根节点是相同的。因此只要能定位中序遍历的根节点，将中序遍历数组拆分为左右两半后就可以了<ol><li>查找中序遍历的数组中值为前序遍历第0个元素节点的下标，记为<code>middle</code></li><li>此时中序遍历左子树节点列表为<code>[:middle]</code>，右子树节点列表为<code>[middle+1:]</code>，左子树长度为<code>len([:middle])</code>，记为<code>leftTreeSize</code></li><li>根据第3点可知，前序遍历的左子树节点列表为<code>[1:leftTreeSize+1]</code>,右子树节点为<code>[leftTreeSize+1:]</code></li></ol></li></ol><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 递归法</span></span><br><span class="line"><span class="hljs-comment">// 中序，左根右；前序根左右</span></span><br><span class="line"><span class="hljs-comment">// 1. 根据中序遍历找到根节点(值为preorder[0]的节点)</span></span><br><span class="line"><span class="hljs-comment">// 2. 中序遍历根节点左边的节点数和前序遍历的节点数是相同的，根据该性质可以将前序遍历拆分为两半</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buildTree</span><span class="hljs-params">(preorder []<span class="hljs-keyword">int</span>, inorder []<span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">TreeNode</span></span> &#123;</span><br><span class="line">n := <span class="hljs-built_in">len</span>(preorder)</span><br><span class="line"><span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">root := &amp;TreeNode&#123;Val: preorder[<span class="hljs-number">0</span>]&#125;</span><br><span class="line"><span class="hljs-comment">// 查找根节点在中序遍历的位置</span></span><br><span class="line">middle := <span class="hljs-number">0</span></span><br><span class="line"><span class="hljs-keyword">for</span> ; middle &lt; n; middle++ &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> inorder[middle] == preorder[<span class="hljs-number">0</span>] &#123;</span><br><span class="line"><span class="hljs-keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">leftTreeSize := <span class="hljs-built_in">len</span>(inorder[:middle])                                 <span class="hljs-comment">// 中序遍历的左半边就是左子树</span></span><br><span class="line">root.Left = buildTree(preorder[<span class="hljs-number">1</span>:leftTreeSize+<span class="hljs-number">1</span>], inorder[:middle])   <span class="hljs-comment">// 将前序遍历的左半边和中序的左半边递归构造左子树</span></span><br><span class="line">root.Right = buildTree(preorder[leftTreeSize+<span class="hljs-number">1</span>:], inorder[middle+<span class="hljs-number">1</span>:]) <span class="hljs-comment">// 将前序遍历的右半边和中序遍历的右半边构建右子树</span></span><br><span class="line"><span class="hljs-keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历
      
    
    </summary>
    
      <category term="algorithm" scheme="https//www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="tree" scheme="https//www.ddhigh.com/tags/tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode99——恢复二叉搜索树</title>
    <link href="https//www.ddhigh.com/2022/02/06/recover-binary-search-tree.html"/>
    <id>https//www.ddhigh.com/2022/02/06/recover-binary-search-tree.html</id>
    <published>2022-02-06T12:24:19.000Z</published>
    <updated>2022-02-06T11:56:58.658Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你二叉搜索树的根节点 root ，该树中的 恰好 两个节点的值被错误地交换。请在不改变其结构的情况下，恢复这棵树 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/28/recover1.jpg" alt="img"></p><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,null,null,<span class="hljs-number">2</span>]</span><br><span class="line">输出：[<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,null,null,<span class="hljs-number">2</span>]</span><br><span class="line">解释：<span class="hljs-number">3</span> 不能是 <span class="hljs-number">1</span> 的左孩子，因为 <span class="hljs-number">3</span> &gt; <span class="hljs-number">1</span> 。交换 <span class="hljs-number">1</span> 和 <span class="hljs-number">3</span> 使二叉搜索树有效。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/28/recover2.jpg" alt="img"></p><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,null,null,<span class="hljs-number">2</span>]</span><br><span class="line">输出：[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,null,null,<span class="hljs-number">3</span>]</span><br><span class="line">解释：<span class="hljs-number">2</span> 不能在 <span class="hljs-number">3</span> 的右子树中，因为 <span class="hljs-number">2</span> &lt; <span class="hljs-number">3</span> 。交换 <span class="hljs-number">2</span> 和 <span class="hljs-number">3</span> 使二叉搜索树有效。</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/recover-binary-search-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/recover-binary-search-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>中序遍历构造一个数组，根据二叉搜索树的性质，中序遍历是严格递增的</li><li>遍历该数组，找出<code>后一个值</code>小于<code>前一个值</code>的下标，根据这两个下标访问数组，可以得到两个错误值</li><li>遍历二叉树，根据第2步的两个值定位两个二叉树节点</li><li>交换两个节点的值</li></ol><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 1. 中序遍历构造一个数组</span></span><br><span class="line"><span class="hljs-comment">// 2. 检查数组顺序，定位有问题的下标</span></span><br><span class="line"><span class="hljs-comment">// 3. 中序遍历原来的树，定位指定下标的节点， 交换两个节点值</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">recoverTree</span><span class="hljs-params">(root *TreeNode)</span></span> &#123;</span><br><span class="line"><span class="hljs-comment">// 构造数组</span></span><br><span class="line"><span class="hljs-keyword">var</span> values []<span class="hljs-keyword">int</span></span><br><span class="line"><span class="hljs-keyword">var</span> valueGetter <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span></span><br><span class="line">valueGetter = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">valueGetter(root.Left)</span><br><span class="line">values = <span class="hljs-built_in">append</span>(values, root.Val)</span><br><span class="line">valueGetter(root.Right)</span><br><span class="line">&#125;</span><br><span class="line">valueGetter(root)</span><br><span class="line"><span class="hljs-comment">// 检查数组值顺序，如果比前面的小或者比后面的大</span></span><br><span class="line"><span class="hljs-keyword">var</span> (</span><br><span class="line">wrongIndex1 = <span class="hljs-number">-1</span></span><br><span class="line">wrongIndex2 = <span class="hljs-number">-1</span></span><br><span class="line">)</span><br><span class="line"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(values)<span class="hljs-number">-1</span>; i++ &#123;</span><br><span class="line"><span class="hljs-comment">// 如果比前面的小或者比后面的大</span></span><br><span class="line"><span class="hljs-keyword">if</span> values[i+<span class="hljs-number">1</span>] &lt; values[i] &#123;</span><br><span class="line">wrongIndex2 = i + <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-keyword">if</span> wrongIndex1 == <span class="hljs-number">-1</span> &#123;</span><br><span class="line">wrongIndex1 = i</span><br><span class="line">&#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 中序遍历，定位到wrongIndex1和wrongIndex2的节点，交换两者的值</span></span><br><span class="line"><span class="hljs-keyword">var</span> (</span><br><span class="line">locator    <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span></span><br><span class="line">wrongNode1 *TreeNode</span><br><span class="line">wrongNode2 *TreeNode</span><br><span class="line">)</span><br><span class="line">locator = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">locator(root.Left)</span><br><span class="line"><span class="hljs-keyword">if</span> root.Val == values[wrongIndex1] &#123; <span class="hljs-comment">// 根据值定位节点</span></span><br><span class="line">wrongNode1 = root</span><br><span class="line">&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> root.Val == values[wrongIndex2] &#123;</span><br><span class="line">wrongNode2 = root</span><br><span class="line">&#125;</span><br><span class="line">locator(root.Right)</span><br><span class="line">&#125;</span><br><span class="line">locator(root)</span><br><span class="line">wrongNode1.Val, wrongNode2.Val = wrongNode2.Val, wrongNode1.Val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你二叉搜索树的根节点 root ，该树中的 恰好 两个节点的值被错误地交换。请在不改变其结构的情况下，恢复这棵树 。&lt;/p&gt;
&lt;p&gt;&lt;st
      
    
    </summary>
    
      <category term="algorithm" scheme="https//www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="tree" scheme="https//www.ddhigh.com/tags/tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode95——不同的二叉搜索树 II</title>
    <link href="https//www.ddhigh.com/2022/02/06/unique-binary-search-trees-ii.html"/>
    <id>https//www.ddhigh.com/2022/02/06/unique-binary-search-trees-ii.html</id>
    <published>2022-02-06T12:24:19.000Z</published>
    <updated>2022-02-06T11:56:58.658Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数 <code>n</code> ，请你生成并返回所有由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的不同 <strong>二叉搜索树</strong> 。可以按 <strong>任意顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg" alt="img"></p><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="hljs-number">3</span></span><br><span class="line">输出：[[<span class="hljs-number">1</span>,null,<span class="hljs-number">2</span>,null,<span class="hljs-number">3</span>],[<span class="hljs-number">1</span>,null,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,null,null,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,null,<span class="hljs-number">1</span>]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p>输入：n = 1<br>输出：[[1]]</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-binary-search-trees-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>由于每个节点都可以成为根节点，因此遍历1~n，i为遍历参数名称，此时可以构造如下树<ol><li>1~i-1为左子树</li><li>i为根节点</li><li>i+1~n为右子树</li></ol></li><li>递归的调用步骤1可以得到所有的组合</li></ol><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generateTrees</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span> []*<span class="hljs-title">TreeNode</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> generate(<span class="hljs-number">1</span>, n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 生成start ~ end的数列表</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generate</span><span class="hljs-params">(start, end <span class="hljs-keyword">int</span>)</span> []*<span class="hljs-title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="hljs-comment">// 非法条件拦截</span></span><br><span class="line"><span class="hljs-keyword">if</span> start &gt; end &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> []*TreeNode&#123;<span class="hljs-literal">nil</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line">allNodes := []*TreeNode&#123;&#125;</span><br><span class="line"><span class="hljs-comment">// 遍历n</span></span><br><span class="line"><span class="hljs-keyword">for</span> i := start; i &lt;= end; i++ &#123;</span><br><span class="line">        <span class="hljs-comment">// start ~ i-1可以构造左子树节点</span></span><br><span class="line">leftTrees := generate(start, i<span class="hljs-number">-1</span>)</span><br><span class="line">        <span class="hljs-comment">// i+1 ~ end可以构造右子树节点</span></span><br><span class="line">rightTrees := generate(i+<span class="hljs-number">1</span>, end)</span><br><span class="line"><span class="hljs-keyword">for</span> _, left := <span class="hljs-keyword">range</span> leftTrees &#123;</span><br><span class="line"><span class="hljs-keyword">for</span> _, right := <span class="hljs-keyword">range</span> rightTrees &#123;</span><br><span class="line">                <span class="hljs-comment">// 组装左根右节点</span></span><br><span class="line">root := &amp;TreeNode&#123;Val: i&#125;</span><br><span class="line">root.Left = left</span><br><span class="line">root.Right = right</span><br><span class="line">allNodes = <span class="hljs-built_in">append</span>(allNodes, root)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> allNodes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个整数 &lt;code&gt;n&lt;/code&gt; ，请你生成并返回所有由 &lt;code&gt;n&lt;/code&gt; 个节点组成且节点值从 &lt;code&gt;1&lt;/c
      
    
    </summary>
    
      <category term="algorithm" scheme="https//www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="tree" scheme="https//www.ddhigh.com/tags/tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode98——验证二叉搜索树</title>
    <link href="https//www.ddhigh.com/2022/02/06/validate-binary-search-tree.html"/>
    <id>https//www.ddhigh.com/2022/02/06/validate-binary-search-tree.html</id>
    <published>2022-02-06T12:24:19.000Z</published>
    <updated>2022-02-06T11:56:58.658Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p><p><strong>有效</strong> 二叉搜索树定义如下：</p><p>节点的左子树只包含 <strong>小于</strong> 当前节点的数。<br>节点的右子树只包含 <strong>大于</strong> 当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg" alt="img"></p><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg" alt="img"></p><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,null,null,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>]</span><br><span class="line">输出：false</span><br><span class="line">解释：根节点的值是 <span class="hljs-number">5</span> ，但是右子节点的值是 <span class="hljs-number">4</span> 。</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/validate-binary-search-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/validate-binary-search-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>直接用中序遍历即可。中序遍历可以保证后一个值一定比前一个值大。</p><p>中序遍历处理顺序：左-&gt;根-&gt;右</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 中序遍历，值如果都是升序就满足要求</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(root *TreeNode)</span> <span class="hljs-title">bool</span></span> &#123;</span><br><span class="line">  <span class="hljs-keyword">var</span> (</span><br><span class="line">lastValue = math.MinInt64 <span class="hljs-comment">// 上一个值，初始化时保证是最小值即可，这样只要树节点有值就能大于该值</span></span><br><span class="line">helper    <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span> <span class="hljs-title">bool</span> // 判断指定节点是否大于<span class="hljs-title">lastValue</span></span></span><br><span class="line">)</span><br><span class="line">helper = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span> <span class="hljs-title">bool</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 节点为空，直接返回true</span></span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> !helper(root.Left) &#123; <span class="hljs-comment">// 如果左子树不满足要求则返回false</span></span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> root.Val &lt;= lastValue &#123; <span class="hljs-comment">// 如果当前节点&lt;=上一个节点，则不满足要求（中序遍历本节点一定大于上一个节点）</span></span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">lastValue = root.Val <span class="hljs-comment">// 更新上一个节点</span></span><br><span class="line"><span class="hljs-keyword">if</span> !helper(root.Right) &#123; <span class="hljs-comment">// 检查右子树</span></span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> helper(root)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有效&lt;/strong&gt; 二叉搜索树定义
      
    
    </summary>
    
      <category term="algorithm" scheme="https//www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="tree" scheme="https//www.ddhigh.com/tags/tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode328——奇偶链表</title>
    <link href="https//www.ddhigh.com/2022/02/05/odd-even-linked-list.html"/>
    <id>https//www.ddhigh.com/2022/02/05/odd-even-linked-list.html</id>
    <published>2022-02-05T12:24:19.000Z</published>
    <updated>2022-02-06T11:56:58.658Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定单链表的头节点 head ，将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后返回重新排序的列表。</p><p>第一个节点的索引被认为是 奇数 ， 第二个节点的索引为 偶数 ，以此类推。</p><p>请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致。</p><p>你必须在 O(1) 的额外空间复杂度和 O(n) 的时间复杂度下解决这个问题。</p><p><strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/10/oddeven-linked-list.jpg" alt="img"></p><figure class="highlight accesslog hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: head = <span class="hljs-string">[1,2,3,4,5]</span></span><br><span class="line">输出: <span class="hljs-string">[1,3,5,2,4]</span></span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/10/oddeven2-linked-list.jpg" alt="img"></p><figure class="highlight accesslog hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: head = <span class="hljs-string">[2,1,3,5,6,4,7]</span></span><br><span class="line">输出: <span class="hljs-string">[2,3,6,7,1,5,4]</span></span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/odd-even-linked-list" target="_blank" rel="noopener">https://leetcode-cn.com/problems/odd-even-linked-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/odd-even-linked-list" target="_blank" rel="noopener">https://leetcode-cn.com/problems/odd-even-linked-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>定义2个链表，<code>odd为奇数链表</code>，<code>even为偶数链表</code></li><li>遍历原链表，根据奇偶位置插入<code>odd</code>或者<code>even</code></li><li>连接<code>odd</code>和<code>even</code></li></ol><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 1. 定义以下节点</span></span><br><span class="line"><span class="hljs-comment">//    1. 偶链表头节点，移动节点</span></span><br><span class="line"><span class="hljs-comment">//    2. 奇链表头结点，移动节点</span></span><br><span class="line"><span class="hljs-comment">// 2. 奇链表尾节点.Next = 偶链表头结点</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">oddEvenList</span><span class="hljs-params">(head *ListNode)</span> *<span class="hljs-title">ListNode</span></span> &#123;</span><br><span class="line"><span class="hljs-comment">// 0,1,2个节点时直接返回</span></span><br><span class="line"><span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> || head.Next == <span class="hljs-literal">nil</span> || head.Next.Next == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> head</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> (</span><br><span class="line">oddHead  *ListNode</span><br><span class="line">oddMove  *ListNode</span><br><span class="line">evenHead *ListNode</span><br><span class="line">evenMove *ListNode</span><br><span class="line">)</span><br><span class="line">p := head</span><br><span class="line"><span class="hljs-keyword">for</span> p != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-comment">// 连接奇数节点</span></span><br><span class="line"><span class="hljs-keyword">if</span> oddHead == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">oddHead = p</span><br><span class="line">oddMove = p</span><br><span class="line">&#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">oddMove.Next = p</span><br><span class="line">oddMove = oddMove.Next</span><br><span class="line">&#125;</span><br><span class="line">p = p.Next</span><br><span class="line"><span class="hljs-comment">// 连接偶数节点</span></span><br><span class="line"><span class="hljs-keyword">if</span> p != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> evenHead == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">evenHead = p</span><br><span class="line">evenMove = p</span><br><span class="line">&#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">evenMove.Next = p</span><br><span class="line">evenMove = evenMove.Next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 移动到下一个奇数节点</span></span><br><span class="line"><span class="hljs-keyword">if</span> p != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">p = p.Next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 断开原来的连接</span></span><br><span class="line">oddMove.Next = <span class="hljs-literal">nil</span></span><br><span class="line">evenMove.Next = <span class="hljs-literal">nil</span></span><br><span class="line"></span><br><span class="line">oddMove.Next = evenHead</span><br><span class="line"><span class="hljs-keyword">return</span> oddHead</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定单链表的头节点 head ，将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后返回重新排序的列表。&lt;/p&gt;
&lt;p&gt;第一个节点的
      
    
    </summary>
    
      <category term="algorithm" scheme="https//www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="linklist" scheme="https//www.ddhigh.com/tags/linklist/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode142——环形链表2</title>
    <link href="https//www.ddhigh.com/2022/02/05/linked-list-cycle-ii.html"/>
    <id>https//www.ddhigh.com/2022/02/05/linked-list-cycle-ii.html</id>
    <published>2022-02-05T12:14:56.000Z</published>
    <updated>2022-02-06T11:56:58.658Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>不允许修改 链表。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-4</span>], pos = <span class="hljs-number">1</span></span><br><span class="line">输出：返回索引为 <span class="hljs-number">1</span> 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], pos = <span class="hljs-number">0</span></span><br><span class="line">输出：返回索引为 <span class="hljs-number">0</span> 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/linked-list-cycle-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>参考上一篇<a href="/2022/02/05/linked-list-cycle.md">环形链表</a>，可以利用哈希表存储节点，当再次遇到该节点时，该节点就是成环点。</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 1. 遍历节点存入map</span></span><br><span class="line"><span class="hljs-comment">// 2. 如果节点已存在，则该节点是成环节点</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">detectCycle</span><span class="hljs-params">(head *ListNode)</span> *<span class="hljs-title">ListNode</span></span> &#123;</span><br><span class="line">m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[*ListNode]<span class="hljs-keyword">struct</span>&#123;&#125;)</span><br><span class="line">p := head</span><br><span class="line"><span class="hljs-keyword">for</span> p != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> _, ok := m[p]; ok &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line">m[p] = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">p = p.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><ol><li>快指针走2步，慢指针走1步</li><li>快慢指针相遇时，慢指针走了<code>s</code>个节点，快指针走了<code>2s</code>，同时快指针比慢指针多走了<code>N</code>圈，设环形区间长度为<code>b</code>,因此<code>2s = s+nb</code>，因此<code>s=nb</code>，也就是快慢指针相遇时慢指针走过的距离刚好是环的倍数。</li><li>新起指针指向头结点，和慢指针一起向后走，两点相遇时新指针走了a，慢指针走了a+nb，此时新指针和慢指针相遇，新指针指向成环点</li></ol><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">detectCycle</span><span class="hljs-params">(head *ListNode)</span> *<span class="hljs-title">ListNode</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> || head.Next == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">fast := head</span><br><span class="line">slow := head</span><br><span class="line"><span class="hljs-keyword">for</span> fast != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">slow = slow.Next</span><br><span class="line">fast = fast.Next</span><br><span class="line"><span class="hljs-keyword">if</span> fast != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">fast = fast.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> fast == slow &#123;</span><br><span class="line"><span class="hljs-comment">// 快慢相遇，新起指针指向节点，然后和慢指针一起走，两者相遇点就是成环点</span></span><br><span class="line">ptr := head</span><br><span class="line"><span class="hljs-keyword">for</span> ptr != slow &#123;</span><br><span class="line">ptr = ptr.Next</span><br><span class="line">slow = slow.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> ptr</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。&lt;/p&gt;
&lt;p&gt;如果链表中有某个节点，可以通过连续跟踪 nex
      
    
    </summary>
    
      <category term="algorithm" scheme="https//www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="linklist" scheme="https//www.ddhigh.com/tags/linklist/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode141——环形链表</title>
    <link href="https//www.ddhigh.com/2022/02/05/linked-list-cycle.html"/>
    <id>https//www.ddhigh.com/2022/02/05/linked-list-cycle.html</id>
    <published>2022-02-05T12:09:35.000Z</published>
    <updated>2022-02-06T11:56:58.658Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个链表的头节点 head ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环 ，则返回 true 。 否则，返回 false 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-4</span>], pos = <span class="hljs-number">1</span></span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], pos = <span class="hljs-number">0</span></span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/linked-list-cycle" target="_blank" rel="noopener">https://leetcode-cn.com/problems/linked-list-cycle</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="哈希表法"><a href="#哈希表法" class="headerlink" title="哈希表法"></a>哈希表法</h3><p>利用哈希表存储访问过的节点，如果遍历时节点在哈希表，则有环。</p><blockquote><p>Go语言中map的value为struct可以不占用存储空间。</p></blockquote><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(head *ListNode)</span> <span class="hljs-title">bool</span></span> &#123;</span><br><span class="line">    m := <span class="hljs-keyword">map</span>[*ListNode]<span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    <span class="hljs-keyword">for</span> head != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> _, ok := m[head]; ok &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        m[head] = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        head = head.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快慢指针法"><a href="#快慢指针法" class="headerlink" title="快慢指针法"></a>快慢指针法</h3><ol><li>快指针每次走两步，慢指针走一步，如果相遇则存在环</li></ol><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(head *ListNode)</span> <span class="hljs-title">bool</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> || head.Next == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">fast := head</span><br><span class="line">slow := head</span><br><span class="line"><span class="hljs-keyword">for</span> fast != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">slow = slow.Next</span><br><span class="line">fast = fast.Next <span class="hljs-comment">// 快指针走1步</span></span><br><span class="line"><span class="hljs-keyword">if</span> fast != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">fast = fast.Next <span class="hljs-comment">// 快指针再走1步</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> fast == slow &#123; <span class="hljs-comment">// 相遇了</span></span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个链表的头节点 head ，判断链表中是否有环。&lt;/p&gt;
&lt;p&gt;如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表
      
    
    </summary>
    
      <category term="algorithm" scheme="https//www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="linklist" scheme="https//www.ddhigh.com/tags/linklist/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode92——反转链表 II</title>
    <link href="https//www.ddhigh.com/2022/02/05/reverse-linked-list-ii.html"/>
    <id>https//www.ddhigh.com/2022/02/05/reverse-linked-list-ii.html</id>
    <published>2022-02-05T11:00:00.000Z</published>
    <updated>2022-02-06T11:56:58.658Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。</p><p><strong>示例 1：</strong><br><img src="https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg" alt="示例1"></p><p>输入：head = [1,2,3,4,5], left = 2, right = 4<br>输出：[1,4,3,2,5]</p><p><strong>示例 2：</strong></p><p>输入：head = [5], left = 1, right = 1<br>输出：[5]</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/reverse-linked-list-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-linked-list-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="转数组"><a href="#转数组" class="headerlink" title="转数组"></a>转数组</h3><blockquote><p>大部分的链表题只要未要求原节点上操作，都可以转数组处理，缺点是空间复杂度会额外增加达到O(n)。</p><ol><li>将原链表按顺序转为数组</li><li>遍历数组，翻转left ~ right之间的数组，此处用双指针即可<ol><li>定义left和right指针，交换left和right的值</li><li>两个指针同时向中间移动，left++,right–</li></ol></li><li>将数组构造为链表返回</li></ol></blockquote><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 数组法</span></span><br><span class="line"><span class="hljs-comment">// 1. 链表转换为数组</span></span><br><span class="line"><span class="hljs-comment">// 2. 翻转left ~ right的数据</span></span><br><span class="line"><span class="hljs-comment">// 3. 重新构造链表</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseBetween</span><span class="hljs-params">(head *ListNode, left <span class="hljs-keyword">int</span>, right <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">ListNode</span></span> &#123;</span><br><span class="line">array := convertListToArray(head)</span><br><span class="line">reverseArrayPart(array, left<span class="hljs-number">-1</span>, right<span class="hljs-number">-1</span>)</span><br><span class="line"><span class="hljs-keyword">return</span> buildLinkList(array)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 翻转数组指定区间</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseArrayPart</span><span class="hljs-params">(array []<span class="hljs-keyword">int</span>, left, right <span class="hljs-keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">for</span> left &lt; right &#123;</span><br><span class="line">array[left], array[right] = array[right], array[left]</span><br><span class="line">left++</span><br><span class="line">right--</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 链表构造为数组</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">convertListToArray</span><span class="hljs-params">(head *ListNode)</span> []<span class="hljs-title">int</span></span> &#123;</span><br><span class="line">array := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>)</span><br><span class="line"><span class="hljs-keyword">for</span> head != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">array = <span class="hljs-built_in">append</span>(array, head.Val)</span><br><span class="line">head = head.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> array</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表操作"><a href="#链表操作" class="headerlink" title="链表操作"></a>链表操作</h3><blockquote><p>链表相关的操作主要是要掌握定位任意节点的指针。</p></blockquote><ol><li>定位以下节点<ol><li>leftPrev: 翻转区间开始节点的上一个节点，最终要连接翻转后的头节点，所以需要保留</li><li>rightNext: 翻转区间结束节点的后一个节点，最终要连接到最终链表，所以需要保留</li><li>left和right节点，翻转开始和翻转结束节点</li></ol></li><li>定义子函数翻转left和right，返回right，翻转思路如下<ol><li>定义prev和curr指针，prev初始指向null，curr指向head</li><li>开始迭代，迭代结束条件curr不等于rightNode<ol><li>保存curr的下一个节点<code>next:=curr.Next</code></li><li>此时我们有3个节点的指针，prev,curr,next</li><li>当前节点指向上一个,<code>curr.Next=prev</code></li><li>prev上一个节点指针后移,<code>prev=curr</code></li><li>curr后移,<code>curr=next</code></li></ol></li><li>迭代结束后将<code>curr</code>指向上一个节点<code>curr.Next=prev</code></li></ol></li><li>按以下顺序连接所有节点：leftPrev -&gt; right -&gt; left -&gt; rightNext，边界情况如下：<ol><li>left是头结点，此时leftPrevNode是空，最终结果链表right节点成为新头结点</li><li>right是尾节点，此时rightNextNode是空，无需特殊处理</li><li>left == right，无需翻转</li></ol></li></ol><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseBetween</span><span class="hljs-params">(head *ListNode, left <span class="hljs-keyword">int</span>, right <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">ListNode</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> left == right &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> head</span><br><span class="line">&#125;</span><br><span class="line">leftPrevNode, leftNode, rightNode, rightNextNode := locateNodes(head, left<span class="hljs-number">-1</span>, right<span class="hljs-number">-1</span>)</span><br><span class="line">rightNode = reverse(leftNode, rightNode)</span><br><span class="line"><span class="hljs-comment">// left是头节点，链表连接顺序，right,left,rightNext</span></span><br><span class="line"><span class="hljs-keyword">if</span> leftPrevNode == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">leftNode.Next = rightNextNode</span><br><span class="line"><span class="hljs-keyword">return</span> rightNode</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 正常连接，连接顺序 leftPrevNode-&gt;right-&gt;left-&gt;rightNextNode</span></span><br><span class="line">leftPrevNode.Next = rightNode</span><br><span class="line">leftNode.Next = rightNextNode</span><br><span class="line"><span class="hljs-keyword">return</span> head</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 翻转left ~ right之间的节点</span></span><br><span class="line"><span class="hljs-comment">// 迭代翻转即可</span></span><br><span class="line"><span class="hljs-comment">// p 指向当前节点</span></span><br><span class="line"><span class="hljs-comment">// prev 指向上一个节点</span></span><br><span class="line"><span class="hljs-comment">// next指向p的next节点</span></span><br><span class="line"><span class="hljs-comment">// 如果p == rightNode则结束翻转并返回right</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverse</span><span class="hljs-params">(leftNode *ListNode, rightNode *ListNode)</span> *<span class="hljs-title">ListNode</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">var</span> (</span><br><span class="line">prev *ListNode</span><br><span class="line">p    = leftNode</span><br><span class="line">)</span><br><span class="line"><span class="hljs-keyword">for</span> p != rightNode &#123;</span><br><span class="line">next := p.Next</span><br><span class="line">p.Next = prev <span class="hljs-comment">// p 指向 上一个节点</span></span><br><span class="line">prev = p      <span class="hljs-comment">// 上一个节点后移</span></span><br><span class="line">p = next      <span class="hljs-comment">// p后移</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// p 此时向rightNode，需要连接p和上一个节点</span></span><br><span class="line">p.Next = prev</span><br><span class="line"><span class="hljs-keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 定位</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">locateNodes</span><span class="hljs-params">(head *ListNode, left, right <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(*ListNode, *ListNode, *ListNode, *ListNode)</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">var</span> (</span><br><span class="line">index         = <span class="hljs-number">0</span></span><br><span class="line">prevNode      *ListNode</span><br><span class="line">leftPrevNode  *ListNode</span><br><span class="line">leftNode      *ListNode</span><br><span class="line">rightNode     *ListNode</span><br><span class="line">rightNextNode *ListNode</span><br><span class="line">)</span><br><span class="line"><span class="hljs-keyword">for</span> head != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-comment">// 找到左节点</span></span><br><span class="line"><span class="hljs-keyword">if</span> index == left &#123;</span><br><span class="line">leftPrevNode = prevNode</span><br><span class="line">leftNode = head</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 找到右节点</span></span><br><span class="line"><span class="hljs-keyword">if</span> index == right &#123;</span><br><span class="line">rightNode = head</span><br><span class="line">rightNextNode = head.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 指针移动</span></span><br><span class="line">index++</span><br><span class="line">prevNode = head</span><br><span class="line">head = head.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> leftPrevNode, leftNode, rightNode, rightNextNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &amp;lt;= right 。请你反转从位置 left 到
      
    
    </summary>
    
      <category term="algorithm" scheme="https//www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="linklist" scheme="https//www.ddhigh.com/tags/linklist/"/>
    
  </entry>
  
  <entry>
    <title>算法篇——二分查找</title>
    <link href="https//www.ddhigh.com/2021/12/29/algo-binarysearch.html"/>
    <id>https//www.ddhigh.com/2021/12/29/algo-binarysearch.html</id>
    <published>2021-12-29T10:32:50.000Z</published>
    <updated>2022-02-06T11:56:58.658Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章将学习/复习常用算法和数据结构。希望能够深入浅出的将复杂的知识讲清楚、说明白。</p><p>本文介绍第一个基础算法：二分查找。二分查找算法可以在<code>有序</code>的数组中快速查询指定值。</p><ul><li>要求：有序数组</li><li>时间复杂度：O(logN)</li><li>空间复杂度：O(1)</li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>大家应该玩过数字猜大小的游戏，接下来看看实际过程。</p><p>主持人从1~10选择1个数字，参与者每次猜1个数字，主持人给出提示正确/大了/小了。次数最少的获胜。</p><h3 id="线性查找"><a href="#线性查找" class="headerlink" title="线性查找"></a>线性查找</h3><blockquote><ul><li>主持人选定数字5。</li><li>参与者：10</li><li>主持人：大了</li><li>参与者：9</li><li>主持人：大了</li><li>参与者：8</li><li>主持人：大了</li><li>…</li><li>参与者：5</li><li>主持人：正确</li></ul></blockquote><p>参与者采用线性报数方式，从最大的数字开始报，每次减1直到猜中。上面的例子主持人选的数字是5，参与者猜了6次（10,9,8,7,6,5)。效率是O(N)。</p><p>主持人的<code>大了/小了</code>提示没有利用上，这肯定不是效率最高的方法。</p><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><blockquote><ul><li>主持人选定数字8。</li><li>参与者：5</li><li>主持人：小了</li><li>参与者：7</li><li>主持人：小了</li><li>参与者：8</li><li>主持人：正确</li></ul></blockquote><p>参与者根据主持人的<code>大了/小了</code>提示每次调整猜测范围直到猜中。上面的例子中主持人选的数字是8，参与者猜了3次：</p><ol><li>(0+10)/2 =&gt; 5，小了，所以下一次应该猜 比5大的数字，从 5 ~ 10继续猜</li><li>(5+10)/2 =&gt; 7(8也可以)，小了，所以下一次继续猜比7大的数字，从7~10继续猜</li><li>(7+10)/2 =&gt; 8(9也可以)，正确</li></ol><p>可以看到二分查找法每次都能过滤掉1半的数据，达到了O(logN)的时间复杂度</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>给定一个有序数组，返回指定值的索引，如果有序数组不存在该值，返回-1。</p><p>思路：</p><ol><li>找中间值，(0 + 数组最后一位的所以)/2得到中间值的位置，然后对比中间值和目标值大小</li><li>如果目标值比中间值小，那么目标值在数组前半部分，应该继续查找 0 ~ 数组中间索引-1的这部分</li><li>如果目标值比中间值大，那么目标值在数组后半部分，应该继续查找 数组中间索引+1 ~ 数组结尾的这部分</li></ol><blockquote><p>为什么继续查找时中间索引要+1或者-1移动？</p><p>因为中间值已经比对过了，不满足条件，所以可以直接跳过中间值往前面后者后面一个位置继续查找</p></blockquote><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">fmt.Println(search([]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;, <span class="hljs-number">5</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">search</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>, target <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;</span><br><span class="line">begin := <span class="hljs-number">0</span></span><br><span class="line">end := <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-keyword">for</span> begin &lt;= end &#123; <span class="hljs-comment">// 开始位置不能超过结束位置，超过证明所以数据都查过了</span></span><br><span class="line">midIndex := (begin + end) / <span class="hljs-number">2</span> <span class="hljs-comment">// 中间索引</span></span><br><span class="line">midValue := nums[midIndex]    <span class="hljs-comment">// 中间值</span></span><br><span class="line">fmt.Printf(<span class="hljs-string">"check pos(%v) value(%v)\n"</span>, midIndex, midValue)</span><br><span class="line"><span class="hljs-keyword">if</span> target &lt; midValue &#123; <span class="hljs-comment">// 目标值比中间值小，所以在左边，将end移动到中间索引-1</span></span><br><span class="line">end = midIndex - <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> target &gt; midValue &#123; <span class="hljs-comment">// 右半边，begin移动到中间索引+1</span></span><br><span class="line">begin = midIndex + <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 相等</span></span><br><span class="line"><span class="hljs-keyword">return</span> midIndex</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下</p><figure class="highlight smali hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">check pos(3) value(4)</span><br><span class="line">check pos(5) value(6)</span><br><span class="line">check pos(4) value(5)</span><br><span class="line">4</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本系列文章将学习/复习常用算法和数据结构。希望能够深入浅出的将复杂的知识讲清楚、说明白。&lt;/p&gt;
&lt;p&gt;本文介绍第一个基础算法：二分查找。二分查找算法可以在&lt;code&gt;有序&lt;/code&gt;的数组中快速查询指定值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;要求：有序数组&lt;/li&gt;
&lt;li&gt;时
      
    
    </summary>
    
      <category term="algorithm" scheme="https//www.ddhigh.com/categories/algorithm/"/>
    
    
      <category term="binarysearch" scheme="https//www.ddhigh.com/tags/binarysearch/"/>
    
  </entry>
  
  <entry>
    <title>gomonkey私有方法打桩</title>
    <link href="https//www.ddhigh.com/2021/09/18/gomonkey-private-method-stub.html"/>
    <id>https//www.ddhigh.com/2021/09/18/gomonkey-private-method-stub.html</id>
    <published>2021-09-18T07:38:23.000Z</published>
    <updated>2022-02-06T11:56:58.658Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ApplyMethod基于反射实现，无法对私有方法打桩，本文将解决这一问题。</p></blockquote><h2 id="被测代码"><a href="#被测代码" class="headerlink" title="被测代码"></a>被测代码</h2><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">type</span> Dao <span class="hljs-keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 私有方法</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *Dao)</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;</span><br><span class="line">   <span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">"failed"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Method 公有方法</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *Dao)</span> <span class="hljs-title">Method</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;</span><br><span class="line">   <span class="hljs-keyword">return</span> d.method1()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>method1</code>是私有方法，使用<code>ApplyMethod</code>无法打桩</li></ul><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDao_Method</span><span class="hljs-params">(t *testing.T)</span></span> &#123;</span><br><span class="line">   <span class="hljs-comment">// 基于ApplyFunc可以读取到私有方法的地址并进行替换</span></span><br><span class="line">   g := gomonkey.ApplyFunc((*Dao).method1, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(_ *Dao)</span> <span class="hljs-title">error</span></span> &#123;</span><br><span class="line">      <span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">"打桩返回的错误"</span>)</span><br><span class="line">   &#125;)</span><br><span class="line">   <span class="hljs-keyword">defer</span> g.Reset()</span><br><span class="line"></span><br><span class="line">   d := Dao&#123;&#125;</span><br><span class="line">   fmt.Println(d.Method())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h2><p>执行时需要添加<code>-gcflags=-l</code>禁止内联(内联后函数地址发生变化，某些函数会直接转化为语句调用)</p><figure class="highlight asciidoc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-section">=== RUN   TestDao_Method</span></span><br><span class="line">打桩返回的错误</span><br><span class="line"><span class="hljs-bullet">--- </span>PASS: TestDao<span class="hljs-emphasis">_Method (0.00s)</span></span><br><span class="line"><span class="hljs-emphasis">PASS</span></span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>执行测试命令时添加<code>-gcflags=-l</code></li><li><code></code>gomonkey.ApplyFunc<code>需要传递</code>(*Dao).method1`(结构体指针对应的函数)</li><li>被测方法的接收器必须是<code>结构体指针</code>(因为第2步是传递指针)<figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *Dao)</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;</span><br><span class="line">   <span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">"failed"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;ApplyMethod基于反射实现，无法对私有方法打桩，本文将解决这一问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;被测代码&quot;&gt;&lt;a href=&quot;#被测代码&quot; class=&quot;headerlink&quot; title=&quot;被测代码&quot;&gt;&lt;/a&gt;被
      
    
    </summary>
    
      <category term="backend" scheme="https//www.ddhigh.com/categories/backend/"/>
    
      <category term="go" scheme="https//www.ddhigh.com/categories/backend/go/"/>
    
    
      <category term="testing" scheme="https//www.ddhigh.com/tags/testing/"/>
    
  </entry>
  
  <entry>
    <title>PlanUML指南</title>
    <link href="https//www.ddhigh.com/2021/06/04/plantuml-tutorial.html"/>
    <id>https//www.ddhigh.com/2021/06/04/plantuml-tutorial.html</id>
    <published>2021-06-04T07:17:06.000Z</published>
    <updated>2022-02-06T11:56:58.658Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p><strong>统一建模语言</strong>（英语：Unified Modeling Language，缩写 UML）是非专利的第三代<a href="https://zh.wikipedia.org/w/index.php?title=对象建模语言&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">建模</a>和<a href="https://zh.wikipedia.org/wiki/规约语言" target="_blank" rel="noopener">规约语言</a>。UML是一种开放的方法，用于说明、可视化、构建和编写一个正在开发的、面向对象的、软件密集系统的制品的开放方法</p></blockquote><p>编写UML的软件很多，但是基本是可视化的，需要手动编写，本文主要介绍基于文本的UML编写工具——PlantUML。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>PlantUML有以下依赖：</p><ol><li>graphviz</li><li>jdk</li><li>Jetbrains IDE插件(可选，本文推荐)</li></ol><h3 id="安装graphviz"><a href="#安装graphviz" class="headerlink" title="安装graphviz"></a>安装graphviz</h3><p>本文使用<code>Homebrew</code>安装<code>graphviz</code>，终端执行以下命令安装<code>graphviz</code>。</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install graphviz</span><br></pre></td></tr></table></figure><p>安装完毕后查看版本信息。</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dot -v</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight vim hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dot - graphviz <span class="hljs-keyword">version</span> <span class="hljs-number">2.47</span>.<span class="hljs-number">0</span> (<span class="hljs-number">20210316.0004</span>)</span><br><span class="line">libdir = <span class="hljs-string">"/usr/local/Cellar/graphviz/2.47.0/lib/graphviz"</span></span><br><span class="line">Activated plugin library: libgvplugin_dot_layout.<span class="hljs-number">6</span>.dylib</span><br><span class="line">Using layou<span class="hljs-variable">t:</span> <span class="hljs-keyword">do</span><span class="hljs-variable">t:dot_layout</span></span><br><span class="line">Activated plugin library: libgvplugin_core.<span class="hljs-number">6</span>.dylib</span><br><span class="line">Using render: <span class="hljs-keyword">do</span><span class="hljs-variable">t:core</span></span><br><span class="line">Using device: <span class="hljs-keyword">do</span><span class="hljs-variable">t:dot</span>:core</span><br><span class="line">The plugin configuration <span class="hljs-keyword">file</span>:</span><br><span class="line">/usr/local/Cellar/graphviz/<span class="hljs-number">2.47</span>.<span class="hljs-number">0</span>/lib/graphviz/config6</span><br><span class="line">was successfully loaded.</span><br><span class="line"> render:  cairo dot dot_json fig gd json json0 <span class="hljs-keyword">map</span> mp pic pov <span class="hljs-keyword">ps</span> quartz svg tk visio vml vrml xdot xdot_json</span><br><span class="line"> layout:  circo dot fdp neato nop nop1 nop2 osage patchwork sfdp twopi</span><br><span class="line"> textlayout:  textlayout</span><br><span class="line"> device:  bmp canon cgimage <span class="hljs-keyword">cmap</span> cmapx cmapx_np dot dot_json eps exr fig gd gd2 gif <span class="hljs-keyword">gv</span> icns ico <span class="hljs-keyword">imap</span> imap_np ismap jp2 jpe jpeg jpg json json0 mp pct pdf pic pict plain plain-ext png pov <span class="hljs-keyword">ps</span> ps2 psd sgi svg svgz tga tif tiff tk vdx vml vmlz vrml wbmp webp xdot xdot1.<span class="hljs-number">2</span> xdot1.<span class="hljs-number">4</span> xdot_json</span><br><span class="line"> loadimage:  (lib) bmp eps gd gd2 gif jpe jpeg jpg pdf png <span class="hljs-keyword">ps</span> svg webp xbm</span><br></pre></td></tr></table></figure><h3 id="jdk"><a href="#jdk" class="headerlink" title="jdk"></a>jdk</h3><p>本文使用<code>Homebrew</code>安装<code>openjdk</code>即可，终端执行以下命令安装<code>openjdk</code>。</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install openjdk</span><br></pre></td></tr></table></figure><p>安装完毕后查看版本信息。</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openjdk version <span class="hljs-string">"11.0.10"</span> <span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-19</span></span><br><span class="line">OpenJDK Runtime Environment (build <span class="hljs-number">11.0</span><span class="hljs-number">.10</span>+<span class="hljs-number">9</span>)</span><br><span class="line">OpenJDK <span class="hljs-number">64</span>-Bit Server VM (build <span class="hljs-number">11.0</span><span class="hljs-number">.10</span>+<span class="hljs-number">9</span>, mixed mode)</span><br></pre></td></tr></table></figure><h3 id="Jetbrains-IDE插件安装"><a href="#Jetbrains-IDE插件安装" class="headerlink" title="Jetbrains IDE插件安装"></a>Jetbrains IDE插件安装</h3><p>本文以<code>Goland</code>为例。</p><ol><li><p>打开IDE设置，打开<code>Plugins</code>窗口，搜索<code>PlantUML integration</code></p></li><li><p>安装完毕后重启IDE</p></li><li><p>打开IDE设置，搜索<code>plantuml</code>，确保<code>Remote rendering</code>已关闭</p></li></ol><p><img src="https://static.ddhigh.com/blog//2021/06/04/1622792407142095000.png" alt="image-20210604154007098"></p><h2 id="PlantUML语法"><a href="#PlantUML语法" class="headerlink" title="PlantUML语法"></a>PlantUML语法</h2><p>以最常用的时序图、类图、流程图、组件图举例。</p><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><h4 id="Get-Started"><a href="#Get-Started" class="headerlink" title="Get Started"></a>Get Started</h4><ol><li>IDE新建一个空项目，打开项目之后，右键新建文件</li></ol><p><img src="https://static.ddhigh.com/blog//2021/06/04/1622791752260150000.png" alt="image-20210604152912197"></p><ol start="2"><li>选择<code>Sequence</code></li></ol><p><img src="https://static.ddhigh.com/blog//2021/06/04/1622791775795758000.png" alt="image-20210604152935751"></p><ol start="3"><li>PlantUML菜单项说明</li></ol><p><img src="https://static.ddhigh.com/blog//2021/06/04/1622793009802684000.png" alt="image-20210604155009752"></p><ol start="4"><li>以微信网页授权为例编写时序图。</li></ol><figure class="highlight less hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-variable">@startuml</span></span><br><span class="line">'<span class="hljs-attribute">https</span>:<span class="hljs-comment">//plantuml.com/sequence-diagram</span></span><br><span class="line"></span><br><span class="line">'启用自动编号</span><br><span class="line">autonumber</span><br><span class="line">'生命线自动激活</span><br><span class="line">autoactivate on</span><br><span class="line"></span><br><span class="line">actor 用户</span><br><span class="line"></span><br><span class="line">用户 -&gt; 应用服务器: 获取用户信息</span><br><span class="line">应用服务器 -&gt; 微信服务器: 跳转授权链接:(appid,scope,callback)</span><br><span class="line">微信服务器 -&gt; 用户: 请求用户授权</span><br><span class="line">return 允许授权</span><br><span class="line">return 返回授权code</span><br><span class="line">应用服务器 -&gt; 微信服务器: 获取用户access_token(appid,secret,code)</span><br><span class="line">return 返回access_token+openid</span><br><span class="line">应用服务器 -&gt; 微信服务器: 获取用户信息(openid,access_token)</span><br><span class="line">return 用户信息</span><br><span class="line">return 用户信息</span><br><span class="line"></span><br><span class="line"><span class="hljs-variable">@enduml</span></span><br></pre></td></tr></table></figure><ol start="5"><li>渲染效果</li></ol><p><img src="https://static.ddhigh.com/blog//2021/06/04/1622792350734661000.png" alt="image-20210604153910674"></p><h4 id="语法说明"><a href="#语法说明" class="headerlink" title="语法说明"></a>语法说明</h4><h5 id="标记声明"><a href="#标记声明" class="headerlink" title="标记声明"></a>标记声明</h5><figure class="highlight less hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-variable">@startuml</span>和<span class="hljs-variable">@enduml</span>是PlantUML的开始结束标记，无需更改。</span><br><span class="line">autonumber 打开启动编号，也就是每个步骤之前都有数字编号，打开之后整个流程更加清晰</span><br><span class="line">autoactivate on 打开生命线自动激活，需要配合<span class="hljs-built_in">`return`</span>使用</span><br><span class="line">actor 用户 声明<span class="hljs-built_in">`用户`</span>的类型是actor(行为人)</span><br></pre></td></tr></table></figure><h5 id="时序声明"><a href="#时序声明" class="headerlink" title="时序声明"></a>时序声明</h5><ul><li>使用<code>-&gt;</code>来声明一个时序操作，<code>:</code>后面可以附加消息</li><li>使用<code>return</code>来返回消息给调用者</li></ul><h5 id="声明参与者"><a href="#声明参与者" class="headerlink" title="声明参与者"></a>声明参与者</h5><p>默认情况下参与者为矩形，无法看出实际类型。实际应用中，会有数据库、消息队列等等参与者，使用以下关键字来改变参与者的图例。</p><figure class="highlight routeros hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">actor 用户</span><br><span class="line">database 数据库</span><br><span class="line">queue 消息队列</span><br></pre></td></tr></table></figure><p><img src="https://static.ddhigh.com/blog//2021/06/04/1622792920216896000.png" alt="image-20210604154840162"></p><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p>类图是UML中非常重要的一种类型，能够在实际编码之前为我们提供OOP的详细设计。</p><h4 id="Get-Started-1"><a href="#Get-Started-1" class="headerlink" title="Get Started"></a>Get Started</h4><ol><li>IDE新建一个空项目，打开项目之后，右键新建文件</li></ol><p><img src="https://static.ddhigh.com/blog//2021/06/04/1622791752260150000.png" alt="image-20210604152912197"></p><ol start="2"><li>选择<code>Class</code></li></ol><p><img src="https://static.ddhigh.com/blog/2021/06/04/1622793181374871000.png" alt="image-20210604155301322"></p><ol start="3"><li>以一个上传类为例编写类图</li></ol><figure class="highlight asciidoc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line"><span class="hljs-emphasis">'https://plantuml.com/class-diagram</span></span><br><span class="line"><span class="hljs-emphasis"></span></span><br><span class="line"><span class="hljs-emphasis">namespace com.ddhigh.uploader &#123;</span></span><br><span class="line"><span class="hljs-emphasis"> interface Uploader &#123;</span></span><br><span class="line"><span class="hljs-emphasis">  + String Upload(String filename) Throws IOException</span></span><br><span class="line"><span class="hljs-emphasis"> &#125;</span></span><br><span class="line"><span class="hljs-emphasis"></span></span><br><span class="line"><span class="hljs-emphasis"> namespace qiniu &#123;</span></span><br><span class="line"><span class="hljs-emphasis">  class QiniuUploader implements Uploader &#123;</span></span><br><span class="line"><span class="hljs-emphasis">- client: qiniu.Client</span></span><br><span class="line"><span class="hljs-emphasis">--</span></span><br><span class="line"><span class="hljs-emphasis">+ String Upload(String filename) Throws IOException</span></span><br><span class="line"><span class="hljs-emphasis">  &#125;</span></span><br><span class="line"><span class="hljs-emphasis">  QiniuUploader *-- qiniu.Client</span></span><br><span class="line"><span class="hljs-emphasis"> &#125;</span></span><br><span class="line"><span class="hljs-emphasis"></span></span><br><span class="line"><span class="hljs-emphasis"> package aliyun &#123;</span></span><br><span class="line"><span class="hljs-emphasis">  class AliyunUploader implements Uploader &#123;</span></span><br><span class="line"><span class="hljs-emphasis">- client: aliyun.Client</span></span><br><span class="line"><span class="hljs-emphasis">--</span></span><br><span class="line"><span class="hljs-emphasis">+ String Upload(String filename) Throws IOException</span></span><br><span class="line"><span class="hljs-emphasis">  &#125;</span></span><br><span class="line"><span class="hljs-emphasis">  AliyunUploader *-- aliyun.Client</span></span><br><span class="line"><span class="hljs-emphasis"> &#125;</span></span><br><span class="line"><span class="hljs-emphasis"></span></span><br><span class="line"><span class="hljs-emphasis"> class UploaderFacade &#123;</span></span><br><span class="line"><span class="hljs-emphasis">  - uploaders: List&lt;Uploader&gt;</span></span><br><span class="line"><span class="hljs-emphasis">  --</span></span><br><span class="line"><span class="hljs-emphasis">  + List&lt;String&gt; Upload(String filename) Throws IOException</span></span><br><span class="line"><span class="hljs-emphasis"> &#125;</span></span><br><span class="line"><span class="hljs-emphasis"> UploaderFacade o-- Uploader</span></span><br><span class="line"><span class="hljs-emphasis">&#125;</span></span><br><span class="line"><span class="hljs-emphasis"></span></span><br><span class="line"><span class="hljs-emphasis">@enduml</span></span><br></pre></td></tr></table></figure><ol start="4"><li>渲染效果</li></ol><p><img src="https://static.ddhigh.com/blog/2021/06/04/1622793501066543000.png" alt="image-20210604155821009"></p><h5 id="语法说明-1"><a href="#语法说明-1" class="headerlink" title="语法说明"></a>语法说明</h5><h5 id="包"><a href="#包" class="headerlink" title="包"></a>包</h5><p>建议使用<code>namespace</code>关键字声明包，<code>package</code>声明的包内的类名必须全局唯一(无视package)，而<code>namespace</code>只要求该<code>namespace</code>内唯一即可。</p><h5 id="class-interface"><a href="#class-interface" class="headerlink" title="class/interface"></a>class/interface</h5><p>与实际编程语言几乎无差别，比如上面例子中采用的是java语法。</p><h5 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h5><p>PlantUML支持3种可见性：</p><ul><li><code>-</code> 私有级别 <code>private</code></li><li><code>#</code> 保护级别 <code>protected</code></li><li><code>+</code> 公有级别 <code>public</code></li></ul><h5 id="元素关系"><a href="#元素关系" class="headerlink" title="元素关系"></a>元素关系</h5><p>PlantUML主要有以下3种关系：</p><ol><li>扩展: 包含<code>implements</code>和<code>extends</code></li><li>聚合: 使用<code>o--</code>，<code>左边</code>的包含<code>右边</code>的</li><li>组合: 使用<code>*--</code>,<code>左边</code>的依赖<code>右边</code>的</li></ol><blockquote><p>组合和聚合的区别：(以上面的图为例)</p><ol><li>组合：QiniuUploader必须依赖Client才能提供上传功能，组合一般是1对1的。</li><li>聚合：UploadFacade可以依赖多个Uploader实例，也可以依赖0个实例(只是这时候不会有文件上传了)，聚合一般是1对多的。</li></ol></blockquote><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p>在梳理复杂业务逻辑时，善用流程图能帮我们更加清晰地梳理清楚，也方便我们和其他人员进行沟通（非开发人员基本看不懂代码）。</p><h4 id="Get-Started-2"><a href="#Get-Started-2" class="headerlink" title="Get Started"></a>Get Started</h4><ol><li>IDE新建一个空项目，打开项目之后，右键新建文件</li></ol><p><img src="https://static.ddhigh.com/blog//2021/06/04/1622791752260150000.png" alt="image-20210604152912197"></p><ol start="2"><li>新建<code>Activity</code>类型文件</li></ol><p><img src="https://static.ddhigh.com/blog/2021/06/04/1622794169645334000.png" alt="image-20210604160929588"></p><ol start="3"><li>下面以一个<code>授权获取用户openid并插入数据库，然后查询用户好友进行消息推送</code>的场景编写流程图</li></ol><figure class="highlight less hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-variable">@startuml</span></span><br><span class="line">'<span class="hljs-attribute">https</span>:<span class="hljs-comment">//plantuml.com/activity-diagram-beta</span></span><br><span class="line"></span><br><span class="line">start</span><br><span class="line">:使用code,appid,secret请求微信服务器获取access_token和openid;</span><br><span class="line">:使用<span class="hljs-selector-tag">access_token</span>和<span class="hljs-selector-tag">openid</span>请求微信服务器获取用户信息;</span><br><span class="line">:查询数据库<span class="hljs-selector-tag">openid</span>是否存在;</span><br><span class="line"><span class="hljs-selector-tag">if</span> (数据库查询失败?) <span class="hljs-selector-tag">then</span> (是)</span><br><span class="line"><span class="hljs-selector-tag">stop</span></span><br><span class="line"><span class="hljs-selector-tag">elseif</span> (用户已存在?) <span class="hljs-selector-tag">then</span> (是)</span><br><span class="line">:更新用户信息;</span><br><span class="line"><span class="hljs-selector-tag">else</span> (否)</span><br><span class="line">:新建用户并绑定<span class="hljs-selector-tag">openid</span>;</span><br><span class="line"><span class="hljs-selector-tag">endif</span></span><br><span class="line"></span><br><span class="line">:获取用户好友列表;</span><br><span class="line"><span class="hljs-selector-tag">while</span>(好友列表遍历完成?) <span class="hljs-selector-tag">is</span> (否)</span><br><span class="line">:推送消息给好友;</span><br><span class="line"><span class="hljs-selector-tag">endwhile</span>(是)</span><br><span class="line"><span class="hljs-selector-tag">stop</span></span><br><span class="line"></span><br><span class="line">@<span class="hljs-selector-tag">enduml</span></span><br></pre></td></tr></table></figure><ol start="4"><li>渲染效果</li></ol><p><img src="https://static.ddhigh.com/blog/2021/06/04/1622794522917043000.png" alt="image-20210604161522881"></p><h4 id="语法说明-2"><a href="#语法说明-2" class="headerlink" title="语法说明"></a>语法说明</h4><ul><li><p>开始和结束: 使用<code>start</code>和<code>stop</code></p></li><li><p>处理语句: 使用<code>:</code>和<code>;</code>包裹该流程</p></li><li>条件判断: 使用<code>if</code>,<code>elseif</code>,<code>else</code>,<code>endif</code>,<code>then</code></li><li>循环语句: 使用<code>while</code>,<code>is</code>,<code>endwhile</code>编写</li></ul><h3 id="组件图"><a href="#组件图" class="headerlink" title="组件图"></a>组件图</h3><p>现阶段组件化MVVM框架大行其道，具有代表性的有<code>Vue</code>,<code>React</code>和<code>Angular</code>。我们可以使用组件图来绘制组件关系，简单易懂。</p><h5 id="Get-Started-3"><a href="#Get-Started-3" class="headerlink" title="Get Started"></a>Get Started</h5><ol><li>IDE新建一个空项目，打开项目之后，右键新建文件</li></ol><p><img src="https://static.ddhigh.com/blog//2021/06/04/1622791752260150000.png" alt="image-20210604152912197"></p><ol start="2"><li>选择<code>Component</code></li></ol><p><img src="https://static.ddhigh.com/blog/2021/06/04/1622794820895677000.png" alt="image-20210604162020830"></p><ol start="3"><li>以微信首页聊天列表为例绘制组件关系图</li></ol><figure class="highlight less hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-variable">@startuml</span></span><br><span class="line">'<span class="hljs-attribute">https</span>:<span class="hljs-comment">//plantuml.com/component-diagram</span></span><br><span class="line"></span><br><span class="line">package widgets &#123;</span><br><span class="line"> <span class="hljs-selector-attr">[SearchBar]</span> <span class="hljs-selector-tag">--</span>&gt; <span class="hljs-selector-attr">[Text]</span></span><br><span class="line"> <span class="hljs-selector-attr">[SearchBar]</span> <span class="hljs-selector-tag">--</span>&gt; <span class="hljs-selector-attr">[Icon]</span></span><br><span class="line"> <span class="hljs-selector-attr">[NavigationBar]</span> <span class="hljs-selector-tag">--</span>&gt; <span class="hljs-selector-attr">[Text]</span></span><br><span class="line"> <span class="hljs-selector-attr">[NavigationBar]</span> <span class="hljs-selector-tag">--</span>&gt; <span class="hljs-selector-attr">[Icon]</span></span><br><span class="line"> </span><br><span class="line"> <span class="hljs-selector-attr">[ListView]</span> <span class="hljs-selector-tag">--</span>&gt; <span class="hljs-selector-attr">[ListItem]</span></span><br><span class="line"> <span class="hljs-selector-attr">[ListItem]</span> <span class="hljs-selector-tag">--</span>&gt; <span class="hljs-selector-attr">[Image]</span></span><br><span class="line"> <span class="hljs-selector-attr">[ListItem]</span> <span class="hljs-selector-tag">--</span>&gt; <span class="hljs-selector-attr">[Text]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package routes &#123;</span><br><span class="line"> <span class="hljs-selector-attr">[Home]</span> <span class="hljs-selector-tag">--</span>&gt; <span class="hljs-selector-attr">[NavigationBar]</span></span><br><span class="line"> <span class="hljs-selector-attr">[Home]</span> <span class="hljs-selector-tag">--</span>&gt; <span class="hljs-selector-attr">[SearchBar]</span></span><br><span class="line"> <span class="hljs-selector-attr">[Home]</span> <span class="hljs-selector-tag">--</span>&gt; <span class="hljs-selector-attr">[ListView]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-variable">@enduml</span></span><br></pre></td></tr></table></figure><ol start="4"><li>渲染效果</li></ol><p><img src="https://static.ddhigh.com/blog/2021/06/04/1622795518286015000.png" alt="image-20210604162521451"></p><blockquote><p>依赖关系如下：</p><ul><li>首页: 导航栏, 搜索框，列表</li><li>导航栏: 文本，图标</li><li>搜索框: 文本，图标</li><li>列表: 列表项</li><li>列表项: 文本，图片</li></ul></blockquote><h5 id="语法说明-3"><a href="#语法说明-3" class="headerlink" title="语法说明"></a>语法说明</h5><ul><li>package 声明包，同一个包内的组件是类似地位</li><li><code>[组件名]</code>声明组件，<code>组件名</code>在单个文件内是唯一的</li><li><code>--&gt;</code> 声明依赖关系，<code>左边</code>依赖<code>右边</code></li></ul><p>(完)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;统一建模语言&lt;/strong&gt;（英语：Unified Modeling Language，缩写 U
      
    
    </summary>
    
      <category term="devtools" scheme="https//www.ddhigh.com/categories/devtools/"/>
    
    
  </entry>
  
  <entry>
    <title>Golang程序设计——函数</title>
    <link href="https//www.ddhigh.com/2021/03/17/golang-function.html"/>
    <id>https//www.ddhigh.com/2021/03/17/golang-function.html</id>
    <published>2021-03-17T02:22:36.000Z</published>
    <updated>2022-02-06T11:56:58.658Z</updated>
    
    <content type="html"><![CDATA[<p>本文学习Go语言函数知识。函数是基本的代码块，用于执行一个任务。在Go语言中，函数可以接收数量不固定的参数，也可以返回多个结果。</p><h2 id="函数结构"><a href="#函数结构" class="headerlink" title="函数结构"></a>函数结构</h2><p>在编程领域，函数向编译器和开发者提供了有关的信息，这些信息指明了函数该接收什么样的输入以及会产生什么样的输出。这些信息是通过函数第一行提供的，第一行称为函数签名。</p><p>Go语言声明函数语法如下：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> 函数名称<span class="hljs-params">(参数名 参数类型)</span> <span class="hljs-params">(返回值名称 返回值类型)</span></span> &#123;</span><br><span class="line">  <span class="hljs-comment">// 函数体</span></span><br><span class="line">  <span class="hljs-keyword">return</span>语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>参数名在参数类型前面，如<code>a int</code>，这一点和其他语言是不同的</li><li>函数参数数量可以不固定，但是只允许最后一个参数数量不固定，而且必须是同种类型</li><li>返回值名称不是必须的，但是参数名是必须写的</li><li>有返回值的函数，函数体内必须包含return语句</li></ol><p>示例：函数定义与调用</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum</span><span class="hljs-params">(a, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="hljs-string">"1+2=%d\n"</span>, sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Go语言中，如果多个参数或多个返回值类型相同，只需要在最后一个参数或返回值声明类型。</p><p>例如下面的函数签名在Go语言中是合法的。</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum2</span><span class="hljs-params">(a, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(c, d <span class="hljs-keyword">int</span>)</span></span></span><br></pre></td></tr></table></figure><h2 id="不定参数函数"><a href="#不定参数函数" class="headerlink" title="不定参数函数"></a>不定参数函数</h2><p>不定参数也就是数量不固定的参数。例如C语言中的printf函数就是一个典型的不定参数函数。Go语言支持不定参数函数，但是不定参数的类型必须相同。要声明不定参数，需要使用3个点(…)。</p><p>示例：不定参数的加法函数</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum</span><span class="hljs-params">(nums ...<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;</span><br><span class="line">total := <span class="hljs-number">0</span></span><br><span class="line"><span class="hljs-keyword">for</span> _, n := <span class="hljs-keyword">range</span> nums &#123;</span><br><span class="line">total += n</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> total</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="hljs-string">"1+2+3+4=%d\n"</span>, sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在sum函数中，nums是一个包含所有参数的切片。</p><h2 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h2><h3 id="多返回值"><a href="#多返回值" class="headerlink" title="多返回值"></a>多返回值</h3><p>在Go语言中，函数能声明多个返回值，在这种情况下，return可以返回多个结果。函数调用者可通过多变量声明接收多个返回值。</p><p>示例：多返回值函数</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> (</span><br><span class="line"><span class="hljs-string">"errors"</span></span><br><span class="line"><span class="hljs-string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">div</span><span class="hljs-params">(a, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, error)</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> b == <span class="hljs-number">0</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, errors.New(<span class="hljs-string">"b is zero"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> a / b, <span class="hljs-literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">ret, err := div(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>)</span><br><span class="line"><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="hljs-keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="hljs-string">"2/1=%d\n"</span>, ret)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="命名返回值"><a href="#命名返回值" class="headerlink" title="命名返回值"></a>命名返回值</h3><p>命名返回值让函数能够在返回前将返回值赋给命名变量，这种设计有利于提高程序可读性。要指定命名返回值，可在函数签名的返回值类型前面添加变量名。</p><p>示例：命名返回值函数</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> (</span><br><span class="line"><span class="hljs-string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum</span><span class="hljs-params">(a, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(total <span class="hljs-keyword">int</span>)</span></span> &#123;</span><br><span class="line">total = a + b</span><br><span class="line"><span class="hljs-keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="hljs-string">"1+2=%d\n"</span>, sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用命名返回值后，return关键字可以单独出现，当然，return关键字继续返回结果值也是合法的。</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum</span><span class="hljs-params">(a, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(total <span class="hljs-keyword">int</span>)</span></span> &#123;</span><br><span class="line">total = a + b</span><br><span class="line"><span class="hljs-keyword">return</span> total</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><p>在Go语言中，函数是一种数据类型，可以将函数赋值给变量、或者作为参数传递，也可以作为返回值返回。</p><p>示例：将函数作为变量、参数、返回值。</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line"><span class="hljs-comment">// 函数作为变量</span></span><br><span class="line">sum := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(a, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="hljs-string">"1+1=%d\n"</span>, sum(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>))</span><br><span class="line"><span class="hljs-comment">// 函数作为参数</span></span><br><span class="line">sum2(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(total <span class="hljs-keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="hljs-string">"1+1=%d\n"</span>, total)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="hljs-comment">// 函数作为返回值</span></span><br><span class="line">totalFn := sum3(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)</span><br><span class="line">fmt.Printf(<span class="hljs-string">"1+1=%d\n"</span>, totalFn())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum2</span><span class="hljs-params">(a, b <span class="hljs-keyword">int</span>, callback <span class="hljs-keyword">func</span>(<span class="hljs-keyword">int</span>)</span>)</span> &#123;</span><br><span class="line">total := a + b</span><br><span class="line">callback(total)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum3</span><span class="hljs-params">(a, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匿名函数、闭包、延迟执行函数"><a href="#匿名函数、闭包、延迟执行函数" class="headerlink" title="匿名函数、闭包、延迟执行函数"></a>匿名函数、闭包、延迟执行函数</h2><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>匿名函数指没有名称的函数，只有函数签名（参数和返回值声明）和函数体，匿名函数经常用于回调、闭包、临时函数等。</p><p>示例：利用匿名函数实现事件总线。</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">emitter := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span>)</span></span><br><span class="line">addEventListener(emitter, <span class="hljs-string">"event1"</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="hljs-string">"event1 called"</span>)</span><br><span class="line">&#125;)</span><br><span class="line">emit(emitter, <span class="hljs-string">"event2"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 添加事件监听器</span></span><br><span class="line"><span class="hljs-comment">// emitter 事件总线</span></span><br><span class="line"><span class="hljs-comment">// event 事件名</span></span><br><span class="line"><span class="hljs-comment">// callback 回调函数</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addEventListener</span><span class="hljs-params">(emitter <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">func</span>()</span>, <span class="hljs-title">event</span> <span class="hljs-title">string</span>, <span class="hljs-title">callback</span> <span class="hljs-title">func</span><span class="hljs-params">()</span>)</span> &#123;</span><br><span class="line">emitter[event] = callback</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 触发事件</span></span><br><span class="line"><span class="hljs-comment">// emitter 事件总线</span></span><br><span class="line"><span class="hljs-comment">// event 事件名</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">emit</span><span class="hljs-params">(emitter <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">func</span>()</span>, <span class="hljs-title">event</span> <span class="hljs-title">string</span>)</span> &#123;</span><br><span class="line">callback, ok := emitter[event]</span><br><span class="line"><span class="hljs-keyword">if</span> ok &#123;</span><br><span class="line">callback()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main函数调用addEventListener时传入的第三个函数即为匿名函数。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包可以理解为定义在一个函数内部的函数。在本质上，闭包是函数和其引用环境的组合体。引用环境即使在外部函数执行结束也不会被回收，因此可以利用闭包保存保存执行环境。</p><p>示例：利用闭包提供唯一ID生成器。</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">s1 := sequenceId()</span><br><span class="line">s2 := sequenceId()</span><br><span class="line">fmt.Printf(<span class="hljs-string">"s1 -&gt; %v\n"</span>, s1())</span><br><span class="line">fmt.Printf(<span class="hljs-string">"s1 -&gt; %v\n"</span>, s1())</span><br><span class="line">fmt.Printf(<span class="hljs-string">"s2 -&gt; %v\n"</span>, s2())</span><br><span class="line">fmt.Printf(<span class="hljs-string">"s2 -&gt; %v\n"</span>, s2())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sequenceId</span><span class="hljs-params">()</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">var</span> id <span class="hljs-keyword">int</span></span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;</span><br><span class="line">id++</span><br><span class="line"><span class="hljs-keyword">return</span> id</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1 -&gt; <span class="hljs-number">1</span></span><br><span class="line">s1 -&gt; <span class="hljs-number">2</span></span><br><span class="line">s2 -&gt; <span class="hljs-number">1</span></span><br><span class="line">s2 -&gt; <span class="hljs-number">2</span></span><br></pre></td></tr></table></figure><p>函数sequenceId定义了一个局部变量id，并返回了一个子函数，子函数内部访问了外部的id，因此这构成一个典型的闭包。在前面的内容中我们学习过变量作用域，内部总是可以访问外部的变量或常量，而外部无法访问内部的变量或常量。此外，由于变量id被子函数使用，因此在sequenceId函数返回后，id也不会被销毁。</p><p>每调用一次sequenceId函数都会返回一个新的子函数以及对应的id，因此s1和s2之间的输出互不影响。</p><blockquote><p>注意：由于闭包会导致被引用的变量无法销毁，因此需要注意使用，避免产生内存泄漏。</p></blockquote><h3 id="延迟执行函数"><a href="#延迟执行函数" class="headerlink" title="延迟执行函数"></a>延迟执行函数</h3><p>在实际编程中往往会打开一些资源，例如文件、网络连接等等，这些资源在使用完毕时（无论是正常关闭或者函数异常）需要主动关闭，当函数的结束分支太多或者逻辑比较复杂时容易发生忘记关闭的情况导致资源泄漏。</p><p>Go语言提供了defer关键字用来延迟执行一个函数，一般使用该函数延迟关闭资源。多个defer语句会按照先进后出的方式执行，也就是最后声明的最先执行，典型的栈结构。</p><p>示例：defer执行顺序。</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">defer</span> f1()</span><br><span class="line"><span class="hljs-keyword">defer</span> f2()</span><br><span class="line">fmt.Println(<span class="hljs-string">"call main"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="hljs-string">"call f1"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">"defer call f2"</span>)</span><br><span class="line">fmt.Println(<span class="hljs-string">"call f2"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">call</span> <span class="hljs-keyword">main</span></span><br><span class="line"><span class="hljs-keyword">call</span> f2</span><br><span class="line">defer <span class="hljs-keyword">call</span> f2</span><br><span class="line"><span class="hljs-keyword">call</span> f1</span><br></pre></td></tr></table></figure><ol><li><p>第一行输出call main是因为main函数中只有一个非defer语句，因此call main最先执行</p></li><li><p>第二行输出call f2是因为f2函数内部有一个非defer语句</p></li><li><p>第三行输出defer call f2是因为f2函数的fmt.Println(“call f2”)执行完毕后才能执行defer</p></li><li><p>第四行输出call f1是因为defer f1()最先声明因此最后执行</p></li></ol><p>示例：基于defer和闭包构造一个函数执行耗时记录器。</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> (</span><br><span class="line"><span class="hljs-string">"fmt"</span></span><br><span class="line"><span class="hljs-string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;</span><br><span class="line">Name <span class="hljs-keyword">string</span></span><br><span class="line">Age  <span class="hljs-keyword">int</span></span><br><span class="line">Sex  <span class="hljs-keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">defer</span> spendTime()()</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">fmt.Println(<span class="hljs-string">"call main"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">spendTime</span><span class="hljs-params">()</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">startAt := time.Now()</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">fmt.Println(time.Since(startAt))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">call</span> <span class="hljs-keyword">main</span></span><br><span class="line"><span class="hljs-number">1.002345498</span>s</span><br></pre></td></tr></table></figure><p>spendTime()会返回一个闭包，因此定义defer时会初始化startAt为当前时间，defer执行时会执行闭包函数得到函数耗时。main函数为了测试方便休眠了一秒钟，因此可以看到输出是超过1秒的。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文介绍了如何在Go语言中使用函数。包括不定参数函数、多返回值和命名返回值函数以及将函数作为类型使用的方法，最后介绍了匿名函数、闭包和延迟执行函数。接下来的内容中将介绍Go语言中的结构体。</p><p><img src="https://static.ddhigh.com/blog/2021-03-09-162926-2.png" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文学习Go语言函数知识。函数是基本的代码块，用于执行一个任务。在Go语言中，函数可以接收数量不固定的参数，也可以返回多个结果。&lt;/p&gt;
&lt;h2 id=&quot;函数结构&quot;&gt;&lt;a href=&quot;#函数结构&quot; class=&quot;headerlink&quot; title=&quot;函数结构&quot;&gt;&lt;/a&gt;函数
      
    
    </summary>
    
      <category term="backend" scheme="https//www.ddhigh.com/categories/backend/"/>
    
      <category term="go" scheme="https//www.ddhigh.com/categories/backend/go/"/>
    
    
  </entry>
  
  <entry>
    <title>Golang程序设计——数据容器</title>
    <link href="https//www.ddhigh.com/2021/03/09/golang-data-container.html"/>
    <id>https//www.ddhigh.com/2021/03/09/golang-data-container.html</id>
    <published>2021-03-09T08:21:34.000Z</published>
    <updated>2022-02-06T11:56:58.658Z</updated>
    
    <content type="html"><![CDATA[<p>本文学习Go语言数据容器、包括数组、切片和映射。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是一个数据集合，常用于存储用数字索引的同类型数据。Go语言的数组调用函数时使用的是值传递，因此形参会拷贝一份实参的值。</p><p>在Go语言中，声明数组需要同时指定长度和数据类型，数组长度是其类型的一部分，因此<code>[5]int</code>和<code>[1]int</code>是两种类型。</p><p>Go语言可以对数组进行写入、读取、删除、遍历等操作。</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line"><span class="hljs-comment">// 声明数组并指明长度，不初始化，因此a的5个元素为int类型的零值（0）</span></span><br><span class="line"><span class="hljs-keyword">var</span> a [<span class="hljs-number">5</span>]<span class="hljs-keyword">int</span></span><br><span class="line"><span class="hljs-comment">// 声明数组并指明长度，并初始化4个元素，因此b的最后1个元素为int类型零值（0）</span></span><br><span class="line"><span class="hljs-keyword">var</span> b = [<span class="hljs-number">5</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;</span><br><span class="line"><span class="hljs-comment">// 声明数组，不指明长度，编译器会根据值数量推导长度为4</span></span><br><span class="line"><span class="hljs-keyword">var</span> c = [...]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;</span><br><span class="line"><span class="hljs-comment">// 数组写入</span></span><br><span class="line">a[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span></span><br><span class="line">a[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-comment">// 数组读取</span></span><br><span class="line">fmt.Printf(<span class="hljs-string">"a[0]=%d\n"</span>, a[<span class="hljs-number">0</span>])</span><br><span class="line"><span class="hljs-comment">// 数组删除（赋零值）</span></span><br><span class="line">a[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span></span><br><span class="line"><span class="hljs-comment">// 数组的遍历</span></span><br><span class="line"><span class="hljs-keyword">for</span> index, value := <span class="hljs-keyword">range</span> c &#123;</span><br><span class="line">fmt.Printf(<span class="hljs-string">"c[%d]=%d\n"</span>, index, value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 输出b</span></span><br><span class="line">fmt.Printf(<span class="hljs-string">"b=%v\n"</span>, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><h3 id="使用切片"><a href="#使用切片" class="headerlink" title="使用切片"></a>使用切片</h3><p>在Go语言中，数组是一个重要的类型，但是使用切片的情况更多。切片是底层数组中的一个连续片段，因此数组支持的特性切片也全部支持，必须顺序遍历、通过索引访问元素等等。</p><p>为何使用切片的情况更多呢？主要是因为Go语言的数组不支持自动扩容，而且不支持删除元素，更重要的是Go语言数组是值类型，切片是引用类型，在向函数传参时切片拥有更好的性能。</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line"><span class="hljs-comment">// 声明一个大小为0的int类型切片</span></span><br><span class="line"><span class="hljs-keyword">var</span> a = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>)</span><br><span class="line"><span class="hljs-comment">// 添加三个元素</span></span><br><span class="line">a = <span class="hljs-built_in">append</span>(a, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</span><br><span class="line">fmt.Println(a)</span><br><span class="line"><span class="hljs-comment">// 遍历元素</span></span><br><span class="line"><span class="hljs-keyword">for</span> index, value := <span class="hljs-keyword">range</span> a &#123;</span><br><span class="line">fmt.Printf(<span class="hljs-string">"a[%d]=%d\n"</span>, index, value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 声明一个大小为4的切片</span></span><br><span class="line"><span class="hljs-keyword">var</span> b = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">4</span>)</span><br><span class="line"><span class="hljs-comment">// 将a的元素复制到b</span></span><br><span class="line"><span class="hljs-built_in">copy</span>(b, a)</span><br><span class="line"><span class="hljs-comment">// 删除指定下标的元素</span></span><br><span class="line">a = <span class="hljs-built_in">append</span>(a[:<span class="hljs-number">1</span>], a[<span class="hljs-number">2</span>:]...)</span><br><span class="line">fmt.Printf(<span class="hljs-string">"a=%v\n"</span>, a)</span><br><span class="line">fmt.Printf(<span class="hljs-string">"b=%v\n"</span>, b)</span><br><span class="line"><span class="hljs-comment">// 使用值初始化切片</span></span><br><span class="line"><span class="hljs-keyword">var</span> c = []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;</span><br><span class="line">fmt.Printf(<span class="hljs-string">"c=%v\n"</span>, c)</span><br><span class="line"><span class="hljs-comment">// 只定义，不初始化切片</span></span><br><span class="line"><span class="hljs-keyword">var</span> d []<span class="hljs-keyword">int</span></span><br><span class="line">d = <span class="hljs-built_in">append</span>(d, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</span><br><span class="line">fmt.Printf(<span class="hljs-string">"d=%v\n"</span>, d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明切片可以不使用make初始化，append也不会报错。</p><h3 id="运行时结构"><a href="#运行时结构" class="headerlink" title="运行时结构"></a>运行时结构</h3><p>切片运行时结构如下：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">type</span> slice <span class="hljs-keyword">struct</span> &#123;</span><br><span class="line">array unsafe.Pointer</span><br><span class="line"><span class="hljs-built_in">len</span>   <span class="hljs-keyword">int</span></span><br><span class="line"><span class="hljs-built_in">cap</span>   <span class="hljs-keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>array是底层数组</p></li><li><p>len是数组大小，可以通过len函数获取</p></li><li><p>cap是数组容量，可以通过cap函数获取</p></li></ol><p>make函数创建切片有两种写法：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">// 1</span></span><br><span class="line"><span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>) <span class="hljs-comment">// 2</span></span><br></pre></td></tr></table></figure><ol><li><p>声明了一个长度为0的切片，此时len为0，cap也为0</p></li><li><p>声明一个长度为0，容量为8的切片，此时len为0，cap为8</p></li></ol><h3 id="追加元素"><a href="#追加元素" class="headerlink" title="追加元素"></a>追加元素</h3><p>Go语言提供append函数追加元素到切片中，append会在必要时扩容底层数组。扩容规则如下：</p><ol><li><p>新容量小于1024时，每次扩容2倍。例如现有容量为2，扩容后为4</p></li><li><p>新容量大于1024时，每次扩容1.25倍。例如现有容量为1024，扩容后为1280</p></li></ol><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line"><span class="hljs-comment">// 直接使用值初始化切片</span></span><br><span class="line"><span class="hljs-keyword">var</span> a = []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;</span><br><span class="line">a = <span class="hljs-built_in">append</span>(a, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>)</span><br><span class="line"><span class="hljs-keyword">var</span> b = []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">9</span>, <span class="hljs-number">10</span>&#125;</span><br><span class="line"><span class="hljs-comment">// 追加b的全部元素到a</span></span><br><span class="line">a = <span class="hljs-built_in">append</span>(a, b...)</span><br><span class="line">fmt.Printf(<span class="hljs-string">"a=%v\n"</span>, a)</span><br><span class="line">fmt.Printf(<span class="hljs-string">"b=%v\n"</span>, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="范围操作符"><a href="#范围操作符" class="headerlink" title="范围操作符"></a>范围操作符</h3><p>切片支持取范围操作，新切片和原切片共享底层数组，因此对切片的修改会同时影响两个切片。</p><p>范围操作符语法如下：a[begin:end]，左闭右开区间。因此a[1:10]包含a切片索引为1~9的元素。</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line"><span class="hljs-comment">// 直接使用值初始化切片</span></span><br><span class="line"><span class="hljs-keyword">var</span> a = []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> b = a[<span class="hljs-number">1</span>:<span class="hljs-number">10</span>]</span><br><span class="line">fmt.Println(b)</span><br><span class="line"><span class="hljs-comment">// 修改新切片元素</span></span><br><span class="line">b[<span class="hljs-number">0</span>] = <span class="hljs-number">11</span></span><br><span class="line">fmt.Println(a)</span><br><span class="line">fmt.Println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到修改b索引为0的元素为11之后，a切片也同时受到影响。</p><p>范围操作符的切片这一点在编程中要特别注意！</p><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>利用范围操作符和append函数可以删除指定的切片元素。</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line"><span class="hljs-comment">// 直接使用值初始化切片</span></span><br><span class="line"><span class="hljs-keyword">var</span> a = []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;</span><br><span class="line"><span class="hljs-comment">// 删除第2个元素</span></span><br><span class="line">a = <span class="hljs-built_in">append</span>(a[:<span class="hljs-number">1</span>], a[<span class="hljs-number">2</span>:]...)</span><br><span class="line">fmt.Println(a)</span><br><span class="line"><span class="hljs-comment">// 删除第2、3个元素</span></span><br><span class="line">a = []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;</span><br><span class="line">a = <span class="hljs-built_in">append</span>(a[:<span class="hljs-number">1</span>], a[<span class="hljs-number">3</span>:]...)</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复制元素"><a href="#复制元素" class="headerlink" title="复制元素"></a>复制元素</h3><p>通过copy函数可以复制切片的全部或部分元素。在复制切片之前，需要声明好目标切片并设置len。</p><p><em>len<strong>必须大于</strong>0**，否则将不会复制任何元素。</em></p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line"><span class="hljs-comment">// 直接使用值初始化切片</span></span><br><span class="line"><span class="hljs-keyword">var</span> a = []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> b = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>)</span><br><span class="line"><span class="hljs-built_in">copy</span>(b, a)</span><br><span class="line">fmt.Println(b)</span><br><span class="line"><span class="hljs-keyword">var</span> c = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">8</span>)</span><br><span class="line"><span class="hljs-built_in">copy</span>(c, a[<span class="hljs-number">9</span>:<span class="hljs-number">10</span>])</span><br><span class="line">fmt.Println(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出如下：</p><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[]</span><br><span class="line">[<span class="hljs-number">10</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>]</span><br></pre></td></tr></table></figure><p>可以看到切片b没有任何值，切片c成功复制了a的最后一个元素。</p><h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>映射也叫字典、哈希表，数组和切片是通过数字索引访问的顺序集合，而映射是通过键来访问的无序集合。映射在查找方面非常高效，有着O(1)的时间复杂度，是非常常用的数据结构。</p><h3 id="使用映射"><a href="#使用映射" class="headerlink" title="使用映射"></a>使用映射</h3><p>映射必须初始化之后才能使用，这一点和切片不同。</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line"><span class="hljs-comment">// 使用make初始化映射</span></span><br><span class="line"><span class="hljs-keyword">var</span> a = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>)</span><br><span class="line">a[<span class="hljs-string">"zhangsan"</span>] = <span class="hljs-number">18</span></span><br><span class="line">a[<span class="hljs-string">"lisi"</span>] = <span class="hljs-number">28</span></span><br><span class="line">fmt.Printf(<span class="hljs-string">"a=%v\n"</span>, a)</span><br><span class="line"><span class="hljs-comment">// 使用值初始化映射</span></span><br><span class="line"><span class="hljs-keyword">var</span> b = <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>&#123;</span><br><span class="line"><span class="hljs-string">"zhangsan"</span>: <span class="hljs-number">18</span>,</span><br><span class="line"><span class="hljs-string">"lisi"</span>:     <span class="hljs-number">28</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="hljs-string">"b=%v\n"</span>, b)</span><br><span class="line"><span class="hljs-comment">// 遍历映射</span></span><br><span class="line"><span class="hljs-keyword">for</span> key, value := <span class="hljs-keyword">range</span> b &#123;</span><br><span class="line">fmt.Printf(<span class="hljs-string">"%s=%d\n"</span>, key, value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是未初始化映射的使用</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">var</span> a <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span></span><br><span class="line">a[<span class="hljs-string">"zhangsan"</span>] = <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> a &#123;</span><br><span class="line">fmt.Printf(<span class="hljs-string">"%s=%d\n"</span>, k, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序会产生运行时错误：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">panic</span>: assignment to entry in <span class="hljs-literal">nil</span> <span class="hljs-keyword">map</span></span><br><span class="line">goroutine <span class="hljs-number">1</span> [running]:</span><br><span class="line">main.main()</span><br><span class="line">/Users/example/<span class="hljs-keyword">go</span>/src/<span class="hljs-keyword">go</span>-microservice-inaction/src/<span class="hljs-number">2.1</span>/main.<span class="hljs-keyword">go</span>:<span class="hljs-number">7</span> +<span class="hljs-number">0x5d</span></span><br></pre></td></tr></table></figure><h3 id="运行时结构-1"><a href="#运行时结构-1" class="headerlink" title="运行时结构"></a>运行时结构</h3><p>映射的运行时结构如下：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">type</span> hmap <span class="hljs-keyword">struct</span> &#123;</span><br><span class="line">count      <span class="hljs-keyword">int</span></span><br><span class="line">flags      <span class="hljs-keyword">uint8</span></span><br><span class="line">B          <span class="hljs-keyword">uint8</span></span><br><span class="line">noverflow  <span class="hljs-keyword">uint16</span></span><br><span class="line">hash0      <span class="hljs-keyword">uint32</span></span><br><span class="line">buckets    unsafe.Pointer</span><br><span class="line">oldbuckets unsafe.Pointer</span><br><span class="line">nevacuate  <span class="hljs-keyword">uintptr</span></span><br><span class="line">extra      *mapextra</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>部分字段说明如下：</p><ol><li><p>count是目前映射的键值对数量</p></li><li><p>B是映射的容量，对数。例如B为8，则映射容量为28=256</p></li><li><p>buckets中存储具体的键值对</p></li><li><p>oldbuckets在扩容中会使用到</p></li><li><p>nevacuate 扩容进度指示器</p></li></ol><p>当装载因子超过6.5时，映射将发生扩容操作。装载因子计算公式：count/2B。例如当前为为166，此时装载因子为166/28=0.6484375，继续插入元素时，装载因子变为167/28= 0.65234375，此时会触发自动扩容。</p><p>每次扩容会增加1倍的空间，同时会对已存在的键值对进行渐进式迁移（一次迁移一小部分）。</p><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><p>Go语言映射添加元素和其他语言类似，使用[]语法即可。</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> m = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>)</span><br><span class="line">m[<span class="hljs-string">"name"</span>] = <span class="hljs-number">18</span></span><br></pre></td></tr></table></figure><p>添加元素时运行时会自动处理扩容和键值对迁移，无需用户程序关心。</p><h3 id="删除元素-1"><a href="#删除元素-1" class="headerlink" title="删除元素"></a>删除元素</h3><p>要从映射中删除元素，需要使用delete函数。</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> m = <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>&#123;</span><br><span class="line">  <span class="hljs-string">"zhangsan"</span>:<span class="hljs-number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-built_in">delete</span>(m, <span class="hljs-string">"zhangsan"</span>)</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本章介绍了Go语言常用的数据容器，其中对切片和映射的底层原理进行了简单介绍。Go语言通过内置切片和映射解决了C语言需要手动实现这两种常用数据结构的问题，提高了开发效率。在下一章将介绍Go语言的函数。</p><p><img src="https://static.ddhigh.com/blog/2021-03-09-162926-2.png" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文学习Go语言数据容器、包括数组、切片和映射。&lt;/p&gt;
&lt;h2 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h2&gt;&lt;p&gt;数组是一个数据集合，常用于存储用数字索引的同类型数据。Go语言的数组调用函数
      
    
    </summary>
    
      <category term="backend" scheme="https//www.ddhigh.com/categories/backend/"/>
    
      <category term="go" scheme="https//www.ddhigh.com/categories/backend/go/"/>
    
    
  </entry>
  
  <entry>
    <title>Golang程序设计——基本语法</title>
    <link href="https//www.ddhigh.com/2021/02/26/golang-basic.html"/>
    <id>https//www.ddhigh.com/2021/02/26/golang-basic.html</id>
    <published>2021-02-26T08:04:33.000Z</published>
    <updated>2022-02-06T11:56:58.658Z</updated>
    
    <content type="html"><![CDATA[<p>本文学习Go语言基本语法，例如变量和常量、数据类型、运算符、条件语句、循环语句。</p><h2 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h2><p>变量和常量是计算机程序不可或缺的部分。本节将介绍如何在Go程序中声明、使用变量和常量、还将介绍声明方式和作用域。</p><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><p>在Go语言中，声明变量的方式有多种。在前面的文章介绍过，Go语言是一种静态类型语言，因此声明变量时必须指明其类型。</p><p>例：声明string类型的变量。</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">var</span> s1 <span class="hljs-keyword">string</span> = <span class="hljs-string">"Hello World"</span></span><br><span class="line"><span class="hljs-keyword">var</span> s2 = <span class="hljs-string">"Hello World"</span></span><br><span class="line"><span class="hljs-keyword">var</span> s3 <span class="hljs-keyword">string</span></span><br><span class="line">s3 = <span class="hljs-string">"Hello World"</span></span><br><span class="line">fmt.Println(s1, s2, s3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>使用关键字var声明变量。</p></li><li><p>如果变量类型可以通过值推导则不用声明类型。s2通过值可以推导类型为string类型。</p></li><li><p>变量可以在声明后赋值，未赋值的变量值为该类型的零值。</p></li></ul><blockquote><p>变量的类型很重要，因为这决定了可将什么值赋给该变量。例如，对于类型为string的变量，不能将整数赋值给它。将不匹配的值赋值给变量时，将导致编译错误。</p></blockquote><p>例：将string类型的值赋值给int类型的变量。</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">var</span> i <span class="hljs-keyword">int</span></span><br><span class="line">i = <span class="hljs-string">"Hello World"</span></span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译该文件将导致编译错误。</p><figure class="highlight routeros hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go build main.go </span><br><span class="line"><span class="hljs-comment"># command-line-arguments</span></span><br><span class="line">./main.go:7:4: cannot use <span class="hljs-string">"Hello World"</span> (type untyped string) as<span class="hljs-built_in"> type </span>int <span class="hljs-keyword">in</span> assignment</span><br></pre></td></tr></table></figure><h3 id="多变量声明"><a href="#多变量声明" class="headerlink" title="多变量声明"></a>多变量声明</h3><p>例：声明多个<strong>类型相同</strong>的变量并进行赋值（显式指定类型）。</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">var</span> s1, s2 <span class="hljs-keyword">string</span> = <span class="hljs-string">"S1"</span>, <span class="hljs-string">"S2"</span></span><br><span class="line">fmt.Println(s1, s2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例：声明多个<strong>类型不同</strong>的变量并进行赋值（不能显式指定类型）。</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">var</span> s1, i1= <span class="hljs-string">"S1"</span>, <span class="hljs-number">1</span></span><br><span class="line">fmt.Println(s1, i1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例：声明多个<strong>类型不同</strong>的变量（显式指定类型）。</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">var</span> (</span><br><span class="line">s1 <span class="hljs-keyword">string</span></span><br><span class="line">i1 <span class="hljs-keyword">int</span></span><br><span class="line">)</span><br><span class="line">s1 = <span class="hljs-string">"Hello"</span></span><br><span class="line">i1 = <span class="hljs-number">10</span></span><br><span class="line">fmt.Println(s1, i1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>声明变量后可以再次赋值，但是同一个变量只允许声明一次，否则将导致编译错误。</p></blockquote><h3 id="简短变量声明"><a href="#简短变量声明" class="headerlink" title="简短变量声明"></a>简短变量声明</h3><p>在<strong>函数</strong>中声明变量时，可以用更简洁的方式。</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">s1 := <span class="hljs-string">"Hello World"</span></span><br><span class="line">fmt.Println(s1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>:=表示简短变量声明，可以不使用var，不指定类型，但是必须进行赋值。</p></li><li><p>只能在函数中使用简短变量声明。</p></li></ul><h3 id="变量声明最佳实践"><a href="#变量声明最佳实践" class="headerlink" title="变量声明最佳实践"></a>变量声明最佳实践</h3><p>Go语言提供了多种变量声明方式，下面的声明方式都是合法的。</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> s <span class="hljs-keyword">string</span> = <span class="hljs-string">"Hello"</span></span><br><span class="line"><span class="hljs-keyword">var</span> s1 = <span class="hljs-string">"Hello"</span></span><br><span class="line"><span class="hljs-keyword">var</span> s2 <span class="hljs-keyword">string</span></span><br><span class="line">s2 = <span class="hljs-string">"Hello"</span></span><br><span class="line">s3 := <span class="hljs-string">"Hello"</span></span><br></pre></td></tr></table></figure><p>该使用哪种方式呢？</p><p>Go语言对此有一个限制——只能在函数内部使用简短变量声明，在函数外部必须使用var进行声明。</p><blockquote><p>在标准库中遵循的约定如下：有初始值的情况下，在函数内使用简短变量声明，在函数外使用var并省略类型；无初始值的情况下使用var并指定类型。</p></blockquote><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> s = <span class="hljs-string">"Hello World"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">s1 := <span class="hljs-string">"Hello World"</span></span><br><span class="line">fmt.Println(s, s1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="变量和零值"><a href="#变量和零值" class="headerlink" title="变量和零值"></a>变量和零值</h3><p>在Go语言中，声明变量时如果未初始化，则变量为默认值，该默认值也称为零值。在其他语言中未初始化的值为null或undefined。</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">var</span> s <span class="hljs-keyword">string</span></span><br><span class="line"><span class="hljs-keyword">var</span> i <span class="hljs-keyword">int</span></span><br><span class="line"><span class="hljs-keyword">var</span> b <span class="hljs-keyword">bool</span></span><br><span class="line"><span class="hljs-keyword">var</span> f <span class="hljs-keyword">float32</span></span><br><span class="line">fmt.Printf(<span class="hljs-string">"%v %v %v %v\n"</span>, s, i, b, f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Go语言中，检查变量是否为空，必须与该类型的零值比较。例如检测string类型的变量是否为空，可以与””判定。</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">var</span> s <span class="hljs-keyword">string</span></span><br><span class="line"><span class="hljs-keyword">if</span> s == <span class="hljs-string">""</span> &#123;</span><br><span class="line">fmt.Println(<span class="hljs-string">"s为空"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><p>作用域指变量可以在什么地方使用，而不是说变量在哪里声明的。Go语言使用基于块的词法作用域，简单来说就是{}会产生一个作用域。</p><p>Go语言作用域规则如下：</p><ol><li>一对大括号({})表示一个块，块是可以嵌套的</li><li>对于在块内声明的变量，可以在本块以及子块中访问</li><li>子块可以访问父块的变量，父块不能访问子块的变量</li></ol><p>例：Go语言的作用域。</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">var</span> s1 = <span class="hljs-string">"s1"</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">var</span> s2 = <span class="hljs-string">"s2"</span></span><br><span class="line"><span class="hljs-comment">// 可以访问s1,s2</span></span><br><span class="line">fmt.Println(s1, s2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">var</span> s3 = <span class="hljs-string">"s3"</span></span><br><span class="line"><span class="hljs-comment">// 可以访问s1,s2,s3</span></span><br><span class="line">fmt.Println(s1, s2, s3)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 只能访问s1</span></span><br><span class="line">fmt.Println(s1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>简单来说，就是块内可以访问块外的变量，块外不能访问块内变量。</p></blockquote><h3 id="声明常量"><a href="#声明常量" class="headerlink" title="声明常量"></a>声明常量</h3><p>常量只在整个程序运行过程中都不变的值，常量必须在声明时赋值，声明后不可以更改。</p><p>Go语言使用const关键字声明常量。</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> s = <span class="hljs-string">"Hello"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">const</span> s2 = <span class="hljs-string">"World"</span></span><br><span class="line"><span class="hljs-keyword">const</span> s3,s4 = <span class="hljs-string">"Hello"</span>,<span class="hljs-string">"World"</span></span><br><span class="line">fmt.Println(s, s2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>常量也支持一次声明多个，此外常量的作用域和变量作用域一致。</p></blockquote><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>Go语言提供了丰富的数据类型，按类别分为布尔型、数值型（整数、浮点数、复数）、字符串型 、派生型。其中派声型包括指针类型、数组类型、结构体类型、接口类型、Channel类型、函数类型、切片类型和Map类型。</p><p>派生类型我们将在后面的内容中进行介绍。</p><h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p>布尔类型值只能为true或false。某些语言允许使用1和0来表示true和false，但Go语言不允许。</p><p>布尔类型的零值为false。</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">var</span> b <span class="hljs-keyword">bool</span></span><br><span class="line"><span class="hljs-keyword">if</span> b &#123;</span><br><span class="line">fmt.Println(<span class="hljs-string">"b是true"</span>)</span><br><span class="line">&#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="hljs-string">"b是false"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数值型"><a href="#数值型" class="headerlink" title="数值型"></a>数值型</h3><p>Go语言中数值型包含整数、浮点数以及复数。</p><p><strong>整数型</strong></p><table><thead><tr><th><strong>类型</strong></th><th><strong>字节数</strong></th><th><strong>范围</strong></th></tr></thead><tbody><tr><td>byte</td><td>1</td><td>0 ~ 28</td></tr><tr><td>uint8</td><td>1</td><td>0 ~ 28</td></tr><tr><td>int8</td><td>1</td><td>-27 ~ 27-1</td></tr><tr><td>uint16</td><td>2</td><td>0 ~ 216</td></tr><tr><td>int16</td><td>2</td><td>-215 ~ 215-1</td></tr><tr><td>uint32</td><td>4</td><td>0 ~ 232</td></tr><tr><td>int32</td><td>4</td><td>-231 ~ 231-1</td></tr><tr><td>uint64</td><td>8</td><td>0 ~ 264</td></tr><tr><td>int64</td><td>8</td><td>263 ~ 263-1</td></tr><tr><td>int</td><td>平台相关(32位或64位)</td><td></td></tr><tr><td>uint</td><td>平台相关(32位或64位)</td></tr></tbody></table><p><strong>浮点数</strong></p><table><thead><tr><th><strong>类型</strong></th><th><strong>字节数</strong></th><th><strong>范围</strong></th></tr></thead><tbody><tr><td>float32</td><td>4</td><td>-3.403E38 ~ 3.403E38</td></tr><tr><td>float64</td><td>8</td><td>-1.798E308 ~ 1.798E308</td></tr></tbody></table><p><strong>复数</strong></p><p>略</p><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><p>字符串可以是任何字符序列，包括数字、字母和符号。Go语言使用Unicode来存储字符串，因此可以支持世界上所有的语言。</p><p>下面是一些字符串示例：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> s = <span class="hljs-string">"$%^&amp;*"</span></span><br><span class="line"><span class="hljs-keyword">var</span> s2 = <span class="hljs-string">"1234"</span></span><br><span class="line"><span class="hljs-keyword">var</span> s3 = <span class="hljs-string">"你好"</span></span><br></pre></td></tr></table></figure><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>运算符用于在程序运行时执行数据运算和逻辑运算。Go语言支持的运算符有：</p><ul><li><p>算术运算符</p></li><li><p>逻辑运算符</p></li><li><p>关系运算符</p></li><li><p>位运算符</p></li></ul><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>算术运算符是用来对数值类型进行算术运算的。下表列出了Go语言支持的算术运算符。</p><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>+</td><td>相加</td></tr><tr><td>-</td><td>相减</td></tr><tr><td>*</td><td>相乘</td></tr><tr><td>/</td><td>相除</td></tr><tr><td>%</td><td>取余</td></tr><tr><td>++</td><td>自增</td></tr><tr><td>–</td><td>自减</td></tr></tbody></table><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">var</span> (</span><br><span class="line">a = <span class="hljs-number">10</span></span><br><span class="line">b = <span class="hljs-number">20</span></span><br><span class="line">)</span><br><span class="line">fmt.Printf(<span class="hljs-string">"a+b=%d\n"</span>, a+b)</span><br><span class="line">fmt.Printf(<span class="hljs-string">"a-b=%d\n"</span>, a-b)</span><br><span class="line">fmt.Printf(<span class="hljs-string">"a*b=%d\n"</span>, a*b)</span><br><span class="line">fmt.Printf(<span class="hljs-string">"a/b=%d\n"</span>, a/b)</span><br><span class="line">fmt.Printf(<span class="hljs-string">"a%%b=%d\n"</span>, a%b)</span><br><span class="line">a++</span><br><span class="line">fmt.Printf(<span class="hljs-string">"a++=%d\n"</span>, a)</span><br><span class="line">a--</span><br><span class="line">fmt.Printf(<span class="hljs-string">"a--=%d\n"</span>, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>和其他语言不同的是，Go语言不提供++a，–a运算符，只提供a++，a–。</p></blockquote><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>关系运算符用来判断两个值的关系。下表列出了Go语言支持的关系运算符。</p><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>==</td><td>判断两个值是否相等</td></tr><tr><td>!=</td><td>判断两个值是否不相等</td></tr><tr><td>&gt;</td><td>判断运算符左边的值是否大于右边的值</td></tr><tr><td>&lt;</td><td>判断运算符左边的值是否小于右边的值</td></tr><tr><td>&gt;=</td><td>判断运算符左边的值是否大于等于右边的值</td></tr><tr><td>&lt;=</td><td>判断运算符左边的值是否小于等于右边的值</td></tr></tbody></table><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">var</span> (</span><br><span class="line">a = <span class="hljs-number">10</span></span><br><span class="line">b = <span class="hljs-number">20</span></span><br><span class="line">)</span><br><span class="line"><span class="hljs-keyword">if</span> a == b &#123;</span><br><span class="line">fmt.Println(<span class="hljs-string">"a==b"</span>)</span><br><span class="line">&#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="hljs-string">"a!=b"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> a &lt; b &#123;</span><br><span class="line">fmt.Println(<span class="hljs-string">"a&lt;b"</span>)</span><br><span class="line">&#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="hljs-string">"a&gt;=b"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> a &lt;= b &#123;</span><br><span class="line">fmt.Println(<span class="hljs-string">"a&lt;=b"</span>)</span><br><span class="line">&#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="hljs-string">"a&gt;b"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>逻辑运算符用来对操作数进行逻辑判断。下表列出了Go语言支持的逻辑运算符。</p><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>逻辑与。两边操作数都为true则结果为true，否则为false</td></tr><tr><td>\</td><td>\</td><td></td><td>逻辑或。两边操作数只要有一个为true则结果为true，否则为false</td></tr><tr><td>!</td><td>逻辑非。如果操作数为true则结果为false，否则为true</td></tr></tbody></table><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">var</span> a, b = <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span></span><br><span class="line"><span class="hljs-keyword">if</span> a &amp;&amp; b &#123;</span><br><span class="line">fmt.Println(<span class="hljs-string">"a和b同时为true"</span>)</span><br><span class="line">&#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="hljs-string">"a和b至少一个为false"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> a || b &#123;</span><br><span class="line">fmt.Println(<span class="hljs-string">"a和b至少一个为true"</span>)</span><br><span class="line">&#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="hljs-string">"a和b都为false"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> !a &#123;</span><br><span class="line">fmt.Println(<span class="hljs-string">"a是false"</span>)</span><br><span class="line">&#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="hljs-string">"a是true"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>位运算符用来对整数进行二进制位操作。下表列出了Go语言支持的位运算符。</p><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>&amp;</td><td>按位与</td></tr><tr><td>\</td><td></td><td>按位或</td></tr><tr><td>^</td><td>按位异或</td></tr><tr><td>&gt;&gt;</td><td>右移</td></tr><tr><td>&lt;&lt;</td><td>左移</td></tr></tbody></table><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">var</span> (</span><br><span class="line">a = <span class="hljs-number">1</span></span><br><span class="line">b = <span class="hljs-number">2</span></span><br><span class="line">)</span><br><span class="line">fmt.Printf(<span class="hljs-string">"a&amp;b=%d\n"</span>, a&amp;b)</span><br><span class="line">fmt.Printf(<span class="hljs-string">"a|b=%d\n"</span>, a|b)</span><br><span class="line">fmt.Printf(<span class="hljs-string">"a^b=%d\n"</span>, a^b)</span><br><span class="line">fmt.Printf(<span class="hljs-string">"a&gt;&gt;1=%d\n"</span>, a&gt;&gt;<span class="hljs-number">1</span>)</span><br><span class="line">fmt.Printf(<span class="hljs-string">"a&lt;&lt;1=%d\n"</span>, a&lt;&lt;<span class="hljs-number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><p>条件语句是计算机程序的重要组成部分，几乎所有编程语言都支持。简单地说，条件语句检查指定的条件是否满足，并在满足时执行指定的操作。</p><p>下表列出了Go语言支持的条件语句。</p><table><thead><tr><th>if</th><th>由一个布尔表达式后紧跟一个或多个语句组成。</th></tr></thead><tbody><tr><td>if…else if…else</td><td>由多个布尔表达式分支组成，并提供例外分支</td></tr><tr><td>switch</td><td>基于不同条件执行不同操作，并提供默认操作</td></tr></tbody></table><p>例：if的使用。</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span></span><br><span class="line"><span class="hljs-keyword">if</span> a &gt; <span class="hljs-number">10</span> &#123;</span><br><span class="line">fmt.Println(<span class="hljs-string">"a大于10"</span>)</span><br><span class="line">&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> a == <span class="hljs-number">10</span> &#123;</span><br><span class="line">fmt.Println(<span class="hljs-string">"a等于10"</span>)</span><br><span class="line">&#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="hljs-string">"a小于10"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例：switch的使用。</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">switch</span> a &#123;</span><br><span class="line"><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:</span><br><span class="line">fmt.Println(<span class="hljs-string">"a等于1"</span>)</span><br><span class="line"><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:</span><br><span class="line">fmt.Println(<span class="hljs-string">"a等于2"</span>)</span><br><span class="line"><span class="hljs-keyword">case</span> <span class="hljs-number">10</span>:</span><br><span class="line">fmt.Println(<span class="hljs-string">"a等于3"</span>)</span><br><span class="line"><span class="hljs-keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="hljs-string">"默认分支"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>和其他语言不同，Go语言的case分支不需要添加break。</p></blockquote><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p>在其他语言中一般会提供for、while、foreach等关键字实现循环，而在Go语言中只提供for关键字，但是也实现了类似的效果。</p><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>for循环有着经典的三段式结构：</p><ol><li><p>循环初始化</p></li><li><p>循环终止条件</p></li><li><p>循环步进条件</p></li></ol><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">  <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><p>while循环指定循环终止条件，不满足条件时循环一直执行并向终止条件靠拢，满足条件后终止循环。（无终止条件的循环称为死循环）</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">  i := <span class="hljs-number">0</span></span><br><span class="line">  <span class="hljs-keyword">for</span> i &lt; <span class="hljs-number">10</span> &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">    i++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>死循环不需要终止条件。</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> (</span><br><span class="line">  <span class="hljs-string">"fmt"</span></span><br><span class="line">  <span class="hljs-string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">  i := <span class="hljs-number">0</span></span><br><span class="line">  <span class="hljs-keyword">for</span> &#123;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">    i++</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h3><p>foreach循环多用来遍历列表、字典等数据结构。</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">  list := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;</span><br><span class="line">  <span class="hljs-keyword">for</span> index, value := <span class="hljs-keyword">range</span> list &#123;</span><br><span class="line">fmt.Println(index, value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p>continue用来跳过本次循环继续执行下次循环。</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">  <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> i == <span class="hljs-number">1</span> &#123;</span><br><span class="line">      <span class="hljs-keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序判断i为1时跳过并执行下次循环，该程序输出如下。</p><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-number">0</span></span><br><span class="line"><span class="hljs-number">2</span></span><br><span class="line"><span class="hljs-number">3</span></span><br><span class="line"><span class="hljs-number">4</span></span><br></pre></td></tr></table></figure><h3 id="3-1-5-break"><a href="#3-1-5-break" class="headerlink" title="3.1.5   break"></a>3.1.5   break</h3><p>break用来跳出循环，后续循环将不执行。</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">  <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> i == <span class="hljs-number">1</span> &#123;</span><br><span class="line">      <span class="hljs-keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序判断i为1时跳出循环，该程序输出如下。</p><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-number">0</span></span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文介绍了Go语言的基本语法，包括变量和常量的使用、基础数据类型、流程控制等知识。下一章将介绍Go语言的数据容器类型，包括数组、切片和映射。</p><p><img src="https://static.ddhigh.com/blog/2021-02-26-161953-2.png" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文学习Go语言基本语法，例如变量和常量、数据类型、运算符、条件语句、循环语句。&lt;/p&gt;
&lt;h2 id=&quot;变量和常量&quot;&gt;&lt;a href=&quot;#变量和常量&quot; class=&quot;headerlink&quot; title=&quot;变量和常量&quot;&gt;&lt;/a&gt;变量和常量&lt;/h2&gt;&lt;p&gt;变量和常量是计算机程
      
    
    </summary>
    
      <category term="backend" scheme="https//www.ddhigh.com/categories/backend/"/>
    
      <category term="go" scheme="https//www.ddhigh.com/categories/backend/go/"/>
    
    
  </entry>
  
  <entry>
    <title>修复GitTalk出现Forbidden问题</title>
    <link href="https//www.ddhigh.com/2021/02/25/fix-gittalk-github.html"/>
    <id>https//www.ddhigh.com/2021/02/25/fix-gittalk-github.html</id>
    <published>2021-02-25T04:00:23.000Z</published>
    <updated>2022-02-06T11:56:58.658Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GitTalk失效原因"><a href="#GitTalk失效原因" class="headerlink" title="GitTalk失效原因"></a>GitTalk失效原因</h2><p>对于所有自建博客的博主来书，GitTalk应该不陌生。GitTalk通过Github的OpenAPI以及issues功能实现社区评论，确实是一大亮点。</p><p>今天在查看文章的时候发现评论区出现了Forbidden错误，通过检查网络请求发现获取Github Token时请求了以下链接</p><figure class="highlight awk hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="hljs-regexp">//</span>cors-anywhere.herokuapp.com<span class="hljs-regexp">/https:/</span><span class="hljs-regexp">/github.com/</span>login<span class="hljs-regexp">/oauth/</span>access_token</span><br></pre></td></tr></table></figure><p>通过查询GitTalk官方文档发现github.com的oauth是不允许跨域请求的，cors-anywhere.herokuapp.com是一个第三方提供的CORS代理服务，会默认放行所有CORS请求。目前由于该CORS代理服务遭到滥用，因此做了限制，导致GitTalk失效。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><blockquote><p>通过自己的nginx进行反向代理转发即可。</p></blockquote><h3 id="修改gitalk初始化参数"><a href="#修改gitalk初始化参数" class="headerlink" title="修改gitalk初始化参数"></a>修改gitalk初始化参数</h3><p>笔者使用的是hexo+icarus主题，其他主题或者博客系统也是类似做法。</p><p>编辑themes/icarus/layout/comment/gitalk.ejs</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="hljs-keyword">var</span> gitalk = <span class="hljs-keyword">new</span> Gitalk(&#123;</span><br><span class="line">        clientID: <span class="hljs-string">'&lt;%= get_config('</span>comment.client_id<span class="hljs-string">') %&gt;'</span>,</span><br><span class="line">        clientSecret: <span class="hljs-string">'&lt;%= get_config('</span>comment.client_secret<span class="hljs-string">') %&gt;'</span>,</span><br><span class="line">        id: <span class="hljs-string">'&lt;%= md5(page.path) %&gt;'</span>,</span><br><span class="line">        repo: <span class="hljs-string">'&lt;%= get_config('</span>comment.repo<span class="hljs-string">') %&gt;'</span>,</span><br><span class="line">        owner: <span class="hljs-string">'&lt;%= get_config('</span>comment.owner<span class="hljs-string">') %&gt;'</span>,</span><br><span class="line">        admin: &lt;%- <span class="hljs-built_in">JSON</span>.stringify(get_config(<span class="hljs-string">'comment.admin'</span>))%&gt;,</span><br><span class="line">        createIssueManually: &lt;%= get_config(<span class="hljs-string">'comment.create_issue_manually'</span>, <span class="hljs-literal">false</span>) %&gt;,</span><br><span class="line">        distractionFreeMode: &lt;%= get_config(<span class="hljs-string">'comment.distraction_free_mode'</span>, <span class="hljs-literal">false</span>) %&gt;,</span><br><span class="line">        proxy: <span class="hljs-string">'/github/login/oauth/access_token'</span> <span class="hljs-comment">// 新添加的</span></span><br><span class="line">    &#125;)</span><br><span class="line">    gitalk.render(<span class="hljs-string">'comment-container'</span>)</span><br><span class="line">&lt;<span class="hljs-regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h3 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h3><p>编辑nginx配置，笔者的博客域名为<a href="http://www.ddhigh.com，因此需要限制CORS来源域名，否则将有盗用风险" target="_blank" rel="noopener">www.ddhigh.com，因此需要限制CORS来源域名，否则将有盗用风险</a>!</p><figure class="highlight nginx hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attribute">location</span> /github &#123;</span><br><span class="line"><span class="hljs-attribute">add_header</span> Access-Control-Allow-Origin www.ddhigh.com;</span><br><span class="line">  <span class="hljs-attribute">add_header</span> Access-Control-Allow-Methods <span class="hljs-string">'GET, POST, OPTIONS'</span>;</span><br><span class="line">  <span class="hljs-attribute">add_header</span> Access-Control-Allow-Headers <span class="hljs-string">'DNT,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization'</span>;</span><br><span class="line">  <span class="hljs-attribute">if</span> (<span class="hljs-variable">$request_method</span> = <span class="hljs-string">'OPTIONS'</span>) &#123;</span><br><span class="line">  <span class="hljs-attribute">return</span> <span class="hljs-number">204</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-attribute">proxy_pass</span> https://github.com/; <span class="hljs-comment"># 尾部斜杠不能少</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行nginx -s reload配置。</p><h3 id="访问测试"><a href="#访问测试" class="headerlink" title="访问测试"></a>访问测试</h3><p>访问新写的文章<a href="https://www.ddhigh.com/2021/02/25/golang-get-started.html，可以看到界面上已经正常了。" target="_blank" rel="noopener">https://www.ddhigh.com/2021/02/25/golang-get-started.html，可以看到界面上已经正常了。</a></p><p><img src="https://static.ddhigh.com/blog/2021-02-25-121050-2.png" alt="image-20210225121050348"></p><p>查看Chrome网络状况，可以看到已经走了自己配置的CORS跨域了。</p><figure class="highlight oxygene hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Request URL: https:<span class="hljs-comment">//www.ddhigh.com/github/login/oauth/access_token</span></span><br><span class="line">Request <span class="hljs-function"><span class="hljs-keyword">Method</span>:</span> POST</span><br><span class="line">Status Code: <span class="hljs-number">200</span> </span><br><span class="line">Remote Address: <span class="hljs-number">106.52</span>.<span class="hljs-number">24.199</span>:<span class="hljs-number">443</span></span><br><span class="line">Referrer Policy: <span class="hljs-keyword">strict</span>-origin-when-cross-origin</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;GitTalk失效原因&quot;&gt;&lt;a href=&quot;#GitTalk失效原因&quot; class=&quot;headerlink&quot; title=&quot;GitTalk失效原因&quot;&gt;&lt;/a&gt;GitTalk失效原因&lt;/h2&gt;&lt;p&gt;对于所有自建博客的博主来书，GitTalk应该不陌生。GitTalk
      
    
    </summary>
    
      <category term="other" scheme="https//www.ddhigh.com/categories/other/"/>
    
    
      <category term="gittalk" scheme="https//www.ddhigh.com/tags/gittalk/"/>
    
  </entry>
  
  <entry>
    <title>Go语言程序设计</title>
    <link href="https//www.ddhigh.com/2021/02/25/golang-get-started.html"/>
    <id>https//www.ddhigh.com/2021/02/25/golang-get-started.html</id>
    <published>2021-02-25T03:13:02.000Z</published>
    <updated>2022-02-06T11:56:58.658Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言概述"><a href="#Go语言概述" class="headerlink" title="Go语言概述"></a>Go语言概述</h2><h3 id="语言历史"><a href="#语言历史" class="headerlink" title="语言历史"></a>语言历史</h3><p>Go语言也称为Golang，是由Google公司开发的一种静态强类型、编译型、语言原生支持并发、具有垃圾回收功能的编程语言。起源于2007年，并在2009年正式对外发布。Go语言是非常年轻的一门语言，它的主要目标是“兼具 Python 等动态语言的开发速度和 C/C++等编译型语言的性能与安全性”。</p><p>Go语言是编程语言设计的又一次尝试，是对类C语言的重大改进，它不但能让你访问底层操作系统，还提供了强大的网络编程和并发编程支持。Go语言的用途众多，可以进行网络编程、系统编程、并发编程等等。</p><p>Go语言的推出，旨在不损失应用程序性能的情况下降低代码的复杂性，具有“部署简单、并发性好、语言设计良好、执行性能好”等优势。</p><p>Go语言有时候被描述为“21世纪的C语言”。Go 从C语言继承了相似的表达式语法、控制流结构、基础数据类型、调用参数传值、指针等很多思想，还有C语言编译后的运行效率。</p><p>Go语言没有类和继承的概念，通过组合来实现代码复用，同时它通过接口（interface）的概念来实现多态性。所以Go语言的面向对象编程和传统面向对象语言（如C++和Java）并不相同。</p><p>Go语言有一个吉祥物，在会议、文档页面和博文中，大多会包含下图所示的 Go Gopher，这是才华横溢的插画家 Renee French 设计的，她也是 Go 设计者之一 Rob Pike 的妻子。</p><p><img src="https://static.ddhigh.com/blog/2021-02-25-111457-2.jpg" alt="img"></p><h3 id="语言特性"><a href="#语言特性" class="headerlink" title="语言特性"></a>语言特性</h3><p><strong>语法简单</strong></p><p>Go语言的设计思想类似Unix的“少即是多”。Go语言的语法规则严谨，没有歧义，这使得Go语言简单易学。Go语言保留了指针，但通常情况下禁止指针运算（保留unsafe包操作指针的能力）。此外，Go语言还内置切片和字典，在保留运行性能的同时也提高了开发效率。</p><p><strong>语言级别支持并发</strong></p><p>主流的并发模型有多进程模型、多线程模型。和主流多并发模型不同，Go语言采用了基于CSP的协程实现，并且在运行时做了更深度的优化处理。这使得语言级别上并发编程变得极为容易，无须处理回调、也无需关注线程切换，只需要添加一个go关键字即可。</p><p>“通过通信去共享内存，而不是通过共享内存去通信”，go语言内置的channel数据结构配合go关键字实现并发通信及控制，这对于需要考虑内存可见性等问题的多线程模型来说，是一个良好的解决方案。</p><p><strong>高效的垃圾回收</strong></p><p>Go语言的每次升级，垃圾回收器必然是核心组件里修改最多的部分。从并发清理，到降低STW时间，直到Go的1.5版本实现并发标记，逐步引入三色标记和写屏障等等，都是为了能让垃圾回收在不影响用户逻辑的情况下更好地工作。从最开始的秒级别STW到目前的微秒级STW，Go语言开发团队一直在垃圾回收方面进行努力。</p><p><strong>静态链接</strong></p><p>静态编译的好处显而易见。将运行时、依赖库直接打包到可执行文件内部，简化了部署和发布操作，无须事先安装运行环境和下载诸多第三方库。虽然相比动态编译增加了可执行文件的大小，但是省去了依赖库的管理。随着微服务和容器化的发展，这也成为了Go语言的杀手锏之一，一个二进制文件即可运行服务。</p><p><strong>标准库</strong></p><p>功能完善、质量可靠的标准库为编程语言提供了有力的支持。在不借助第三方扩展的情况下，就可完成大部分基础功能开发，这大大降低了学习和使用成本。</p><p>Go语言标准库可以说极为丰富。其中值得称道的是net/http，仅须简单几条语句就能实现一个高性能 Web Server。</p><p><strong>工具链</strong></p><p>完整的工具链对于项目开发极为重要。Go语言在此做得相当不错，无论是编译、格式化、错误检查、帮助文档，还是第三方包下载、更新都有对应的工具。</p><p>值得一提的gofmt工具，为了解决开发者经常遇到的“代码风格不统一”的难题，官方直接通过gofmt指定一套标准，可以看出go语言在工程方面确实解决了许多实际问题。</p><p>此外Go语言内置完整测试框架，其中包括单元测试、性能测试、代码覆盖率、数据竞争，以及用来调优的pprof，这些都是保障代码能正确而稳定运行的必备利器。</p><h3 id="Go语言应用场景"><a href="#Go语言应用场景" class="headerlink" title="Go语言应用场景"></a>Go语言应用场景</h3><p>Go 语言从发布1.0版本以来备受众多开发者关注并得到广泛使用，Go 语言的简单、高效、并发特性吸引了众多传统语言开发者的加入，而且人数越来越多。</p><p>鉴于Go语言的特点和设计的初衷，Go语言作为服务器编程语言，很适合处理日志、数据打包、虚拟机处理、文件系统、分布式系统、数据库代理等；网络编程方面，Go语言广泛应用于Web应用、API应用、下载应用等；除此之外，Go语言还适用于内存数据库和云平台领域，目前国外很多云平台都是采用Go开发。</p><ul><li><p>服务器编程。例如处理日志、数据打包、虚拟机处理、文件系统等。</p></li><li><p>分布式系统、数据库代理器、中间件等。例如Etcd。</p></li><li><p>网络编程。这一块目前应用最广，包括Web应用、API应用、下载应用等等。</p></li><li><p>开发云平台。目前国内外很多云平台在采用Go开发。</p></li></ul><h3 id="Go语言知名项目"><a href="#Go语言知名项目" class="headerlink" title="Go语言知名项目"></a>Go语言知名项目</h3><p>Go发布之后，很多公司特别是云计算公司开始用Go重构他们的基础架构，很多基础设施都是直接采用Go进行了开发，诞生了许多热门项目。</p><p><strong>基础设施</strong></p><p>代表项目：docker、kubernetes、etcd、consul等。</p><p><strong>数据库</strong></p><p>代表项目：influxdb、cockroachdb等。</p><p><strong>微服务</strong></p><p>代表项目：go-kit、micro、kratos等。</p><h2 id="安装Go语言"><a href="#安装Go语言" class="headerlink" title="安装Go语言"></a>安装Go语言</h2><p>Go语言可用于FreeBSD、Linux、Windows和macOS等操作系统。有关对这些平台的要求，请参与Go语言网站列出的系统需求。</p><p>Go语言的官方网站为<a href="https://golang.org/，国内的用户可以访问https://golang.google.cn/dl/。通常情况下，按照本文的步骤进行安装不会出现问题，遇到安装问题的读者，请通过公众号与我联系。" target="_blank" rel="noopener">https://golang.org/，国内的用户可以访问https://golang.google.cn/dl/。通常情况下，按照本文的步骤进行安装不会出现问题，遇到安装问题的读者，请通过公众号与我联系。</a></p><h3 id="Windows系统"><a href="#Windows系统" class="headerlink" title="Windows系统"></a>Windows系统</h3><p><strong>下载链接</strong></p><ul><li><p>32位下载地址：<a href="https://golang.google.cn/dl/go1.15.8.windows-386.msi" target="_blank" rel="noopener">https://golang.google.cn/dl/go1.15.8.windows-386.msi</a></p></li><li><p>64位下载地址：<a href="https://golang.google.cn/dl/go1.15.8.windows-amd64.msi" target="_blank" rel="noopener">https://golang.google.cn/dl/go1.15.8.windows-amd64.msi</a></p></li></ul><p>默认安装到C:\go目录下，建议不要更改安装目录。</p><p><strong>GOPATH配置</strong></p><p>安装完毕后需要配置GOPATH，GOPATH是Go语言用来存放第三方源码、二进制文件、类库等文件的路径。</p><ol><li><p>例如系统用户名为demo，则需要新建以下三个目录：</p><ul><li><p>C:\Users\demo\go\src 存放源码</p></li><li><p>C:\Users\demo\go\pkg 存放类库</p></li><li><p>C:\Users\demo\go\bin 存在二进制文件</p></li></ul></li><li><p>环境变量设置：</p><ul><li><p>新增GOPATH，值为C:\Users\demo\go</p></li><li><p>新增PATH（已存在则编辑），值为C:\Users\demo\go\bin</p></li></ul></li></ol><h3 id="Linux系统"><a href="#Linux系统" class="headerlink" title="Linux系统"></a>Linux系统</h3><p>Linux具有众多发行版，如Ubuntu、CentOS、RedHat、Debian等等，所有发行版的安装步骤是一致的，区别是根据CPU架构选择不同的发布包。</p><p>常见的个人计算机CPU架构为amd64，下载amd64架构的发布包即可。</p><p><strong>Linux配置命令</strong></p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># 下载压缩包</span></span><br><span class="line">wget https://golang.google.cn/dl/go1.15.8.linux-amd64.tar.gz</span><br><span class="line"><span class="hljs-comment"># 移动到opt目录</span></span><br><span class="line">mv go1.15.8.linux-amd64.tar.gz /opt</span><br><span class="line"><span class="hljs-comment"># 解压</span></span><br><span class="line">tar xf go1.15.8.linux-amd64.tar.gz</span><br><span class="line"><span class="hljs-comment"># 新建GOPATH目录</span></span><br><span class="line"><span class="hljs-built_in">cd</span> ~</span><br><span class="line">mkdir go</span><br><span class="line"><span class="hljs-built_in">cd</span> go</span><br><span class="line">mkdir pkg src bin</span><br><span class="line"><span class="hljs-comment"># 编辑 ~/.bashrc文件, 添加bin路径到PATH环境变量中</span></span><br><span class="line"><span class="hljs-built_in">echo</span> <span class="hljs-string">'GOPATH=用户主目录/go'</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="hljs-built_in">echo</span> <span class="hljs-string">'PATH=/opt/go/bin:$GOPATH/bin:$PATH'</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="hljs-comment"># 更新环境变量</span></span><br><span class="line"><span class="hljs-built_in">source</span> ~/.bashrc</span><br><span class="line"><span class="hljs-comment"># 测试安装结果</span></span><br><span class="line">go version</span><br></pre></td></tr></table></figure><h3 id="macOS系统"><a href="#macOS系统" class="headerlink" title="macOS系统"></a>macOS系统</h3><p>Apple公司于2020年发布了采用M1芯片(arm64架构)的硬件产品，支持M1芯片的Go语言版本为1.16，根据CPU架构选择对应的pkg包安装即可。</p><ul><li><p>amd64: <a href="https://golang.google.cn/dl/go1.15.8.darwin-amd64.pkg" target="_blank" rel="noopener">https://golang.google.cn/dl/go1.15.8.darwin-amd64.pkg</a></p></li><li><p>arm64: <a href="https://golang.google.cn/dl/go1.16.darwin-arm64.pkg" target="_blank" rel="noopener">https://golang.google.cn/dl/go1.16.darwin-arm64.pkg</a></p></li></ul><p><strong>macOS配置命令</strong></p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># 新建GOPATH目录</span></span><br><span class="line"><span class="hljs-built_in">cd</span> ~</span><br><span class="line">mkdir go</span><br><span class="line"><span class="hljs-built_in">cd</span> go</span><br><span class="line">mkdir pkg src bin</span><br><span class="line"><span class="hljs-comment"># 编辑 ~/.bashrc文件, 添加bin路径到PATH环境变量中</span></span><br><span class="line"><span class="hljs-built_in">echo</span> <span class="hljs-string">'GOPATH=用户主目录/go'</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="hljs-built_in">echo</span> <span class="hljs-string">'PATH=$GOPATH/bin:$PATH'</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="hljs-comment"># 更新环境变量</span></span><br><span class="line"><span class="hljs-built_in">source</span> ~/.bashrc</span><br><span class="line"><span class="hljs-comment"># 测试安装结果</span></span><br><span class="line">go version</span><br></pre></td></tr></table></figure><h2 id="配置集成开发环境"><a href="#配置集成开发环境" class="headerlink" title="配置集成开发环境"></a>配置集成开发环境</h2><p>本节将介绍如何在本地计算机上配置集成开发环境，以下步骤使用macOS版本作为示例，其他操作系统类似。</p><p>Visual Studio Code(简称VSCode)是由微软开发的、同时支持Windows、Linux和macOS操作系统的开源编辑器，它支持测试，并且内置了git功能，提供了丰富的语言支持与常用编程工具。</p><ol><li><p>打开官方网站 <a href="https://code.visualstudio.com/，点击蓝色按钮下载即可。" target="_blank" rel="noopener">https://code.visualstudio.com/，点击蓝色按钮下载即可。</a></p></li><li><p>新版本的VSCode不再内置中文语言包，需要安装语言包扩展。安装VSCode后打开VSCode编辑器，在扩展窗口中搜索“Chinese”，安装第一个即可。</p></li></ol><p><img src="https://static.ddhigh.com/blog/2021-02-25-111457-2.png" alt="image-20191022102923920"></p><ol start="3"><li>用VSCode新建一个空项目，打开项目之后新建main.go，此时VSCode右下角会弹出Go工具链安装的提示，选择”Install All“即可。</li></ol><h2 id="编写HTTP服务器"><a href="#编写HTTP服务器" class="headerlink" title="编写HTTP服务器"></a>编写HTTP服务器</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> (</span><br><span class="line"><span class="hljs-string">"io"</span></span><br><span class="line"><span class="hljs-string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="hljs-string">"/"</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">io.WriteString(w, <span class="hljs-string">"hello world"</span>)</span><br><span class="line">&#125;)</span><br><span class="line">http.ListenAndServe(<span class="hljs-string">":8080"</span>, <span class="hljs-literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="程序结构说明"><a href="#程序结构说明" class="headerlink" title="程序结构说明"></a>程序结构说明</h3><ul><li>package 关键字声明文件所在的包，每个go文件都必须声明。每个可执行程序都必须包含main包，程序的入口点为main包的func main函数</li><li>import 关键字声明需要导入的包，代码中需要使用http服务器相关方法，因此导入了http包</li><li>func main程序的入口点</li></ul><h3 id="编译并运行程序"><a href="#编译并运行程序" class="headerlink" title="编译并运行程序"></a>编译并运行程序</h3><p>编译并运行文件是开发过程中的一个常见步骤，Go提供了完成这个步骤的快捷途径。</p><p>Go语言提供了build和run两个命令来编译运行Go程序：</p><ul><li>go build 会编译可执行文件，并不执行</li><li>go run 不会创建可执行文件，直接执行</li></ul><p>使用go run运行HTTP服务器，之后通过浏览器打开即可。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文介绍了Go语言的安装以及集成开发环境的配置。通过HTTP服务器演示了Go程序的开发过程。</p><p>下一章将学习Go语言的基本语法：</p><ul><li>变量和常量</li><li>数据类型</li><li>运算符</li><li>条件语句</li><li>循环语句</li></ul><p><img src="https://static.ddhigh.com/blog/2021-02-26-161953-2.png" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言概述&quot;&gt;&lt;a href=&quot;#Go语言概述&quot; class=&quot;headerlink&quot; title=&quot;Go语言概述&quot;&gt;&lt;/a&gt;Go语言概述&lt;/h2&gt;&lt;h3 id=&quot;语言历史&quot;&gt;&lt;a href=&quot;#语言历史&quot; class=&quot;headerlink&quot; title=&quot;语
      
    
    </summary>
    
      <category term="backend" scheme="https//www.ddhigh.com/categories/backend/"/>
    
      <category term="go" scheme="https//www.ddhigh.com/categories/backend/go/"/>
    
    
  </entry>
  
  <entry>
    <title>golang依赖注入工具wire指南</title>
    <link href="https//www.ddhigh.com/2021/02/06/go-wire-tutorial.html"/>
    <id>https//www.ddhigh.com/2021/02/06/go-wire-tutorial.html</id>
    <published>2021-02-06T12:27:14.000Z</published>
    <updated>2022-02-06T11:56:58.658Z</updated>
    
    <content type="html"><![CDATA[<h2 id="wire与依赖注入"><a href="#wire与依赖注入" class="headerlink" title="wire与依赖注入"></a>wire与依赖注入</h2><p><a href="https://github.com/google/wire" target="_blank" rel="noopener">Wire</a> 是一个的Golang依赖注入工具，通过自动生成代码的方式在<strong>编译期</strong>完成依赖注入，Java体系中最出名的<strong>Spring</strong>框架采用<strong>运行时</strong>注入，个人认为这是wire和其他依赖注入最大的不同之处。</p><p>依赖注入(Dependency Injection)也称作控制反转(Inversion of Control)，个人给控制反转下的定义如下：</p><blockquote><p>当前对象需要的依赖对象由外部提供（通常是IoC容器），外部负责依赖对象的构造等操作，当前对象只负责调用，而不关心依赖对象的构造。即依赖对象的控制权交给了IoC容器。</p></blockquote><p>下面给出一个控制反转的示例，比如我们通过配置去创建一个数据库连接：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 连接配置</span></span><br><span class="line"><span class="hljs-keyword">type</span> DatabaseConfig <span class="hljs-keyword">struct</span> &#123;</span><br><span class="line">    Dsn <span class="hljs-keyword">string</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewDB</span><span class="hljs-params">(config *DatabaseConfig)</span><span class="hljs-params">(*sql.DB, error)</span></span> &#123;</span><br><span class="line">    db,err := sql.Open(<span class="hljs-string">"mysql"</span>, config.Dsn)</span><br><span class="line">    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun NewConfig()(*DatabaseConfig,error) &#123;</span><br><span class="line">    <span class="hljs-comment">// 读取配置文件</span></span><br><span class="line">    fp, err := os.Open(<span class="hljs-string">"config.json"</span>)</span><br><span class="line">    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>,err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">defer</span> fp.Close()</span><br><span class="line">    <span class="hljs-comment">// 解析为Json</span></span><br><span class="line">    <span class="hljs-keyword">var</span> config DatabaseConfig</span><br><span class="line">    <span class="hljs-keyword">if</span> err:=json.NewDecoder(fp).Decode(&amp;config);err!=<span class="hljs-literal">nil</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>,err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> &amp;config, <span class="hljs-literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InitDatabase</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">    cfg, err:=NewConfig()</span><br><span class="line">    <span class="hljs-keyword">if</span> err!=<span class="hljs-literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    db,err:=NewDB(cfg)</span><br><span class="line">    <span class="hljs-keyword">if</span> err!=<span class="hljs-literal">nil</span> &#123;</span><br><span class="line">        log.Fatail(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">// db对象构造完毕</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据库配置怎么来的，<code>NewDB</code>方法并不关心(示例代码采用的是<code>NewConfig</code>提供的JSON配置对象)，<code>NewDB</code>只负责创建DB对象并返回，和配置方式并没有耦合，所以即使换成配置中心或者其他方式来提供配置，<code>NewDB</code>代码也无需更改，这就是控制反转的魔力！</p><p>来看一个反面例子，也就是控制正转：</p><blockquote><p>当前对象需要的依赖由自己创建，即依赖对象的控制权在当前对象自己手里。</p></blockquote><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">type</span> DatabaseConfig <span class="hljs-keyword">struct</span> &#123;</span><br><span class="line">    Dsn <span class="hljs-keyword">string</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewDB</span><span class="hljs-params">()</span><span class="hljs-params">(*sql.DB, error)</span></span> &#123;</span><br><span class="line">    <span class="hljs-comment">// 读取配置文件</span></span><br><span class="line">    fp, err := os.Open(<span class="hljs-string">"config.json"</span>)</span><br><span class="line">    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>,err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">defer</span> fp.Close()</span><br><span class="line">    <span class="hljs-comment">// 解析为Json</span></span><br><span class="line">    <span class="hljs-keyword">var</span> config DatabaseConfig</span><br><span class="line">    <span class="hljs-keyword">if</span> err:=json.NewDecoder(fp).Decode(&amp;config);err!=<span class="hljs-literal">nil</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>,err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">// 初始化数据库连接</span></span><br><span class="line">    db,err = sql.Open(<span class="hljs-string">"mysql"</span>, config.Dsn)</span><br><span class="line">    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在控制正转模式下，<code>NewDB</code>方法需要自己实现配置对象的创建工作，在示例中需要读取Json配置文件，这是<strong>强耦合</strong>的代码，一旦配置文件的格式不是Json，<code>NewDB</code>方法将返回错误。</p><p>依赖注入固然好用，但是像刚才的例子中去手动管理依赖关系是相当复杂也是相当痛苦的一件事，因此在接下来的内容中会重点介绍golang的依赖注入工具——wire。</p><h2 id="上手使用"><a href="#上手使用" class="headerlink" title="上手使用"></a>上手使用</h2><p>通过<code>go get github.com/google/wire/cmd/wire</code>安装好<code>wire</code>命令行工具即可。</p><p>在正式开始之前需要介绍一下wire中的两个概念：<code>Provider</code>和<code>Injector</code>：</p><ul><li><code>Provider</code>：负责创建对象的方法，比如上文中<code>控制反转示例</code>的<code>NewDB</code>(提供DB对象)和<code>NewConfig</code>(提供DatabaseConfig对象)方法。</li><li><code>Injector</code>：负责根据对象的依赖，依次构造依赖对象，最终构造目的对象的方法，比如上文中<code>控制反转示例</code>的<code>InitDatabase</code>方法。</li></ul><p>现在我们通过<code>wire</code>来实现一个简单的项目。项目结构如下：</p><figure class="highlight 1c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-string">|--cmd</span></span><br><span class="line"><span class="hljs-string">|--main.go</span></span><br><span class="line"><span class="hljs-string">|--wire.go</span></span><br><span class="line"><span class="hljs-string">|--config</span></span><br><span class="line"><span class="hljs-string">|--app.json</span></span><br><span class="line"><span class="hljs-string">|--internal</span></span><br><span class="line"><span class="hljs-string">|--config</span></span><br><span class="line"><span class="hljs-string">|--config.go</span></span><br><span class="line"><span class="hljs-string">|--db</span></span><br><span class="line"><span class="hljs-string">|--db.go</span></span><br></pre></td></tr></table></figure><p>config/app.json</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="hljs-attr">"database"</span>: &#123;</span><br><span class="line">    <span class="hljs-attr">"dsn"</span>: <span class="hljs-string">"root:root@tcp(localhost:3306)/test"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>internal/config/config.go</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> config</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> (</span><br><span class="line"><span class="hljs-string">"encoding/json"</span></span><br><span class="line"><span class="hljs-string">"github.com/google/wire"</span></span><br><span class="line"><span class="hljs-string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> Provider = wire.NewSet(New) <span class="hljs-comment">// 将New方法声明为Provider，表示New方法可以创建一个被别人依赖的对象,也就是Config对象</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">type</span> Config <span class="hljs-keyword">struct</span> &#123;</span><br><span class="line">Database database <span class="hljs-string">`json:"database"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">type</span> database <span class="hljs-keyword">struct</span> &#123;</span><br><span class="line">Dsn <span class="hljs-keyword">string</span> <span class="hljs-string">`json:"dsn"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">()</span> <span class="hljs-params">(*Config, error)</span></span> &#123;</span><br><span class="line">fp, err := os.Open(<span class="hljs-string">"config/app.json"</span>)</span><br><span class="line"><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">defer</span> fp.Close()</span><br><span class="line"><span class="hljs-keyword">var</span> cfg Config</span><br><span class="line"><span class="hljs-keyword">if</span> err := json.NewDecoder(fp).Decode(&amp;cfg); err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> &amp;cfg, <span class="hljs-literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>internal/db/db.go</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> db</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> (</span><br><span class="line"><span class="hljs-string">"database/sql"</span></span><br><span class="line">_ <span class="hljs-string">"github.com/go-sql-driver/mysql"</span></span><br><span class="line"><span class="hljs-string">"github.com/google/wire"</span></span><br><span class="line"><span class="hljs-string">"wire-example2/internal/config"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> Provider = wire.NewSet(New) <span class="hljs-comment">// 同理</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(cfg *config.Config)</span> <span class="hljs-params">(db *sql.DB, err error)</span></span> &#123;</span><br><span class="line">db, err = sql.Open(<span class="hljs-string">"mysql"</span>, cfg.Database.Dsn)</span><br><span class="line"><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> err = db.Ping(); err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> db, <span class="hljs-literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cmd/main.go</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> (</span><br><span class="line"><span class="hljs-string">"database/sql"</span></span><br><span class="line"><span class="hljs-string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">type</span> App <span class="hljs-keyword">struct</span> &#123; <span class="hljs-comment">// 最终需要的对象</span></span><br><span class="line">db *sql.DB</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewApp</span><span class="hljs-params">(db *sql.DB)</span> *<span class="hljs-title">App</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> &amp;App&#123;db: db&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">app, err := InitApp() <span class="hljs-comment">// 使用wire生成的injector方法获取app对象</span></span><br><span class="line"><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> version <span class="hljs-keyword">string</span></span><br><span class="line">row := app.db.QueryRow(<span class="hljs-string">"SELECT VERSION()"</span>)</span><br><span class="line"><span class="hljs-keyword">if</span> err := row.Scan(&amp;version); err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">log.Println(version)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cmd/wire.go</p><p>重点文件，也就是实现Injector的核心所在：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// +build wireinject</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> (</span><br><span class="line"><span class="hljs-string">"github.com/google/wire"</span></span><br><span class="line"><span class="hljs-string">"wire-example2/internal/config"</span></span><br><span class="line"><span class="hljs-string">"wire-example2/internal/db"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InitApp</span><span class="hljs-params">()</span> <span class="hljs-params">(*App, error)</span></span> &#123;</span><br><span class="line"><span class="hljs-built_in">panic</span>(wire.Build(config.Provider, db.Provider, NewApp)) <span class="hljs-comment">// 调用wire.Build方法传入所有的依赖对象以及构建最终对象的函数得到目标对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件编写完毕，进入<code>cmd</code>目录执行<code>wire</code>命令会得到以下输出：</p><figure class="highlight taggerscript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:<span class="hljs-symbol">\U</span>sers<span class="hljs-symbol">\A</span>dministrator<span class="hljs-symbol">\G</span>olandProjects<span class="hljs-symbol">\w</span>ire-example2<span class="hljs-symbol">\c</span>md&gt;wire</span><br><span class="line">wire: wire-example2/cmd: wrote C:<span class="hljs-symbol">\U</span>sers<span class="hljs-symbol">\A</span>dministrator<span class="hljs-symbol">\G</span>olandProjects<span class="hljs-symbol">\w</span>ire-example2<span class="hljs-symbol">\c</span>md<span class="hljs-symbol">\w</span>ire_gen.go</span><br></pre></td></tr></table></figure><p>表明成功生成<code>wire_gen.go</code>文件，文件内容如下：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// Code generated by Wire. DO NOT EDIT.</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//go:generate go run github.com/google/wire/cmd/wire</span></span><br><span class="line"><span class="hljs-comment">//+build !wireinject</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> (</span><br><span class="line"><span class="hljs-string">"wire-example2/internal/config"</span></span><br><span class="line"><span class="hljs-string">"wire-example2/internal/db"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Injectors from wire.go:</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InitApp</span><span class="hljs-params">()</span> <span class="hljs-params">(*App, error)</span></span> &#123;</span><br><span class="line">configConfig, err := config.New()</span><br><span class="line"><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">sqlDB, err := db.New(configConfig)</span><br><span class="line"><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">app := NewApp(sqlDB)</span><br><span class="line"><span class="hljs-keyword">return</span> app, <span class="hljs-literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到生成App对象的代码已经自动生成了。</p><h3 id="Provider说明"><a href="#Provider说明" class="headerlink" title="Provider说明"></a>Provider说明</h3><p>通过<code>NewSet</code>方法将本包内创建对象的方法声明为<code>Provider</code>以供其他对象使用。<code>NewSet</code>可以接收多个参数，比如我们<code>db</code>包内可以创建Mysql和Redis连接对象，则可以如下声明：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> Provider = wire.NewSet(NewDB, NewRedis)</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewDB</span><span class="hljs-params">(config *Config)</span><span class="hljs-params">(*sql.DB,error)</span></span> &#123; <span class="hljs-comment">// 创建数据库对象</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewRedis</span><span class="hljs-params">(config *Config)</span><span class="hljs-params">(*redis.Client,error)</span></span> &#123; <span class="hljs-comment">// 创建Redis对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="wire-go文件说明"><a href="#wire-go文件说明" class="headerlink" title="wire.go文件说明"></a>wire.go文件说明</h3><p><code>wire.go</code>文件需要放在创建目标对象的地方，比如我们<code>Config</code>和<code>DB</code>对象最终是为<code>App</code>服务的，因此<code>wire.go</code>文件需要放在<code>App</code>所在的包内。</p><blockquote><p>wire.go文件名不是固定的，不过大家习惯叫这个文件名。</p></blockquote><p><code>wire.go</code>的第一行<code>// +build wireinject</code>是必须的，含义如下：</p><blockquote><p>只有添加了名称为”wireinject”的build tag，本文件才会编译，而我们go build main.go的时候通常不会加。因此，该文件不会参与最终编译。</p></blockquote><p><code>wire.Build(config.Provider, db.Provider, NewApp)</code>通过传入<code>config</code>以及<code>db</code>对象来创建最终需要的<code>App</code>对象</p><h3 id="wire-gen-go文件说明"><a href="#wire-gen-go文件说明" class="headerlink" title="wire_gen.go文件说明"></a>wire_gen.go文件说明</h3><p>该文件由<code>wire</code>自动生成，无需手工编辑！！！</p><p><code>//+build !wireinject</code>标签和<code>wire.go</code>文件的标签相对应，含义如下：</p><blockquote><p>编译时只有<strong>未添加</strong>“wireinject”的build tag，本文件才参与编译。</p></blockquote><p>因此，任意时刻下，<code>wire.go</code>和<code>wire_gen.go</code>只会有一个参与编译。</p><h2 id="高级玩法"><a href="#高级玩法" class="headerlink" title="高级玩法"></a>高级玩法</h2><h3 id="cleanup函数"><a href="#cleanup函数" class="headerlink" title="cleanup函数"></a>cleanup函数</h3><p>在创建依赖资源时，如果由某个资源创建失败，那么其他资源需要关闭的情况下，可以使用cleanup函数来关闭资源。比如咱们给<code>db.New</code>方法返回一个<code>cleanup</code>函数来关闭数据库连接，相关代码修改如下(未列出的代码不修改)：</p><p>internal/db/db.go</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(cfg *config.Config)</span> <span class="hljs-params">(db *sql.DB, cleanup <span class="hljs-keyword">func</span>()</span>, <span class="hljs-title">err</span> <span class="hljs-title">error</span>)</span> &#123; <span class="hljs-comment">// 声明第二个返回值</span></span><br><span class="line">db, err = sql.Open(<span class="hljs-string">"mysql"</span>, cfg.Database.Dsn)</span><br><span class="line"><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> err = db.Ping(); err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">cleanup = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-comment">// cleanup函数中关闭数据库连接</span></span><br><span class="line">db.Close()</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> db, cleanup, <span class="hljs-literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cmd/wire.go</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InitApp</span><span class="hljs-params">()</span> <span class="hljs-params">(*App, <span class="hljs-keyword">func</span>()</span>, <span class="hljs-title">error</span>)</span> &#123; <span class="hljs-comment">// 声明第二个返回值</span></span><br><span class="line"><span class="hljs-built_in">panic</span>(wire.Build(config.Provider, db.Provider, NewApp))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cmd/main.go</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">app, cleanup, err := InitApp() <span class="hljs-comment">// 添加第二个参数</span></span><br><span class="line"><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">defer</span> cleanup() <span class="hljs-comment">// 延迟调用cleanup关闭资源</span></span><br><span class="line"><span class="hljs-keyword">var</span> version <span class="hljs-keyword">string</span></span><br><span class="line">row := app.db.QueryRow(<span class="hljs-string">"SELECT VERSION()"</span>)</span><br><span class="line"><span class="hljs-keyword">if</span> err := row.Scan(&amp;version); err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">log.Println(version)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新在cmd目录执行<code>wire</code>命令，生成的<code>wire_gen.go</code>如下：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InitApp</span><span class="hljs-params">()</span> <span class="hljs-params">(*App, <span class="hljs-keyword">func</span>()</span>, <span class="hljs-title">error</span>)</span> &#123;</span><br><span class="line">configConfig, err := config.New()</span><br><span class="line"><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">sqlDB, cleanup, err := db.New(configConfig)</span><br><span class="line"><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">app := NewApp(sqlDB)</span><br><span class="line"><span class="hljs-keyword">return</span> app, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-comment">// 返回了清理函数</span></span><br><span class="line">cleanup()</span><br><span class="line">&#125;, <span class="hljs-literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口绑定"><a href="#接口绑定" class="headerlink" title="接口绑定"></a>接口绑定</h3><p>在面向接口编程中，代码依赖的往往是接口，而不是具体的struct，此时依赖注入相关代码需要做一点小小的修改，继续刚才的例子，示例修改如下：</p><p>新增<code>internal/db/dao.go</code></p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> db</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">"database/sql"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">type</span> Dao <span class="hljs-keyword">interface</span> &#123; <span class="hljs-comment">// 接口声明</span></span><br><span class="line">Version() (<span class="hljs-keyword">string</span>, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">type</span> dao <span class="hljs-keyword">struct</span> &#123; <span class="hljs-comment">// 默认实现</span></span><br><span class="line">db *sql.DB</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d dao)</span> <span class="hljs-title">Version</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-keyword">string</span>, error)</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">var</span> version <span class="hljs-keyword">string</span></span><br><span class="line">row := d.db.QueryRow(<span class="hljs-string">"SELECT VERSION()"</span>)</span><br><span class="line"><span class="hljs-keyword">if</span> err := row.Scan(&amp;version); err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-string">""</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> version, <span class="hljs-literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewDao</span><span class="hljs-params">(db *sql.DB)</span> *<span class="hljs-title">dao</span></span> &#123; <span class="hljs-comment">// 生成dao对象的方法</span></span><br><span class="line"><span class="hljs-keyword">return</span> &amp;dao&#123;db: db&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>internal/db/db.go也需要修改Provider，增加<code>NewDao</code>声明:</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> Provider = wire.NewSet(New, NewDao)</span><br></pre></td></tr></table></figure><p>cmd/main.go文件修改：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> (</span><br><span class="line"><span class="hljs-string">"log"</span></span><br><span class="line"><span class="hljs-string">"wire-example2/internal/db"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">type</span> App <span class="hljs-keyword">struct</span> &#123;</span><br><span class="line">dao db.Dao <span class="hljs-comment">// 依赖Dao接口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewApp</span><span class="hljs-params">(dao db.Dao)</span> *<span class="hljs-title">App</span></span> &#123; <span class="hljs-comment">// 依赖Dao接口</span></span><br><span class="line"><span class="hljs-keyword">return</span> &amp;App&#123;dao: dao&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">app, cleanup, err := InitApp()</span><br><span class="line"><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">defer</span> cleanup()</span><br><span class="line">version, err := app.dao.Version() <span class="hljs-comment">// 调用Dao接口方法</span></span><br><span class="line"><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">log.Println(version)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入cmd目录执行<code>wire</code>命令，此时会出现报错：</p><figure class="highlight verilog hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator\GolandProjects\<span class="hljs-keyword">wire</span>-example2\cmd&gt;<span class="hljs-keyword">wire</span></span><br><span class="line"><span class="hljs-keyword">wire</span>: C:\Users\Administrator\GolandProjects\<span class="hljs-keyword">wire</span>-example2\cmd\<span class="hljs-keyword">wire</span><span class="hljs-variable">.go</span>:<span class="hljs-number">11</span>:<span class="hljs-number">1</span>: inject InitApp: no provider found <span class="hljs-keyword">for</span> <span class="hljs-keyword">wire</span>-example2/internal/db<span class="hljs-variable">.Dao</span></span><br><span class="line">        needed by *<span class="hljs-keyword">wire</span>-example2/cmd<span class="hljs-variable">.App</span> in provider <span class="hljs-string">"NewApp"</span> (C:\Users\Administrator\GolandProjects\<span class="hljs-keyword">wire</span>-example2\cmd\main<span class="hljs-variable">.go</span>:<span class="hljs-number">12</span>:<span class="hljs-number">6</span>)</span><br><span class="line"><span class="hljs-keyword">wire</span>: <span class="hljs-keyword">wire</span>-example2/cmd: <span class="hljs-keyword">generate</span> failed</span><br><span class="line"><span class="hljs-keyword">wire</span>: at least one <span class="hljs-keyword">generate</span> failure</span><br></pre></td></tr></table></figure><p><code>wire</code>提示<code>inject InitApp: no provider found for wire-example2/internal/db.Dao</code>，也就是没找到能提供<code>db.Dao</code>对象的<code>Provider</code>，咱们不是提供了默认的<code>db.dao</code>实现也注册了<code>Provider</code>吗？这也是go的OOP设计奇特之处。</p><p>咱们修改一下<code>internal/db/db.go</code>的<code>Provider</code>声明，增加<code>db.*dao</code>和<code>db.Dao</code>的接口绑定关系:</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> Provider = wire.NewSet(New, NewDao, wire.Bind(<span class="hljs-built_in">new</span>(Dao), <span class="hljs-built_in">new</span>(*dao)))</span><br></pre></td></tr></table></figure><p><code>wire.Bind()</code>方法第一个参数为<code>interface{}</code>，第二个参数为<code>实现</code>。</p><p>此时再执行<code>wire</code>命令就可以成功了！</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p><code>wire</code>工具还有很多玩法，但是就笔者个人工作经验而言，掌握本文介绍到的知识已经能够胜任绝大部分场景了！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;wire与依赖注入&quot;&gt;&lt;a href=&quot;#wire与依赖注入&quot; class=&quot;headerlink&quot; title=&quot;wire与依赖注入&quot;&gt;&lt;/a&gt;wire与依赖注入&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/google/wire&quot; t
      
    
    </summary>
    
      <category term="backend" scheme="https//www.ddhigh.com/categories/backend/"/>
    
      <category term="go" scheme="https//www.ddhigh.com/categories/backend/go/"/>
    
    
  </entry>
  
  <entry>
    <title>Golang组件化网络服务器框架Halia指南</title>
    <link href="https//www.ddhigh.com/2021/01/12/golang-halia-get-started.html"/>
    <id>https//www.ddhigh.com/2021/01/12/golang-halia-get-started.html</id>
    <published>2021-01-12T04:00:00.000Z</published>
    <updated>2022-02-06T11:56:58.658Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在<strong>netty</strong>框架面世之前，几乎没有一个成熟的OOP/组件化规范指导网络服务器开发，一些常用的<code>FrameDecoder</code>,<code>BusinessHandler</code>等等组件紧密耦合在了项目当中，整个项目可以说扩展性比较差。</p><p>netty的出现可以说是划时代的，基于OOP/组件化屏蔽了底层 <strong>BlockingIO</strong>/<strong>NonBlockingIO</strong>/<strong>AsynchrousIO</strong>之间的差异，各种组件可以无缝切换，网络服务器开发效率有了非常大的提高。</p><p>通过阅读netty源码，以及核心组件的架构，基于Golang进行了实现，至此，Golang的Halia框架面世了！</p><h2 id="Halia特性"><a href="#Halia特性" class="headerlink" title="Halia特性"></a>Halia特性</h2><h3 id="组件化-可扩展"><a href="#组件化-可扩展" class="headerlink" title="组件化/可扩展"></a>组件化/可扩展</h3><p>Halia框架面向接口编程，并提供默认实现，同时内置常用的解码器，真正做到开箱即用。</p><h3 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h3><p>基于Golang原生网络库进行开发，无第三方依赖，性能有保障。</p><h3 id="易用性"><a href="#易用性" class="headerlink" title="易用性"></a>易用性</h3><p>Halia框架采用极简设计，没有冗余代码，并附带3个常用解码器示例，助您基于Halia快速开始开发。</p><h3 id="开源免费"><a href="#开源免费" class="headerlink" title="开源免费"></a>开源免费</h3><p>Halia框架基于MIT开源协议发布，无论是商用以及非商用都可以免费使用。</p><h3 id="社区驱动"><a href="#社区驱动" class="headerlink" title="社区驱动"></a>社区驱动</h3><p>Halia框架托管于Github，任何人都可以贡献一臂之力。</p><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p>接下来将演示如何开发一个时间回显服务器。</p><p>客户端每隔1秒发送时间字符串给服务器，服务器回显该数据。</p><h3 id="公用代码"><a href="#公用代码" class="headerlink" title="公用代码"></a>公用代码</h3><h4 id="encoder-go"><a href="#encoder-go" class="headerlink" title="encoder.go"></a>encoder.go</h4><p>字符串编码器，将字符串转换为<code>[]byte</code>传输到下一个出站处理器</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> (</span><br><span class="line"><span class="hljs-string">"halia/channel"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">type</span> StringToByteEncoder <span class="hljs-keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="hljs-comment">// 编码器不处理处理，交由下一个处理器(也就是业务处理器)处理</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *StringToByteEncoder)</span> <span class="hljs-title">OnError</span><span class="hljs-params">(c channel.HandlerContext, err error)</span></span> &#123;</span><br><span class="line">c.FireOnError(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *StringToByteEncoder)</span> <span class="hljs-title">Write</span><span class="hljs-params">(c channel.HandlerContext, msg <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> str, ok := msg.(<span class="hljs-keyword">string</span>); ok &#123; <span class="hljs-comment">// string才转换</span></span><br><span class="line"><span class="hljs-keyword">return</span> c.Write([]<span class="hljs-keyword">byte</span>(str))</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> c.Write(msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *StringToByteEncoder)</span> <span class="hljs-title">Flush</span><span class="hljs-params">(c channel.HandlerContext)</span> <span class="hljs-title">error</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> c.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码"></a>客户端代码</h3><h4 id="handler-go"><a href="#handler-go" class="headerlink" title="handler.go"></a>handler.go</h4><p>客户端业务处理代码。</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> (</span><br><span class="line"><span class="hljs-string">"fmt"</span></span><br><span class="line">log <span class="hljs-string">"github.com/sirupsen/logrus"</span></span><br><span class="line"><span class="hljs-string">"halia/channel"</span></span><br><span class="line"><span class="hljs-string">"strings"</span></span><br><span class="line"><span class="hljs-string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">type</span> EchoClientHandler <span class="hljs-keyword">struct</span> &#123;</span><br><span class="line">log *log.Entry</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewEchoClientHandler</span><span class="hljs-params">()</span> *<span class="hljs-title">EchoClientHandler</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> &amp;EchoClientHandler&#123;</span><br><span class="line">log: log.WithField(<span class="hljs-string">"component"</span>, <span class="hljs-string">"EchoClientHandler"</span>),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 发送错误回调</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *EchoClientHandler)</span> <span class="hljs-title">OnError</span><span class="hljs-params">(c channel.HandlerContext, err error)</span></span> &#123;</span><br><span class="line">p.log.WithField(<span class="hljs-string">"peer"</span>, c.Channel().RemoteAddr()).Warnln(<span class="hljs-string">"error caught"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 连接已建立</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *EchoClientHandler)</span> <span class="hljs-title">ChannelActive</span><span class="hljs-params">(c channel.HandlerContext)</span></span> &#123;</span><br><span class="line">p.log.WithField(<span class="hljs-string">"peer"</span>, c.Channel().RemoteAddr()).Infoln(<span class="hljs-string">"connected"</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> err := c.WriteAndFlush(<span class="hljs-string">"Hello World\r\n"</span>); err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">p.log.WithError(err).Warnln(<span class="hljs-string">"write error"</span>)</span><br><span class="line">&#125;</span><br><span class="line">p.log.Infof(<span class="hljs-string">"pipeline in: %v"</span>, strings.Join(c.Pipeline().InboundNames(), <span class="hljs-string">"-&gt;"</span>))</span><br><span class="line">p.log.Infof(<span class="hljs-string">"pipeline out: %v"</span>, strings.Join(c.Pipeline().OutboundNames(), <span class="hljs-string">"-&gt;"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 连接已断开</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *EchoClientHandler)</span> <span class="hljs-title">ChannelInActive</span><span class="hljs-params">(c channel.HandlerContext)</span></span> &#123;</span><br><span class="line">p.log.WithField(<span class="hljs-string">"peer"</span>, c.Channel().RemoteAddr()).Infoln(<span class="hljs-string">"disconnected"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 读取到完整的消息回调</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *EchoClientHandler)</span> <span class="hljs-title">ChannelRead</span><span class="hljs-params">(c channel.HandlerContext, msg <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">data, ok := msg.([]<span class="hljs-keyword">byte</span>)</span><br><span class="line"><span class="hljs-keyword">if</span> !ok &#123;</span><br><span class="line">p.log.WithField(<span class="hljs-string">"peer"</span>, c.Channel().RemoteAddr()).Warnf(<span class="hljs-string">"unknown msg type: %+v"</span>, msg)</span><br><span class="line"><span class="hljs-keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">str := <span class="hljs-keyword">string</span>(data)</span><br><span class="line">p.log.WithField(<span class="hljs-string">"peer"</span>, c.Channel().RemoteAddr()).Infoln(<span class="hljs-string">"receive "</span>, str)</span><br><span class="line">    <span class="hljs-comment">// 1秒后发送数据给服务器</span></span><br><span class="line">time.AfterFunc(time.Second, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> err := c.WriteAndFlush(fmt.Sprintf(<span class="hljs-string">"client say:%s\r\n"</span>, time.Now().String())); err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">p.log.WithError(err).Warnln(<span class="hljs-string">"write error"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="main-go"><a href="#main-go" class="headerlink" title="main.go"></a>main.go</h4><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> (</span><br><span class="line">log <span class="hljs-string">"github.com/sirupsen/logrus"</span></span><br><span class="line"><span class="hljs-string">"halia/bootstrap"</span></span><br><span class="line"><span class="hljs-string">"halia/channel"</span></span><br><span class="line"><span class="hljs-string">"halia/handler/codec"</span></span><br><span class="line"><span class="hljs-string">"net"</span></span><br><span class="line"><span class="hljs-string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">log.SetOutput(os.Stdout)</span><br><span class="line">log.SetLevel(log.DebugLevel)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">client := bootstrap.NewClient(&amp;bootstrap.ClientOptions&#123;</span><br><span class="line">        <span class="hljs-comment">// 将原始net.Conn包装为Channel实现，一般情况下用DefaultChannel即可</span></span><br><span class="line">ChannelFactory: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(conn net.Conn)</span> <span class="hljs-title">channel</span>.<span class="hljs-title">Channel</span></span> &#123;</span><br><span class="line">c := channel.NewDefaultChannel(conn)</span><br><span class="line">            <span class="hljs-comment">// 添加解码器，换行符分割报文解码器</span></span><br><span class="line">c.Pipeline().AddInbound(<span class="hljs-string">"decoder"</span>, codec.NewLineBasedFrameDecoder())</span><br><span class="line">            <span class="hljs-comment">// 添加业务处理器</span></span><br><span class="line">c.Pipeline().AddInbound(<span class="hljs-string">"handler"</span>, NewEchoClientHandler())</span><br><span class="line">            <span class="hljs-comment">// 添加编码器</span></span><br><span class="line">c.Pipeline().AddOutbound(<span class="hljs-string">"encoder"</span>, &amp;StringToByteEncoder&#123;&#125;)</span><br><span class="line"><span class="hljs-keyword">return</span> c</span><br><span class="line">&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="hljs-comment">// 连接服务器</span></span><br><span class="line">log.WithField(<span class="hljs-string">"component"</span>, <span class="hljs-string">"client"</span>).Fatal(client.Dial(<span class="hljs-string">"tcp"</span>, <span class="hljs-string">"127.0.0.1:8080"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务端代码"><a href="#服务端代码" class="headerlink" title="服务端代码"></a>服务端代码</h3><h4 id="handler-go-1"><a href="#handler-go-1" class="headerlink" title="handler.go"></a>handler.go</h4><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> (</span><br><span class="line">log <span class="hljs-string">"github.com/sirupsen/logrus"</span></span><br><span class="line"><span class="hljs-string">"halia/channel"</span></span><br><span class="line"><span class="hljs-string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">type</span> EchoServerHandler <span class="hljs-keyword">struct</span> &#123;</span><br><span class="line">log *log.Entry</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewEchoServerHandler</span><span class="hljs-params">()</span> *<span class="hljs-title">EchoServerHandler</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> &amp;EchoServerHandler&#123;</span><br><span class="line">log: log.WithField(<span class="hljs-string">"component"</span>, <span class="hljs-string">"EchoServerHandler"</span>),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *EchoServerHandler)</span> <span class="hljs-title">OnError</span><span class="hljs-params">(c channel.HandlerContext, err error)</span></span> &#123;</span><br><span class="line">p.log.WithField(<span class="hljs-string">"peer"</span>, c.Channel().RemoteAddr()).Warnln(<span class="hljs-string">"error caught"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *EchoServerHandler)</span> <span class="hljs-title">ChannelActive</span><span class="hljs-params">(c channel.HandlerContext)</span></span> &#123;</span><br><span class="line">p.log.WithField(<span class="hljs-string">"peer"</span>, c.Channel().RemoteAddr()).Infoln(<span class="hljs-string">"connected"</span>)</span><br><span class="line"></span><br><span class="line">p.log.Infof(<span class="hljs-string">"pipeline in: %v"</span>, strings.Join(c.Pipeline().InboundNames(), <span class="hljs-string">"-&gt;"</span>))</span><br><span class="line">p.log.Infof(<span class="hljs-string">"pipeline out: %v"</span>, strings.Join(c.Pipeline().OutboundNames(), <span class="hljs-string">"-&gt;"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *EchoServerHandler)</span> <span class="hljs-title">ChannelInActive</span><span class="hljs-params">(c channel.HandlerContext)</span></span> &#123;</span><br><span class="line">p.log.WithField(<span class="hljs-string">"peer"</span>, c.Channel().RemoteAddr()).Infoln(<span class="hljs-string">"disconnected"</span>)</span><br><span class="line"></span><br><span class="line">p.log.Infof(<span class="hljs-string">"pipeline in: %v"</span>, strings.Join(c.Pipeline().InboundNames(), <span class="hljs-string">"-&gt;"</span>))</span><br><span class="line">p.log.Infof(<span class="hljs-string">"pipeline out: %v"</span>, strings.Join(c.Pipeline().OutboundNames(), <span class="hljs-string">"-&gt;"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *EchoServerHandler)</span> <span class="hljs-title">ChannelRead</span><span class="hljs-params">(c channel.HandlerContext, msg <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">data, ok := msg.([]<span class="hljs-keyword">byte</span>)</span><br><span class="line"><span class="hljs-keyword">if</span> !ok &#123;</span><br><span class="line">p.log.WithField(<span class="hljs-string">"peer"</span>, c.Channel().RemoteAddr()).Warnf(<span class="hljs-string">"unknown msg type: %+v"</span>, msg)</span><br><span class="line"><span class="hljs-keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">str := <span class="hljs-keyword">string</span>(data)</span><br><span class="line">p.log.WithField(<span class="hljs-string">"peer"</span>, c.Channel().RemoteAddr()).Infoln(<span class="hljs-string">"receive "</span>, str)</span><br><span class="line"><span class="hljs-keyword">if</span> err := c.Write(<span class="hljs-string">"server:"</span> + str + <span class="hljs-string">"\r\n"</span>); err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">p.log.WithField(<span class="hljs-string">"peer"</span>, c.Channel().RemoteAddr()).WithError(err).Warnln(<span class="hljs-string">"write error"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="main-go-1"><a href="#main-go-1" class="headerlink" title="main.go"></a>main.go</h4><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> (</span><br><span class="line">log <span class="hljs-string">"github.com/sirupsen/logrus"</span></span><br><span class="line"><span class="hljs-string">"halia/bootstrap"</span></span><br><span class="line"><span class="hljs-string">"halia/channel"</span></span><br><span class="line"><span class="hljs-string">"halia/handler/codec"</span></span><br><span class="line"><span class="hljs-string">"net"</span></span><br><span class="line"><span class="hljs-string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">log.SetOutput(os.Stdout)</span><br><span class="line">log.SetLevel(log.DebugLevel)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">s := bootstrap.NewServer(&amp;bootstrap.ServerOptions&#123;</span><br><span class="line">ChannelFactory: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(conn net.Conn)</span> <span class="hljs-title">channel</span>.<span class="hljs-title">Channel</span></span> &#123;</span><br><span class="line">c := channel.NewDefaultChannel(conn)</span><br><span class="line">c.Pipeline().AddInbound(<span class="hljs-string">"decoder"</span>, codec.NewLineBasedFrameDecoder())</span><br><span class="line">c.Pipeline().AddInbound(<span class="hljs-string">"handler"</span>, NewEchoServerHandler())</span><br><span class="line">c.Pipeline().AddOutbound(<span class="hljs-string">"encoder"</span>, &amp;StringToByteEncoder&#123;&#125;)</span><br><span class="line"><span class="hljs-keyword">return</span> c</span><br><span class="line">&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">log.WithField(<span class="hljs-string">"component"</span>, <span class="hljs-string">"server"</span>).Fatal(s.Listen(<span class="hljs-string">"tcp"</span>, <span class="hljs-string">"0.0.0.0:8080"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>先运行服务端，再运行客户端。</p><p>服务端输出</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">time=&quot;2021-01-12T11:30:13+08:00&quot; level=info msg=started addr=&quot;0.0.0.0:8080&quot; component=server network=tcp pid=7584</span><br><span class="line">time=&quot;2021-01-12T11:30:13+08:00&quot; level=info msg=initialized component=channelId machineId=a0c5895a25a3 pid=7584</span><br><span class="line">time=&quot;2021-01-12T11:30:18+08:00&quot; level=info msg=connected component=EchoServerHandler peer=&quot;127.0.0.1:57641&quot;</span><br><span class="line">time=&quot;2021-01-12T11:30:18+08:00&quot; level=info msg=&quot;pipeline in: InHeadContext-&gt;decoder-&gt;handler&quot; component=EchoServerHandler</span><br><span class="line">time=&quot;2021-01-12T11:30:18+08:00&quot; level=info msg=&quot;pipeline out: OutHeadContext-&gt;encoder-&gt;OutTailContext&quot; component=EchoServerHandler</span><br><span class="line">time=&quot;2021-01-12T11:30:18+08:00&quot; level=info msg=&quot;receive  Hello World&quot; component=EchoServerHandler peer=&quot;127.0.0.1:57641&quot;</span><br><span class="line">time=&quot;2021-01-12T11:30:19+08:00&quot; level=info msg=&quot;receive  client say:2021-01-12 11:30:19.5192868 +0800 CST m=+1.046443501&quot; component=EchoServerHandler peer=&quot;127.0.0.1:57641&quot;</span><br><span class="line">time=&quot;2021-01-12T11:30:20+08:00&quot; level=info msg=&quot;receive  client say:2021-01-12 11:30:20.5193884 +0800 CST m=+2.046545101&quot; component=EchoServerHandler peer=&quot;127.0.0.1:57641&quot;</span><br><span class="line">time=&quot;2021-01-12T11:30:21+08:00&quot; level=info msg=&quot;receive  client say:2021-01-12 11:30:21.5345887 +0800 CST m=+3.061745401&quot; component=EchoServerHandler peer=&quot;127.0.0.1:57641&quot;</span><br><span class="line">time=&quot;2021-01-12T11:30:22+08:00&quot; level=info msg=&quot;receive  client say:2021-01-12 11:30:22.5459978 +0800 CST m=+4.073154501&quot; component=EchoServerHandler peer=&quot;127.0.0.1:57641&quot;</span><br></pre></td></tr></table></figure><p>客户端输出</p><figure class="highlight routeros hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attribute">time</span>=<span class="hljs-string">"2021-01-12T11:30:18+08:00"</span> <span class="hljs-attribute">level</span>=info <span class="hljs-attribute">msg</span>=connected <span class="hljs-attribute">component</span>=EchoClientHandler <span class="hljs-attribute">peer</span>=<span class="hljs-string">"127.0.0.1:8080"</span></span><br><span class="line"><span class="hljs-attribute">time</span>=<span class="hljs-string">"2021-01-12T11:30:18+08:00"</span> <span class="hljs-attribute">level</span>=info <span class="hljs-attribute">msg</span>=<span class="hljs-string">"pipeline in: InHeadContext-&gt;decoder-&gt;handler"</span> <span class="hljs-attribute">component</span>=EchoClientHandler</span><br><span class="line"><span class="hljs-attribute">time</span>=<span class="hljs-string">"2021-01-12T11:30:18+08:00"</span> <span class="hljs-attribute">level</span>=info <span class="hljs-attribute">msg</span>=<span class="hljs-string">"pipeline out: OutHeadContext-&gt;encoder-&gt;OutTailContext"</span> <span class="hljs-attribute">component</span>=EchoClientHandler</span><br><span class="line"><span class="hljs-attribute">time</span>=<span class="hljs-string">"2021-01-12T11:30:18+08:00"</span> <span class="hljs-attribute">level</span>=info <span class="hljs-attribute">msg</span>=<span class="hljs-string">"receive  server:Hello World"</span> <span class="hljs-attribute">component</span>=EchoClientHandler <span class="hljs-attribute">peer</span>=<span class="hljs-string">"127.0.0.1:8080"</span></span><br><span class="line"><span class="hljs-attribute">time</span>=<span class="hljs-string">"2021-01-12T11:30:18+08:00"</span> <span class="hljs-attribute">level</span>=info <span class="hljs-attribute">msg</span>=initialized <span class="hljs-attribute">component</span>=channelId <span class="hljs-attribute">machineId</span>=a0c5895a25a3 <span class="hljs-attribute">pid</span>=960</span><br><span class="line"><span class="hljs-attribute">time</span>=<span class="hljs-string">"2021-01-12T11:30:19+08:00"</span> <span class="hljs-attribute">level</span>=info <span class="hljs-attribute">msg</span>=<span class="hljs-string">"receive  server:client say:2021-01-12 11:30:19.5192868 +0800 CST m=+1.046443501"</span> <span class="hljs-attribute">component</span>=EchoClientHandler <span class="hljs-attribute">peer</span>=<span class="hljs-string">"127.0.0.1:8080"</span></span><br><span class="line"><span class="hljs-attribute">time</span>=<span class="hljs-string">"2021-01-12T11:30:20+08:00"</span> <span class="hljs-attribute">level</span>=info <span class="hljs-attribute">msg</span>=<span class="hljs-string">"receive  server:client say:2021-01-12 11:30:20.5193884 +0800 CST m=+2.046545101"</span> <span class="hljs-attribute">component</span>=EchoClientHandler <span class="hljs-attribute">peer</span>=<span class="hljs-string">"127.0.0.1:8080"</span></span><br><span class="line"><span class="hljs-attribute">time</span>=<span class="hljs-string">"2021-01-12T11:30:21+08:00"</span> <span class="hljs-attribute">level</span>=info <span class="hljs-attribute">msg</span>=<span class="hljs-string">"receive  server:client say:2021-01-12 11:30:21.5345887 +0800 CST m=+3.061745401"</span> <span class="hljs-attribute">component</span>=EchoClientHandler <span class="hljs-attribute">peer</span>=<span class="hljs-string">"127.0.0.1:8080"</span></span><br><span class="line"><span class="hljs-attribute">time</span>=<span class="hljs-string">"2021-01-12T11:30:22+08:00"</span> <span class="hljs-attribute">level</span>=info <span class="hljs-attribute">msg</span>=<span class="hljs-string">"receive  server:client say:2021-01-12 11:30:22.5459978 +0800 CST m=+4.073154501"</span> <span class="hljs-attribute">component</span>=EchoClientHandler <span class="hljs-attribute">peer</span>=<span class="hljs-string">"127.0.0.1:8080"</span></span><br></pre></td></tr></table></figure><h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>Halia期待您的贡献！</p><ul><li><a href="https://halia-group.github.io/halia/" target="_blank" rel="noopener">文档地址</a></li><li><a href="https://github.com/halia-group/halia" target="_blank" rel="noopener">仓库地址</a></li></ul><p><img src="https://imgkr2.cn-bj.ufileos.com/ccd85d43-46ce-405b-8efb-6f22c0f9ec3f.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;Signature=APhNQ04SOdsYvwRWMyj6hc%252BUu5s%253D&amp;Expires=1610510873" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;在&lt;strong&gt;netty&lt;/strong&gt;框架面世之前，几乎没有一个成熟的OOP/组件化规范指导网络服务器开发，一些常用
      
    
    </summary>
    
      <category term="backend" scheme="https//www.ddhigh.com/categories/backend/"/>
    
      <category term="go" scheme="https//www.ddhigh.com/categories/backend/go/"/>
    
    
      <category term="halia" scheme="https//www.ddhigh.com/tags/halia/"/>
    
  </entry>
  
</feed>
