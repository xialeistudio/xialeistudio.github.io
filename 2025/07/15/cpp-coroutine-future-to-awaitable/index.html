<!doctype html><html lang=zh><head><meta name=viewport content="width=device-width,initial-scale=1"><title>C++ 协程进阶：将 std::future 转换为 asio::awaitable</title>
<meta charset=utf-8><meta name=google-adsense-account content="ca-pub-2871082647721658"><meta content="Web开发 ,Java ,Go ,Node.js ,PHP ,Koa ,MySQL ,Redis ,前端 ,后端 ,数据库" name=keywords><meta name=description content="在现代 C++ 开发中，协程为异步编程带来了革命性的改变。然而，在使用 boost::asio 或 standalone asio 时，我们经常遇到需要将传统的 std::future<T> 转换为 asio::awaitable<T> 的场景。本文将详细介绍一种高效、线程安全的转换方法。"><meta name=author content="Lei Xia"><link rel=canonical href=https://www.ddhigh.com/2025/07/15/cpp-coroutine-future-to-awaitable/><link rel=alternate type=application/rss+xml href=https://www.ddhigh.com/index.xml title=每天进步一点点><script async src="https://www.googletagmanager.com/gtag/js?id=G-EC3XLVSGKV"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-EC3XLVSGKV")</script><meta property="og:title" content="C++ 协程进阶：将 std::future 转换为 asio::awaitable"><meta property="og:description" content="在现代 C++ 开发中，协程为异步编程带来了革命性的改变。然而，在使用 boost::asio 或 standalone asio 时，我们经常遇到需要将传统的 std::future<T> 转换为 asio::awaitable<T> 的场景。本文将详细介绍一种高效、线程安全的转换方法。"><meta property="og:type" content="article"><meta property="og:url" content="https://www.ddhigh.com/2025/07/15/cpp-coroutine-future-to-awaitable/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-07-15T09:00:00+08:00"><meta property="article:modified_time" content="2025-07-15T09:00:00+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="C++ 协程进阶：将 std::future 转换为 asio::awaitable"><meta name=twitter:description content="在现代 C++ 开发中，协程为异步编程带来了革命性的改变。然而，在使用 boost::asio 或 standalone asio 时，我们经常遇到需要将传统的 std::future<T> 转换为 asio::awaitable<T> 的场景。本文将详细介绍一种高效、线程安全的转换方法。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://www.ddhigh.com/posts/"},{"@type":"ListItem","position":3,"name":"C++ 协程进阶：将 std::future 转换为 asio::awaitable","item":"https://www.ddhigh.com/2025/07/15/cpp-coroutine-future-to-awaitable/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"C++ 协程进阶：将 std::future 转换为 asio::awaitable","name":"C\u002b\u002b 协程进阶：将 std::future 转换为 asio::awaitable","description":"在现代 C++ 开发中，协程为异步编程带来了革命性的改变。然而，在使用 boost::asio 或 standalone asio 时，我们经常遇到需要将传统的 std::future\u0026lt;T\u0026gt; 转换为 asio::awaitable\u0026lt;T\u0026gt; 的场景。本文将详细介绍一种高效、线程安全的转换方法。\n","keywords":["cpp","coroutine","asio","future"],"articleBody":"在现代 C++ 开发中，协程为异步编程带来了革命性的改变。然而，在使用 boost::asio 或 standalone asio 时，我们经常遇到需要将传统的 std::future 转换为 asio::awaitable 的场景。本文将详细介绍一种高效、线程安全的转换方法。\n问题背景 在使用 asio 协程时，我们经常遇到这样的场景：\n需要调用返回 std::future 的第三方库（如数据库驱动） 希望在协程中使用 co_await 来处理这些异步操作 不希望阻塞 IO 线程，保持高性能 传统的解决方案可能会使用定时器轮询或直接在 IO 线程中调用 future.get()，这些方法要么效率低下，要么会阻塞 IO 线程。\n核心解决方案 我们的解决方案基于 asio::async_initiate，它提供了与 asio 协程系统的完美集成，同时避免了阻塞 IO 线程的问题。\n核心实现 #include #include #include #include // 线程池用于处理阻塞操作 asio::thread_pool blocking_pool(4); // 将 std::future 转换为 asio::awaitable template\u003ctypename T, typename CompletionToken\u003e auto future_to_awaitable(std::future\u003cT\u003e future, CompletionToken\u0026\u0026 token) { return asio::async_initiate\u003cCompletionToken, void(std::tuple\u003cstd::optional\u003cT\u003e, std::exception_ptr\u003e)\u003e( [future = std::move(future)](auto\u0026\u0026 handler) mutable { auto executor = asio::get_associated_executor(handler); // 在线程池中执行阻塞操作，避免阻塞 IO 线程 asio::post(blocking_pool, [future = std::move(future), handler = std::move(handler), executor]() mutable { std::tuple\u003cstd::optional\u003cT\u003e, std::exception_ptr\u003e result; try { T value = future.get(); result = std::make_tuple(std::make_optional(std::move(value)), nullptr); } catch (...) { result = std::make_tuple(std::nullopt, std::current_exception()); } // 回到原始执行器上下文中调用 handler asio::post(executor, [handler = std::move(handler), result = std::move(result)]() mutable { handler(std::move(result)); }); }); }, token ); } // 协程专用的包装函数 template\u003ctypename T\u003e asio::awaitable\u003cT\u003e await_future(std::future\u003cT\u003e future) { auto [result, exception] = co_await future_to_awaitable(std::move(future), asio::use_awaitable); if (exception) { std::rethrow_exception(exception); } if (result) { co_return std::move(*result); } throw std::runtime_error(\"Unknown error: no result and no exception\"); } 使用示例 基本使用 // 模拟数据库查询 std::future\u003cstd::string\u003e query_mysql(const std::string\u0026 sql) { return std::async(std::launch::async, [sql] { std::this_thread::sleep_for(std::chrono::seconds(1)); return \"Query result for: \" + sql + \" - Found 10 rows\"; }); } // 在协程中使用 asio::awaitable\u003cvoid\u003e example_coro() { try { // 直接在协程中 await future auto result = co_await await_future(query_mysql(\"SELECT * FROM users\")); std::cout \u003c\u003c \"Query successful: \" \u003c\u003c result \u003c\u003c std::endl; } catch (const std::exception\u0026 e) { std::cout \u003c\u003c \"Query failed: \" \u003c\u003c e.what() \u003c\u003c std::endl; } } 异常处理 std::future\u003cstd::string\u003e query_with_error(const std::string\u0026 sql) { return std::async(std::launch::async, [sql]() -\u003e std::string { std::this_thread::sleep_for(std::chrono::seconds(1)); throw std::runtime_error(\"Database connection failed\"); }); } asio::awaitable\u003cvoid\u003e error_handling_example() { try { auto result = co_await await_future(query_with_error(\"SELECT * FROM invalid_table\")); std::cout \u003c\u003c \"Should not reach here\" \u003c\u003c std::endl; } catch (const std::exception\u0026 e) { std::cout \u003c\u003c \"Exception caught: \" \u003c\u003c e.what() \u003c\u003c std::endl; } } 技术要点分析 1. 使用 async_initiate 的优势 完美集成：与 asio 协程系统无缝集成 类型安全：编译时类型检查 性能优化：避免了定时器轮询的开销 2. 线程池设计 asio::thread_pool blocking_pool(4); 专门用于处理阻塞操作 避免阻塞 IO 线程 可根据需要调整线程数量 3. 异常处理策略 使用 std::tuple","wordCount":"391","inLanguage":"zh","datePublished":"2025-07-15T09:00:00+08:00","dateModified":"2025-07-15T09:00:00+08:00","author":{"@type":"Person","name":"Lei Xia"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.ddhigh.com/2025/07/15/cpp-coroutine-future-to-awaitable/"},"publisher":{"@type":"Organization","name":"每天进步一点点","logo":{"@type":"ImageObject","url":"https://www.ddhigh.com/favicon.ico"}}}</script><link rel=icon href=/img/favicon.ico sizes=16x16><link rel=apple-touch-icon href=/img/favicon.ico><link rel=manifest href=/img/favicon.ico><link href=/titilliumweb/titilliumweb.css rel=stylesheet><link rel=stylesheet href=/css/main.min.0eb4160ba4a2d63122fe8ae83f1560951a87ab510d5dab0615973b5206555759.css integrity="sha256-DrQWC6Si1jEi/oroPxVglRqHq1ENXasGFZc7UgZVV1k=" crossorigin=anonymous media=screen><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css integrity="sha512-ygEyjMC6rqnzJqWGjRTJUPYMEs9JUOm3i7OWUS9CgQ4XkBUvMsgCS1I8JqavidQ2ClHcREB7IbA2mN08+r9Elg==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=/scss/highlight/github-dark.min.min.66034289ee9a113219a2c4aae0a8bd2095ab255c832a42efcf5863f10814e7a1.css><script src=/js/highlight.min.min.894ca9c68afab956438c4926a0dc7f5293e04e08595bd27abdb123e94801f684.js></script><script>hljs.highlightAll()</script><script>$darkModeInit.Content|safeJS</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2871082647721658" crossorigin=anonymous></script></head><body><main class=wrapper><nav class=navigation><section class=container><a class=navigation-brand href=/>每天进步一点点
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><span></span><span></span><span></span></label><ul class=navigation-list id=navigation-list><li class="navigation-item navigation-menu"><a class=navigation-link href=/>首页</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/archives>归档</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/books>出版物</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/guestbook>留言板</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class="navigation-item navigation-social"><a class=navigation-link href=https://github.com/xialeistudio><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li class="navigation-item navigation-dark"><button id=mode type=button aria-label="toggle user light or dark theme">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span><span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></li><li class="navigation-item navigation-language"><a href=https://www.ddhigh.com/en/2025/07/15/cpp-coroutine-future-to-awaitable/>EN</a></li></ul></section></nav><div id=content><article class=blog-single><header class=blog-title><h1>C++ 协程进阶：将 std::future 转换为 asio::awaitable</h1></header><p><small>2025年7月15日&nbsp;· 391 字&nbsp;· 2 分钟</small><p><div class=blog-toc><nav id=TableOfContents><ul><li><a href=#问题背景>问题背景</a></li><li><a href=#核心解决方案>核心解决方案</a><ul><li><a href=#核心实现>核心实现</a></li></ul></li><li><a href=#使用示例>使用示例</a><ul><li><a href=#基本使用>基本使用</a></li><li><a href=#异常处理>异常处理</a></li></ul></li><li><a href=#技术要点分析>技术要点分析</a><ul><li><a href=#1-使用-async_initiate-的优势>1. 使用 <code>async_initiate</code> 的优势</a></li><li><a href=#2-线程池设计>2. 线程池设计</a></li><li><a href=#3-异常处理策略>3. 异常处理策略</a></li><li><a href=#4-执行器上下文保持>4. 执行器上下文保持</a></li></ul></li><li><a href=#性能考虑>性能考虑</a></li><li><a href=#实际应用场景>实际应用场景</a></li><li><a href=#总结>总结</a></li></ul></nav></div><section class=blog-content><p>在现代 C++ 开发中，协程为异步编程带来了革命性的改变。然而，在使用 boost::asio 或 standalone asio 时，我们经常遇到需要将传统的 <code>std::future&lt;T></code> 转换为 <code>asio::awaitable&lt;T></code> 的场景。本文将详细介绍一种高效、线程安全的转换方法。</p><h2 id=问题背景>问题背景</h2><p>在使用 asio 协程时，我们经常遇到这样的场景：</p><ul><li>需要调用返回 <code>std::future</code> 的第三方库（如数据库驱动）</li><li>希望在协程中使用 <code>co_await</code> 来处理这些异步操作</li><li>不希望阻塞 IO 线程，保持高性能</li></ul><p>传统的解决方案可能会使用定时器轮询或直接在 IO 线程中调用 <code>future.get()</code>，这些方法要么效率低下，要么会阻塞 IO 线程。</p><h2 id=核心解决方案>核心解决方案</h2><p>我们的解决方案基于 <code>asio::async_initiate</code>，它提供了与 asio 协程系统的完美集成，同时避免了阻塞 IO 线程的问题。</p><h3 id=核心实现>核心实现</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;asio.hpp&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;future&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;optional&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;tuple&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 线程池用于处理阻塞操作
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>asio<span style=color:#f92672>::</span>thread_pool blocking_pool(<span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 将 std::future&lt;T&gt; 转换为 asio::awaitable&lt;T&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T, <span style=color:#66d9ef>typename</span> CompletionToken<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>auto</span> future_to_awaitable(std<span style=color:#f92672>::</span>future<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> future, CompletionToken<span style=color:#f92672>&amp;&amp;</span> token) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> asio<span style=color:#f92672>::</span>async_initiate<span style=color:#f92672>&lt;</span>CompletionToken, <span style=color:#66d9ef>void</span>(std<span style=color:#f92672>::</span>tuple<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>optional<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>, std<span style=color:#f92672>::</span>exception_ptr<span style=color:#f92672>&gt;</span>)<span style=color:#f92672>&gt;</span>(
</span></span><span style=display:flex><span>        [future <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>move(future)](<span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;&amp;</span> handler) <span style=color:#66d9ef>mutable</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>auto</span> executor <span style=color:#f92672>=</span> asio<span style=color:#f92672>::</span>get_associated_executor(handler);
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 在线程池中执行阻塞操作，避免阻塞 IO 线程
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            asio<span style=color:#f92672>::</span>post(blocking_pool, [future <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>move(future), handler <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>move(handler), executor]() <span style=color:#66d9ef>mutable</span> {
</span></span><span style=display:flex><span>                std<span style=color:#f92672>::</span>tuple<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>optional<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>, std<span style=color:#f92672>::</span>exception_ptr<span style=color:#f92672>&gt;</span> result;
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                    T value <span style=color:#f92672>=</span> future.get();
</span></span><span style=display:flex><span>                    result <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>make_tuple(std<span style=color:#f92672>::</span>make_optional(std<span style=color:#f92672>::</span>move(value)), <span style=color:#66d9ef>nullptr</span>);
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>catch</span> (...) {
</span></span><span style=display:flex><span>                    result <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>make_tuple(std<span style=color:#f92672>::</span>nullopt, std<span style=color:#f92672>::</span>current_exception());
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 回到原始执行器上下文中调用 handler
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                asio<span style=color:#f92672>::</span>post(executor, [handler <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>move(handler), result <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>move(result)]() <span style=color:#66d9ef>mutable</span> {
</span></span><span style=display:flex><span>                    handler(std<span style=color:#f92672>::</span>move(result));
</span></span><span style=display:flex><span>                });
</span></span><span style=display:flex><span>            });
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>        token
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 协程专用的包装函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>asio<span style=color:#f92672>::</span>awaitable<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> await_future(std<span style=color:#f92672>::</span>future<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> future) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>auto</span> [result, exception] <span style=color:#f92672>=</span> <span style=color:#66d9ef>co_await</span> future_to_awaitable(std<span style=color:#f92672>::</span>move(future), asio<span style=color:#f92672>::</span>use_awaitable);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (exception) {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>rethrow_exception(exception);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (result) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>co_return</span> std<span style=color:#f92672>::</span>move(<span style=color:#f92672>*</span>result);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>throw</span> std<span style=color:#f92672>::</span>runtime_error(<span style=color:#e6db74>&#34;Unknown error: no result and no exception&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=使用示例>使用示例</h2><h3 id=基本使用>基本使用</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// 模拟数据库查询
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>std<span style=color:#f92672>::</span>future<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>string<span style=color:#f92672>&gt;</span> query_mysql(<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>string<span style=color:#f92672>&amp;</span> sql) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> std<span style=color:#f92672>::</span>async(std<span style=color:#f92672>::</span>launch<span style=color:#f92672>::</span>async, [sql] {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>this_thread<span style=color:#f92672>::</span>sleep_for(std<span style=color:#f92672>::</span>chrono<span style=color:#f92672>::</span>seconds(<span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;Query result for: &#34;</span> <span style=color:#f92672>+</span> sql <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; - Found 10 rows&#34;</span>;
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 在协程中使用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>asio<span style=color:#f92672>::</span>awaitable<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>void</span><span style=color:#f92672>&gt;</span> example_coro() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 直接在协程中 await future
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>auto</span> result <span style=color:#f92672>=</span> <span style=color:#66d9ef>co_await</span> await_future(query_mysql(<span style=color:#e6db74>&#34;SELECT * FROM users&#34;</span>));
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Query successful: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> result <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>exception<span style=color:#f92672>&amp;</span> e) {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Query failed: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> e.what() <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=异常处理>异常处理</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#f92672>::</span>future<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>string<span style=color:#f92672>&gt;</span> query_with_error(<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>string<span style=color:#f92672>&amp;</span> sql) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> std<span style=color:#f92672>::</span>async(std<span style=color:#f92672>::</span>launch<span style=color:#f92672>::</span>async, [sql]() <span style=color:#f92672>-&gt;</span> std<span style=color:#f92672>::</span>string {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>this_thread<span style=color:#f92672>::</span>sleep_for(std<span style=color:#f92672>::</span>chrono<span style=color:#f92672>::</span>seconds(<span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> std<span style=color:#f92672>::</span>runtime_error(<span style=color:#e6db74>&#34;Database connection failed&#34;</span>);
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>asio<span style=color:#f92672>::</span>awaitable<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>void</span><span style=color:#f92672>&gt;</span> error_handling_example() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>auto</span> result <span style=color:#f92672>=</span> <span style=color:#66d9ef>co_await</span> await_future(query_with_error(<span style=color:#e6db74>&#34;SELECT * FROM invalid_table&#34;</span>));
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Should not reach here&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>exception<span style=color:#f92672>&amp;</span> e) {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Exception caught: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> e.what() <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=技术要点分析>技术要点分析</h2><h3 id=1-使用-async_initiate-的优势>1. 使用 <code>async_initiate</code> 的优势</h3><ul><li><strong>完美集成</strong>：与 asio 协程系统无缝集成</li><li><strong>类型安全</strong>：编译时类型检查</li><li><strong>性能优化</strong>：避免了定时器轮询的开销</li></ul><h3 id=2-线程池设计>2. 线程池设计</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>asio<span style=color:#f92672>::</span>thread_pool blocking_pool(<span style=color:#ae81ff>4</span>);
</span></span></code></pre></div><ul><li>专门用于处理阻塞操作</li><li>避免阻塞 IO 线程</li><li>可根据需要调整线程数量</li></ul><h3 id=3-异常处理策略>3. 异常处理策略</h3><p>使用 <code>std::tuple&lt;std::optional&lt;T>, std::exception_ptr></code> 来处理两种情况：</p><ul><li>正常结果：<code>{std::optional&lt;T>, nullptr}</code></li><li>异常情况：<code>{std::nullopt, std::exception_ptr}</code></li></ul><p>这种设计能够正确处理边界情况，比如返回类型本身就是 <code>std::exception_ptr</code> 的情况。</p><h3 id=4-执行器上下文保持>4. 执行器上下文保持</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>auto</span> executor <span style=color:#f92672>=</span> asio<span style=color:#f92672>::</span>get_associated_executor(handler);
</span></span><span style=display:flex><span><span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>asio<span style=color:#f92672>::</span>post(executor, [handler <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>move(handler), result <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>move(result)]() <span style=color:#66d9ef>mutable</span> {
</span></span><span style=display:flex><span>    handler(std<span style=color:#f92672>::</span>move(result));
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>确保最终的 handler 调用在正确的执行器上下文中进行，保持了 asio 的执行器语义。</p><h2 id=性能考虑>性能考虑</h2><ol><li><strong>避免 IO 线程阻塞</strong>：所有阻塞操作都在独立的线程池中执行</li><li><strong>移动语义</strong>：大量使用 <code>std::move</code> 避免不必要的拷贝</li><li><strong>零拷贝设计</strong>：结果直接在线程间传递，无需额外拷贝</li></ol><h2 id=实际应用场景>实际应用场景</h2><p>这种转换方法特别适合以下场景：</p><ol><li><strong>数据库操作</strong>：将数据库驱动的异步接口转换为协程友好的形式</li><li><strong>文件 I/O</strong>：处理可能阻塞的文件操作</li><li><strong>第三方库集成</strong>：与返回 <code>std::future</code> 的库进行集成</li><li><strong>计算密集型任务</strong>：将 CPU 密集型任务转换为可 await 的形式</li></ol><h2 id=总结>总结</h2><p>通过使用 <code>asio::async_initiate</code> 和线程池，我们实现了一个高效、线程安全的 <code>std::future</code> 到 <code>asio::awaitable</code> 的转换方案。这种方法不仅避免了阻塞 IO 线程，还提供了完美的异常处理机制，是现代 C++ 异步编程的最佳实践之一。</p><p>这种设计模式可以轻松扩展到其他异步场景，为构建高性能的协程应用奠定了坚实的基础。</p><div class=blog-footer><div class=social-share></div><div class=copyright><ul><li style=margin-bottom:.5em>本文作者: <a href=https://ddhigh.com/ target=_blank style=color:#000;text-decoration:none>xialeistudio</a></li><li style=margin-bottom:.5em>本文链接: <a href=https://www.ddhigh.com/2025/07/15/cpp-coroutine-future-to-awaitable/ target=_blank style=color:#000;text-decoration:none>C++ 协程进阶：将 std::future 转换为 asio::awaitable</a></li><li>版权声明: <a href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank style=color:#000;text-decoration:none>「署名-非商业性使用-相同方式共享 4.0 国际」</a></li></ul></div><div style=margin-top:2rem><img src=/img/mp.png alt=qrcode></div></div></section><div class=paginator><a class=next href=https://www.ddhigh.com/2025/07/12/lunet-high-performance-coroutine-network-library/><span>Lunet: 高性能协程网络库的设计与实现</span><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M12.055 9C12.711 9.61644 14.3679 10.997 15.9519 11.7966 16.0174 11.8297 16.0154 11.9753 15.9494 12.0063 14.945 12.4779 13.0706 13.9264 12.055 15m3.5006-3.0333C13.1345 12.0608 8 12 6 11" stroke="currentcolor" stroke-linecap="round"/></svg></a></div><div class=comments><script>const getTheme=window.localStorage&&window.localStorage.getItem("theme");let theme=getTheme==="dark"?"dark":"light",s=document.createElement("script");s.src="https://giscus.app/client.js",s.setAttribute("data-repo","xialeistudio/discussion"),s.setAttribute("data-repo-id","R_kgDOKurTRA"),s.setAttribute("data-category","General"),s.setAttribute("data-category-id","DIC_kwDOKurTRM4CbCJt"),s.setAttribute("data-mapping","pathname"),s.setAttribute("data-strict","0"),s.setAttribute("data-reactions-enabled","1"),s.setAttribute("data-emit-metadata","0"),s.setAttribute("data-input-position","bottom"),s.setAttribute("data-theme",theme),s.setAttribute("data-lang","en"),s.setAttribute("data-loading","lazy"),s.setAttribute("crossorigin","anonymous"),s.setAttribute("async",""),document.querySelector("div.comments").innerHTML="",document.querySelector("div.comments").appendChild(s)</script></div></article></div><footer class=footer><p>&copy; 2014 - 2025 <a href=https://www.ddhigh.com>每天进步一点点</a>
Powered by
<a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>
<a href=https://github.com/guangzhengli/hugo-theme-ladder rel=noopener target=_blank>Ladder</a>
️</p></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.5376 22.7916C11.0152 22.7207 22.5795 21.1781 22.0978 10.4211 22.0536 9.43274 21.9303 8.53367 21.7387 7.71865M10.5376 22.7916C16.876 22.3728 20.0969 19.8899 21.5383 16.9142M10.5376 22.7916C9.7707 22.9055 8.97982 22.8964 8.19743 22.7725M21.7387 7.71865C21.4988 6.69828 21.1518 5.80967 20.7188 5.04257m1.0199 2.67608C22.6022 10.1105 23.0542 13.7848 21.5383 16.9142M20.7188 5.04257c-3.5504-6.28886-12.88753-4.410077-16.44303.0C2.88063 6.77451-.0433281 11.1668 1.38159 16.6571c.89322 3.4417 3.7911 5.6365 6.81584 6.1154M20.7188 5.04257c1.3509 1.89783 3.3111 6.34223 1.6353 10.37273M21.5383 16.9142C21.8737 16.4251 22.1428 15.9235 22.3541 15.4153M8.19743 22.7725C12.1971 23.4683 20.6281 22.971 22.3541 15.4153M14 10.945C13.3836 10.289 12.003 8.63215 11.2034 7.04814 11.1703 6.98257 11.0247 6.98456 10.9937 7.05061 10.5221 8.05496 9.07362 9.92941 8 10.945m3.0333-3.50056C10.9392 9.86549 11 15 12 17" stroke="currentcolor" stroke-linecap="round"/></svg></a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function n(){t.innerHTML="Copied",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)}),e.parentNode.appendChild(t)})</script><script src=https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js integrity="sha512-9DNXrSjk17bU9MUbRp3IjwcWe46V8FaGA062PFbryPUAEQVRbz4jiZP6FW0AdbqEGtMYBDWnul3eiGBMJOQajA==" crossorigin=anonymous referrerpolicy=no-referrer></script></main></body><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script><script>const images=Array.from(document.querySelectorAll(".blog-content img"));images.forEach(e=>{mediumZoom(e,{margin:10,scrollOffset:40,container:null,template:null,background:"rgba(0, 0, 0, 0.5)"})})</script><script src=/main.min.6bb26b69159420159c74dc9e097b06a578ed2b68c701466a91a44a9632d851bd0af167a1b30012387b4c512b48ad9ad4d3394e04d77ae38d57e1920fe4ed34fe.js integrity="sha512-a7JraRWUIBWcdNyeCXsGpXjtK2jHAUZqkaRKljLYUb0K8WehswASOHtMUStIrZrU0zlOBNd6441X4ZIP5O00/g==" crossorigin=anonymous defer></script></html>