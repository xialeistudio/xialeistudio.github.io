<!doctype html><html lang=en><head><meta name=viewport content="width=device-width,initial-scale=1"><title>string</title>
<meta charset=utf-8><meta name=description content="Ladder@Learning & Writing & Sharing"><meta name=author content="Lei Xia"><link rel=canonical href=https://www.ddhigh.com/tags/string/><link rel=alternate type=application/rss+xml href=https://www.ddhigh.com/index.xml title="Lei Xia"><script async defer data-website-id=865c8529-0729-4cf5-88a9-448616abbcbb src=https://umami-beta-peach.vercel.app/xialeistudio></script><meta property="og:title" content="string"><meta property="og:description" content="Learning & Writing & Sharing"><meta property="og:type" content="website"><meta property="og:url" content="https://www.ddhigh.com/tags/string/"><meta name=twitter:card content="summary"><meta name=twitter:title content="string"><meta name=twitter:description content="Learning & Writing & Sharing"><link rel=icon href=/img/favicon.ico sizes=16x16><link rel=apple-touch-icon href=/img/favicon.ico><link rel=manifest href=/img/favicon.ico><link rel=stylesheet href=https://cdn.staticfile.org/lxgw-wenkai-webfont/1.6.0/style.css><link rel=stylesheet href=/css/main.min.ff1bc260fafbfb440e10194d7d06d57eb5e85eed11d12d06255581262664204e.css integrity="sha256-/xvCYPr7+0QOEBlNfQbVfrXoXu0R0S0GJVWBJiZkIE4=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/highlight/github-dark.min.min.66034289ee9a113219a2c4aae0a8bd2095ab255c832a42efcf5863f10814e7a1.css><script src=/js/highlight.min.min.894ca9c68afab956438c4926a0dc7f5293e04e08595bd27abdb123e94801f684.js></script><script>hljs.highlightAll()</script><script>(()=>{var t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,e=localStorage.getItem("theme");t&&e===null&&(localStorage.setItem("theme","dark"),document.documentElement.setAttribute("data-dark-mode","")),t&&e==="dark"&&document.documentElement.setAttribute("data-dark-mode",""),e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script></head><body><main class=wrapper><nav class=navigation><section class=container><a class=navigation-brand href=/>HOME
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><span></span><span></span><span></span></label><ul class=navigation-list id=navigation-list><li class="navigation-item navigation-menu"><a class=navigation-link href=/archives>Archive</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/tags>Tags</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/guestbook>Guestbook</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class="navigation-item navigation-social"><a class=navigation-link href=https://github.com/xialeistudio><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li class="navigation-item navigation-dark"><button id=mode type=button aria-label="toggle user light or dark theme">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span><span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></li></ul></section></nav><div id=content><div class=blog-wrapper><div><div class=blog-list><article><div class=blog-card><h3><a href=/2022/02/06/binary-tree-level-order-traversal-ii/>LeetCode107——二叉树的层序遍历 II</a></h3><p><small>February 6, 2022&nbsp;· 138 words&nbsp;· One minute</small><p>题目 给你二叉树的根节点 root ，返回其节点值 自底向上的层序遍历 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）
示例 1：
输入：root = [3,9,20,null,null,15,7] 输出：[[15,7],[9,20],[3]] 示例 2：
输入：root = [1] 输出：[[1]] 示例 3：
输入：root = [] 输出：[] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 直接用层序遍历即可，结果数组翻转之后就是答案
// BFS正向遍历，最后翻转一下最终结果 func levelOrderBottom(root *TreeNode) [][]int { if root == nil { return [][]int{} } answers := [][]int{} queue := []*TreeNode{root} for len(queue) > 0 { size := len(queue) tmp := queue queue = []*TreeNode{} // 清空，存储下一层的节点 level := []int{} for i := 0; i &lt; size; i++ { node := tmp[0] tmp = tmp[1:] level = append(level, node.</div></article><article><div class=blog-card><h3><a href=/2022/02/06/unique-binary-search-trees-ii/>LeetCode95——不同的二叉搜索树 II</a></h3><p><small>February 6, 2022&nbsp;· 138 words&nbsp;· One minute</small><p>题目 给你一个整数 n ，请你生成并返回所有由 n 个节点组成且节点值从 1 到 n 互不相同的不同 二叉搜索树 。可以按 任意顺序 返回答案。
示例 1：
输入：n = 3 输出：[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]] 示例 2：
输入：n = 1 输出：[[1]]
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/unique-binary-search-trees-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 由于每个节点都可以成为根节点，因此遍历1~n，i为遍历参数名称，此时可以构造如下树 1~i-1为左子树 i为根节点 i+1~n为右子树 递归的调用步骤1可以得到所有的组合 func generateTrees(n int) []*TreeNode { if n == 0 { return nil } return generate(1, n) } // 生成start ~ end的数列表 func generate(start, end int) []*TreeNode { // 非法条件拦截 if start > end { return []*TreeNode{nil} } allNodes := []*TreeNode{} // 遍历n for i := start; i &lt;= end; i++ { // start ~ i-1可以构造左子树节点 leftTrees := generate(start, i-1) // i+1 ~ end可以构造右子树节点 rightTrees := generate(i+1, end) for _, left := range leftTrees { for _, right := range rightTrees { // 组装左根右节点 root := &amp;TreeNode{Val: i} root.</div></article><article><div class=blog-card><h3><a href=/2022/02/06/validate-binary-search-tree/>LeetCode98——验证二叉搜索树</a></h3><p><small>February 6, 2022&nbsp;· 110 words&nbsp;· One minute</small><p>题目 给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。
有效 二叉搜索树定义如下：
节点的左子树只包含 小于 当前节点的数。 节点的右子树只包含 大于 当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。
示例 1：
输入：root = [2,1,3] 输出：true 示例 2：
输入：root = [5,1,4,null,null,3,6] 输出：false 解释：根节点的值是 5 ，但是右子节点的值是 4 。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/validate-binary-search-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 直接用中序遍历即可。中序遍历可以保证后一个值一定比前一个值大。
中序遍历处理顺序：左->根->右
// 中序遍历，值如果都是升序就满足要求 func isValidBST(root *TreeNode) bool { var ( lastValue = math.MinInt64 // 上一个值，初始化时保证是最小值即可，这样只要树节点有值就能大于该值 helper func(root *TreeNode) bool // 判断指定节点是否大于lastValue ) helper = func(root *TreeNode) bool { if root == nil { // 节点为空，直接返回true return true } if !</div></article><article><div class=blog-card><h3><a href=/2022/02/06/recover-binary-search-tree/>LeetCode99——恢复二叉搜索树</a></h3><p><small>February 6, 2022&nbsp;· 196 words&nbsp;· One minute</small><p>题目 给你二叉搜索树的根节点 root ，该树中的 恰好 两个节点的值被错误地交换。请在不改变其结构的情况下，恢复这棵树 。
示例 1：
输入：root = [1,3,null,null,2] 输出：[3,1,null,null,2] 解释：3 不能是 1 的左孩子，因为 3 > 1 。交换 1 和 3 使二叉搜索树有效。 示例 2：
输入：root = [3,1,4,null,null,2] 输出：[2,1,4,null,null,3] 解释：2 不能在 3 的右子树中，因为 2 &lt; 3 。交换 2 和 3 使二叉搜索树有效。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/recover-binary-search-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 中序遍历构造一个数组，根据二叉搜索树的性质，中序遍历是严格递增的 遍历该数组，找出后一个值小于前一个值的下标，根据这两个下标访问数组，可以得到两个错误值 遍历二叉树，根据第2步的两个值定位两个二叉树节点 交换两个节点的值 // 1. 中序遍历构造一个数组 // 2. 检查数组顺序，定位有问题的下标 // 3. 中序遍历原来的树，定位指定下标的节点， 交换两个节点值 func recoverTree(root *TreeNode) { // 构造数组 var values []int var valueGetter func(root *TreeNode) valueGetter = func(root *TreeNode) { if root == nil { return } valueGetter(root.</div></article><article><div class=blog-card><h3><a href=/2022/02/06/binary-tree-level-order-traversal/>LeetCode102--二叉树的层序遍历</a></h3><p><small>February 6, 2022&nbsp;· 123 words&nbsp;· One minute</small><p>题目 给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。
示例 1：
输入：root = [3,9,20,null,null,15,7] 输出：[[3],[9,20],[15,7]] 示例 2：
输入：root = [1] 输出：[[1]] 示例 3：
输入：root = [] 输出：[] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 层序遍历直接用广度有限遍历即可。
用两个队列存储本层节点tmp和下一层节点queue（可以简化处理清理，避免一个队列操作时即弹出又插入的问题） 获取队列长度，将queue复制到tmp,清空本层节点变量(queue) tmp不断出队即可，出队时把后代节点插入queue // BFS遍历即可 // 用队列处理，需要注意的是，每次处理一层，每层的大小就是队列的大小，可以准备两个队列，一个用来存储本层，一个用来存储下一层 func levelOrder(root *TreeNode) [][]int { if root == nil { return [][]int{} } answers := [][]int{} queue := []*TreeNode{root} for len(queue) > 0 { size := len(queue) tmp := queue queue = []*TreeNode{} // 清空，存储下一层的节点 level := []int{} for i := 0; i &lt; size; i++ { node := tmp[0] tmp = tmp[1:] level = append(level, node.</div></article><article><div class=blog-card><h3><a href=/2022/02/05/odd-even-linked-list/>LeetCode328——奇偶链表</a></h3><p><small>February 5, 2022&nbsp;· 178 words&nbsp;· One minute</small><p>题目 给定单链表的头节点 head ，将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后返回重新排序的列表。
第一个节点的索引被认为是 奇数 ， 第二个节点的索引为 偶数 ，以此类推。
请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致。
你必须在 O(1) 的额外空间复杂度和 O(n) 的时间复杂度下解决这个问题。
示例 1:
输入: head = [1,2,3,4,5] 输出: [1,3,5,2,4] 示例2:
输入: head = [2,1,3,5,6,4,7] 输出: [2,3,6,7,1,5,4] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/odd-even-linked-list 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/odd-even-linked-list 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 定义2个链表，odd为奇数链表，even为偶数链表 遍历原链表，根据奇偶位置插入odd或者even 连接odd和even // 1. 定义以下节点 // 1. 偶链表头节点，移动节点 // 2. 奇链表头结点，移动节点 // 2. 奇链表尾节点.Next = 偶链表头结点 func oddEvenList(head *ListNode) *ListNode { // 0,1,2个节点时直接返回 if head == nil || head.Next == nil || head.</div></article><article><div class=blog-card><h3><a href=/2022/02/05/linked-list-cycle-ii/>LeetCode142——环形链表2</a></h3><p><small>February 5, 2022&nbsp;· 168 words&nbsp;· One minute</small><p>题目 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。
如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。
不允许修改 链表。
示例 1：
输入：head = [3,2,0,-4], pos = 1 输出：返回索引为 1 的链表节点 解释：链表中有一个环，其尾部连接到第二个节点。 示例 2：
输入：head = [1,2], pos = 0 输出：返回索引为 0 的链表节点 解释：链表中有一个环，其尾部连接到第一个节点。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/linked-list-cycle-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 哈希表 参考上一篇环形链表，可以利用哈希表存储节点，当再次遇到该节点时，该节点就是成环点。
// 1. 遍历节点存入map // 2. 如果节点已存在，则该节点是成环节点 func detectCycle(head *ListNode) *ListNode { m := make(map[*ListNode]struct{}) p := head for p != nil { if _, ok := m[p]; ok { return p } m[p] = struct{}{} p = p.</div></article><article><div class=blog-card><h3><a href=/2022/02/05/linked-list-cycle/>LeetCode141——环形链表</a></h3><p><small>February 5, 2022&nbsp;· 144 words&nbsp;· One minute</small><p>题目 给你一个链表的头节点 head ，判断链表中是否有环。
如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。
如果链表中存在环 ，则返回 true 。 否则，返回 false 。
示例 1：
输入：head = [3,2,0,-4], pos = 1 输出：true 解释：链表中有一个环，其尾部连接到第二个节点。 示例 2：
输入：head = [1,2], pos = 0 输出：true 解释：链表中有一个环，其尾部连接到第一个节点。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/linked-list-cycle 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 哈希表法 利用哈希表存储访问过的节点，如果遍历时节点在哈希表，则有环。
Go语言中map的value为struct可以不占用存储空间。
func hasCycle(head *ListNode) bool { m := map[*ListNode]struct{}{} for head != nil { if _, ok := m[head]; ok { return true } m[head] = struct{}{} head = head.</div></article><article><div class=blog-card><h3><a href=/2022/02/05/reverse-linked-list-ii/>LeetCode92——反转链表 II</a></h3><p><small>February 5, 2022&nbsp;· 365 words&nbsp;· 2 min</small><p>题目 给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。
示例 1： 输入：head = [1,2,3,4,5], left = 2, right = 4 输出：[1,4,3,2,5]
示例 2：
输入：head = [5], left = 1, right = 1 输出：[5]
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/reverse-linked-list-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 转数组 大部分的链表题只要未要求原节点上操作，都可以转数组处理，缺点是空间复杂度会额外增加达到O(n)。
将原链表按顺序转为数组 遍历数组，翻转left ~ right之间的数组，此处用双指针即可 定义left和right指针，交换left和right的值 两个指针同时向中间移动，left++,right&ndash; 将数组构造为链表返回 // 数组法 // 1. 链表转换为数组 // 2. 翻转left ~ right的数据 // 3. 重新构造链表 func reverseBetween(head *ListNode, left int, right int) *ListNode { array := convertListToArray(head) reverseArrayPart(array, left-1, right-1) return buildLinkList(array) } // 翻转数组指定区间 func reverseArrayPart(array []int, left, right int) { for left &lt; right { array[left], array[right] = array[right], array[left] left++ right-- } } // 链表构造为数组 func convertListToArray(head *ListNode) []int { array := make([]int, 0) for head !</div></article><article><div class=blog-card><h3><a href=/2021/12/29/algo-binarysearch/>算法篇——二分查找</a></h3><p><small>December 29, 2021&nbsp;· 164 words&nbsp;· One minute</small><p>本系列文章将学习/复习常用算法和数据结构。希望能够深入浅出的将复杂的知识讲清楚、说明白。
本文介绍第一个基础算法：二分查找。二分查找算法可以在有序的数组中快速查询指定值。
要求：有序数组 时间复杂度：O(logN) 空间复杂度：O(1) 例子 大家应该玩过数字猜大小的游戏，接下来看看实际过程。
主持人从1~10选择1个数字，参与者每次猜1个数字，主持人给出提示正确/大了/小了。次数最少的获胜。
线性查找 主持人选定数字5。 参与者：10 主持人：大了 参与者：9 主持人：大了 参与者：8 主持人：大了 &mldr; 参与者：5 主持人：正确 参与者采用线性报数方式，从最大的数字开始报，每次减1直到猜中。上面的例子主持人选的数字是5，参与者猜了6次（10,9,8,7,6,5)。效率是O(N)。
主持人的大了/小了提示没有利用上，这肯定不是效率最高的方法。
二分查找 主持人选定数字8。 参与者：5 主持人：小了 参与者：7 主持人：小了 参与者：8 主持人：正确 参与者根据主持人的大了/小了提示每次调整猜测范围直到猜中。上面的例子中主持人选的数字是8，参与者猜了3次：
(0+10)/2 => 5，小了，所以下一次应该猜 比5大的数字，从 5 ~ 10继续猜 (5+10)/2 => 7(8也可以)，小了，所以下一次继续猜比7大的数字，从7~10继续猜 (7+10)/2 => 8(9也可以)，正确 可以看到二分查找法每次都能过滤掉1半的数据，达到了O(logN)的时间复杂度
代码示例 给定一个有序数组，返回指定值的索引，如果有序数组不存在该值，返回-1。
思路：
找中间值，(0 + 数组最后一位的所以)/2得到中间值的位置，然后对比中间值和目标值大小 如果目标值比中间值小，那么目标值在数组前半部分，应该继续查找 0 ~ 数组中间索引-1的这部分 如果目标值比中间值大，那么目标值在数组后半部分，应该继续查找 数组中间索引+1 ~ 数组结尾的这部分 为什么继续查找时中间索引要+1或者-1移动？
因为中间值已经比对过了，不满足条件，所以可以直接跳过中间值往前面后者后面一个位置继续查找
package main import "fmt" func main() { fmt.Println(search([]int{1, 2, 3, 4, 5, 6, 7}, 5)) } func search(nums []int, target int) int { begin := 0 end := len(nums) - 1 for begin &lt;= end { // 开始位置不能超过结束位置，超过证明所以数据都查过了 midIndex := (begin + end) / 2 // 中间索引 midValue := nums[midIndex] // 中间值 fmt.</div></article></div><div class=paginator><a class=prev href=/tags/string/page/3/>&larr;&nbsp;&nbsp;Pre Page</a>
<a class=next href=/tags/string/page/5/>Next Page&nbsp;&nbsp;&rarr;</a></div></div></div></div><footer class=footer><p>&copy; 2014 - 2023 <a href=https://www.ddhigh.com>Lei Xia</a>
Powered by
<a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>
<a href=https://github.com/guangzhengli/hugo-theme-ladder rel=noopener target=_blank>Ladder</a>
<a href=https://umami-beta-peach.vercel.app/ target=_blank>Statistics</a>
️</p></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.5376 22.7916C11.0152 22.7207 22.5795 21.1781 22.0978 10.4211 22.0536 9.43274 21.9303 8.53367 21.7387 7.71865M10.5376 22.7916C16.876 22.3728 20.0969 19.8899 21.5383 16.9142M10.5376 22.7916C9.7707 22.9055 8.97982 22.8964 8.19743 22.7725M21.7387 7.71865C21.4988 6.69828 21.1518 5.80967 20.7188 5.04257m1.0199 2.67608C22.6022 10.1105 23.0542 13.7848 21.5383 16.9142M20.7188 5.04257c-3.5504-6.28886-12.88753-4.410077-16.44303.0C2.88063 6.77451-.0433281 11.1668 1.38159 16.6571c.89322 3.4417 3.7911 5.6365 6.81584 6.1154M20.7188 5.04257c1.3509 1.89783 3.3111 6.34223 1.6353 10.37273M21.5383 16.9142C21.8737 16.4251 22.1428 15.9235 22.3541 15.4153M8.19743 22.7725C12.1971 23.4683 20.6281 22.971 22.3541 15.4153M14 10.945C13.3836 10.289 12.003 8.63215 11.2034 7.04814 11.1703 6.98257 11.0247 6.98456 10.9937 7.05061 10.5221 8.05496 9.07362 9.92941 8 10.945m3.0333-3.50056C10.9392 9.86549 11 15 12 17" stroke="currentcolor" stroke-linecap="round"/></svg></a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function n(){t.innerHTML="Copied",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)}),e.parentNode.appendChild(t)})</script></main></body><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script><script>const images=Array.from(document.querySelectorAll(".blog-content img"));images.forEach(e=>{mediumZoom(e,{margin:10,scrollOffset:40,container:null,template:null,background:"rgba(0, 0, 0, 0.5)"})})</script><script src=/main.min.6bb26b69159420159c74dc9e097b06a578ed2b68c701466a91a44a9632d851bd0af167a1b30012387b4c512b48ad9ad4d3394e04d77ae38d57e1920fe4ed34fe.js integrity="sha512-a7JraRWUIBWcdNyeCXsGpXjtK2jHAUZqkaRKljLYUb0K8WehswASOHtMUStIrZrU0zlOBNd6441X4ZIP5O00/g==" crossorigin=anonymous defer></script></html>