<!doctype html><html lang=en><head><meta name=viewport content="width=device-width,initial-scale=1"><title>C++</title>
<meta charset=utf-8><meta name=description content="Ladder@Learning & Writing & Sharing"><meta name=author content="Lei Xia"><link rel=canonical href=https://www.ddhigh.com/tags/c++/><link rel=alternate type=application/rss+xml href=https://www.ddhigh.com/index.xml title="Lei Xia"><script async defer data-website-id=865c8529-0729-4cf5-88a9-448616abbcbb src=https://umami-beta-peach.vercel.app/xialeistudio></script><meta property="og:title" content="C++"><meta property="og:description" content="Learning & Writing & Sharing"><meta property="og:type" content="website"><meta property="og:url" content="https://www.ddhigh.com/tags/c++/"><meta name=twitter:card content="summary"><meta name=twitter:title content="C++"><meta name=twitter:description content="Learning & Writing & Sharing"><link rel=icon href=/img/favicon.ico sizes=16x16><link rel=apple-touch-icon href=/img/favicon.ico><link rel=manifest href=/img/favicon.ico><link rel=stylesheet href=https://cdn.staticfile.org/lxgw-wenkai-webfont/1.6.0/style.css><link rel=stylesheet href=/css/main.min.ff1bc260fafbfb440e10194d7d06d57eb5e85eed11d12d06255581262664204e.css integrity="sha256-/xvCYPr7+0QOEBlNfQbVfrXoXu0R0S0GJVWBJiZkIE4=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/highlight/github-dark.min.min.66034289ee9a113219a2c4aae0a8bd2095ab255c832a42efcf5863f10814e7a1.css><script src=/js/highlight.min.min.894ca9c68afab956438c4926a0dc7f5293e04e08595bd27abdb123e94801f684.js></script><script>hljs.highlightAll()</script><script>(()=>{var t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,e=localStorage.getItem("theme");t&&e===null&&(localStorage.setItem("theme","dark"),document.documentElement.setAttribute("data-dark-mode","")),t&&e==="dark"&&document.documentElement.setAttribute("data-dark-mode",""),e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script></head><body><main class=wrapper><nav class=navigation><section class=container><a class=navigation-brand href=/>HOME
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><span></span><span></span><span></span></label><ul class=navigation-list id=navigation-list><li class="navigation-item navigation-menu"><a class=navigation-link href=/archives>Archive</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/tags>Tags</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/guestbook>Guestbook</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class="navigation-item navigation-social"><a class=navigation-link href=https://github.com/xialeistudio><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li class="navigation-item navigation-dark"><button id=mode type=button aria-label="toggle user light or dark theme">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span><span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></li></ul></section></nav><div id=content><div class=blog-wrapper><div><div class=blog-list><article><div class=blog-card><h3><a href=/2023/01/03/shuffle-algorithm/>洗牌算法</a></h3><p><small>January 3, 2023&nbsp;· 99 words&nbsp;· One minute</small><p>洗牌算法用来将给定的序列打乱，可以认为是排序的反操作。
正确性判断 对于包含$n$个元素的序列，其全排列有$n!$种。如果序列打乱的结果为$n!$种且每种序列出现的概率相同，则是正确的洗牌算法。
Fisher–Yates 洗牌算法 以下算法说明摘自: https://gaohaoyang.github.io/2016/10/16/shuffle-algorithm/
Fisher–Yates shuffle 的原始版本，最初描述在 1938 年的 Ronald Fisher和 Frank Yates 写的书中，书名为《Statistical tables for biological, agricultural and medical research》。他们使用纸和笔去描述了这个算法，并使用了一个随机数表来提供随机数。它给出了 1 到 N 的数字的的随机排列，具体步骤如下：
写下从 1 到 N 的数字 取一个从 1 到剩下的数字（包括这个数字）的随机数 k 从低位开始，得到第 k 个数字（这个数字还没有被取出），把它写在独立的一个列表的最后一位 重复第 2 步，直到所有的数字都被取出 第 3 步写出的这个序列，现在就是原始数字的随机排列 已经证明如果第 2 步取出的数字是真随机的，那么最后得到的排序一定也是。
正确性证明 正确的洗牌算法要保证每个数字出现在每个位置的概率一样。我们来看看Fisher–Yates洗牌算法是否正确。
假设现在有1,2,3,4,5五个数字。
首先在1-5随机一个数，假设是4，随机概率为1/5 再次从1,2,3,5中随机一个数，假设是5，随机概率为1/4，但是5在第一步没被选上的概率是4/5，因此总体概率是1/4*4/5还是1/5 代码 public void shuffle(int[] nums) { var n = nums.length; for (int i = 0; i &lt; n; i++) { int newIndex = i + random.</div></article><article><div class=blog-card><h3><a href=/2022/12/31/cyclic-sort/>原地哈希算法</a></h3><p><small>December 31, 2022&nbsp;· 214 words&nbsp;· 2 min</small><p>原地哈希算法(Cyclic Sort)主要应用在值都在$[0,n]$的数组$nums$中，此时可以将$nums[i]$作为索引，放回原数组，当然，由于程序上索引是从0开始，因此可以将$nums[i]$放到$nums[nums[i]-1]$的位置上。
举例 Leetcode 268. 丢失的数字
给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。
示例 1：
输入：nums = [3,0,1] 输出：2 解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。 示例 2：
输入：nums = [0,1] 输出：2 解释：n = 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，因为它没有出现在 nums 中。 示例 3：
输入：nums = [9,6,4,2,3,5,7,0,1] 输出：8 解释：n = 9，因为有 9 个数字，所以所有的数字都在范围 [0,9] 内。8 是丢失的数字，因为它没有出现在 nums 中。 示例 4：
输入：nums = [0] 输出：1 解释：n = 1，因为有 1 个数字，所以所有的数字都在范围 [0,1] 内。1 是丢失的数字，因为它没有出现在 nums 中。 提示：</div></article><article><div class=blog-card><h3><a href=/2022/12/31/eratosthenes-sieve/>厄拉多塞筛素数筛选算法</a></h3><p><small>December 31, 2022&nbsp;· 197 words&nbsp;· One minute</small><p>厄拉多塞筛算法（Eratosthenes Sieve）是一种求素数的方法，由古希腊数学家厄拉多塞提出。它的原理是，给定一个数 n，从 2 开始依次将 $\sqrt n$ 以内的素数的倍数标记为合数，标记完成后，剩余未被标记的数为素数（从 2 开始）。如此可省去检查每个数的步骤，使筛选素数的过程更加简单。
算法 厄拉多塞筛算法具体步骤如下：
读取输入的数 n，将 2 到 n 的所有整数记录在表中 从 2 开始，划去表中所有 2 的倍数 由小到大寻找表中下一个未被划去的整数，再划去表中所有该整数的倍数 重复第（3）步，直到找到的整数大于$\sqrt n$为止 表中所有未被划去的整数均为素数 朴素的素数筛选算法如下：对给定的数字$i$，设定数字$j$从$2$遍历到$\sqrt i$，如果中间$i$能整除$j$，则$i$不是素数。该方法的时间复杂度为$O(n\sqrt n)$ ,$n$是数组长度，外层循环需要遍历$n$次，内层循环需要遍历$\sqrt n$次。
而厄拉多塞筛算法的时间复杂度为$O(n log(log(n)))$。
举例 这是一张来自维基百科的算法示意图。
先从2开始遍历，将2的倍数(2,4,6,8,&mldr;)标记为为非素数 继续遍历，当前数字是素数时，继续将当前数字的倍数标记为非素数 直到所有数字标记完，重新标记数组，未被标记的就是素数 算法题 Leetcode 204. 计数质数
给定整数 n ，返回 所有小于非负整数 n 的质数的数量 。
示例 1：
输入：n = 10 输出：4 解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。 示例 2：</div></article><article><div class=blog-card><h3><a href=/2022/12/31/boyer-moore-majority-vote-algorithm/>博耶-摩尔多数投票算法</a></h3><p><small>December 31, 2022&nbsp;· 263 words&nbsp;· 2 min</small><p>来自维基百科的解释：
博耶-摩尔多数投票算法（英语：Boyer–Moore majority vote algorithm）,中文常作多数投票算法、摩尔投票算法等，是一种用来寻找一组元素中占多数元素的常数空间级时间复杂度算法。这一算法由罗伯特·S·博耶（英语：Robert S. Boyer）和J·斯特罗瑟·摩尔（英语：J Strother Moore）在1981年发表[1]，也是处理数据流（英语：streaming algorithm）的一种典型算法。
简单来说，博耶-摩尔多数投票算法用来寻找数组中的多数元素，相比于用哈希表存储元素和次数使用$O(n)$的时间复杂度来说，该投票算法使用$O(1)$的空间复杂度。
算法 摩尔投票算法分为投票-校验两个阶段。投票阶段会统计候选人的票数，遍历数组，如果当前数字和当前候选人不相等，则该候选人票数-1，当候选人票数归0时，需要更换候选人为当前数字；在校验阶段，需要重新遍历数字，并将值等于候选人的数字计数，遍历结束后，比如计数满足要求，则候选人满足要求。
举例 比如[A,A, A, B,C]这组元素，我们需要筛选数量超过一半的数字。
首先我们定A为候选人，然后遍历数组，遇到B时A有3个，由于A!=B，因此A结果为2，再和C比较，犹豫A!=C，因此A结尾为1，遍历结束，A是投票阶段的候选人；再遍历数组，统计A的数量为3，超过一半(5/2)，因此A是票数最高的元素。
算法题 Leetcode 229. 多数元素 II
给定一个大小为 n 的整数数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。
示例 1：
输入：nums = [3,2,3] 输出：[3] 示例 2：
输入：nums = [1] 输出：[1] 示例 3：
输入：nums = [1,2] 输出：[1,2] 思路 题目要求找出所有出现次数超过n/3次的元素，由于摩尔投票算法空间复杂度是常数，因此需要预先定义候选人个数。
设出现次数超过n/3次的元素有$x$个，以下是求解$x$的过程： $$ \begin{equation}\label{eqn:1} \begin{aligned} & 假设刚好是n/3个 \ & \because x * n/3 = n \ & \therefore x=3 \ & 而实际上题目要求次数 > n/3 \ & \therefore x &lt; 3 \ & \therefore x = 2 \end{aligned} \end{equation} $$ 所以本题最多能选择2个候选人。</div></article><article><div class=blog-card><h3><a href=/2022/12/30/radix-sort/>基数排序算法</a></h3><p><small>December 30, 2022&nbsp;· 282 words&nbsp;· 2 min</small><p>基数排序又叫桶排序，是一种时间复杂度为$O(n)$的排序算法，但是相比于其他排序算法有$O(n)$的空间复杂度。
思路 基数排序的核心思路如下：
准备0~9的10个桶，根据数字当前比较位的值来决定放入哪个桶。如当前比较个位，则数字13应该放入索引为3的桶中；当前比较百位，则123应该放入索引为1的桶中。 当所有数字全部放入桶之后，遍历0~9这10个桶，然后依次将数字保存到待排序数组，因为桶是有序的，所以本轮放回去的数字是有序的。 当前比较的位数左移，比如本轮比较个位，下一轮应该比较百位。 重复步骤1~3。 举例 现在我们来看一个实际例子。
待排序数字：717, 328, 803, 422, 586, 944, 557, 308, 496, 624
第1轮比较个位 直接按照个位放入桶中。
0 1 2 3 4 5 6 7 8 9 422 803 624 586 717 328 496 557 308 按照从左到右，从上到下的原则将数字归位：422,803,624,586,496,717,557,328,308
第2轮比较十位 0 1 2 3 4 5 6 7 8 9 803 717 422 557 586 496 308 624 328 按照从左到右，从上到下的原则将数字归位：803,308,717,422,624,328,557,586,496
第3轮比较百位 0 1 2 3 4 5 6 7 8 9 308 422 557 624 717 803 328 496 586 按照从左到右，从上到下的原则将数字归位：308,328,422,496,557,586,624,717,803</div></article><article><div class=blog-card><h3><a href=/2022/03/17/palindrome-partitioning/>算法篇-leetcode 131 分割回文串</a></h3><p><small>March 17, 2022&nbsp;· 630 words&nbsp;· 3 min</small><p>题目 给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。
回文串 是正着读和反着读都一样的字符串。
示例1
输入：s = "aab" 输出：[["a","a","b"],["aa","b"]] 解答 题目要求
将字符串字符打散后，将其中的回文串添加到一个单独的List 第1步的所有List构成最后的答案 可以看出，这是一个典型的回溯问题，考察有多少种方法可以组装最后的答案。
方法一：直接回溯 思路及算法
回溯需要回答以下3个问题：
回溯终止条件是什么？ 回溯有哪些选择? 如何进入下一个选择？ 对于本题来说，我们需要将字符串打散，从中选择回文串添加到最终答案，因此，需要定义以下变量:
$index$, 记录当前选择的字符索引 $path$, 记录本次回文串选择情况 $answer$, 记录最终答案 回答上面提出来的两个问题：
回溯终止条件: $index==s.length()$，此时将$path$拷贝到$answer$，不可以直接添加，因为回溯存在撤回操作，必须断开$answer$和$path$的引用。 回溯有哪些选择：定义变量$right$, 遍历 $s[index,s.length())$，当$s[index,right]$是回文串时，将其加入$path$。 如何进入下一个选择：第2个问题满足条件的情况下，增加$index$然后再次递归即可。 class Solution { /** * DFS回溯 * 1. 回溯出口 index == s.length() * 2. 回溯递进 遍历[i,n) 如果s[i,j] 是回文串，则加入path，然后递归 s[i,j+1] * * @param s * @return */ public List&lt;List&lt;String>> partition(String s) { List&lt;List&lt;String>> answer = new ArrayList&lt;>(); List&lt;String> path = new ArrayList&lt;>(); dfs(answer, path, 0, s.</div></article><article><div class=blog-card><h3><a href=/2022/02/08/construct-binary-tree-from-inorder-and-postorder-traversal/>LeetCode106——从中序与后序遍历序列构造二叉树</a></h3><p><small>February 8, 2022&nbsp;· 125 words&nbsp;· One minute</small><p>题目 给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。
示例 1:
输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3] 输出：[3,9,20,null,null,15,7] 示例 2:
输入：inorder = [-1], postorder = [-1] 输出：[-1] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 核心是中序遍历的顺序是[左，根，右]，后序遍历是[左，右，根]。而同一颗树不管前/中/后序遍历，节点数是不变的。
// 后序遍历顺序: 左右根 // 1. postorder最后一个元素为根 // 2. 遍历inorder查找根的index // 3. inorder[:index]为左子树，inorder[index+1:]为右子树，左子树大小记为leftTreeSize // 4. postorder[:leftTreeSize]为左子树，postorder[leftTreeSize:len(postorder)-1]是右子树 func buildTree(inorder []int, postorder []int) *TreeNode { n := len(inorder) if n == 0 { return nil } if n == 1 { return &amp;TreeNode{Val: inorder[0]} } // 查找中序遍历根的index index := -1 rootValue := postorder[len(postorder)-1] for i := 0; i &lt; len(inorder); i++ { if inorder[i] == rootValue { index = i break } } // 分割数组 leftTreeSize := len(inorder[:index]) root := &amp;TreeNode{Val: rootValue} root.</div></article><article><div class=blog-card><h3><a href=/2022/02/08/convert-sorted-array-to-binary-search-tree/>LeetCode108——将有序数组转换为二叉搜索树</a></h3><p><small>February 8, 2022&nbsp;· 106 words&nbsp;· One minute</small><p>题目 给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。
高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。
示例 1：
输入：nums = [-10,-3,0,5,9] 输出：[0,-3,9,-10,null,5] 示例 2：
输入：nums = [1,3] 输出：[3,1] 解释：[1,3] 和 [3,1] 都是高度平衡二叉搜索树。 思路 二叉树的中序遍历是升序，节点顺序为[左，根，右]
对于给定的数组，根据升序的性质，可知，中间节点为根节点，左半部分为左子树，右半部分为右子树 左半部分也是一颗完整的树，复用1的逻辑，因此用递归即可 // 升序数组是树的中序遍历结果，中间Index就是根，可以递归的还原为一个树 func sortedArrayToBST(nums []int) *TreeNode { if len(nums) == 0 { return nil } if len(nums) == 1 { return &amp;TreeNode{Val: nums[0]} } return helper(nums, 0, len(nums)-1) } func helper(nums []int, start, end int) *TreeNode { if start > end { return nil } // 取得根 rootIndex := (start + end) / 2 rootValue := nums[rootIndex] root := &amp;TreeNode{Val: rootValue} root.</div></article><article><div class=blog-card><h3><a href=/2022/02/08/convert-sorted-list-to-binary-search-tree/>LeetCode109——有序链表转换二叉搜索树</a></h3><p><small>February 8, 2022&nbsp;· 292 words&nbsp;· 2 min</small><p>题目 给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。
本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。
示例:
给定的有序链表： [-10, -3, 0, 5, 9], 一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树： 0 / \ -3 9 / / -10 5 思路 转换为数组 转换为数组后解法跟前面一道题一样。
// 链表转换为数组，复用108解法 func sortedListToBST(head *ListNode) *TreeNode { if head == nil { return nil } list := listToArray(head) return helper(list, 0, len(list)-1) } func listToArray(head *ListNode) []int { result := []int{} for head != nil { result = append(result, head.</div></article><article><div class=blog-card><h3><a href=/2022/02/06/binary-tree-zigzag-level-order-traversal/>LeetCode103——二叉树的锯齿形层序遍历</a></h3><p><small>February 6, 2022&nbsp;· 149 words&nbsp;· One minute</small><p>题目 给你二叉树的根节点 root ，返回其节点值的 锯齿形层序遍历 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。
示例 1：
输入：root = [3,9,20,null,null,15,7] 输出：[[3],[20,9],[15,7]] 示例 2：
输入：root = [1] 输出：[[1]] 示例 3：
输入：root = [] 输出：[] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 用层序遍历的思路即可，不过偶数行需要将该行的值翻转。
// BFS处理，记录遍历层数，当层数是奇数，翻转下本层元素 func zigzagLevelOrder(root *TreeNode) [][]int { if root == nil { return [][]int{} } answers := [][]int{} queue := []*TreeNode{root} for level := 1; len(queue) > 0; level++ { size := len(queue) tmp := queue queue = []*TreeNode{} // 清空，存储下一层的节点 vals := []int{} for i := 0; i &lt; size; i++ { node := tmp[0] tmp = tmp[1:] vals = append(vals, node.</div></article></div><div class=paginator><a class=prev href=/tags/c++/page/2/>&larr;&nbsp;&nbsp;Pre Page</a>
<a class=next href=/tags/c++/page/4/>Next Page&nbsp;&nbsp;&rarr;</a></div></div></div></div><footer class=footer><p>&copy; 2014 - 2023 <a href=https://www.ddhigh.com>Lei Xia</a>
Powered by
<a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>
<a href=https://github.com/guangzhengli/hugo-theme-ladder rel=noopener target=_blank>Ladder</a>
<a href=https://umami-beta-peach.vercel.app/ target=_blank>Statistics</a>
️</p></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.5376 22.7916C11.0152 22.7207 22.5795 21.1781 22.0978 10.4211 22.0536 9.43274 21.9303 8.53367 21.7387 7.71865M10.5376 22.7916C16.876 22.3728 20.0969 19.8899 21.5383 16.9142M10.5376 22.7916C9.7707 22.9055 8.97982 22.8964 8.19743 22.7725M21.7387 7.71865C21.4988 6.69828 21.1518 5.80967 20.7188 5.04257m1.0199 2.67608C22.6022 10.1105 23.0542 13.7848 21.5383 16.9142M20.7188 5.04257c-3.5504-6.28886-12.88753-4.410077-16.44303.0C2.88063 6.77451-.0433281 11.1668 1.38159 16.6571c.89322 3.4417 3.7911 5.6365 6.81584 6.1154M20.7188 5.04257c1.3509 1.89783 3.3111 6.34223 1.6353 10.37273M21.5383 16.9142C21.8737 16.4251 22.1428 15.9235 22.3541 15.4153M8.19743 22.7725C12.1971 23.4683 20.6281 22.971 22.3541 15.4153M14 10.945C13.3836 10.289 12.003 8.63215 11.2034 7.04814 11.1703 6.98257 11.0247 6.98456 10.9937 7.05061 10.5221 8.05496 9.07362 9.92941 8 10.945m3.0333-3.50056C10.9392 9.86549 11 15 12 17" stroke="currentcolor" stroke-linecap="round"/></svg></a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function n(){t.innerHTML="Copied",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)}),e.parentNode.appendChild(t)})</script></main></body><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script><script>const images=Array.from(document.querySelectorAll(".blog-content img"));images.forEach(e=>{mediumZoom(e,{margin:10,scrollOffset:40,container:null,template:null,background:"rgba(0, 0, 0, 0.5)"})})</script><script src=/main.min.6bb26b69159420159c74dc9e097b06a578ed2b68c701466a91a44a9632d851bd0af167a1b30012387b4c512b48ad9ad4d3394e04d77ae38d57e1920fe4ed34fe.js integrity="sha512-a7JraRWUIBWcdNyeCXsGpXjtK2jHAUZqkaRKljLYUb0K8WehswASOHtMUStIrZrU0zlOBNd6441X4ZIP5O00/g==" crossorigin=anonymous defer></script></html>