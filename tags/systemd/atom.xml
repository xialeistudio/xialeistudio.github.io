<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>systemd on Lei Xia</title><link>https://www.ddhigh.com/tags/systemd/</link><description>Recent content in systemd on Lei Xia</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Thu, 28 Feb 2019 21:51:16 +0000</lastBuildDate><atom:link href="https://www.ddhigh.com/tags/systemd/atom.xml" rel="self" type="application/rss+xml"/><item><title>使用systemd来构建你的服务</title><link>https://www.ddhigh.com/2019/02/28/build-service-by-systemd/</link><pubDate>Thu, 28 Feb 2019 21:51:16 +0000</pubDate><guid>https://www.ddhigh.com/2019/02/28/build-service-by-systemd/</guid><description>&lt;h2 id="systemd是什么">systemd是什么&lt;/h2>
&lt;p>Systemd 服务是一种以 .service 结尾的单元（unit）配置文件，用于控制由Systemd 控制或监视的进程。简单说，用于后台以守护精灵（daemon）的形式运行程序。&lt;/p>
&lt;h2 id="为什么要使用systemd">为什么要使用systemd&lt;/h2>
&lt;ol>
&lt;li>service文件编写简单易用&lt;/li>
&lt;li>可以自动维持进程存活（强大的功能，可以取代PM2）&lt;/li>
&lt;li>自动收集进程输出的输出&lt;/li>
&lt;/ol>
&lt;h2 id="systemd主要命令">systemd主要命令&lt;/h2>
&lt;p>可以看到systemd以字母d结尾，根据linux惯用规则，可以判断该进程为守护进程，可以通过&lt;code>systemctl&lt;/code>与之交互。&lt;/p>
&lt;pre tabindex="0">&lt;code>systemctl start redis.service #启动服务
systemctl stop redis.service #停止服务
systemctl restart redis.service #重启服务
systemctl enable redis.service #将redis设置为开机启动
&lt;/code>&lt;/pre>&lt;h2 id="编写systemd">编写systemd&lt;/h2>
&lt;p>systmd service文件一般放在&lt;code>/etc/systemd/system/&lt;/code>文件夹中。&lt;/p>
&lt;p>systemd service文件是结构化的，以下给出一份笔者常用的清单。&lt;/p>
&lt;pre tabindex="0">&lt;code>[Unit]
Description=Git Auto Update Hook Service
After=network.target
[Service]
Type=simple
ExecStart=/root/src/git-hookd/git-hookd
Restart=always
[Install]
WantedBy=multi-user.target
&lt;/code>&lt;/pre>&lt;p>拿之前写过的init.d的脚本对比一下&lt;/p>
&lt;pre tabindex="0">&lt;code>#!/bin/bash
### BEGIN INIT INFO
# Provides: xialeistudio
# Required-Start: $network
# Required-Stop: $local_fs
# Default-Start: 2 3 4 5
# Default-Stop: 0 1 6
# Short-Description: test service
# Description: test service
### END INIT INFO
PROG=&amp;#34;testd&amp;#34;
PROG_PATH=&amp;#34;/root/apps/testd&amp;#34;
PROG_ARGS=&amp;#34;-u xialei&amp;#34;
PID_PATH=&amp;#34;/var/run/&amp;#34;
start() {
if [ -e &amp;#34;$PID_PATH/$PROG.pid&amp;#34; ]; then
echo &amp;#34;Error! $PROG is running!&amp;#34; 2&amp;gt;&amp;amp;1
exit 1
else
$PROG_PATH/$PROG $PROG_ARGS 2&amp;gt;&amp;amp;1 &amp;gt; &amp;#34;/var/log/$PROG.log&amp;#34; &amp;amp;
pid=`ps ax|grep testd|awk &amp;#39;{print $2}&amp;#39;|head -n 1`
echo &amp;#34;$PROG started&amp;#34;
echo $pid &amp;gt; &amp;#34;$PID_PATH/$PROG.pid&amp;#34;
fi
}
stop() {
if [ -e &amp;#34;$PID_PATH/$PROG.pid&amp;#34; ]; then
pid=`ps ax|grep testd|awk &amp;#39;{print $2}&amp;#39;|head -n 1`
kill $pid
rm -rf &amp;#34;$PID_PATH/$PROG.pid&amp;#34;
echo &amp;#34;$PROG $pid killed&amp;#34;
else
echo &amp;#34;Error! $PROG not running!&amp;#34; 2&amp;gt;&amp;amp;1
exit 1
fi
}
if [ &amp;#34;$(id -u)&amp;#34; != &amp;#34;0&amp;#34; ]; then
echo &amp;#34;Please run as root!&amp;#34; 2&amp;gt;&amp;amp;1
exit 1
fi
case &amp;#34;$1&amp;#34; in
start)
start
exit 0
;;
stop)
stop
exit 0
;;
reload|restart)
stop
start
exit 0
;;
**)
echo &amp;#34;Usage: $0 {start|stop|reload}&amp;#34; 2&amp;gt;&amp;amp;1
exit 1
;;
esac
&lt;/code>&lt;/pre>&lt;p>可以看到init.d脚本实在是太原始了，systemd取代init.d指日可待&lt;/p>
&lt;h2 id="systemd-service文件说明">systemd service文件说明&lt;/h2>
&lt;p>service文件由 Unit, Service, Install 三部分组成&lt;/p>
&lt;h3 id="unit">Unit&lt;/h3>
&lt;p>所有引导过程中systemd要控制的文件/设备/程序等等都称为一个单元。&lt;/p>
&lt;ul>
&lt;li>Description: 服务描述&lt;/li>
&lt;li>Wants: 本单元启动成功，则会启动此字段定义的单元，如果Wants定义的单元启动失败，对本单元无影响&lt;/li>
&lt;li>Requires：本单元启动成功，则会启动此字段定义的单元，如果Requires定义的单元启动失败，本单元也失败。该字段无法控制先后顺序，如果Requires定义的单元未启动完成就启动本单元，那么一个都启动不了，不建议用这个字段&lt;/li>
&lt;li>OnFailure： 本单元如果启动失败，则启动该字段定义的单元&lt;/li>
&lt;li>Before/After：指定本单元的启动顺序&lt;/li>
&lt;/ul>
&lt;p>本例中只需要依赖网络单元即可&lt;/p>
&lt;h3 id="service">Service&lt;/h3>
&lt;p>服务本体定义：&lt;/p>
&lt;ul>
&lt;li>Type 启动类型&lt;/li>
&lt;li>ExecStart 启动服务的命令&lt;/li>
&lt;li>ExecStop 停止服务的命令（一般不写）&lt;/li>
&lt;li>Restart 重启规则&lt;/li>
&lt;li>RemainAfterExit 即使没有进程，也任务服务启动成功&lt;/li>
&lt;/ul>
&lt;p>Type 启动类型有以下几种：
+ simple： 默认类型，启动的进程将成为服务进程。
+ forking：标准Unix Daemon进程。本进程启动后会通过系统调用fork，把必要的通信频道都设置好之后父进程退出，留下守护精灵的子进程。（也就是说你自己来将进程变成daemon进程）
+ oneshot：一次性命令。该服务运行完毕后没有进程，所以需要配合RemainAfterExit。&lt;/p>
&lt;p>Restart 重启规则有以下几种：
+ no（默认值）：退出后不会重启
+ always：不管是什么退出原因，总是重启
+ on-success：只有正常退出时（退出状态码为0），才会重启
+ on-failure：非正常退出时（退出状态码非0），包括被信号终止和超时，才会重启
+ on-abnormal：只有被信号终止和超时，才会重启
+ on-abort：只有在收到没有捕捉到的信号终止时，才会重启
+ on-watchdog：超时退出，才会重启&lt;/p>
&lt;h3 id="install">Install&lt;/h3>
&lt;p>systemd装载规则定义&lt;/p>
&lt;ul>
&lt;li>WantedBy 将被谁装载，本例中使用multi-user.target，最终服务将通过软链接到&lt;code>/etc/systemd/system/multi-user.target.wants&lt;/code>目录&lt;/li>
&lt;li>Alias 服务别名，可以通过 &lt;code>systemctl 服务别名 restart&lt;/code> 之类的来操作&lt;/li>
&lt;/ul>
&lt;h2 id="写在最后">写在最后&lt;/h2>
&lt;p>是时候通过systemd改写init.d的服务了，有必要的话可以连pm2守护的进程都交给systemd来处理。&lt;/p></description></item></channel></rss>