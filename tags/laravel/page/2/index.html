<!doctype html><html lang=en><head><meta name=viewport content="width=device-width,initial-scale=1"><title>laravel</title>
<meta charset=utf-8><meta name=description content="Ladder@Learning & Writing & Sharing"><meta name=author content="Lei Xia"><link rel=canonical href=https://www.ddhigh.com/tags/laravel/><link rel=alternate type=application/rss+xml href=https://www.ddhigh.com/index.xml title="Lei Xia"><script async defer data-website-id=865c8529-0729-4cf5-88a9-448616abbcbb src=https://umami-beta-peach.vercel.app/xialeistudio></script><meta property="og:title" content="laravel"><meta property="og:description" content="Learning & Writing & Sharing"><meta property="og:type" content="website"><meta property="og:url" content="https://www.ddhigh.com/tags/laravel/"><meta name=twitter:card content="summary"><meta name=twitter:title content="laravel"><meta name=twitter:description content="Learning & Writing & Sharing"><link rel=icon href=/img/favicon.ico sizes=16x16><link rel=apple-touch-icon href=/img/favicon.ico><link rel=manifest href=/img/favicon.ico><link rel=stylesheet href=https://cdn.staticfile.org/lxgw-wenkai-webfont/1.6.0/style.css><link rel=stylesheet href=/css/main.min.ff1bc260fafbfb440e10194d7d06d57eb5e85eed11d12d06255581262664204e.css integrity="sha256-/xvCYPr7+0QOEBlNfQbVfrXoXu0R0S0GJVWBJiZkIE4=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/highlight/github-dark.min.min.66034289ee9a113219a2c4aae0a8bd2095ab255c832a42efcf5863f10814e7a1.css><script src=/js/highlight.min.min.894ca9c68afab956438c4926a0dc7f5293e04e08595bd27abdb123e94801f684.js></script><script>hljs.highlightAll()</script><script>(()=>{var t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,e=localStorage.getItem("theme");t&&e===null&&(localStorage.setItem("theme","dark"),document.documentElement.setAttribute("data-dark-mode","")),t&&e==="dark"&&document.documentElement.setAttribute("data-dark-mode",""),e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script></head><body><main class=wrapper><nav class=navigation><section class=container><a class=navigation-brand href=/>HOME
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><span></span><span></span><span></span></label><ul class=navigation-list id=navigation-list><li class="navigation-item navigation-menu"><a class=navigation-link href=/archives>Archive</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/tags>Tags</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/guestbook>Guestbook</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class="navigation-item navigation-social"><a class=navigation-link href=https://github.com/xialeistudio><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li class="navigation-item navigation-dark"><button id=mode type=button aria-label="toggle user light or dark theme">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span><span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></li></ul></section></nav><div id=content><div class=blog-wrapper><div><div class=blog-list><article><div class=blog-card><h3><a href=/2023/04/20/fix-gomonkey-permission-defined/>修复M1使用gomonkey提示permission defined错误</a></h3><p><small>April 20, 2023&nbsp;· 20 words&nbsp;· One minute</small><p>问题 Go单元测试在M1上使用github.com/agiledragon/gomonkey/v2 v2.9.0包提示permission defined。 网上查阅消息得知是由于内存安全导致，不能同时对内存进行写和执行
解决方法 下面分享一种比较简单的方法，需要修改本地的go源码。
修改go/pkg/mod/github.com/agiledragon/gomonkey/v2@v2.9.0/modify_binary_darwin.go的modifyBinary方法。 将
err := mprotectCrossPage(target, len(bytes), syscall.PROT_READ|syscall.PROT_WRITE|syscall.PROT_EXEC) 修改为
err := mprotectCrossPage(target, len(bytes), syscall.PROT_READ|syscall.PROT_WRITE)</div></article><article><div class=blog-card><h3><a href=/2023/02/10/topological-sorting/>拓补排序</a></h3><p><small>February 10, 2023&nbsp;· 150 words&nbsp;· One minute</small><p>在计算机科学领域，有向图的拓扑排序或拓扑测序是对其顶点的一种线性排序，使得对于从顶点$u$到顶点$v$的每个有向边$uv$, $u$在排序中都在$v$之前。
例如，图形的顶点可以表示要执行的任务，并且边可以表示一个任务必须在另一个任务之前执行的约束；在这个应用中，拓扑排序只是一个有效的任务顺序。
当且仅当图中没有定向环时（即有向无环图），才有可能进行拓扑排序。
任何有向无环图至少有一个拓扑排序。
算法 遍历有向边，构造u->v边中v的入度表，可使用哈希存储入度 将入度为0的节点入队 队列节点不断出队，出队时减小被更新节点的入度，如果被更新节点入度为0，则该节点入队 重复以上过程，最终可以得到一个从入度为0到最终节点的序列，这就是拓补排序算法。 示例 Leetcode 210. 课程表2
class Solution { // 生成邻接表 &lt;当前节点，后置节点> // 进行BFS拓补排序，由最低依赖的开始写入答案 public int[] findOrder(int numCourses, int[][] prerequisites) { Set&lt;Integer>[] graph = new HashSet[numCourses]; for (int i = 0; i &lt; numCourses; i++) { graph[i] = new HashSet&lt;>(); } // 入度 int[] inDegree = new int[numCourses]; for (int[] p : prerequisites) { int current = p[0]; int pre = p[1]; graph[pre].</div></article><article><div class=blog-card><h3><a href=/2023/01/19/reservoir-sampling/>水塘抽样算法</a></h3><p><small>January 19, 2023&nbsp;· 100 words&nbsp;· One minute</small><p>下面是维基百科水塘抽样的说明。
水塘抽样是一系列的随机算法，其目的在于从包含 $n$个项目的集合 中选取$k$ 个样本，其中 $n$为一很大或未知的数量，尤其适用于不能把所有 $n$ 个项目都存放到内存的情况。
本文分享在随机数据流中等概率抽取target的水塘抽样算法。
算法 定义$count$计数变量 遍历给定的数据流，如果当前数字等于$target$, $count$+1 在$[0, count]$产生随机数，如果等于$count$，则抽样成功 示例 Leetcode 398. 随机数索引
代码
class Solution { // 哈希表保存&lt;值,List&lt;下标>> private final int[] nums; private final Random random; public Solution(int[] nums) { this.nums = nums; this.random = new Random(System.currentTimeMillis()); } // 水塘抽样 // 统计target count,随机数%count 为0时重置index public int pick(int target) { var count = 0; var index = 0; for (var i = 0; i &lt; nums.</div></article><article><div class=blog-card><h3><a href=/2023/01/19/time-difference/>时间差计算算法</a></h3><p><small>January 19, 2023&nbsp;· 103 words&nbsp;· One minute</small><p>本文分享如何解决计算时间差类的问题。
算法 首先需要将时间转化为数字，比如23:59，可以转化为23*60+59 然后根据数字从小到大排序，此时从[0, n]处的数据有序，可以遍历该区间计算差值 需要注意的是，由于时间的特殊性，比如23:59下一分会归0，因此还需要比如0处和n处的时间差 示例 Leetcode 539. 最小时间差
代码
class Solution { // 模拟 // 时间字符串转化为数字 // 排序，线性遍历，然后再比较第一个和最后一个的差值 public int findMinDifference(List&lt;String> timePoints) { // 24小时总共1440个可能，超过1440，直接返回0（存在重复时间点） if (timePoints.size() > 1440) { return 0; } var array = new int[timePoints.size()]; for (int i = 0; i &lt; timePoints.size(); i++) { var str = timePoints.get(i); array[i] = Integer.parseInt(str.substring(0, 2)) * 60 + Integer.parseInt(str.substring(3)); } Arrays.sort(array); var answer = Integer.MAX_VALUE; for (int i = 1; i &lt; array.</div></article><article><div class=blog-card><h3><a href=/2023/01/19/slide-window-algorithm/>滑动窗口算法</a></h3><p><small>January 19, 2023&nbsp;· 128 words&nbsp;· One minute</small><p>滑动窗口算法是查找连续区间常用的算法之一。
本文分享滑动窗口算法的通用框架。
算法 定义$left$和$right$双指针，代表窗口的左边界和右边界 当$right$小于给定区间大小时，我们可以进行操作。 在扩大窗口时，需要加当前新加入的数据进行处理 当当前窗口内数据不满足条件时，右移$left$指针缩小窗口 计算$[left,right]$之间的数据，和最佳答案比较并更新最佳答案 右移$right$ 下面是滑动窗口通用框架的java语言实现。
int left = 0; int right = 0; while(right &lt; 上界) { 将right处数据加入窗口 while(窗口数据不符合要求) { 移除left数据 left++ } 根据当前right和left计算最佳答案并更新 right++ } 示例 Leetcode 3. 无重复字符的最长子串
思路
基于算法框架的思路如下：
定义$left$和$right$双指针，代表窗口的左边界和右边界，再定义HashMap&lt;Character, Integer>存储窗口内的字符和数量(可以使用长度为128的字符数组代替，省去操作hashmap的开销。 当$right$小于$s.length()$时，我们可以进行操作。 在扩大窗口时，将$s.charAt(right)$加入HashMap 当HashMap.get(s.charAt(right)>1)，此时$right$处字符重复，需要收缩左边界，$left$处的字符数量-1，右移$left$ 计算$[left,right]$之间的数据，和最佳答案比较并更新最佳答案 代码
class Solution { // 滑动窗口 // 定义left,right, hashmap&lt;char,int> // 循环条件 right&lt;s.length() // right字符入map // while刚才入的字符重复，map移除left的字符，left++ // 计算长度 // right++ public int lengthOfLongestSubstring(String s) { var left = 0; var right = 0; var answer = 0; var map = new int[128]; while (right &lt; s.</div></article><article><div class=blog-card><h3><a href=/2023/01/05/subsequence-checking-algorithm/>字符串子序列检测算法</a></h3><p><small>January 5, 2023&nbsp;· 63 words&nbsp;· One minute</small><p>本文分享一种检测一个字符串是否为另一个字符串子序列的算法。
子序列的定义：
若字符串$s1$可以由字符串$s2$删除某些字符得到，则$s1$是$s2$的子序列。换句话说，若$s1$的所有字符都在$s2$中且顺序一致，则$s1$是$s2$的子序列。
例如：
a是aaa的子序列，adf是abcdef的子序列，但是cba不是abc的子序列（因为字符顺序变了）。
算法 声明$s1$的下标变量$strIndex$，若$s2$有$s1$的该字符，则$strIndex+1$ 若遍历过程中$strIndex$和$s1$的长度相等，则证明$s1$所有字符都在$s2$中，返回$s1$是$s2$在子序列 遍历结束仍未返回，证明$s1$不是$s2$的子序列 代码 class Solution { public boolean isSubsequent(String str, String str1) { var strIndex = 0; // 逐字符遍历 // 如果字符想通，则strIndex++ // 如果strIndex到达末尾，则证明str是子序列 for (var i = 0; i &lt; str1.length(); i++) { if (str.charAt(strIndex) == str1.charAt(i)) { strIndex++; } if (strIndex == str.length()) { return true; } } return false; } } 复杂度分析
时间复杂度：$O(n)$,$n$是$str1$的长度。
空间复杂度：$O(1)$。</div></article><article><div class=blog-card><h3><a href=/2023/01/05/counting-bit1-of-binary-number/>计算数字二进制位中1的个数</a></h3><p><small>January 5, 2023&nbsp;· 48 words&nbsp;· One minute</small><p>本文分享一种计算给定数字二进制表示中有多少个1的算法。
位运算对于非硬件相关的开发者来说可能用的比较少，朴素做法是将数字转换为二进制字符串，然后遍历该字符串得到1的个数。
算法 通过右移我们可以访问到数字的指定比特 将该比特与1进行按位与&，结果为1则证明当前比特位是1，计数器+1 根据给定数字的数据类型可以确定需要位移的次数，对于int来说，4个字节，因此需要右移32次，而对于long来说，8个字节，需要右移64次。
代码 class Solution { public int getBit1Count(int num) { var count = 0; for (int i = 0; i &lt; 32; i++) { if (((num >> i) & 1) == 1) { count++; } } return count; } } 复杂度分析
时间复杂度：$O(1)$，不管多大的数字，只需要右移32次。
空间复杂度：$O(1)$，无需额外空间。</div></article><article><div class=blog-card><h3><a href=/2023/01/03/parse-number-in-string/>解析字符串中的数字</a></h3><p><small>January 3, 2023&nbsp;· 108 words&nbsp;· One minute</small><p>本文分享一种如何在字符串中解析数字的算法。
思路 解析字符串中的数字需要判断当前是否是数字字符，以及如何处理连续的数字字符。
本文使用while循环来解析数字，之所以不使用for循环，是笔者认为while循环操控力比for循环要好。
while循环解析方法如下：
如果当前字符是数字，则开启内部while循环 内部while循环退出条件为当前字符不是数字 内部循环操作为读取当前数字，然后加上一个数字乘以10 内部循环退出后，我们就得到一个连续的数字 示例 Leetcode 2042. 检查句子中的数字是否递增
class Solution { // 提取字符串中的数字，判断是否严格递增 public boolean areNumbersAscending(String s) { // 定义上一个数字，初始化为最小的数字 var lastNumber = Integer.MIN_VALUE; var i = 0; while (i &lt; s.length()) { if (Character.isDigit(s.charAt(i))) { // 当前是数字，继续处理 var number = 0; // 核心代码 while (i &lt; s.length() && Character.isDigit(s.charAt(i))) { // 字符串没越界而且当前字符是数字字符 number = number * 10 + (s.charAt(i) - '0'); // (s.charAt(i) - '0') 就是利用ASCII码表直接得到数字值，不需要再做parseInt i++; // 坐标后移 } if (number &lt;= lastNumber) { // 如果当前数字&lt;=上一个数字，证明不是严格递增，return false return false; } // number > lastNumber，更新lastNumber lastNumber = number; } // i后移 i++; } return true; } } 复杂度分析</div></article><article><div class=blog-card><h3><a href=/2023/01/03/nth-maximum-number/>查找第N大的数</a></h3><p><small>January 3, 2023&nbsp;· 206 words&nbsp;· One minute</small><p>在给定的序列中查找第N大的数，朴素做法是对序列排序，然后根据索引直接查询，时间复杂度为$O(nlogn)$。
本文介绍一种在$O(n)$的时间复杂度查询第N大的数的算法。
算法 算法思路就是定义标志变量，然后遍历数组，根据标志变量和当前数组变量的大小更新标志变量，最后根据情况返回标志变量。
示例：查找第2大的数 定义$first$和$second$分别存储最大和次大，然后遍历数组时更新即可。
/** * 查找第二大的数字 */ public class SecondMaximumNumber { public int secondMaximumNumber(int[] nums) { // 最大数 var first = Integer.MIN_VALUE; // 次大数 var second = Integer.MIN_VALUE; for (var num : nums) { // 当前数字比最大数还大，最大数更新为当前数字，原来的最大数更新为第2大 if (num >= first) { second = first; first = num; } else if (num >= second) { // 当前数字小于最大，但是大于第2大，更新第2大 second = num; } } return second; } public static void main(String[] args) { var nums = new int[]{1, 3, 2, 8, 5}; var s = new SecondMaximumNumber(); System.</div></article><article><div class=blog-card><h3><a href=/2023/01/03/shuffle-algorithm/>洗牌算法</a></h3><p><small>January 3, 2023&nbsp;· 99 words&nbsp;· One minute</small><p>洗牌算法用来将给定的序列打乱，可以认为是排序的反操作。
正确性判断 对于包含$n$个元素的序列，其全排列有$n!$种。如果序列打乱的结果为$n!$种且每种序列出现的概率相同，则是正确的洗牌算法。
Fisher–Yates 洗牌算法 以下算法说明摘自: https://gaohaoyang.github.io/2016/10/16/shuffle-algorithm/
Fisher–Yates shuffle 的原始版本，最初描述在 1938 年的 Ronald Fisher和 Frank Yates 写的书中，书名为《Statistical tables for biological, agricultural and medical research》。他们使用纸和笔去描述了这个算法，并使用了一个随机数表来提供随机数。它给出了 1 到 N 的数字的的随机排列，具体步骤如下：
写下从 1 到 N 的数字 取一个从 1 到剩下的数字（包括这个数字）的随机数 k 从低位开始，得到第 k 个数字（这个数字还没有被取出），把它写在独立的一个列表的最后一位 重复第 2 步，直到所有的数字都被取出 第 3 步写出的这个序列，现在就是原始数字的随机排列 已经证明如果第 2 步取出的数字是真随机的，那么最后得到的排序一定也是。
正确性证明 正确的洗牌算法要保证每个数字出现在每个位置的概率一样。我们来看看Fisher–Yates洗牌算法是否正确。
假设现在有1,2,3,4,5五个数字。
首先在1-5随机一个数，假设是4，随机概率为1/5 再次从1,2,3,5中随机一个数，假设是5，随机概率为1/4，但是5在第一步没被选上的概率是4/5，因此总体概率是1/4*4/5还是1/5 代码 public void shuffle(int[] nums) { var n = nums.length; for (int i = 0; i &lt; n; i++) { int newIndex = i + random.</div></article></div><div class=paginator><a class=prev href=/tags/laravel/>&larr;&nbsp;&nbsp;Pre Page</a>
<a class=next href=/tags/laravel/page/3/>Next Page&nbsp;&nbsp;&rarr;</a></div></div></div></div><footer class=footer><p>&copy; 2014 - 2023 <a href=https://www.ddhigh.com>Lei Xia</a>
Powered by
<a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>
<a href=https://github.com/guangzhengli/hugo-theme-ladder rel=noopener target=_blank>Ladder</a>
<a href=https://umami-beta-peach.vercel.app/ target=_blank>Statistics</a>
️</p></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.5376 22.7916C11.0152 22.7207 22.5795 21.1781 22.0978 10.4211 22.0536 9.43274 21.9303 8.53367 21.7387 7.71865M10.5376 22.7916C16.876 22.3728 20.0969 19.8899 21.5383 16.9142M10.5376 22.7916C9.7707 22.9055 8.97982 22.8964 8.19743 22.7725M21.7387 7.71865C21.4988 6.69828 21.1518 5.80967 20.7188 5.04257m1.0199 2.67608C22.6022 10.1105 23.0542 13.7848 21.5383 16.9142M20.7188 5.04257c-3.5504-6.28886-12.88753-4.410077-16.44303.0C2.88063 6.77451-.0433281 11.1668 1.38159 16.6571c.89322 3.4417 3.7911 5.6365 6.81584 6.1154M20.7188 5.04257c1.3509 1.89783 3.3111 6.34223 1.6353 10.37273M21.5383 16.9142C21.8737 16.4251 22.1428 15.9235 22.3541 15.4153M8.19743 22.7725C12.1971 23.4683 20.6281 22.971 22.3541 15.4153M14 10.945C13.3836 10.289 12.003 8.63215 11.2034 7.04814 11.1703 6.98257 11.0247 6.98456 10.9937 7.05061 10.5221 8.05496 9.07362 9.92941 8 10.945m3.0333-3.50056C10.9392 9.86549 11 15 12 17" stroke="currentcolor" stroke-linecap="round"/></svg></a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function n(){t.innerHTML="Copied",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)}),e.parentNode.appendChild(t)})</script></main></body><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script><script>const images=Array.from(document.querySelectorAll(".blog-content img"));images.forEach(e=>{mediumZoom(e,{margin:10,scrollOffset:40,container:null,template:null,background:"rgba(0, 0, 0, 0.5)"})})</script><script src=/main.min.6bb26b69159420159c74dc9e097b06a578ed2b68c701466a91a44a9632d851bd0af167a1b30012387b4c512b48ad9ad4d3394e04d77ae38d57e1920fe4ed34fe.js integrity="sha512-a7JraRWUIBWcdNyeCXsGpXjtK2jHAUZqkaRKljLYUb0K8WehswASOHtMUStIrZrU0zlOBNd6441X4ZIP5O00/g==" crossorigin=anonymous defer></script></html>