<!doctype html><html lang=en><head><meta name=viewport content="width=device-width,initial-scale=1"><title>spring-boot</title>
<meta charset=utf-8><meta name=description content="Ladder@Learning & Writing & Sharing"><meta name=author content="Lei Xia"><link rel=canonical href=https://www.ddhigh.com/tags/spring-boot/><link rel=alternate type=application/rss+xml href=https://www.ddhigh.com/index.xml title="Lei Xia"><script async defer data-website-id=865c8529-0729-4cf5-88a9-448616abbcbb src=https://umami-beta-peach.vercel.app/xialeistudio></script><meta property="og:title" content="spring-boot"><meta property="og:description" content="Learning & Writing & Sharing"><meta property="og:type" content="website"><meta property="og:url" content="https://www.ddhigh.com/tags/spring-boot/"><meta name=twitter:card content="summary"><meta name=twitter:title content="spring-boot"><meta name=twitter:description content="Learning & Writing & Sharing"><link rel=icon href=/img/favicon.ico sizes=16x16><link rel=apple-touch-icon href=/img/favicon.ico><link rel=manifest href=/img/favicon.ico><link rel=stylesheet href=https://cdn.staticfile.org/lxgw-wenkai-webfont/1.6.0/style.css><link rel=stylesheet href=/css/main.min.ff1bc260fafbfb440e10194d7d06d57eb5e85eed11d12d06255581262664204e.css integrity="sha256-/xvCYPr7+0QOEBlNfQbVfrXoXu0R0S0GJVWBJiZkIE4=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/highlight/github-dark.min.min.66034289ee9a113219a2c4aae0a8bd2095ab255c832a42efcf5863f10814e7a1.css><script src=/js/highlight.min.min.894ca9c68afab956438c4926a0dc7f5293e04e08595bd27abdb123e94801f684.js></script><script>hljs.highlightAll()</script><script>(()=>{var t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,e=localStorage.getItem("theme");t&&e===null&&(localStorage.setItem("theme","dark"),document.documentElement.setAttribute("data-dark-mode","")),t&&e==="dark"&&document.documentElement.setAttribute("data-dark-mode",""),e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script></head><body><main class=wrapper><nav class=navigation><section class=container><a class=navigation-brand href=/>HOME
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><span></span><span></span><span></span></label><ul class=navigation-list id=navigation-list><li class="navigation-item navigation-menu"><a class=navigation-link href=/archives>Archive</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/tags>Tags</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/guestbook>Guestbook</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class="navigation-item navigation-social"><a class=navigation-link href=https://github.com/xialeistudio><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li class="navigation-item navigation-dark"><button id=mode type=button aria-label="toggle user light or dark theme">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span><span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></li></ul></section></nav><div id=content><div class=blog-wrapper><div><div class=blog-list><article><div class=blog-card><h3><a href=/2019/10/22/let-and-const/>不只是块级作用域，你不知道的let和const</a></h3><p><small>October 22, 2019&nbsp;· 171 words&nbsp;· One minute</small><p>ES6新增了两个重要的关键字let和const，相信大家都不陌生，但是包括我在内，在系统学习ES6之前也只使用到了【不存在变量提升】这个特性。
let声明一个块级作用域的本地变量 const语句声明一个块级作用域的本地常量，不可以重新赋值 支持块级作用域 var定义的变量会提升到整个函数作用域内，let/const则支持块级作用域。
块级作用域: 由{}包裹的作用域（函数那种{}不算）
来看一个var的例子:
{ var a = 1; } console.log(a); 此时输出1，因为var没有块级作用域。
来看一个let的例子(const效果一样):
{ let a = 1; } console.log(a); 此时会报错ReferenceError，因为let/const支持块级作用域，所以let定义的a只在{}可以访问
不存在变量提升 与var不同的是，let/const声明的变量不存在变量提升，也就是说{}对于let/const是有效的。
来看一个var的例子:
console.log(a); var a = 1; 此时会输出undefined，因为var声明的变量会提升到作用域顶部（只提升声明，不提升赋值）
来看一个let的例子(const效果也一样):
console.log(a); let a = 1; 此时会报错ReferenceError，因为let不存在变量提升
同一作用域内不可以重复声明 同一作用域内let/const不可以重复声明,var可以。
来看一个var的例子:
var a = 1; var a = 2; console.log(a); 此时会输出2，var是支持重复声明的，后面声明的值会覆盖前面声明的值。
来看一个let的例子(const效果也一样):
let a = 1; let a = 2; console.log(a); 此时会报错SyntaxError，因为同一作用域内let/const不可以重复声明。
再来看一个不同作用域的例子：
let a = 1; { let a = 2; } console.</div></article><article><div class=blog-card><h3><a href=/2019/10/15/valueof-and-tostring/>聊一聊valueOf和toString</a></h3><p><small>October 15, 2019&nbsp;· 407 words&nbsp;· 2 min</small><p>valueOf和toString是Object.prototype的方法。一般很少直接调用，但是在使用对象参与运算的时候就会调用这两个方法了。我想大部分人都存在以下疑问：
valueOf和toString哪个优先级较高? 是不是所有场景都会调用valueOf和toString 概念解释 valueOf: 返回对象的原始值表示 toString: 返回对象的字符串表示 在介绍下面的内容之前先了解一下转换规则，下面的内容解释都是基于这个规则表来的：
valueOf转换规则 valueOf是Object.prototype的方法，由Object来的对象都会有该方法，但是很多内置对象会重写这个方法，以适合实际需要。
说到原始值就必须说到原始类型，JS规范中 原始类型 如下：
Boolean Null Undefined Number String 非原始值(也就是对象)重写规则如下：
对象 valueOf返回值 Array 数组本身 Boolean 布尔值 Date 返回毫秒形式的时间戳 Function 函数本身 Number 数字值 Object 对象本身 String 字符串值 以下规则是经过验证的，如果对验证过程不关心，可以只看转换规则。
建议看一下验证过程，这样可以加深理解
对象转换为布尔值 直接转换为true（包装类型也一样），不调用valueOf和toString 对象转换为数字 在预期会将对象用作数字使用时，比如参与算术运算等等操作，对象转换为数字会依次调用valueOf和toString方法，具体规则如下：
如果对象具有valueOf方法且返回原始值(string、number、boolean、undefined、null)，则将该原始值转换为数字(转换失败会返回NaN)，并返回这个数字 如果对象具有toString方法且返回原始值(string、number、boolean、undefined、null)，则将该原始值转换为数字(转换失败会返回NaN)，并返回这个数字 转换失败，抛出TypeError 对象转换为字符串 如果对象具有toString方法且返回原始值(string、number、boolean、undefined、null)，则将该原始值转换为字符串，并返回该字符串 如果对象具有valueOf方法且返回原始值(string、number、boolean、undefined、null)，则将该原始值转换为字符串，并返回该字符串 转换失败，抛出TypeError toString转换规则 对象 toString返回值 Array 以逗号分割的字符串，如[1,2]的toString返回值为"1,2" Boolean &ldquo;True&rdquo; Date 可读的时间字符串，如"Tue Oct 15 2019 12:20:56 GMT+0800 (中国标准时间)" Function 声明函数的JS源代码字符串 Number &ldquo;数字值&rdquo; Object &ldquo;[object Object]&rdquo; String &ldquo;字符串&rdquo; 验证对象到原始值的转换 光看valueOf和toString没啥东西可说，日常开发中也很少直接调用，但是当我们将对象当做原始值来使用时会发生转换，而且转换过程还略微有点迷糊。</div></article><article><div class=blog-card><h3><a href=/2019/10/14/js-closure/>搞懂JS闭包</a></h3><p><small>October 14, 2019&nbsp;· 198 words&nbsp;· One minute</small><p>闭包(Closure)是JS比较难懂的一个东西，或者说别人说的难以理解， 本文将以简洁的语言+面试题来深入浅出地介绍一下。
作用域和作用域链 在将闭包之前，需要先讲一下作用域。
JS中有全局作用域和局部作用域两种。
全局作用域任何地方都能访问，而局部作用于只有内部能访问。
function a() { var num = 1; } console.log(num); 在上面的例子中会报错，num不存在。
总结：函数外部无法访问函数内部的值
当代码在一个作用域中执行时，JS引擎会默认创建一个作用域链(从当前作用域一直链接到全局作用域)。
在访问变量或者函数时，如果当前作用域查找不到，则向上级作用域查找，找到就返回，如果查找到全局作用域还没找到的话就报错。
function a() { var num = 1; function b() { console.log(num); } } 在上面的例子中，num是在a函数作用域下的局部变量，我们在b函数访问num时会有以下过程：
在b的作用域查找num，发现找不到 往上一级作用域查找，发现num在a作用域，查找成功 总结：函数可以访问同级或上级作用域的值
闭包 当我们需要在函数外部访问函数内部的值时，闭包就产生了。
function a() { var num = 1; function b () { console.log(num); } return b; } var bb = a(); bb(); // 1 在函数a的内部声明一个函数b，然后把return b，这个时候的b()函数就可以在外部访问，最终能够访问到num。
简单来说：
闭包就是函数内部的函数，上面的那个b就是闭包，可以在外面访问到内部的num
面试题 // 每隔1秒输出0-10的数字 for(var i = 0;i&lt;10;i++) { setTimeout(function() { console.</div></article><article><div class=blog-card><h3><a href=/2019/10/11/https-protocol/>HTTPS协议是如何保证安全的?</a></h3><p><small>October 11, 2019&nbsp;· 89 words&nbsp;· One minute</small><p>相信大家对于HTTPS协议都不陌生，但是应该存在以下疑问：
HTTPS协议到底是如何运作的?
HTTPS是如何解决HTTP协议的不安全特性的?
HTTPS网站抓包为什么要信任证书?
HTTP协议 HTTP协议是一个应用层协议，通常运行在TCP协议之上。它是一个明文协议，客户端发起请求，服务端给出响应的响应。
由于网络并不是可信任的，HTTP协议的明文特性会存在以下风险：
通信数据有被窃听和被篡改的风险 目标网站有被冒充的风险 一般的网站可能没什么影响，但是如果是银行这种网站呢?
好在国内的银行在HTTP协议时代针对IE开发了ActiveX插件来保证安全性，这一点算是值得点赞了。
解决方案 既然HTTP协议是明文协议，如果对数据进行加密之后是否就能保证安全性了呢?
在回答这个问题之前，我们先看看比较常见的两种加密算法。
加密算法 常见的有对称加密算法和非对称加密算法。
对称加密
加密和解密使用同一个密钥。加解密效率比非对称加密高。但是密钥一旦泄露，通信就不安全了
非对称加密
存在密钥对，公钥加密私钥解密或者私钥加密公钥解密，无法通过公钥反推私钥，也无法通过私钥反推公钥。
一般情况下，使用非对称加密来传输通信所用的密钥，通信过程中采用对称加密，可以解决对称加密的安全问题以及非对称加密的性能问题。
HTTP加密通信过程 浏览器生成随机串A作为通信密钥 浏览器使用公钥将随机串A加密后得到密文B发送给服务器，这一步是安全的，因为黑客没有服务端私钥无法解密 服务端利用私钥解密出随机串A得到通信密钥 服务端和客户端用随机串A以及对称加密算法进行通信 这么一看似乎没有问题，毕竟黑客无法破解非对称加密的的内容，但是浏览器是如何得到公钥的?
有以下两种办法：
浏览器内置(不太可能，网站域名这么多，浏览器内置这么多公钥不现实) 服务器给浏览器下发(由于是明文下发，存在被窃听和篡改风险，也就是著名的中间人攻击) 中间人攻击 浏览器请求服务器获取公钥 中间人劫持了服务器的公钥，保存在自己手里 中间人生成一对密钥对，把伪造的公钥下发给浏览器 浏览器使用伪造的公钥和中间人通信 中间人和服务器进行通信 由于浏览器使用了伪造的公钥进行通信，所以通信过程是不可靠的
需要解决的问题 只要保证浏览器得到的公钥是目标网站的公钥即可保证通信安全，那么问题来了，如何在不可靠的网络上安全的传输公钥呢?
这就是HTTPS协议需要解决的问题
HTTPS协议 HTTPS协议涉及到的知识很多，本文只关注密钥安全交换部分，这也是HTTPS协议的精华。
HTTPS协议引入了CA和数字证书的概念。
数字证书 包含签发机构、有效期、申请人公钥、证书所有者、证书签名算法、证书指纹以及指纹算法等信息。
CA 数字证书签发机构，权威CA是受操作系统信任的，安装操作系统就会内置。
数字签名 用Hash算法对数据进行计算得到Hash值，利用私钥对该Hash加密得到签名。
只有匹配的公钥才能解密出签名，来保证签名是本人私钥签发的
证书签发过程 网站生成密钥对，将私钥自己保存，公钥和网站域名等信息提交给CA CA把证书签发机构(也就是自己)、证书有效期、网站的公钥、网站域名等信息以明文形式写入到一个文本文件 CA选择一个指纹算法(一般为hash算法)计算文本文件的内容得到指纹，用CA的私钥对指纹和指纹算法进行加密得到数字签名，签名算法包含在证书的明文部分 CA把明文证书、指纹、指纹算法、数字签名等信息打包在一起得到证书下发给服务器 此时服务器拥有了权威CA颁发的数字证书以及自己的私钥 证书验证过程 浏览器是如何验证网站的有效性的呢?
浏览器以HTTPS协议请求服务器的443端口 服务器下发自己的数字证书给浏览器(明文) 浏览器先校验CA、有效期、域名是否有效，如果无效，则终止连接(服务器此时不可信任) 如果有效，则从操作系统取出证书颁发机构的公钥，根据签名算法对数字签名解密得到证书指纹和指纹算法 浏览器用解密得到的指纹算法计算证书的指纹，与解密得到的指纹进行比对，如果一致，证书有效，公钥也安全拿到了 浏览器此时已经和真实的服务器进行通信了，中间人无法得知通信内容，因为中间人没有网站私钥 问题是如何解决的 黑客冒充CA给了一个假证书给浏览器
浏览器通过CA名称从操作系统取出CA公钥时对数字签名进行解密，发现解密失败，证明这个CA签名用的私钥和操作系统内置的不是一对，就发现了伪造
黑客篡改了证书中的网站公钥
证书中的网站公钥可以被篡改，但是数字签名是CA私钥计算出来的，黑客无法计算数字签名，浏览器用内置的CA公钥对数字签名解密时就会发现指纹不匹配了，这也发现了伪造
黑客也能正常获取网站公钥</div></article><article><div class=blog-card><h3><a href=/2019/09/27/javascript-this/>Javavscript基础——this指向</a></h3><p><small>September 27, 2019&nbsp;· 374 words&nbsp;· 2 min</small><p>本文研究一下Javascript的this指向。
Javascript的this指向问题，有些人可能觉得很简单，有些人却觉得扑朔迷离，看完本文之后相应会对this的掌握有一个直观的判断，而不是"开局全靠猜"。
敲黑板 function函数this指向由调用方式确定，跟定义环境无关。
箭头函数this指向由定义环境决定，与调用方式无关，也不可以bind(this)。
严格模式 非严格模式下，全局作用域下的this指向window
严格模式下，全局作用域下的this指向undefined
以下讨论均为非严格模式，这个不影响今天的讨论。
实践 说结论往往是让人难以理解的，下面通过不同的调用场景对this做一个说明。
1. 直接调用 function test() { console.log(this); } test(); // 输出undefined 直接调用是最简单的， 大部分人在这里都能回答的很好。
总结 直接调用时this指向全局作用域。
非严格模式this指向window 严格模式this指向undefined 2. 对象调用 'use strict' var n = 1; var a = { n: 2, b: function() { console.log(this.n); } }; a.b(); // 输出2 var b = a.b; b(); // 输出1 面试题：请问上述例子输出什么? 非严格模式下，输出2和1，严格模式下输出2和一个报错(this指向undefined，访问undefined的n属性肯定报错)
那如果你这么回答，满分!
分析 知其然还要知其所以然，我们分析一下：
为什么输出2?
因为a.b()是对象调用方式，所以b()中的this指向a
为什么输出1?
这个非常有意思，而且也很有迷惑性，面试的时候经常问到，也经常有人被问倒。
var b = a.b 把a.</div></article><article><div class=blog-card><h3><a href=/2019/09/23/javascript-prototype/>Javavscript基础——原型和原型链</a></h3><p><small>September 23, 2019&nbsp;· 289 words&nbsp;· 2 min</small><p>本文研究一下Javascript的核心基础——原型链和继承。
对于使用过基于类的语言(如Java或C#)的人来说，Javascript的继承有点难以搞懂，因为它本身没有class这种东西。(ES6中引入了class关键字，看上去也像传统的OOP语言，但是那只是语法糖，底层还是基于原型)。
原型链 MDN上对于原型链的解释：
当谈到继承时，JavaScript 只有一种结构：对象。每个实例对象（ object ）都有一个私有属性（称之为 __proto__ ）指向它的构造函数的原型对象（prototype ）。该原型对象也有一个自己的原型对象( __proto__ ) ，层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节。
几乎所有 JavaScript 中的对象都是位于原型链顶端的 Object 的实例。
这段话可能难以理解，我们来举个例子：
const list = []; // 定义数组 list.__proto__ === Array.prototype; // true list.__proto__.__proto__ === Object.prototype; // true list.__proto__.__proto__.__proto__===null; // true // 继承关系为 // list -> Array.prototype -> Object.prototype -> null 结合MDN的解释，我们来解释一下上述例子：
list是Array的实例对象，使用了字面量的方式创建了对象实例。
每个实例对象（ object ）都有一个私有属性（称之为 __proto__ ）指向它的构造函数的原型对象（prototype ）。
// list的构造函数是Array，所以list.__proto__指向构造函数Array的原型对象。 list.__proto__ === Array.prototype; // true 该原型对象也有一个自己的原型对象( __proto__ )
// Array.</div></article><article><div class=blog-card><h3><a href=/2019/09/20/leetcode-median-of-two-sorted-arrays/>leetcode(4)——寻找两个有序数组的中位数</a></h3><p><small>September 20, 2019&nbsp;· 453 words&nbsp;· 3 min</small><p>本文是力扣算法的第四篇，讲解寻找两个有序数组的中位数。
Question 给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。
请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。
你可以假设 nums1 和 nums2 不会同时为空。
示例 1:
nums1 = [1, 3] nums2 = [2] 则中位数是 2.0 示例 2:
nums1 = [1, 2] nums2 = [3, 4] 则中位数是 (2 + 3)/2 = 2.5 中位数 中位数是按顺序排列的一组数据中居于中间位置的数，即在这组数据中，有一半的数据比他大，有一半的数据比他小。
暴力法 将两个有序数组合并成一个有序数组
如果长度是奇数则返回中间的值，如果是否则则返回中间两个数的平均值。
var findMedianSortedArrays = function (nums1, nums2) { const nums = []; let p1 = p2 = 0; while (p1 &lt; nums1.</div></article><article><div class=blog-card><h3><a href=/2019/09/17/javascript-var-scope/>搞懂JS变量提升</a></h3><p><small>September 17, 2019&nbsp;· 107 words&nbsp;· One minute</small><p>本文讲解Javascript变量提升引起的问题以及如何规避。
问题 今天看到一道有意思的面试题，考察的还真是JS的基本功，题目如下：
var name = "world"; (function(){ if(typeof name === "undefined") { var name = "Jack"; console.log("Hello " + name); } else { console.log("Hello " + name); } }()); 根据if条件可以得出可能的答案：
Hello world Hello Jack 正确答案 答案是Hello Jack，但是答案怎么来的，回答不好可能还是只能打50分，有以下两种理解：
理解1：
立即执行函数有独立的作用域，访问不到外部name，所以if判断成立，输出 Hello Jack
这个理解是不正确的。虽然函数隔离了作用域，但是由于作用域链的关系，JS会从当前作用域一直往上级查找，直到顶级作用域（浏览器环境为window）。
如下代码输出Hello world
var name = "world"; (function(){ console.log("Hello " + name); }()); 理解2：
var存在变量提升，所以if在判断的时候name确实为undefined，走了if分支，输出 Hello Jack
变量提升 MDN对变量提升的解释：
“变量提升”意味着变量和函数的声明会在物理层面移动到代码的最前面，但这么说并不准确。实际上变量和函数声明在代码里的位置是不会动的，而是在编译阶段被放入内存中。
JavaScript 仅提升声明，而不提升初始化 函数和变量相比，会被优先提升 根据变量提升理论我们可以“模拟”JS实际执行代码的过程：
var name = "world"; (function(){ var name; // 变量提升，仅提升声明，不提升初始化 if(typeof name === "undefined") { name = "Jack"; console.</div></article><article><div class=blog-card><h3><a href=/2019/09/16/leetcode-longest-substring-without-repeating-characters-copy/>leetcode(3)——无重复字符的最长子串</a></h3><p><small>September 16, 2019&nbsp;· 341 words&nbsp;· 2 min</small><p>本文是力扣算法的第三篇，讲解无重复字符的最长子串问题。
Question 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。
示例1：
输入: "abcabcbb" 输出: 3 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。 示例2：
输入: "bbbbb" 输出: 1 解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。 示例3：
输入: "pwwkew" 输出: 3 解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。 遍历法 最容易想到的一种算法，也是效率最低的一种算法
通过两次遍历得到所有可能的 子字符串 列表 将每个字符串传入一个函数检测是否包含重复字符，如果不包含则更新最长子串的长度 // 判断给定的子串是否包含重复字符 function isUnique(str, start, end) { const chars = []; for(let i = start; i &lt; end; i++) { const char = str[i]; if(chars.indexOf(char) !== -1) { // 字符已存在，本字符串不符合条件 return false; } chars.</div></article><article><div class=blog-card><h3><a href=/2019/09/12/leetcode-add-two-sum/>leetcode(2) —— 两数相加</a></h3><p><small>September 12, 2019&nbsp;· 189 words&nbsp;· One minute</small><p>本文是力扣算法的第二篇，讲解两数相加问题。
Question 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。
如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。
您可以假设除了数字 0 之外，这两个数都不会以 0 开头。
示例：
输入：(2 -> 4 -> 3) + (5 -> 6 -> 4) 输出：7 -> 0 -> 8 原因：342 + 465 = 807 分析 遍历两个链表把值加起来好之后插入链表，如果有进位的话需要把进位的值保存到后面的节点上，如果遍历完毕之后还剩下需要进位的值，那么需要插入末尾新节点。
边界情况 遇到链表相关的题目时一定要处理好边界情况，因为有些为空的链表或者只有1个节点的链表没有处理的必要，及时返回可以降低算法复杂度。
链表1和链表2同时为空，直接返回undefined即可 链表1为空，返回链表2 链表2为空，返回链表1 解题方法 // 链表节点定义 function ListNode(val) { this.val = val; this.next = null; } function addTwoNumbers(l1, l2) { if(!l1 && !l2) { // 链表1和链表2同时为空，无需任何处理 return; } if(!l1) { // 链表1为空，直接返回链表2 return l2; } if(!</div></article></div><div class=paginator><a class=prev href=/tags/spring-boot/page/7/>&larr;&nbsp;&nbsp;Pre Page</a>
<a class=next href=/tags/spring-boot/page/9/>Next Page&nbsp;&nbsp;&rarr;</a></div></div></div></div><footer class=footer><p>&copy; 2014 - 2023 <a href=https://www.ddhigh.com>Lei Xia</a>
Powered by
<a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>
<a href=https://github.com/guangzhengli/hugo-theme-ladder rel=noopener target=_blank>Ladder</a>
<a href=https://umami-beta-peach.vercel.app/ target=_blank>Statistics</a>
️</p></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.5376 22.7916C11.0152 22.7207 22.5795 21.1781 22.0978 10.4211 22.0536 9.43274 21.9303 8.53367 21.7387 7.71865M10.5376 22.7916C16.876 22.3728 20.0969 19.8899 21.5383 16.9142M10.5376 22.7916C9.7707 22.9055 8.97982 22.8964 8.19743 22.7725M21.7387 7.71865C21.4988 6.69828 21.1518 5.80967 20.7188 5.04257m1.0199 2.67608C22.6022 10.1105 23.0542 13.7848 21.5383 16.9142M20.7188 5.04257c-3.5504-6.28886-12.88753-4.410077-16.44303.0C2.88063 6.77451-.0433281 11.1668 1.38159 16.6571c.89322 3.4417 3.7911 5.6365 6.81584 6.1154M20.7188 5.04257c1.3509 1.89783 3.3111 6.34223 1.6353 10.37273M21.5383 16.9142C21.8737 16.4251 22.1428 15.9235 22.3541 15.4153M8.19743 22.7725C12.1971 23.4683 20.6281 22.971 22.3541 15.4153M14 10.945C13.3836 10.289 12.003 8.63215 11.2034 7.04814 11.1703 6.98257 11.0247 6.98456 10.9937 7.05061 10.5221 8.05496 9.07362 9.92941 8 10.945m3.0333-3.50056C10.9392 9.86549 11 15 12 17" stroke="currentcolor" stroke-linecap="round"/></svg></a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function n(){t.innerHTML="Copied",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)}),e.parentNode.appendChild(t)})</script></main></body><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script><script>const images=Array.from(document.querySelectorAll(".blog-content img"));images.forEach(e=>{mediumZoom(e,{margin:10,scrollOffset:40,container:null,template:null,background:"rgba(0, 0, 0, 0.5)"})})</script><script src=/main.min.6bb26b69159420159c74dc9e097b06a578ed2b68c701466a91a44a9632d851bd0af167a1b30012387b4c512b48ad9ad4d3394e04d77ae38d57e1920fe4ed34fe.js integrity="sha512-a7JraRWUIBWcdNyeCXsGpXjtK2jHAUZqkaRKljLYUb0K8WehswASOHtMUStIrZrU0zlOBNd6441X4ZIP5O00/g==" crossorigin=anonymous defer></script></html>