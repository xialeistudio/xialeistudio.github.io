<!doctype html><html lang=en><head><meta name=viewport content="width=device-width,initial-scale=1"><title>es6</title>
<meta charset=utf-8><meta name=description content="Ladder@Learning & Writing & Sharing"><meta name=author content="Lei Xia"><link rel=canonical href=https://www.ddhigh.com/tags/es6/><link rel=alternate type=application/rss+xml href=https://www.ddhigh.com/index.xml title="Lei Xia"><script async defer data-website-id=865c8529-0729-4cf5-88a9-448616abbcbb src=https://umami-beta-peach.vercel.app/xialeistudio></script><meta property="og:title" content="es6"><meta property="og:description" content="Learning & Writing & Sharing"><meta property="og:type" content="website"><meta property="og:url" content="https://www.ddhigh.com/tags/es6/"><meta name=twitter:card content="summary"><meta name=twitter:title content="es6"><meta name=twitter:description content="Learning & Writing & Sharing"><link rel=icon href=/img/favicon.ico sizes=16x16><link rel=apple-touch-icon href=/img/favicon.ico><link rel=manifest href=/img/favicon.ico><link rel=stylesheet href=https://cdn.staticfile.org/lxgw-wenkai-webfont/1.6.0/style.css><link rel=stylesheet href=/css/main.min.ff1bc260fafbfb440e10194d7d06d57eb5e85eed11d12d06255581262664204e.css integrity="sha256-/xvCYPr7+0QOEBlNfQbVfrXoXu0R0S0GJVWBJiZkIE4=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/highlight/github-dark.min.min.66034289ee9a113219a2c4aae0a8bd2095ab255c832a42efcf5863f10814e7a1.css><script src=/js/highlight.min.min.894ca9c68afab956438c4926a0dc7f5293e04e08595bd27abdb123e94801f684.js></script><script>hljs.highlightAll()</script><script>(()=>{var t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,e=localStorage.getItem("theme");t&&e===null&&(localStorage.setItem("theme","dark"),document.documentElement.setAttribute("data-dark-mode","")),t&&e==="dark"&&document.documentElement.setAttribute("data-dark-mode",""),e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script></head><body><main class=wrapper><nav class=navigation><section class=container><a class=navigation-brand href=/>HOME
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><span></span><span></span><span></span></label><ul class=navigation-list id=navigation-list><li class="navigation-item navigation-menu"><a class=navigation-link href=/archives>Archive</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/tags>Tags</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/guestbook>Guestbook</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=https://umami-beta-peach.vercel.app/>Dashboard</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class="navigation-item navigation-social"><a class=navigation-link href=https://github.com/xialeistudio><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li class="navigation-item navigation-dark"><button id=mode type=button aria-label="toggle user light or dark theme">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span><span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></li></ul></section></nav><div id=content><div class=blog-wrapper><div><div class=blog-list><article><div class=blog-card><h3><a href=/2019/11/14/es6-iterator/>深入浅出ES6的迭代器</a></h3><p><small>November 14, 2019&nbsp;· 175 words&nbsp;· One minute</small><p>迭代器是ES2015中新增的规范，与之相关的for&mldr;of也是ES2015新增的。
本文来深入研究一下迭代器是什么，以及迭代器能够干什么？
或许你对for &mldr; of的执行还不了解，比如什么情况下可以使用for &mldr; of去遍历对象，什么情况下会报错等等，这篇文章应该能帮到你。
迭代器协议 for &mldr; of只能迭代满足【迭代器协议】的对象
可迭代对象的必须存在[Symbol.iterator]方法，该方法一个无参函数，返回迭代器协议的对象。
迭代器对象包含一个next()函数，该函数返回值有两种:
如果迭代未结束，返回如下
return { value: 'item', // item是本次迭代值，可以为任意对象 done: false } 如果迭代已结束，返回如下
return { done: true } 下面是未提供迭代器的示例。
const obj = { name: 'xialei', id: 1 }; for(let item of obj) { // TypeError: obj is not iterable } 下面是提供迭代器的示例。
const obj = { name: 'xialei', id: 1, [Symbol.iterator]: function () { // 迭代器属性 const keys = Object.keys(this); // 读取对象键列表 let keyIndex = 0; // 遍历未知 const self = this; // 保存this，next中的function会有自己的this return { // 返回带有next()的对象 next: function () { if (keyIndex &lt; keys.</div></article><article><div class=blog-card><h3><a href=/2019/11/04/es6-proxy/>深入浅出ES6的标准内置对象Proxy</a></h3><p><small>November 4, 2019&nbsp;· 776 words&nbsp;· 4 min</small><p>Proxy是ES6规范定义的标准内置对象，可以对目标对象的读取、函数调用等操作进行拦截。一般来说，通过Proxy可以让目标对象“可控”，比如是否能调用对象的某个方法，能否往对象添加属性等等。
const originalObj = { name: 'xialei' }; const publicObj = new Proxy(originalObj, { set(target, prop, value) { // 将属性值转化为大写 target[prop] = value.toString().toUpperCase(); } }); publicObj.name = 'xialei'; console.log(publicObj.name); // XIALEI 从上例可以看出Proxy不需要更改目标对象(也就是originalObj)，就可以对originalObj的行为进行拦截。
语法 let obj = new Proxy(target, handler);
target Object 目标对象。可以是任何类型的对象，甚至包括原生对象（比如数组，函数，另一个Proxy对象） handler Object 代理行为对象。访问目标对象时会自动触发该handler的对应属性。 和大多数开发者一样，刚开始学习Proxy的时候，这个handler不知道是个什么东西，什么时候能触发。
先看一个简单的例子，看看handler到底是什么东西。假设我们开发一个游戏脚本，由于内存修改器的盛行，我们需要对内存中的数据进行安全处理，但是不能影响外部使用，我们使用Proxy完成这个功能。
const gameObj = { hp: 0 }; const publicGameObj = new Proxy(gameObj, { get(target, prop) { return target[prop]/2; }, set(target, prop, value) { target[prop] = value*2; } }); publicGameObj.</div></article><article><div class=blog-card><h3><a href=/2019/10/31/es6-set/>ES6的Set类型</a></h3><p><small>October 31, 2019&nbsp;· 213 words&nbsp;· One minute</small><p>本文内容
Set的基本使用 常用用法 Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。
基本使用 new Set([iterator]) iterator 与Map类似，Set接收一个可选的Iterator对象，所有元素将按照顺序不重复地添加到Set中。传递null或者undefined将返回一个空Set const set = new Set(); // 添加元素 set.add(1); // 移除元素 set.delete(1); // 检测元素是否存在 set.has(1); // 清空Set set.clear(); 数据类型的唯一性判定 const set = new Set(undefined); set. add("string").add("string"). add(1).add(1). add(true).add(true). add(null).add(null). add(undefined).add(undefined) .add(NaN).add(NaN) .add({}).add({}) .add([]).add([]) .add(function () { }).add(function () { }); console.log(set); 输出如下：
Set { 'string', 1, true, null, undefined, NaN, {}, {}, [], [], [Function], [Function] } 结论 string/number/boolean/null/undefined/NaN是使用值判重 NaN!==NaN，但是Set也只会存一份，所以值判定应该不完全是用===做的 object/array/function等object类型使用引用判重 Set的迭代 for&mldr;of</div></article><article><div class=blog-card><h3><a href=/2019/10/30/es6-map/>ES6的Map类型</a></h3><p><small>October 30, 2019&nbsp;· 550 words&nbsp;· 3 min</small><p>本文内容
Map的基本使用 Map支持的数据类型 Map的迭代 Map与其他对象的转化 在Map出现之前，要实现类似需求，只能使用Object，但是Object还是存在一些问题的。
如果使用Object作为key存储在{}中，key最终是当做[object Object]来使用的 Object的keys是无序的 无法安全遍历Object 无法直接获取Object大小 Map 对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。
基本操作 new Map([iterator]) iterator 可以是一个数组或者其他iterator对象，其元素为键值对(如['key', 'value'])。 null或undefined不会生效，返回一个空的Map 非iterator会抛出错误 TypeError: object is not iterable const map = new Map(); // Create map.set('name','xialei'); map.set('site', 'https://www.ddhigh.com'); // Update map.set('name', 'xialeistudio'); // Read map.get('name'); // Delete map.delete('name'); // 清空 map.clear(); // map大小 console.log(map.size); 数据类型测试 JS中基本数据类型有string、number、boolean、null、undefined、symbol，复杂数据类型有object(包括object,array,function等)，还有个特殊的NaN(typeof结果是number)，分别对这些类型进行测试
const map = new Map(); const sKey = 'key', nKey = 1, bKey = true, nullKey = null, uKey = undefined, symbolKey = Symbol("key"), oKey = {}, ooKey = oKey, aKey = [], fKey = function () { }, nanKey = NaN; map.</div></article><article><div class=blog-card><h3><a href=/2019/10/28/symbol/>深入浅出ES6的Symbol类型</a></h3><p><small>October 28, 2019&nbsp;· 252 words&nbsp;· 2 min</small><p>本文内容 JS基本数据类型种类 Symbol的主要用法, 全局Symbol的使用与检测 Symbol与其他基本类型转换时的规则 ES6引入了一种新的原始数据类型，表示独一无二的值，最大的用处是作为对象属性的唯一标识符。
至此，Javascript拥有6种基本数据类型和一种复杂数据类型。
数据类型 基本类型
string number boolean undefined null symbol 复杂类型
object 用法 基本语法 Symbol([description]) description 可选的描述，一般用在调试的时候作为区分，但是 不能用来访问Symbol。 该方法返回一个symbol值 let s = Symbol('test'); let s2 = Symbol('test'); let s3 = new Symbol('test'); // TypeError console.log(s === s2); // false console.log(typeof s); // symbol console.log(s.description); // test 每次调用Symbol()返回的值都是独一无二的，不管描述是否一致。 Symbol不支持new调用 通过description属性可以获取到传入Symbol的描述性字符串 全局单例的Symbol 使用Symbol.for()可以创建全局单例的symbol值，语法如下：
Symbol.for([name]) name 可选的描述，建议传入，否则name会作为undefined传入 类似于单例模式，执行环境(一般是浏览器)内部维护了一个全局Symbol注册表，记录name和Symbol(name)关系 尝试通过name在该注册表查找对应symbol值，如果找到，则返回这个symbol值 如果没找到，则使用Symbol(name)创建一个symbol值，并记录该symbol值与name的关联关系，之后返回该symbol const name = Symbol('name'); const name2 = Symbol.for('name'); const name3 = Symbol.</div></article><article><div class=blog-card><h3><a href=/2019/10/22/let-and-const/>不只是块级作用域，你不知道的let和const</a></h3><p><small>October 22, 2019&nbsp;· 171 words&nbsp;· One minute</small><p>ES6新增了两个重要的关键字let和const，相信大家都不陌生，但是包括我在内，在系统学习ES6之前也只使用到了【不存在变量提升】这个特性。
let声明一个块级作用域的本地变量 const语句声明一个块级作用域的本地常量，不可以重新赋值 支持块级作用域 var定义的变量会提升到整个函数作用域内，let/const则支持块级作用域。
块级作用域: 由{}包裹的作用域（函数那种{}不算）
来看一个var的例子:
{ var a = 1; } console.log(a); 此时输出1，因为var没有块级作用域。
来看一个let的例子(const效果一样):
{ let a = 1; } console.log(a); 此时会报错ReferenceError，因为let/const支持块级作用域，所以let定义的a只在{}可以访问
不存在变量提升 与var不同的是，let/const声明的变量不存在变量提升，也就是说{}对于let/const是有效的。
来看一个var的例子:
console.log(a); var a = 1; 此时会输出undefined，因为var声明的变量会提升到作用域顶部（只提升声明，不提升赋值）
来看一个let的例子(const效果也一样):
console.log(a); let a = 1; 此时会报错ReferenceError，因为let不存在变量提升
同一作用域内不可以重复声明 同一作用域内let/const不可以重复声明,var可以。
来看一个var的例子:
var a = 1; var a = 2; console.log(a); 此时会输出2，var是支持重复声明的，后面声明的值会覆盖前面声明的值。
来看一个let的例子(const效果也一样):
let a = 1; let a = 2; console.log(a); 此时会报错SyntaxError，因为同一作用域内let/const不可以重复声明。
再来看一个不同作用域的例子：
let a = 1; { let a = 2; } console.</div></article></div></div></div></div><footer class=footer><p>&copy; 2014 - 2023 <a href=https://www.ddhigh.com>Lei Xia</a>
Powered by
<a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>
<a href=https://github.com/guangzhengli/hugo-theme-ladder rel=noopener target=_blank>Ladder</a>
️</p></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.5376 22.7916C11.0152 22.7207 22.5795 21.1781 22.0978 10.4211 22.0536 9.43274 21.9303 8.53367 21.7387 7.71865M10.5376 22.7916C16.876 22.3728 20.0969 19.8899 21.5383 16.9142M10.5376 22.7916C9.7707 22.9055 8.97982 22.8964 8.19743 22.7725M21.7387 7.71865C21.4988 6.69828 21.1518 5.80967 20.7188 5.04257m1.0199 2.67608C22.6022 10.1105 23.0542 13.7848 21.5383 16.9142M20.7188 5.04257c-3.5504-6.28886-12.88753-4.410077-16.44303.0C2.88063 6.77451-.0433281 11.1668 1.38159 16.6571c.89322 3.4417 3.7911 5.6365 6.81584 6.1154M20.7188 5.04257c1.3509 1.89783 3.3111 6.34223 1.6353 10.37273M21.5383 16.9142C21.8737 16.4251 22.1428 15.9235 22.3541 15.4153M8.19743 22.7725C12.1971 23.4683 20.6281 22.971 22.3541 15.4153M14 10.945C13.3836 10.289 12.003 8.63215 11.2034 7.04814 11.1703 6.98257 11.0247 6.98456 10.9937 7.05061 10.5221 8.05496 9.07362 9.92941 8 10.945m3.0333-3.50056C10.9392 9.86549 11 15 12 17" stroke="currentcolor" stroke-linecap="round"/></svg></a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function n(){t.innerHTML="Copied",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)}),e.parentNode.appendChild(t)})</script></main></body><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script><script>const images=Array.from(document.querySelectorAll(".blog-content img"));images.forEach(e=>{mediumZoom(e,{margin:10,scrollOffset:40,container:null,template:null,background:"rgba(0, 0, 0, 0.5)"})})</script><script src=/main.min.6bb26b69159420159c74dc9e097b06a578ed2b68c701466a91a44a9632d851bd0af167a1b30012387b4c512b48ad9ad4d3394e04d77ae38d57e1920fe4ed34fe.js integrity="sha512-a7JraRWUIBWcdNyeCXsGpXjtK2jHAUZqkaRKljLYUb0K8WehswASOHtMUStIrZrU0zlOBNd6441X4ZIP5O00/g==" crossorigin=anonymous defer></script></html>