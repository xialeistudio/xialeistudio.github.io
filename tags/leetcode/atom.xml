<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>leetcode on Lei Xia</title><link>https://www.ddhigh.com/tags/leetcode/</link><description>Recent content in leetcode on Lei Xia</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Fri, 10 Feb 2023 12:00:00 +0000</lastBuildDate><atom:link href="https://www.ddhigh.com/tags/leetcode/atom.xml" rel="self" type="application/rss+xml"/><item><title>拓补排序</title><link>https://www.ddhigh.com/2023/02/10/topological-sorting/</link><pubDate>Fri, 10 Feb 2023 12:00:00 +0000</pubDate><guid>https://www.ddhigh.com/2023/02/10/topological-sorting/</guid><description>&lt;blockquote>
&lt;p>在计算机科学领域，有向图的拓扑排序或拓扑测序是对其顶点的一种线性排序，使得对于从顶点$u$到顶点$v$的每个有向边$uv$, $u$在排序中都在$v$之前。&lt;/p>
&lt;p>例如，图形的顶点可以表示要执行的任务，并且边可以表示一个任务必须在另一个任务之前执行的约束；在这个应用中，拓扑排序只是一个有效的任务顺序。&lt;/p>
&lt;p>当且仅当图中没有定向环时（即有向无环图），才有可能进行拓扑排序。&lt;/p>
&lt;p>任何有向无环图至少有一个拓扑排序。&lt;/p>
&lt;/blockquote>
&lt;h2 id="算法">算法&lt;/h2>
&lt;ol>
&lt;li>遍历有向边，构造u-&amp;gt;v边中v的入度表，可使用哈希存储入度&lt;/li>
&lt;li>将入度为0的节点入队&lt;/li>
&lt;li>队列节点不断出队，出队时减小被更新节点的入度，如果被更新节点入度为0，则该节点入队&lt;/li>
&lt;li>重复以上过程，最终可以得到一个从入度为0到最终节点的序列，这就是拓补排序算法。&lt;/li>
&lt;/ol>
&lt;h2 id="示例">示例&lt;/h2>
&lt;p>Leetcode &lt;a href="https://leetcode.cn/problems/course-schedule-ii/description/">210. 课程表2&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 生成邻接表 &amp;lt;当前节点，后置节点&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 进行BFS拓补排序，由最低依赖的开始写入答案&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> &lt;span style="color:#a6e22e">findOrder&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> numCourses, &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[][]&lt;/span> prerequisites) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Set&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer&lt;span style="color:#f92672">&amp;gt;[]&lt;/span> graph &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> HashSet&lt;span style="color:#f92672">[&lt;/span>numCourses&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> numCourses; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> graph&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> HashSet&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 入度&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> inDegree &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[&lt;/span>numCourses&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> p : prerequisites) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> current &lt;span style="color:#f92672">=&lt;/span> p&lt;span style="color:#f92672">[&lt;/span>0&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> pre &lt;span style="color:#f92672">=&lt;/span> p&lt;span style="color:#f92672">[&lt;/span>1&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> graph&lt;span style="color:#f92672">[&lt;/span>pre&lt;span style="color:#f92672">]&lt;/span>.&lt;span style="color:#a6e22e">add&lt;/span>(current);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> inDegree&lt;span style="color:#f92672">[&lt;/span>current&lt;span style="color:#f92672">]++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Queue&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> queue &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> LinkedList&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> numCourses; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (inDegree&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">==&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> queue.&lt;span style="color:#a6e22e">offer&lt;/span>(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> answer &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[&lt;/span>numCourses&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> index &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>queue.&lt;span style="color:#a6e22e">isEmpty&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 弹出课程&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> course &lt;span style="color:#f92672">=&lt;/span> queue.&lt;span style="color:#a6e22e">remove&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> answer&lt;span style="color:#f92672">[&lt;/span>index&lt;span style="color:#f92672">++]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> course;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 遍历邻接表，减掉入度，入度归0时入队&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> target : graph&lt;span style="color:#f92672">[&lt;/span>course&lt;span style="color:#f92672">]&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> inDegree&lt;span style="color:#f92672">[&lt;/span>target&lt;span style="color:#f92672">]--&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (inDegree&lt;span style="color:#f92672">[&lt;/span>target&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">==&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> queue.&lt;span style="color:#a6e22e">offer&lt;/span>(target);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> index &lt;span style="color:#f92672">&amp;gt;=&lt;/span> numCourses &lt;span style="color:#f92672">?&lt;/span> answer : &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[&lt;/span>0&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>复杂度分析&lt;/strong>&lt;/p>
&lt;p>时间复杂度：$O(n)$ ,$n$是课程数量&lt;/p>
&lt;p>空间复杂度：$O(n)$，$n$是课程数量&lt;/p></description></item><item><title>水塘抽样算法</title><link>https://www.ddhigh.com/2023/01/19/reservoir-sampling/</link><pubDate>Thu, 19 Jan 2023 23:34:44 +0000</pubDate><guid>https://www.ddhigh.com/2023/01/19/reservoir-sampling/</guid><description>&lt;p>下面是&lt;a href="https://zh.wikipedia.org/zh-mo/%E6%B0%B4%E5%A1%98%E6%8A%BD%E6%A8%A3">维基百科水塘抽样&lt;/a>的说明。&lt;/p>
&lt;blockquote>
&lt;p>水塘抽样是一系列的随机算法，其目的在于从包含 $n$个项目的集合 中选取$k$ 个样本，其中 $n$为一很大或未知的数量，尤其适用于不能把所有 $n$ 个项目都存放到内存的情况。&lt;/p>
&lt;/blockquote>
&lt;p>本文分享在随机数据流中等概率抽取target的水塘抽样算法。&lt;/p>
&lt;h2 id="算法">算法&lt;/h2>
&lt;ol>
&lt;li>定义$count$计数变量&lt;/li>
&lt;li>遍历给定的数据流，如果当前数字等于$target$, $count$+1&lt;/li>
&lt;li>在$[0, count]$产生随机数，如果等于$count$，则抽样成功&lt;/li>
&lt;/ol>
&lt;h2 id="示例">示例&lt;/h2>
&lt;p>Leetcode &lt;a href="https://leetcode.cn/problems/random-pick-index/">398. 随机数索引&lt;/a>&lt;/p>
&lt;p>&lt;strong>代码&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 哈希表保存&amp;lt;值,List&amp;lt;下标&amp;gt;&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> nums;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> Random random;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> nums) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">nums&lt;/span> &lt;span style="color:#f92672">=&lt;/span> nums;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">random&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Random(System.&lt;span style="color:#a6e22e">currentTimeMillis&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 水塘抽样&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 统计target count,随机数%count 为0时重置index&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">pick&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> target) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> count &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> index &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">var&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> nums.&lt;span style="color:#a6e22e">length&lt;/span>; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (nums&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">==&lt;/span> target) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (random.&lt;span style="color:#a6e22e">nextInt&lt;/span>() &lt;span style="color:#f92672">%&lt;/span> count &lt;span style="color:#f92672">==&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> index &lt;span style="color:#f92672">=&lt;/span> i;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> index;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>复杂度分析&lt;/strong>&lt;/p>
&lt;p>时间复杂度：$O(n)$,$n$是$nums$长度，需要遍历一次$nums$&lt;/p>
&lt;p>空间复杂度：$O(1)$,严格来说，java默认使用浅拷贝，因此$nums$不会有额外空间占用。&lt;/p></description></item><item><title>时间差计算算法</title><link>https://www.ddhigh.com/2023/01/19/time-difference/</link><pubDate>Thu, 19 Jan 2023 23:27:14 +0000</pubDate><guid>https://www.ddhigh.com/2023/01/19/time-difference/</guid><description>&lt;p>本文分享如何解决计算时间差类的问题。&lt;/p>
&lt;h2 id="算法">算法&lt;/h2>
&lt;ol>
&lt;li>首先需要将时间转化为数字，比如23:59，可以转化为23*60+59&lt;/li>
&lt;li>然后根据数字从小到大排序，此时从&lt;code>[0, n]&lt;/code>处的数据有序，可以遍历该区间计算差值&lt;/li>
&lt;li>需要注意的是，由于时间的特殊性，比如&lt;code>23:59&lt;/code>下一分会归0，因此还需要比如&lt;code>0&lt;/code>处和&lt;code>n&lt;/code>处的时间差&lt;/li>
&lt;/ol>
&lt;h2 id="示例">示例&lt;/h2>
&lt;p>Leetcode &lt;a href="https://leetcode.cn/problems/minimum-time-difference/">539. 最小时间差&lt;/a>&lt;/p>
&lt;p>&lt;strong>代码&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 模拟&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 时间字符串转化为数字&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 排序，线性遍历，然后再比较第一个和最后一个的差值&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">findMinDifference&lt;/span>(List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> timePoints) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 24小时总共1440个可能，超过1440，直接返回0（存在重复时间点）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (timePoints.&lt;span style="color:#a6e22e">size&lt;/span>() &lt;span style="color:#f92672">&amp;gt;&lt;/span> 1440) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> array &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[&lt;/span>timePoints.&lt;span style="color:#a6e22e">size&lt;/span>()&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> timePoints.&lt;span style="color:#a6e22e">size&lt;/span>(); i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> str &lt;span style="color:#f92672">=&lt;/span> timePoints.&lt;span style="color:#a6e22e">get&lt;/span>(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> array&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> Integer.&lt;span style="color:#a6e22e">parseInt&lt;/span>(str.&lt;span style="color:#a6e22e">substring&lt;/span>(0, 2)) &lt;span style="color:#f92672">*&lt;/span> 60 &lt;span style="color:#f92672">+&lt;/span> Integer.&lt;span style="color:#a6e22e">parseInt&lt;/span>(str.&lt;span style="color:#a6e22e">substring&lt;/span>(3));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Arrays.&lt;span style="color:#a6e22e">sort&lt;/span>(array);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> answer &lt;span style="color:#f92672">=&lt;/span> Integer.&lt;span style="color:#a6e22e">MAX_VALUE&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 1; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> array.&lt;span style="color:#a6e22e">length&lt;/span>; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> answer &lt;span style="color:#f92672">=&lt;/span> Math.&lt;span style="color:#a6e22e">min&lt;/span>(answer, array&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">-&lt;/span> array&lt;span style="color:#f92672">[&lt;/span>i &lt;span style="color:#f92672">-&lt;/span> 1&lt;span style="color:#f92672">]&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 和首尾差值比较&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Math.&lt;span style="color:#a6e22e">min&lt;/span>(answer, array&lt;span style="color:#f92672">[&lt;/span>0&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">+&lt;/span> 1440 &lt;span style="color:#f92672">-&lt;/span> array&lt;span style="color:#f92672">[&lt;/span>array.&lt;span style="color:#a6e22e">length&lt;/span> &lt;span style="color:#f92672">-&lt;/span> 1&lt;span style="color:#f92672">]&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>复杂度分析&lt;/strong>&lt;/p>
&lt;p>时间复杂度：$O(nlogn)$,$n$是序列长度，主要是排序的时间。&lt;/p>
&lt;p>空间复杂度：$O(n)$,$n$是序列长度。&lt;/p></description></item><item><title>滑动窗口算法</title><link>https://www.ddhigh.com/2023/01/19/slide-window-algorithm/</link><pubDate>Thu, 19 Jan 2023 23:16:29 +0000</pubDate><guid>https://www.ddhigh.com/2023/01/19/slide-window-algorithm/</guid><description>&lt;p>滑动窗口算法是查找连续区间常用的算法之一。&lt;/p>
&lt;p>本文分享滑动窗口算法的通用框架。&lt;/p>
&lt;h2 id="算法">算法&lt;/h2>
&lt;ol>
&lt;li>定义$left$和$right$双指针，代表窗口的左边界和右边界&lt;/li>
&lt;li>当$right$小于给定区间大小时，我们可以进行操作。&lt;/li>
&lt;li>在扩大窗口时，需要加当前新加入的数据进行处理&lt;/li>
&lt;li>当当前窗口内数据不满足条件时，右移$left$指针缩小窗口&lt;/li>
&lt;li>计算$[left,right]$之间的数据，和最佳答案比较并更新最佳答案&lt;/li>
&lt;li>右移$right$&lt;/li>
&lt;/ol>
&lt;p>下面是滑动窗口通用框架的java语言实现。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> left &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> right &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">while&lt;/span>(right &lt;span style="color:#f92672">&amp;lt;&lt;/span> 上界) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 将right处数据加入窗口
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">while&lt;/span>(窗口数据不符合要求) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 移除left数据
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> left&lt;span style="color:#f92672">++&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 根据当前right和left计算最佳答案并更新
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> right&lt;span style="color:#f92672">++&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="示例">示例&lt;/h2>
&lt;p>Leetcode &lt;a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/">3. 无重复字符的最长子串&lt;/a>&lt;/p>
&lt;p>&lt;strong>思路&lt;/strong>&lt;/p>
&lt;p>基于算法框架的思路如下：&lt;/p>
&lt;ol>
&lt;li>定义$left$和$right$双指针，代表窗口的左边界和右边界，再定义&lt;code>HashMap&amp;lt;Character, Integer&amp;gt;&lt;/code>存储窗口内的字符和数量(可以使用长度为&lt;code>128&lt;/code>的字符数组代替，省去操作hashmap的开销。&lt;/li>
&lt;li>当$right$小于$s.length()$时，我们可以进行操作。&lt;/li>
&lt;li>在扩大窗口时，将$s.charAt(right)$加入&lt;code>HashMap&lt;/code>&lt;/li>
&lt;li>当&lt;code>HashMap.get(s.charAt(right)&amp;gt;1)&lt;/code>，此时$right$处字符重复，需要收缩左边界，$left$处的字符数量-1，右移$left$&lt;/li>
&lt;li>计算$[left,right]$之间的数据，和最佳答案比较并更新最佳答案&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>代码&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 滑动窗口&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 定义left,right, hashmap&amp;lt;char,int&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 循环条件 right&amp;lt;s.length()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// right字符入map&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// while刚才入的字符重复，map移除left的字符，left++&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 计算长度&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// right++&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">lengthOfLongestSubstring&lt;/span>(String s) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> left &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> right &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> answer &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> map &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[&lt;/span>128&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (right &lt;span style="color:#f92672">&amp;lt;&lt;/span> s.&lt;span style="color:#a6e22e">length&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> rightChar &lt;span style="color:#f92672">=&lt;/span> s.&lt;span style="color:#a6e22e">charAt&lt;/span>(right);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> map&lt;span style="color:#f92672">[&lt;/span>rightChar&lt;span style="color:#f92672">]++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 窗口有重复字符，收缩左边界&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (map&lt;span style="color:#f92672">[&lt;/span>rightChar&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">&amp;gt;&lt;/span> 1) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> leftChar &lt;span style="color:#f92672">=&lt;/span> s.&lt;span style="color:#a6e22e">charAt&lt;/span>(left);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> map&lt;span style="color:#f92672">[&lt;/span>leftChar&lt;span style="color:#f92672">]--&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> left&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> answer &lt;span style="color:#f92672">=&lt;/span> Math.&lt;span style="color:#a6e22e">max&lt;/span>(answer, right &lt;span style="color:#f92672">-&lt;/span> left &lt;span style="color:#f92672">+&lt;/span> 1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> right&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> answer;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>复杂度分析&lt;/strong>&lt;/p>
&lt;p>时间复杂度：$O(n)$, $n$是字符串长度，每个字符至多访问2次。&lt;/p>
&lt;p>空间复杂度: $O(1)$，只需常数项空间。&lt;/p></description></item><item><title>字符串子序列检测算法</title><link>https://www.ddhigh.com/2023/01/05/subsequence-checking-algorithm/</link><pubDate>Thu, 05 Jan 2023 12:36:10 +0000</pubDate><guid>https://www.ddhigh.com/2023/01/05/subsequence-checking-algorithm/</guid><description>&lt;p>本文分享一种检测一个字符串是否为另一个字符串子序列的算法。&lt;/p>
&lt;p>子序列的定义：&lt;/p>
&lt;p>若字符串$s1$可以由字符串$s2$删除某些字符得到，则$s1$是$s2$的子序列。换句话说，若$s1$的所有字符都在$s2$中且顺序一致，则$s1$是$s2$的子序列。&lt;/p>
&lt;p>例如：&lt;/p>
&lt;p>a是aaa的子序列，adf是abcdef的子序列，但是cba不是abc的子序列（因为字符顺序变了）。&lt;/p>
&lt;h2 id="算法">算法&lt;/h2>
&lt;ol>
&lt;li>声明$s1$的下标变量$strIndex$，若$s2$有$s1$的该字符，则$strIndex+1$&lt;/li>
&lt;li>若遍历过程中$strIndex$和$s1$的长度相等，则证明$s1$所有字符都在$s2$中，返回$s1$是$s2$在子序列&lt;/li>
&lt;li>遍历结束仍未返回，证明$s1$不是$s2$的子序列&lt;/li>
&lt;/ol>
&lt;h2 id="代码">代码&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">isSubsequent&lt;/span>(String str, String str1) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> strIndex &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 逐字符遍历&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 如果字符想通，则strIndex++&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 如果strIndex到达末尾，则证明str是子序列&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">var&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> str1.&lt;span style="color:#a6e22e">length&lt;/span>(); i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (str.&lt;span style="color:#a6e22e">charAt&lt;/span>(strIndex) &lt;span style="color:#f92672">==&lt;/span> str1.&lt;span style="color:#a6e22e">charAt&lt;/span>(i)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> strIndex&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (strIndex &lt;span style="color:#f92672">==&lt;/span> str.&lt;span style="color:#a6e22e">length&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>复杂度分析&lt;/strong>&lt;/p>
&lt;p>时间复杂度：$O(n)$,$n$是$str1$的长度。&lt;/p>
&lt;p>空间复杂度：$O(1)$。&lt;/p></description></item><item><title>计算数字二进制位中1的个数</title><link>https://www.ddhigh.com/2023/01/05/counting-bit1-of-binary-number/</link><pubDate>Thu, 05 Jan 2023 12:35:00 +0000</pubDate><guid>https://www.ddhigh.com/2023/01/05/counting-bit1-of-binary-number/</guid><description>&lt;p>本文分享一种计算给定数字二进制表示中有多少个1的算法。&lt;/p>
&lt;p>位运算对于非硬件相关的开发者来说可能用的比较少，朴素做法是将数字转换为二进制字符串，然后遍历该字符串得到1的个数。&lt;/p>
&lt;h2 id="算法">算法&lt;/h2>
&lt;ol>
&lt;li>通过右移我们可以访问到数字的指定比特&lt;/li>
&lt;li>将该比特与1进行按位与&lt;code>&amp;amp;&lt;/code>，结果为1则证明当前比特位是1，计数器+1&lt;/li>
&lt;/ol>
&lt;p>根据给定数字的数据类型可以确定需要位移的次数，对于&lt;code>int&lt;/code>来说，4个字节，因此需要右移32次，而对于&lt;code>long&lt;/code>来说，8个字节，需要右移64次。&lt;/p>
&lt;h2 id="代码">代码&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">getBit1Count&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> num) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> count &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> 32; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (((num &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> i) &lt;span style="color:#f92672">&amp;amp;&lt;/span> 1) &lt;span style="color:#f92672">==&lt;/span> 1) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> count;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>复杂度分析&lt;/strong>&lt;/p>
&lt;p>时间复杂度：$O(1)$，不管多大的数字，只需要右移32次。&lt;/p>
&lt;p>空间复杂度：$O(1)$，无需额外空间。&lt;/p></description></item><item><title>解析字符串中的数字</title><link>https://www.ddhigh.com/2023/01/03/parse-number-in-string/</link><pubDate>Tue, 03 Jan 2023 22:36:49 +0000</pubDate><guid>https://www.ddhigh.com/2023/01/03/parse-number-in-string/</guid><description>&lt;p>本文分享一种如何在字符串中解析数字的算法。&lt;/p>
&lt;h2 id="思路">思路&lt;/h2>
&lt;p>解析字符串中的数字需要判断当前是否是数字字符，以及如何处理连续的数字字符。&lt;/p>
&lt;p>本文使用while循环来解析数字，之所以不使用for循环，是笔者认为while循环操控力比for循环要好。&lt;/p>
&lt;p>while循环解析方法如下：&lt;/p>
&lt;ol>
&lt;li>如果当前字符是数字，则开启内部while循环&lt;/li>
&lt;li>内部while循环退出条件为当前字符不是数字&lt;/li>
&lt;li>内部循环操作为读取当前数字，然后加上一个数字乘以10&lt;/li>
&lt;li>内部循环退出后，我们就得到一个连续的数字&lt;/li>
&lt;/ol>
&lt;h2 id="示例">示例&lt;/h2>
&lt;p>Leetcode &lt;a href="https://leetcode.cn/problems/check-if-numbers-are-ascending-in-a-sentence/">2042. 检查句子中的数字是否递增&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 提取字符串中的数字，判断是否严格递增&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">areNumbersAscending&lt;/span>(String s) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 定义上一个数字，初始化为最小的数字&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> lastNumber &lt;span style="color:#f92672">=&lt;/span> Integer.&lt;span style="color:#a6e22e">MIN_VALUE&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (i &lt;span style="color:#f92672">&amp;lt;&lt;/span> s.&lt;span style="color:#a6e22e">length&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (Character.&lt;span style="color:#a6e22e">isDigit&lt;/span>(s.&lt;span style="color:#a6e22e">charAt&lt;/span>(i))) { &lt;span style="color:#75715e">// 当前是数字，继续处理&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> number &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 核心代码&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (i &lt;span style="color:#f92672">&amp;lt;&lt;/span> s.&lt;span style="color:#a6e22e">length&lt;/span>() &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> Character.&lt;span style="color:#a6e22e">isDigit&lt;/span>(s.&lt;span style="color:#a6e22e">charAt&lt;/span>(i))) { &lt;span style="color:#75715e">// 字符串没越界而且当前字符是数字字符&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> number &lt;span style="color:#f92672">=&lt;/span> number &lt;span style="color:#f92672">*&lt;/span> 10 &lt;span style="color:#f92672">+&lt;/span> (s.&lt;span style="color:#a6e22e">charAt&lt;/span>(i) &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#e6db74">&amp;#39;0&amp;#39;&lt;/span>); &lt;span style="color:#75715e">// (s.charAt(i) - &amp;#39;0&amp;#39;) 就是利用ASCII码表直接得到数字值，不需要再做parseInt&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i&lt;span style="color:#f92672">++&lt;/span>; &lt;span style="color:#75715e">// 坐标后移&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (number &lt;span style="color:#f92672">&amp;lt;=&lt;/span> lastNumber) { &lt;span style="color:#75715e">// 如果当前数字&amp;lt;=上一个数字，证明不是严格递增，return false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// number &amp;gt; lastNumber，更新lastNumber&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lastNumber &lt;span style="color:#f92672">=&lt;/span> number;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// i后移&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>复杂度分析&lt;/strong>&lt;/p>
&lt;p>时间复杂度：$O(n)$，每个字符访问一次。
空间复杂度:$O(1)$，仅需常数项额外变量。&lt;/p>
&lt;p>&lt;strong>注意&lt;/strong>&lt;/p>
&lt;p>时间复杂度就是分析随着数据量增大，算法执行次数的变化。本题虽然有两重循环，有些同学可能无脑以为时间复杂度是$O(n^2)$，实际上是不对的。可以发现每个字符串最多访问一次，所以复杂度是$O(n)$。&lt;/p></description></item><item><title>查找第N大的数</title><link>https://www.ddhigh.com/2023/01/03/nth-maximum-number/</link><pubDate>Tue, 03 Jan 2023 12:22:08 +0000</pubDate><guid>https://www.ddhigh.com/2023/01/03/nth-maximum-number/</guid><description>&lt;p>在给定的序列中查找第N大的数，朴素做法是对序列排序，然后根据索引直接查询，时间复杂度为$O(nlogn)$。&lt;/p>
&lt;p>本文介绍一种在$O(n)$的时间复杂度查询第N大的数的算法。&lt;/p>
&lt;h2 id="算法">算法&lt;/h2>
&lt;p>算法思路就是定义标志变量，然后遍历数组，根据标志变量和当前数组变量的大小更新标志变量，最后根据情况返回标志变量。&lt;/p>
&lt;h2 id="示例查找第2大的数">示例：查找第2大的数&lt;/h2>
&lt;p>定义$first$和$second$分别存储最大和次大，然后遍历数组时更新即可。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 查找第二大的数字
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">SecondMaximumNumber&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">secondMaximumNumber&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> nums) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 最大数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> first &lt;span style="color:#f92672">=&lt;/span> Integer.&lt;span style="color:#a6e22e">MIN_VALUE&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 次大数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> second &lt;span style="color:#f92672">=&lt;/span> Integer.&lt;span style="color:#a6e22e">MIN_VALUE&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">var&lt;/span> num : nums) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 当前数字比最大数还大，最大数更新为当前数字，原来的最大数更新为第2大&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (num &lt;span style="color:#f92672">&amp;gt;=&lt;/span> first) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> second &lt;span style="color:#f92672">=&lt;/span> first;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> first &lt;span style="color:#f92672">=&lt;/span> num;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (num &lt;span style="color:#f92672">&amp;gt;=&lt;/span> second) { &lt;span style="color:#75715e">// 当前数字小于最大，但是大于第2大，更新第2大&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> second &lt;span style="color:#f92672">=&lt;/span> num;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> second;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span> args) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> nums &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span>{1, 3, 2, 8, 5};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> s &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> SecondMaximumNumber();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(s.&lt;span style="color:#a6e22e">secondMaximumNumber&lt;/span>(nums));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="示例查找第3大的数">示例：查找第3大的数&lt;/h2>
&lt;p>Leetcode: &lt;a href="https://leetcode.cn/problems/third-maximum-number/">第三大的数&lt;/a>&lt;/p>
&lt;p>原理和查第2大的数想通，定义$first$,$second$,$third$三个变量，然后遍历$nums$&lt;/p>
&lt;ol>
&lt;li>若$num &amp;gt; first$，则$second$赋值给$third$，$first$赋值给$second$,$num$赋值给$first$&lt;/li>
&lt;li>若$num &amp;lt; first$且 $num &amp;gt; second$，则$second$赋值给$third$，$num$赋值给$second$&lt;/li>
&lt;li>若$num &amp;lt; second$且$num &amp;gt; third$，则$num$赋值给$third$&lt;/li>
&lt;/ol>
&lt;p>最后根据题意返回$third$或者$first$即可。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution3&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 三个变量&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">thirdMax&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> nums) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> first &lt;span style="color:#f92672">=&lt;/span> Long.&lt;span style="color:#a6e22e">MIN_VALUE&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> second &lt;span style="color:#f92672">=&lt;/span> first;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> third &lt;span style="color:#f92672">=&lt;/span> second;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">var&lt;/span> num : nums) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (num &lt;span style="color:#f92672">&amp;gt;&lt;/span> first) { &lt;span style="color:#75715e">// 如果num&amp;gt;最大值，原来的最大变次大，原来的次大变三大, 当前边最大&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> third &lt;span style="color:#f92672">=&lt;/span> second;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> second &lt;span style="color:#f92672">=&lt;/span> first;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> first &lt;span style="color:#f92672">=&lt;/span> num;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (num &lt;span style="color:#f92672">&amp;lt;&lt;/span> first &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> num &lt;span style="color:#f92672">&amp;gt;&lt;/span> second) { &lt;span style="color:#75715e">// 小于最大，但是大于第二, 第二变第三，当前边第二&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> third &lt;span style="color:#f92672">=&lt;/span> second;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> second &lt;span style="color:#f92672">=&lt;/span> num;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (num &lt;span style="color:#f92672">&amp;lt;&lt;/span> second &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> num &lt;span style="color:#f92672">&amp;gt;&lt;/span> third) { &lt;span style="color:#75715e">// 小于第二，但是大于第三&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> third &lt;span style="color:#f92672">=&lt;/span> num;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span>) (third &lt;span style="color:#f92672">==&lt;/span> Long.&lt;span style="color:#a6e22e">MIN_VALUE&lt;/span> &lt;span style="color:#f92672">?&lt;/span> first : third);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>时间复杂度:$O(n)$，$n$是数组长度，仅需遍历一次。&lt;/p>
&lt;p>空间复杂度: $O(1)$，仅需使用3个变量。&lt;/p></description></item><item><title>洗牌算法</title><link>https://www.ddhigh.com/2023/01/03/shuffle-algorithm/</link><pubDate>Tue, 03 Jan 2023 12:05:44 +0000</pubDate><guid>https://www.ddhigh.com/2023/01/03/shuffle-algorithm/</guid><description>&lt;p>洗牌算法用来将给定的序列打乱，可以认为是排序的反操作。&lt;/p>
&lt;h2 id="正确性判断">正确性判断&lt;/h2>
&lt;p>对于包含$n$个元素的序列，其全排列有$n!$种。如果&lt;strong>序列打乱的结果为$n!$种且每种序列出现的概率相同&lt;/strong>，则是正确的洗牌算法。&lt;/p>
&lt;h2 id="fisheryates-洗牌算法">Fisher–Yates 洗牌算法&lt;/h2>
&lt;blockquote>
&lt;p>以下算法说明摘自: &lt;a href="https://gaohaoyang.github.io/2016/10/16/shuffle-algorithm/">https://gaohaoyang.github.io/2016/10/16/shuffle-algorithm/&lt;/a>&lt;/p>
&lt;p>Fisher–Yates shuffle 的原始版本，最初描述在 1938 年的 Ronald Fisher和 Frank Yates 写的书中，书名为《Statistical tables for biological, agricultural and medical research》。他们使用纸和笔去描述了这个算法，并使用了一个随机数表来提供随机数。它给出了 1 到 N 的数字的的随机排列，具体步骤如下：&lt;/p>
&lt;ol>
&lt;li>写下从 1 到 N 的数字&lt;/li>
&lt;li>取一个从 1 到剩下的数字（包括这个数字）的随机数 k&lt;/li>
&lt;li>从低位开始，得到第 k 个数字（这个数字还没有被取出），把它写在独立的一个列表的最后一位&lt;/li>
&lt;li>重复第 2 步，直到所有的数字都被取出&lt;/li>
&lt;li>第 3 步写出的这个序列，现在就是原始数字的随机排列&lt;/li>
&lt;/ol>
&lt;p>已经证明如果第 2 步取出的数字是真随机的，那么最后得到的排序一定也是。&lt;/p>
&lt;/blockquote>
&lt;h2 id="正确性证明">正确性证明&lt;/h2>
&lt;p>正确的洗牌算法要保证每个数字出现在每个位置的概率一样。我们来看看Fisher–Yates洗牌算法是否正确。&lt;/p>
&lt;p>假设现在有1,2,3,4,5五个数字。&lt;/p>
&lt;ol>
&lt;li>首先在&lt;code>1-5&lt;/code>随机一个数，假设是&lt;code>4&lt;/code>，随机概率为&lt;code>1/5&lt;/code>&lt;/li>
&lt;li>再次从&lt;code>1,2,3,5&lt;/code>中随机一个数，假设是&lt;code>5&lt;/code>，随机概率为&lt;code>1/4&lt;/code>，但是&lt;code>5&lt;/code>在第一步没被选上的概率是&lt;code>4/5&lt;/code>，因此总体概率是&lt;code>1/4*4/5&lt;/code>还是&lt;code>1/5&lt;/code>&lt;/li>
&lt;/ol>
&lt;h2 id="代码">代码&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">shuffle&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> nums) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> nums.&lt;span style="color:#a6e22e">length&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> newIndex &lt;span style="color:#f92672">=&lt;/span> i &lt;span style="color:#f92672">+&lt;/span> random.&lt;span style="color:#a6e22e">nextInt&lt;/span>(n &lt;span style="color:#f92672">-&lt;/span> i); &lt;span style="color:#75715e">// 在i之后的下标随机，可以保证不会随机到i前面的&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> temp &lt;span style="color:#f92672">=&lt;/span> nums&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> nums&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> nums&lt;span style="color:#f92672">[&lt;/span>newIndex&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> nums&lt;span style="color:#f92672">[&lt;/span>newIndex&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> temp;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>时间复杂度: $O(n)$，$n$是数组长度，只需要遍历一次。&lt;/p>
&lt;p>空间复杂度：$O(1)$，仅需常数项空间。&lt;/p></description></item><item><title>原地哈希算法</title><link>https://www.ddhigh.com/2022/12/31/cyclic-sort/</link><pubDate>Sat, 31 Dec 2022 14:16:32 +0000</pubDate><guid>https://www.ddhigh.com/2022/12/31/cyclic-sort/</guid><description>&lt;p>原地哈希算法(Cyclic Sort)主要应用在值都在$[0,n]$的数组$nums$中，此时可以将$nums[i]$作为索引，放回原数组，当然，由于程序上索引是从0开始，因此可以将$nums[i]$放到$nums[nums[i]-1]$的位置上。&lt;/p>
&lt;h2 id="举例">举例&lt;/h2>
&lt;p>Leetcode &lt;a href="https://leetcode.cn/problems/missing-number/">268. 丢失的数字&lt;/a>&lt;/p>
&lt;p>给定一个包含 &lt;code>[0, n]&lt;/code> 中 &lt;code>n&lt;/code> 个数的数组 &lt;code>nums&lt;/code> ，找出 &lt;code>[0, n]&lt;/code> 这个范围内没有出现在数组中的那个数。&lt;/p>
&lt;p>&lt;strong>示例 1：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>输入：nums = [3,0,1]
输出：2
解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。
&lt;/code>&lt;/pre>&lt;p>&lt;strong>示例 2：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>输入：nums = [0,1]
输出：2
解释：n = 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，因为它没有出现在 nums 中。
&lt;/code>&lt;/pre>&lt;p>&lt;strong>示例 3：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>输入：nums = [9,6,4,2,3,5,7,0,1]
输出：8
解释：n = 9，因为有 9 个数字，所以所有的数字都在范围 [0,9] 内。8 是丢失的数字，因为它没有出现在 nums 中。
&lt;/code>&lt;/pre>&lt;p>&lt;strong>示例 4：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>输入：nums = [0]
输出：1
解释：n = 1，因为有 1 个数字，所以所有的数字都在范围 [0,1] 内。1 是丢失的数字，因为它没有出现在 nums 中。
&lt;/code>&lt;/pre>&lt;p>&lt;strong>提示：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>n == nums.length&lt;/code>&lt;/li>
&lt;li>&lt;code>1 &amp;lt;= n &amp;lt;= 104&lt;/code>&lt;/li>
&lt;li>&lt;code>0 &amp;lt;= nums[i] &amp;lt;= n&lt;/code>&lt;/li>
&lt;li>&lt;code>nums&lt;/code> 中的所有数字都 &lt;strong>独一无二&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>**进阶：**你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题?&lt;/p>
&lt;h2 id="解答">解答&lt;/h2>
&lt;p>用哈希表可以解答，但是空间复杂度达到了$O(n)$，没有利用到值都在$[0,n]$这个已知条件。所以我们用原地哈希解答本题。&lt;/p>
&lt;ol>
&lt;li>遍历数组，如果$nums[i]-1&amp;gt;=0$ 且$nums[i] != nums[nums[i]-1]$，证明$nums[i]$未归位，我们将$i$和$nums[i]-1$处的数字交换，此步骤要一直循环到$nums[i]-1$越界或者$nums[i]$归位&lt;/li>
&lt;li>重新遍历数组，如果$nums[i] != i+1$，证明当前位置的$nums[i]$是错的，也就是缺少本来应该放到这个位置的数字，所以答案也就呼之欲出了。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 原地哈希&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 1. 将nums[i] 放到 nums[nums[i]-1]的位置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 2. 重新遍历，如果 nums[i] != i+1 则缺失i+1数字&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">missingNumber&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> nums) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> nums.&lt;span style="color:#a6e22e">length&lt;/span>; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 数字归位&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 如nums[i]为2，那么最终需要放到1号索引&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (nums&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">-&lt;/span> 1 &lt;span style="color:#f92672">&amp;gt;=&lt;/span> 0 &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> nums&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> nums&lt;span style="color:#f92672">[&lt;/span>nums&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">-&lt;/span> 1&lt;span style="color:#f92672">]&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> swap(nums, i, nums&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">-&lt;/span> 1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 数字已归位，查询哪个数字的值和位置不匹配，不匹配的就是缺失的数字&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> nums.&lt;span style="color:#a6e22e">length&lt;/span>; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (nums&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> i &lt;span style="color:#f92672">+&lt;/span> 1) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> i &lt;span style="color:#f92672">+&lt;/span> 1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">swap&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> nums, &lt;span style="color:#66d9ef">int&lt;/span> i, &lt;span style="color:#66d9ef">int&lt;/span> j) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> temp &lt;span style="color:#f92672">=&lt;/span> nums&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> nums&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> nums&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> nums&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> temp;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>时间复杂度：$O(n)$。$n$是数组长度，每个元素会被一次性移动归位，此后不再移动，因此每个元素的访问次数是常数，而总共需要访问$n$个数字。&lt;/p>
&lt;p>空间复杂度：$O(1)$。复用题目给定的$nums$空间作为哈希表，未引入额外空间。&lt;/p></description></item><item><title>博耶-摩尔多数投票算法</title><link>https://www.ddhigh.com/2022/12/31/boyer-moore-majority-vote-algorithm/</link><pubDate>Sat, 31 Dec 2022 14:13:06 +0000</pubDate><guid>https://www.ddhigh.com/2022/12/31/boyer-moore-majority-vote-algorithm/</guid><description>&lt;p>来自&lt;a href="https://zh.m.wikipedia.org/zh-hans/%E5%A4%9A%E6%95%B0%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95">维基百科&lt;/a>的解释：&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>博耶-摩尔多数投票算法&lt;/strong>（英语：Boyer–Moore majority vote algorithm）,中文常作&lt;strong>多数投票算法&lt;/strong>、&lt;strong>摩尔投票算法&lt;/strong>等，是一种用来寻找一组元素中占多数元素的常数空间级&lt;a href="https://zh.m.wikipedia.org/wiki/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">时间复杂度&lt;/a>算法。这一算法由&lt;a href="https://zh.m.wikipedia.org/w/index.php?title=%E7%BD%97%E4%BC%AF%E7%89%B9%C2%B7S%C2%B7%E5%8D%9A%E8%80%B6&amp;amp;action=edit&amp;amp;redlink=1">罗伯特·S·博耶&lt;/a>（英语：&lt;a href="https://en.wikipedia.org/wiki/Robert_S._Boyer">Robert S. Boyer&lt;/a>）和&lt;a href="https://zh.m.wikipedia.org/w/index.php?title=J_Strother_Moore&amp;amp;action=edit&amp;amp;redlink=1">J·斯特罗瑟·摩尔&lt;/a>（英语：&lt;a href="https://en.wikipedia.org/wiki/J_Strother_Moore">J Strother Moore&lt;/a>）在1981年发表[&lt;a href="https://zh.m.wikipedia.org/zh-hans/%E5%A4%9A%E6%95%B0%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95#cite_note-bm-1">1]&lt;/a>，也是&lt;a href="https://zh.m.wikipedia.org/w/index.php?title=Streaming_algorithm&amp;amp;action=edit&amp;amp;redlink=1">处理数据流&lt;/a>（英语：&lt;a href="https://en.wikipedia.org/wiki/streaming_algorithm">streaming algorithm&lt;/a>）的一种典型算法。&lt;/p>
&lt;/blockquote>
&lt;p>简单来说，博耶-摩尔多数投票算法用来寻找数组中的多数元素，相比于用哈希表存储元素和次数使用$O(n)$的时间复杂度来说，该投票算法使用$O(1)$的空间复杂度。&lt;/p>
&lt;h2 id="算法">算法&lt;/h2>
&lt;p>摩尔投票算法分为投票-校验两个阶段。投票阶段会统计候选人的票数，遍历数组，如果当前数字和当前候选人不相等，则该候选人票数-1，当候选人票数归0时，需要更换候选人为当前数字；在校验阶段，需要重新遍历数字，并将值等于候选人的数字计数，遍历结束后，比如计数满足要求，则候选人满足要求。&lt;/p>
&lt;h2 id="举例">举例&lt;/h2>
&lt;p>比如[A,A, A, B,C]这组元素，我们需要筛选数量超过一半的数字。&lt;/p>
&lt;p>首先我们定A为候选人，然后遍历数组，遇到B时A有3个，由于A!=B，因此A结果为2，再和C比较，犹豫A!=C，因此A结尾为1，遍历结束，A是投票阶段的候选人；再遍历数组，统计A的数量为3，超过一半(5/2)，因此A是票数最高的元素。&lt;/p>
&lt;h2 id="算法题">算法题&lt;/h2>
&lt;p>Leetcode &lt;a href="https://leetcode.cn/problems/majority-element-ii/">229. 多数元素 II&lt;/a>&lt;/p>
&lt;p>给定一个大小为 &lt;em>n&lt;/em> 的整数数组，找出其中所有出现超过 &lt;code>⌊ n/3 ⌋&lt;/code> 次的元素。&lt;/p>
&lt;p>&lt;strong>示例 1：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>输入：nums = [3,2,3]
输出：[3]
&lt;/code>&lt;/pre>&lt;p>&lt;strong>示例 2：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>输入：nums = [1]
输出：[1]
&lt;/code>&lt;/pre>&lt;p>&lt;strong>示例 3：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>输入：nums = [1,2]
输出：[1,2]
&lt;/code>&lt;/pre>&lt;h3 id="思路">思路&lt;/h3>
&lt;p>题目要求找出所有出现次数超过&lt;code>n/3&lt;/code>次的元素，由于摩尔投票算法空间复杂度是常数，因此需要预先定义候选人个数。&lt;/p>
&lt;p>设出现次数超过&lt;code>n/3&lt;/code>次的元素有$x$个，以下是求解$x$的过程：
$$
\begin{equation}\label{eqn:1}
\begin{aligned}
&amp;amp; 假设刚好是n/3个 \
&amp;amp; \because x * n/3 = n \
&amp;amp; \therefore x=3 \
&amp;amp; 而实际上题目要求次数 &amp;gt; n/3 \
&amp;amp; \therefore x &amp;lt; 3 \
&amp;amp; \therefore x = 2
\end{aligned}
\end{equation}
$$
所以本题最多能选择2个候选人。&lt;/p>
&lt;ol>
&lt;li>不妨设两个候选人$candidate1$和$candidate2$，$count1$和$count2$都是0&lt;/li>
&lt;li>遍历数组，如果当前$nums[i]==candidate1$，则$count1++$，否则$count1&amp;ndash;$，对$candidate2$同样处理&lt;/li>
&lt;li>如果遍历过程中$count1$或$count2$为0，则更新对应的候选人为$nums[i]$&lt;/li>
&lt;li>投票阶段结束，进入重新计数校验阶段，我们留下了$candidate1$和$candidate2$，再次遍历数组，如果值和这两个候选人相同，则对应的$count$增加&lt;/li>
&lt;li>如果$count&amp;gt;nums.length/3$，则将当前候选人加入答案&lt;/li>
&lt;/ol>
&lt;h3 id="代码">代码&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution2&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 摩尔投票法&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 1. 因为题目要求超过 n/3 的数字，因此最多有2个数字&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 2. 投票阶段，初始化2个数字，以及count&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 3. 遍历nums，如果和num1相等，则count1++，如果和num2相等，则count2++，否则票数--&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 4. 如果num1的count1为0，则num1为当前num&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 5. 校验阶段&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 6. 统计num1和num2的次数，看看是否&amp;gt;n/3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">majorityElement&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> nums) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> answer &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (nums.&lt;span style="color:#a6e22e">length&lt;/span> &lt;span style="color:#f92672">==&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Collections.&lt;span style="color:#a6e22e">emptyList&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> candidate1 &lt;span style="color:#f92672">=&lt;/span> nums&lt;span style="color:#f92672">[&lt;/span>0&lt;span style="color:#f92672">]&lt;/span>, count1 &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> candidate2 &lt;span style="color:#f92672">=&lt;/span> nums&lt;span style="color:#f92672">[&lt;/span>0&lt;span style="color:#f92672">]&lt;/span>, count2 &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> num : nums) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 增加1的票数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (num &lt;span style="color:#f92672">==&lt;/span> candidate1) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count1&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">continue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 增加2的票数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (num &lt;span style="color:#f92672">==&lt;/span> candidate2) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count2&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">continue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 1票数不足，更新候选人1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (count1 &lt;span style="color:#f92672">==&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> candidate1 &lt;span style="color:#f92672">=&lt;/span> num;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count1&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">continue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 2票数不足，更新候选人2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (count2 &lt;span style="color:#f92672">==&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> candidate2 &lt;span style="color:#f92672">=&lt;/span> num;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count2&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">continue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 票数相减&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count1&lt;span style="color:#f92672">--&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count2&lt;span style="color:#f92672">--&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count1 &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count2 &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">var&lt;/span> num : nums) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (num &lt;span style="color:#f92672">==&lt;/span> candidate1) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count1&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (num &lt;span style="color:#f92672">==&lt;/span> candidate2) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count2&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (count1 &lt;span style="color:#f92672">&amp;gt;&lt;/span> nums.&lt;span style="color:#a6e22e">length&lt;/span> &lt;span style="color:#f92672">/&lt;/span> 3) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> answer.&lt;span style="color:#a6e22e">add&lt;/span>(candidate1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (count2 &lt;span style="color:#f92672">&amp;gt;&lt;/span> nums.&lt;span style="color:#a6e22e">length&lt;/span> &lt;span style="color:#f92672">/&lt;/span> 3) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> answer.&lt;span style="color:#a6e22e">add&lt;/span>(candidate2);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> answer;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>时间复杂度：$O(n)$, $n$是数组长度，需要遍历两次。&lt;/p>
&lt;p>空间复杂度: $O(1)$，只需要常数项额外空间。&lt;/p></description></item><item><title>基数排序算法</title><link>https://www.ddhigh.com/2022/12/30/radix-sort/</link><pubDate>Fri, 30 Dec 2022 18:57:38 +0000</pubDate><guid>https://www.ddhigh.com/2022/12/30/radix-sort/</guid><description>&lt;p>基数排序又叫桶排序，是一种时间复杂度为$O(n)$的排序算法，但是相比于其他排序算法有$O(n)$的空间复杂度。&lt;/p>
&lt;h2 id="思路">思路&lt;/h2>
&lt;p>基数排序的核心思路如下：&lt;/p>
&lt;ol>
&lt;li>准备0~9的10个桶，根据数字当前比较位的值来决定放入哪个桶。如当前比较个位，则数字13应该放入索引为3的桶中；当前比较百位，则123应该放入索引为1的桶中。&lt;/li>
&lt;li>当所有数字全部放入桶之后，遍历0~9这10个桶，然后依次将数字保存到待排序数组，因为桶是有序的，所以本轮放回去的数字是有序的。&lt;/li>
&lt;li>当前比较的位数左移，比如本轮比较个位，下一轮应该比较百位。&lt;/li>
&lt;li>重复步骤1~3。&lt;/li>
&lt;/ol>
&lt;h2 id="举例">举例&lt;/h2>
&lt;p>现在我们来看一个实际例子。&lt;/p>
&lt;p>待排序数字：717, 328, 803, 422, 586, 944, 557, 308, 496, 624&lt;/p>
&lt;h3 id="第1轮比较个位">第1轮比较个位&lt;/h3>
&lt;p>直接按照个位放入桶中。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>0&lt;/th>
&lt;th>1&lt;/th>
&lt;th>2&lt;/th>
&lt;th>3&lt;/th>
&lt;th>4&lt;/th>
&lt;th>5&lt;/th>
&lt;th>6&lt;/th>
&lt;th>7&lt;/th>
&lt;th>8&lt;/th>
&lt;th>9&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>422&lt;/td>
&lt;td>803&lt;/td>
&lt;td>624&lt;/td>
&lt;td>&lt;/td>
&lt;td>586&lt;/td>
&lt;td>717&lt;/td>
&lt;td>328&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>496&lt;/td>
&lt;td>557&lt;/td>
&lt;td>308&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>按照从左到右，从上到下的原则将数字归位：422,803,624,586,496,717,557,328,308&lt;/p>
&lt;h3 id="第2轮比较十位">第2轮比较十位&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>0&lt;/th>
&lt;th>1&lt;/th>
&lt;th>2&lt;/th>
&lt;th>3&lt;/th>
&lt;th>4&lt;/th>
&lt;th>5&lt;/th>
&lt;th>6&lt;/th>
&lt;th>7&lt;/th>
&lt;th>8&lt;/th>
&lt;th>9&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>803&lt;/td>
&lt;td>717&lt;/td>
&lt;td>422&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>557&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>586&lt;/td>
&lt;td>496&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>308&lt;/td>
&lt;td>&lt;/td>
&lt;td>624&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>328&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>按照从左到右，从上到下的原则将数字归位：803,308,717,422,624,328,557,586,496&lt;/p>
&lt;h3 id="第3轮比较百位">第3轮比较百位&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>0&lt;/th>
&lt;th>1&lt;/th>
&lt;th>2&lt;/th>
&lt;th>3&lt;/th>
&lt;th>4&lt;/th>
&lt;th>5&lt;/th>
&lt;th>6&lt;/th>
&lt;th>7&lt;/th>
&lt;th>8&lt;/th>
&lt;th>9&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>308&lt;/td>
&lt;td>422&lt;/td>
&lt;td>557&lt;/td>
&lt;td>624&lt;/td>
&lt;td>717&lt;/td>
&lt;td>803&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>328&lt;/td>
&lt;td>496&lt;/td>
&lt;td>586&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>按照从左到右，从上到下的原则将数字归位：308,328,422,496,557,586,624,717,803&lt;/p>
&lt;p>可以发现，比较的轮次由数组中最大的数字决定，以上面的例子来说，如果还存在一个1234数字，那么需要比较4轮才可以完成排序。&lt;/p>
&lt;h2 id="代码实现">代码实现&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">RadixSort&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 基数排序&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">sort&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> nums) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (nums.&lt;span style="color:#a6e22e">length&lt;/span> &lt;span style="color:#f92672">&amp;lt;=&lt;/span> 1) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> max &lt;span style="color:#f92672">=&lt;/span> Arrays.&lt;span style="color:#a6e22e">stream&lt;/span>(nums).&lt;span style="color:#a6e22e">max&lt;/span>().&lt;span style="color:#a6e22e">getAsInt&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 当前处理位数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> exp &lt;span style="color:#f92672">=&lt;/span> 1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 桶&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> bucket &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[&lt;/span>10&lt;span style="color:#f92672">][&lt;/span>nums.&lt;span style="color:#a6e22e">length&lt;/span>&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 记录每个桶有几个数字&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> bucketCount &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[&lt;/span>10&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (max &lt;span style="color:#f92672">&amp;gt;=&lt;/span> exp) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 求得每个数字当前位数的值&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">var&lt;/span> num : nums) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 求得当前位余数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> bitNumber &lt;span style="color:#f92672">=&lt;/span> (num &lt;span style="color:#f92672">/&lt;/span> exp) &lt;span style="color:#f92672">%&lt;/span> 10;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 放入桶, index是桶的index，在同一个桶的数字需要index来标识位置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> index &lt;span style="color:#f92672">=&lt;/span> bucketCount&lt;span style="color:#f92672">[&lt;/span>bitNumber&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bucket&lt;span style="color:#f92672">[&lt;/span>bitNumber&lt;span style="color:#f92672">][&lt;/span>index&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> num;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 桶内数量+1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bucketCount&lt;span style="color:#f92672">[&lt;/span>bitNumber&lt;span style="color:#f92672">]++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 桶内数字归位&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> k &lt;span style="color:#f92672">=&lt;/span> 0; &lt;span style="color:#75715e">// 已归位的数字下标&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">var&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> 10; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (bucketCount&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">&amp;gt;&lt;/span> 0) { &lt;span style="color:#75715e">// 当前桶有数字&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> 0; j &lt;span style="color:#f92672">&amp;lt;&lt;/span> bucketCount&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span>; j&lt;span style="color:#f92672">++&lt;/span>) { &lt;span style="color:#75715e">// 遍历同一个桶的数字&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> nums&lt;span style="color:#f92672">[&lt;/span>k&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> bucket&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">][&lt;/span>j&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> k&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 桶数字清空&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bucketCount&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 位数左移&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exp &lt;span style="color:#f92672">*=&lt;/span> 10;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> max &lt;span style="color:#f92672">=&lt;/span> Integer.&lt;span style="color:#a6e22e">MIN_VALUE&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 1; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> nums.&lt;span style="color:#a6e22e">length&lt;/span>; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> gap &lt;span style="color:#f92672">=&lt;/span> nums&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">-&lt;/span> nums&lt;span style="color:#f92672">[&lt;/span>i &lt;span style="color:#f92672">-&lt;/span> 1&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (gap &lt;span style="color:#f92672">&amp;gt;&lt;/span> max) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> max &lt;span style="color:#f92672">=&lt;/span> gap;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span> args) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> sort &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> RadixSort();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> list &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span>{422, 803, 624, 586, 496, 717, 557, 328, 308};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sort.&lt;span style="color:#a6e22e">sort&lt;/span>(list);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(Arrays.&lt;span style="color:#a6e22e">toString&lt;/span>(list));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>时间复杂度: $O(n)$ ，严格来说是$O(log(n))$。$n$是待排序数组长度，在数据量小的情况下，最外层的while循环遍历次数可以认为是常数，内部嵌套的for循环次数为数组长度$n$，因此时间复杂度为$O(n)$；在数据量大的情况下，最外层的while循环次数为$O(log(n))$，内部嵌套的for循环次数依旧是$n$，因此时间复杂度为$O(nlog(n))$。&lt;/p>
&lt;p>空间复杂度：$O(n)$。$n$是待排序数组长度，$bucket$的大小为$10*n$，$bucketCount$大小为$n$，因此总体空间复杂度为$O(n)$。&lt;/p></description></item><item><title>算法篇-leetcode 131 分割回文串</title><link>https://www.ddhigh.com/2022/03/17/palindrome-partitioning/</link><pubDate>Thu, 17 Mar 2022 12:00:14 +0000</pubDate><guid>https://www.ddhigh.com/2022/03/17/palindrome-partitioning/</guid><description>&lt;h2 id="题目">题目&lt;/h2>
&lt;p>给你一个字符串 &lt;code>s&lt;/code>，请你将 &lt;code>s&lt;/code> 分割成一些子串，使每个子串都是 &lt;strong>回文串&lt;/strong> 。返回 &lt;code>s&lt;/code> 所有可能的分割方案。&lt;/p>
&lt;p>&lt;strong>回文串&lt;/strong> 是正着读和反着读都一样的字符串。&lt;/p>
&lt;p>&lt;strong>示例1&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>输入：s = &amp;#34;aab&amp;#34;
输出：[[&amp;#34;a&amp;#34;,&amp;#34;a&amp;#34;,&amp;#34;b&amp;#34;],[&amp;#34;aa&amp;#34;,&amp;#34;b&amp;#34;]]
&lt;/code>&lt;/pre>&lt;h2 id="解答">解答&lt;/h2>
&lt;p>&lt;strong>题目要求&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>将字符串字符打散后，将其中的回文串添加到一个单独的List&lt;/li>
&lt;li>第1步的所有List构成最后的答案&lt;/li>
&lt;/ol>
&lt;p>可以看出，这是一个典型的回溯问题，考察有多少种方法可以组装最后的答案。&lt;/p>
&lt;h4 id="方法一直接回溯">方法一：直接回溯&lt;/h4>
&lt;p>&lt;strong>思路及算法&lt;/strong>&lt;/p>
&lt;p>回溯需要回答以下3个问题：&lt;/p>
&lt;ol>
&lt;li>回溯终止条件是什么？&lt;/li>
&lt;li>回溯有哪些选择?&lt;/li>
&lt;li>如何进入下一个选择？&lt;/li>
&lt;/ol>
&lt;p>对于本题来说，我们需要将字符串打散，从中选择回文串添加到最终答案，因此，需要定义以下变量:&lt;/p>
&lt;ol>
&lt;li>$index$, 记录当前选择的字符索引&lt;/li>
&lt;li>$path$, 记录本次回文串选择情况&lt;/li>
&lt;li>$answer$, 记录最终答案&lt;/li>
&lt;/ol>
&lt;p>回答上面提出来的两个问题：&lt;/p>
&lt;ol>
&lt;li>回溯终止条件: $index==s.length()$，此时将$path$拷贝到$answer$，不可以直接添加，因为回溯存在撤回操作，必须断开$answer$和$path$的引用。&lt;/li>
&lt;li>回溯有哪些选择：定义变量$right$, 遍历 $s[index,s.length())$，当$s[index,right]$是回文串时，将其加入$path$。&lt;/li>
&lt;li>如何进入下一个选择：第2个问题满足条件的情况下，增加$index$然后再次递归即可。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * DFS回溯
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 1. 回溯出口 index == s.length()
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 2. 回溯递进 遍历[i,n) 如果s[i,j] 是回文串，则加入path，然后递归 s[i,j+1]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @param s
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @return
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">partition&lt;/span>(String s) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> answer &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> path &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dfs(answer, path, 0, s.&lt;span style="color:#a6e22e">length&lt;/span>(), s);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> answer;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">dfs&lt;/span>(List&lt;span style="color:#f92672">&amp;lt;&lt;/span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> answer, List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> path, &lt;span style="color:#66d9ef">int&lt;/span> index, &lt;span style="color:#66d9ef">int&lt;/span> length, String s) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (index &lt;span style="color:#f92672">==&lt;/span> length) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> answer.&lt;span style="color:#a6e22e">add&lt;/span>(&lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>(path));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 本次有什么选择?&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// j =&amp;gt; [index,len)，检测s[index,j]是否回文，如果是，则加入path，最后撤销选择&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> index; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> length; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>isPalindrome(s, index, i)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">continue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> path.&lt;span style="color:#a6e22e">add&lt;/span>(s.&lt;span style="color:#a6e22e">substring&lt;/span>(index, i &lt;span style="color:#f92672">+&lt;/span> 1));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dfs(answer, path, i &lt;span style="color:#f92672">+&lt;/span> 1, length, s);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> path.&lt;span style="color:#a6e22e">remove&lt;/span>(path.&lt;span style="color:#a6e22e">size&lt;/span>() &lt;span style="color:#f92672">-&lt;/span> 1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">isPalindrome&lt;/span>(String s, &lt;span style="color:#66d9ef">int&lt;/span> left, &lt;span style="color:#66d9ef">int&lt;/span> right) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (left &lt;span style="color:#f92672">&amp;lt;&lt;/span> right) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (s.&lt;span style="color:#a6e22e">charAt&lt;/span>(left) &lt;span style="color:#f92672">!=&lt;/span> s.&lt;span style="color:#a6e22e">charAt&lt;/span>(right)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> left&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> right&lt;span style="color:#f92672">--&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>复杂度分析&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>时间复杂度：$O(N*2^n)$，每个位置的字符可以拆分也可以不拆分，因此时间复杂度是$O(2^n)$，判断每个子字符串是否为回文串需要$O(N)$的时间。&lt;/li>
&lt;li>空间复杂度：$O(N*2^n)$，考虑$answer$，每个位置的字符可以拆分也可以不拆分，两种情况都需要占用空间，此部分空间是$O(2^n)$，而对于所有的答案都需要保存，此部分空间是$O(N)$.&lt;/li>
&lt;/ul>
&lt;h4 id="方法二记忆法回溯">方法二：记忆法回溯&lt;/h4>
&lt;p>&lt;strong>思路及算法&lt;/strong>&lt;/p>
&lt;p>在方法一的基础上添加$memo$保存$s[i,j]$是否为回文串，减少重复判断。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * DFS回溯
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 1. 回溯出口 index == s.length()
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 2. 回溯递进 遍历[i,n) 如果s[i,j] 是回文串，则加入path，然后递归 s[i,j+1]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @param s
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @return
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">partition&lt;/span>(String s) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> answer &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> path &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Boolean&lt;span style="color:#f92672">[][]&lt;/span> memo &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Boolean&lt;span style="color:#f92672">[&lt;/span>s.&lt;span style="color:#a6e22e">length&lt;/span>()&lt;span style="color:#f92672">][&lt;/span>s.&lt;span style="color:#a6e22e">length&lt;/span>()&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dfs(memo, answer, path, 0, s.&lt;span style="color:#a6e22e">length&lt;/span>(), s);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> answer;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">dfs&lt;/span>(Boolean&lt;span style="color:#f92672">[][]&lt;/span> memo, List&lt;span style="color:#f92672">&amp;lt;&lt;/span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> answer, List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> path, &lt;span style="color:#66d9ef">int&lt;/span> index, &lt;span style="color:#66d9ef">int&lt;/span> length, String s) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (index &lt;span style="color:#f92672">==&lt;/span> length) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> answer.&lt;span style="color:#a6e22e">add&lt;/span>(&lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>(path));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 本次有什么选择?&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// j =&amp;gt; [index,len)，检测s[index,j]是否回文，如果是，则加入path，最后撤销选择&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> index; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> length; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>isPalindrome(memo, s, index, i)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">continue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> path.&lt;span style="color:#a6e22e">add&lt;/span>(s.&lt;span style="color:#a6e22e">substring&lt;/span>(index, i &lt;span style="color:#f92672">+&lt;/span> 1));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dfs(memo, answer, path, i &lt;span style="color:#f92672">+&lt;/span> 1, length, s);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> path.&lt;span style="color:#a6e22e">remove&lt;/span>(path.&lt;span style="color:#a6e22e">size&lt;/span>() &lt;span style="color:#f92672">-&lt;/span> 1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">isPalindrome&lt;/span>(Boolean&lt;span style="color:#f92672">[][]&lt;/span> memo, String s, &lt;span style="color:#66d9ef">int&lt;/span> left, &lt;span style="color:#66d9ef">int&lt;/span> right) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (memo&lt;span style="color:#f92672">[&lt;/span>left&lt;span style="color:#f92672">][&lt;/span>right&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> memo&lt;span style="color:#f92672">[&lt;/span>left&lt;span style="color:#f92672">][&lt;/span>right&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (left &lt;span style="color:#f92672">&amp;lt;&lt;/span> right) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (s.&lt;span style="color:#a6e22e">charAt&lt;/span>(left) &lt;span style="color:#f92672">!=&lt;/span> s.&lt;span style="color:#a6e22e">charAt&lt;/span>(right)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> memo&lt;span style="color:#f92672">[&lt;/span>left&lt;span style="color:#f92672">][&lt;/span>right&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> left&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> right&lt;span style="color:#f92672">--&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> memo&lt;span style="color:#f92672">[&lt;/span>left&lt;span style="color:#f92672">][&lt;/span>right&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>复杂度分析&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>时间复杂度：$O(N*2^n)$，每个位置的字符可以拆分也可以不拆分，因此时间复杂度是$O(2^n)$，判断每个子字符串是否为回文串需要$O(N)$的时间，但是添加了记忆化搜索，每个子串至多搜索一次。&lt;/li>
&lt;li>空间复杂度：$O(N*2^n)$，考虑$answer$，每个位置的字符可以拆分也可以不拆分，两种情况都需要占用空间，此部分空间是$O(2^n)$，而对于所有的答案都需要保存，此部分空间是$O(N)$.&lt;/li>
&lt;/ul>
&lt;h4 id="方法三dp回溯">方法三：DP+回溯&lt;/h4>
&lt;p>我们可以利用DP通过提前计算好字符串的回文信息。&lt;/p>
&lt;p>&lt;strong>思路和算法&lt;/strong>&lt;/p>
&lt;p>需要提前截取子字符串然后进行DP。那么问题来了，如何截取所有在子字符串？
我们可以定义如下双重循环：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> right &lt;span style="color:#f92672">=&lt;/span> 0;right &lt;span style="color:#f92672">&amp;lt;&lt;/span> s.&lt;span style="color:#a6e22e">length&lt;/span>(); right&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> left &lt;span style="color:#f92672">=&lt;/span> 0;left&lt;span style="color:#f92672">&amp;lt;=&lt;/span> right; right&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// s[left,right] 就是所有的子字符串&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>思考状态转移方程&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>定义$dp[i][j]$代表$s[i, j]$是否为回文串&lt;/li>
&lt;li>当$s[left] == s[right]$可知字符串两端是相等的，需要考虑$left和right$的距离，通过穷举(笨办法)可知：
&lt;ol>
&lt;li>$right - left = 0$时，$left$和$right$就是同一个字符，显然可以直接得到答案$true$&lt;/li>
&lt;li>$right - left = 1$时，$left$和$right$是挨着的，比如$aa$，显然可以直接得到答案$true$&lt;/li>
&lt;li>$right - right = 2$时，$left$和$right$中间夹了一个字符，比如$aba$，显然可以直接得到答案$true$&lt;/li>
&lt;li>$right - right &amp;gt; 2$ 时，不能直接看不出来了，需要进行状态转移，比如$aabaa$，当$s[0] == s[4]$时，我们需要看看$s[1,3]$是不是回文串，在本例中，由于$s[1,3]$是回文串，因此$s[0,4]$也是。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>综上，DP方程如下：&lt;/p>
&lt;p>$$
dp(i,j) = \begin{cases}
false, &amp;amp; \text{if } s[i] \ne s[j] \
true, &amp;amp; \text{if } s[i] = s[j] &amp;amp; j-i \le 2 \&lt;br>
dp[i+1][j-1], &amp;amp; \text{if } j-i \gt 2
\end{cases}
$$&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * DP+DFS回溯
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 1. DP处理 dp[i][j]是否为回文
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 1.1 dp[i][i] = true
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 1.2 dp[i][j] = s[i] == s[j] &amp;amp;&amp;amp; (dp[i+1][j-1] || j-i&amp;lt;=2)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 2. 回溯
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 2.1 回溯出口: index == s.length()
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 2.2 回溯递进：j =&amp;gt; [i,s.length()) if(dp[i][j]) 添加子串，然后 dfs(index+1)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @param s
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @return
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">partition&lt;/span>(String s) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> s.&lt;span style="color:#a6e22e">length&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">boolean&lt;/span>&lt;span style="color:#f92672">[][]&lt;/span> dp &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span>&lt;span style="color:#f92672">[&lt;/span>n&lt;span style="color:#f92672">][&lt;/span>n&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> right &lt;span style="color:#f92672">=&lt;/span> 0; right &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; right&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> left &lt;span style="color:#f92672">=&lt;/span> 0; left &lt;span style="color:#f92672">&amp;lt;=&lt;/span> right; left&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (s.&lt;span style="color:#a6e22e">charAt&lt;/span>(left) &lt;span style="color:#f92672">==&lt;/span> s.&lt;span style="color:#a6e22e">charAt&lt;/span>(right)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (right &lt;span style="color:#f92672">-&lt;/span> left &lt;span style="color:#f92672">&amp;lt;=&lt;/span> 2) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dp&lt;span style="color:#f92672">[&lt;/span>left&lt;span style="color:#f92672">][&lt;/span>right&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dp&lt;span style="color:#f92672">[&lt;/span>left&lt;span style="color:#f92672">][&lt;/span>right&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> dp&lt;span style="color:#f92672">[&lt;/span>left &lt;span style="color:#f92672">+&lt;/span> 1&lt;span style="color:#f92672">][&lt;/span>right &lt;span style="color:#f92672">-&lt;/span> 1&lt;span style="color:#f92672">]&lt;/span>; &lt;span style="color:#75715e">// 上一轮遍历过&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> answer &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> path &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dfs(answer, path, dp, 0, n, s);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> answer;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">dfs&lt;/span>(List&lt;span style="color:#f92672">&amp;lt;&lt;/span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> answer, List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> path, &lt;span style="color:#66d9ef">boolean&lt;/span>&lt;span style="color:#f92672">[][]&lt;/span> dp, &lt;span style="color:#66d9ef">int&lt;/span> index, &lt;span style="color:#66d9ef">int&lt;/span> n, String s) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (index &lt;span style="color:#f92672">==&lt;/span> n) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> answer.&lt;span style="color:#a6e22e">add&lt;/span>(&lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>(path));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> right &lt;span style="color:#f92672">=&lt;/span> index; right &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; right&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (dp&lt;span style="color:#f92672">[&lt;/span>index&lt;span style="color:#f92672">][&lt;/span>right&lt;span style="color:#f92672">]&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> path.&lt;span style="color:#a6e22e">add&lt;/span>(s.&lt;span style="color:#a6e22e">substring&lt;/span>(index, right &lt;span style="color:#f92672">+&lt;/span> 1));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dfs(answer, path, dp, right &lt;span style="color:#f92672">+&lt;/span> 1, n, s);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> path.&lt;span style="color:#a6e22e">remove&lt;/span>(path.&lt;span style="color:#a6e22e">size&lt;/span>() &lt;span style="color:#f92672">-&lt;/span> 1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>复杂度分析&lt;/strong>
+时间复杂度：$O(2^n)$，计算$dp$需要$O(n^2)$,回溯需要$O(2^n)$。&lt;/p>
&lt;ul>
&lt;li>空间复杂度：$O(N*2^n)$，考虑$answer$，每个位置的字符可以拆分也可以不拆分，两种情况都需要占用空间，此部分空间是$O(2^n)$，而对于所有的答案都需要保存，此部分空间是$O(N)$;考虑$dp$，需要$O(n^2)$的空间&lt;/li>
&lt;/ul></description></item><item><title>LeetCode106——从中序与后序遍历序列构造二叉树</title><link>https://www.ddhigh.com/2022/02/08/construct-binary-tree-from-inorder-and-postorder-traversal/</link><pubDate>Tue, 08 Feb 2022 20:24:19 +0000</pubDate><guid>https://www.ddhigh.com/2022/02/08/construct-binary-tree-from-inorder-and-postorder-traversal/</guid><description>&lt;h2 id="题目">题目&lt;/h2>
&lt;p>给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。&lt;/p>
&lt;p>&lt;strong>示例 1:&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]
输出：[3,9,20,null,null,15,7]
&lt;/code>&lt;/pre>&lt;p>&lt;strong>示例 2:&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>输入：inorder = [-1], postorder = [-1]
输出：[-1]
&lt;/code>&lt;/pre>&lt;p>来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/p>
&lt;h2 id="思路">思路&lt;/h2>
&lt;blockquote>
&lt;p>核心是中序遍历的顺序是[左，根，右]，后序遍历是[左，右，根]。而同一颗树不管前/中/后序遍历，节点数是不变的。&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 后序遍历顺序: 左右根
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 1. postorder最后一个元素为根
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 2. 遍历inorder查找根的index
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 3. inorder[:index]为左子树，inorder[index+1:]为右子树，左子树大小记为leftTreeSize
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 4. postorder[:leftTreeSize]为左子树，postorder[leftTreeSize:len(postorder)-1]是右子树
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">buildTree&lt;/span>(&lt;span style="color:#a6e22e">inorder&lt;/span> []&lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#a6e22e">postorder&lt;/span> []&lt;span style="color:#66d9ef">int&lt;/span>) &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">TreeNode&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> len(&lt;span style="color:#a6e22e">inorder&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">TreeNode&lt;/span>{&lt;span style="color:#a6e22e">Val&lt;/span>: &lt;span style="color:#a6e22e">inorder&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>]}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 查找中序遍历根的index
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">index&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">rootValue&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">postorder&lt;/span>[len(&lt;span style="color:#a6e22e">postorder&lt;/span>)&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span> &amp;lt; len(&lt;span style="color:#a6e22e">inorder&lt;/span>); &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">inorder&lt;/span>[&lt;span style="color:#a6e22e">i&lt;/span>] &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#a6e22e">rootValue&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">index&lt;/span> = &lt;span style="color:#a6e22e">i&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 分割数组
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">leftTreeSize&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> len(&lt;span style="color:#a6e22e">inorder&lt;/span>[:&lt;span style="color:#a6e22e">index&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">root&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">TreeNode&lt;/span>{&lt;span style="color:#a6e22e">Val&lt;/span>: &lt;span style="color:#a6e22e">rootValue&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">root&lt;/span>.&lt;span style="color:#a6e22e">Left&lt;/span> = &lt;span style="color:#a6e22e">buildTree&lt;/span>(&lt;span style="color:#a6e22e">inorder&lt;/span>[:&lt;span style="color:#a6e22e">index&lt;/span>], &lt;span style="color:#a6e22e">postorder&lt;/span>[:&lt;span style="color:#a6e22e">leftTreeSize&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">root&lt;/span>.&lt;span style="color:#a6e22e">Right&lt;/span> = &lt;span style="color:#a6e22e">buildTree&lt;/span>(&lt;span style="color:#a6e22e">inorder&lt;/span>[&lt;span style="color:#a6e22e">index&lt;/span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>:], &lt;span style="color:#a6e22e">postorder&lt;/span>[&lt;span style="color:#a6e22e">leftTreeSize&lt;/span>:len(&lt;span style="color:#a6e22e">postorder&lt;/span>)&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">root&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>LeetCode108——将有序数组转换为二叉搜索树</title><link>https://www.ddhigh.com/2022/02/08/convert-sorted-array-to-binary-search-tree/</link><pubDate>Tue, 08 Feb 2022 20:24:19 +0000</pubDate><guid>https://www.ddhigh.com/2022/02/08/convert-sorted-array-to-binary-search-tree/</guid><description>&lt;h2 id="题目">题目&lt;/h2>
&lt;p>给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。&lt;/p>
&lt;p>高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。&lt;/p>
&lt;p>&lt;strong>示例 1：&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg" alt="img">&lt;/p>
&lt;pre tabindex="0">&lt;code>输入：nums = [-10,-3,0,5,9]
输出：[0,-3,9,-10,null,5]
&lt;/code>&lt;/pre>&lt;p>&lt;strong>示例 2：&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://assets.leetcode.com/uploads/2021/02/18/btree.jpg" alt="img">&lt;/p>
&lt;pre tabindex="0">&lt;code>输入：nums = [1,3]
输出：[3,1]
解释：[1,3] 和 [3,1] 都是高度平衡二叉搜索树。
&lt;/code>&lt;/pre>&lt;h2 id="思路">思路&lt;/h2>
&lt;blockquote>
&lt;p>二叉树的中序遍历是升序，节点顺序为[左，根，右]&lt;/p>
&lt;/blockquote>
&lt;ol>
&lt;li>对于给定的数组，根据升序的性质，可知，中间节点为根节点，左半部分为左子树，右半部分为右子树&lt;/li>
&lt;li>左半部分也是一颗完整的树，复用1的逻辑，因此用递归即可&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 升序数组是树的中序遍历结果，中间Index就是根，可以递归的还原为一个树
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">sortedArrayToBST&lt;/span>(&lt;span style="color:#a6e22e">nums&lt;/span> []&lt;span style="color:#66d9ef">int&lt;/span>) &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">TreeNode&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> len(&lt;span style="color:#a6e22e">nums&lt;/span>) &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> len(&lt;span style="color:#a6e22e">nums&lt;/span>) &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">TreeNode&lt;/span>{&lt;span style="color:#a6e22e">Val&lt;/span>: &lt;span style="color:#a6e22e">nums&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>]}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">helper&lt;/span>(&lt;span style="color:#a6e22e">nums&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, len(&lt;span style="color:#a6e22e">nums&lt;/span>)&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">helper&lt;/span>(&lt;span style="color:#a6e22e">nums&lt;/span> []&lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#a6e22e">start&lt;/span>, &lt;span style="color:#a6e22e">end&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">TreeNode&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">start&lt;/span> &amp;gt; &lt;span style="color:#a6e22e">end&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 取得根
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">rootIndex&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> (&lt;span style="color:#a6e22e">start&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">end&lt;/span>) &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">rootValue&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">nums&lt;/span>[&lt;span style="color:#a6e22e">rootIndex&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">root&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">TreeNode&lt;/span>{&lt;span style="color:#a6e22e">Val&lt;/span>: &lt;span style="color:#a6e22e">rootValue&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">root&lt;/span>.&lt;span style="color:#a6e22e">Left&lt;/span> = &lt;span style="color:#a6e22e">helper&lt;/span>(&lt;span style="color:#a6e22e">nums&lt;/span>, &lt;span style="color:#a6e22e">start&lt;/span>, &lt;span style="color:#a6e22e">rootIndex&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">root&lt;/span>.&lt;span style="color:#a6e22e">Right&lt;/span> = &lt;span style="color:#a6e22e">helper&lt;/span>(&lt;span style="color:#a6e22e">nums&lt;/span>, &lt;span style="color:#a6e22e">rootIndex&lt;/span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#a6e22e">end&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">root&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>LeetCode109——有序链表转换二叉搜索树</title><link>https://www.ddhigh.com/2022/02/08/convert-sorted-list-to-binary-search-tree/</link><pubDate>Tue, 08 Feb 2022 20:24:19 +0000</pubDate><guid>https://www.ddhigh.com/2022/02/08/convert-sorted-list-to-binary-search-tree/</guid><description>&lt;h2 id="题目">题目&lt;/h2>
&lt;p>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。&lt;/p>
&lt;p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。&lt;/p>
&lt;p>&lt;strong>示例:&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>给定的有序链表： [-10, -3, 0, 5, 9],
一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：
0
/ \
-3 9
/ /
-10 5
&lt;/code>&lt;/pre>&lt;h2 id="思路">思路&lt;/h2>
&lt;h3 id="转换为数组">转换为数组&lt;/h3>
&lt;blockquote>
&lt;p>转换为数组后解法跟前面一道题一样。&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 链表转换为数组，复用108解法
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">sortedListToBST&lt;/span>(&lt;span style="color:#a6e22e">head&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ListNode&lt;/span>) &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">TreeNode&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">head&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">list&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">listToArray&lt;/span>(&lt;span style="color:#a6e22e">head&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">helper&lt;/span>(&lt;span style="color:#a6e22e">list&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, len(&lt;span style="color:#a6e22e">list&lt;/span>)&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">listToArray&lt;/span>(&lt;span style="color:#a6e22e">head&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ListNode&lt;/span>) []&lt;span style="color:#66d9ef">int&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">result&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> []&lt;span style="color:#66d9ef">int&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">head&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">result&lt;/span> = append(&lt;span style="color:#a6e22e">result&lt;/span>, &lt;span style="color:#a6e22e">head&lt;/span>.&lt;span style="color:#a6e22e">Val&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">head&lt;/span> = &lt;span style="color:#a6e22e">head&lt;/span>.&lt;span style="color:#a6e22e">Next&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">result&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">helper&lt;/span>(&lt;span style="color:#a6e22e">nums&lt;/span> []&lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#a6e22e">start&lt;/span>, &lt;span style="color:#a6e22e">end&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">TreeNode&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">start&lt;/span> &amp;gt; &lt;span style="color:#a6e22e">end&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 取得根
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">rootIndex&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> (&lt;span style="color:#a6e22e">start&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">end&lt;/span>) &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">rootValue&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">nums&lt;/span>[&lt;span style="color:#a6e22e">rootIndex&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">root&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">TreeNode&lt;/span>{&lt;span style="color:#a6e22e">Val&lt;/span>: &lt;span style="color:#a6e22e">rootValue&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">root&lt;/span>.&lt;span style="color:#a6e22e">Left&lt;/span> = &lt;span style="color:#a6e22e">helper&lt;/span>(&lt;span style="color:#a6e22e">nums&lt;/span>, &lt;span style="color:#a6e22e">start&lt;/span>, &lt;span style="color:#a6e22e">rootIndex&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">root&lt;/span>.&lt;span style="color:#a6e22e">Right&lt;/span> = &lt;span style="color:#a6e22e">helper&lt;/span>(&lt;span style="color:#a6e22e">nums&lt;/span>, &lt;span style="color:#a6e22e">rootIndex&lt;/span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#a6e22e">end&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">root&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="链表操作">链表操作&lt;/h3>
&lt;blockquote>
&lt;p>我们遍历到中间节点后，将链表拆分为[左部分，中间点，右部分]即可复用逻辑，而且无额外空间占用&lt;/p>
&lt;/blockquote>
&lt;p>单链表是无法直到中间点在哪里的，因此我们需要先遍历一次，获取链表长度，除以2就是中间的index。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 1. 遍历一遍链表得到链表长度，算出中间节点index
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 2. 再次遍历链表，拆分为三段
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 1. 起点到中间节点的上一个节点：左子链表
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 2. 中间节点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 3. 中间节点的下一个节点到链表末尾：右子链表
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 3. 将中间节点作为树根，利用左右子链表，递归构建左右子树，然后挂到根节点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">sortedListToBST&lt;/span>(&lt;span style="color:#a6e22e">head&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ListNode&lt;/span>) &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">TreeNode&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">head&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">helper&lt;/span>(&lt;span style="color:#a6e22e">head&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">helper&lt;/span>(&lt;span style="color:#a6e22e">head&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ListNode&lt;/span>) &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">TreeNode&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">head&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">head&lt;/span>.&lt;span style="color:#a6e22e">Next&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">TreeNode&lt;/span>{&lt;span style="color:#a6e22e">Val&lt;/span>: &lt;span style="color:#a6e22e">head&lt;/span>.&lt;span style="color:#a6e22e">Val&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 获取链表总长度
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">length&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">p&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">head&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">p&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">length&lt;/span>&lt;span style="color:#f92672">++&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">p&lt;/span> = &lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">Next&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">middle&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">length&lt;/span> &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#75715e">// 取得中间点位置
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 再次遍历到中间点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">prev&lt;/span> = &lt;span style="color:#a6e22e">head&lt;/span> &lt;span style="color:#75715e">// 指向中间点的上一个节点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">curr&lt;/span> = &lt;span style="color:#a6e22e">head&lt;/span>.&lt;span style="color:#a6e22e">Next&lt;/span> &lt;span style="color:#75715e">// 指向中间点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">left&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ListNode&lt;/span> &lt;span style="color:#75715e">// 左子链表头结点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">right&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ListNode&lt;/span> &lt;span style="color:#75715e">// 右子链表头结点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">index&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">curr&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// index是prev的下标，因此定位到middle的前一个
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">index&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#a6e22e">middle&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 找到中点，将中点和右子链表连接打断
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">right&lt;/span> = &lt;span style="color:#a6e22e">curr&lt;/span>.&lt;span style="color:#a6e22e">Next&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">curr&lt;/span>.&lt;span style="color:#a6e22e">Next&lt;/span> = &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 将左子链表和中点连接打断
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">prev&lt;/span>.&lt;span style="color:#a6e22e">Next&lt;/span> = &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">left&lt;/span> = &lt;span style="color:#a6e22e">head&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">prev&lt;/span> = &lt;span style="color:#a6e22e">curr&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">curr&lt;/span> = &lt;span style="color:#a6e22e">curr&lt;/span>.&lt;span style="color:#a6e22e">Next&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">index&lt;/span>&lt;span style="color:#f92672">++&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 此时我们拥有left,curr,right 三个链表，开始递归组合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">root&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">TreeNode&lt;/span>{&lt;span style="color:#a6e22e">Val&lt;/span>: &lt;span style="color:#a6e22e">curr&lt;/span>.&lt;span style="color:#a6e22e">Val&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">root&lt;/span>.&lt;span style="color:#a6e22e">Left&lt;/span> = &lt;span style="color:#a6e22e">helper&lt;/span>(&lt;span style="color:#a6e22e">left&lt;/span>) &lt;span style="color:#75715e">// 给你一条链表，给我构建一个树出来
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">root&lt;/span>.&lt;span style="color:#a6e22e">Right&lt;/span> = &lt;span style="color:#a6e22e">helper&lt;/span>(&lt;span style="color:#a6e22e">right&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">root&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>LeetCode103——二叉树的锯齿形层序遍历</title><link>https://www.ddhigh.com/2022/02/06/binary-tree-zigzag-level-order-traversal/</link><pubDate>Sun, 06 Feb 2022 20:24:19 +0000</pubDate><guid>https://www.ddhigh.com/2022/02/06/binary-tree-zigzag-level-order-traversal/</guid><description>&lt;h2 id="题目">题目&lt;/h2>
&lt;p>给你二叉树的根节点 &lt;code>root&lt;/code> ，返回其节点值的 &lt;strong>锯齿形层序遍历&lt;/strong> 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。&lt;/p>
&lt;p>&lt;strong>示例 1：&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt="img">&lt;/p>
&lt;pre tabindex="0">&lt;code>输入：root = [3,9,20,null,null,15,7]
输出：[[3],[20,9],[15,7]]
&lt;/code>&lt;/pre>&lt;p>&lt;strong>示例 2：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>输入：root = [1]
输出：[[1]]
&lt;/code>&lt;/pre>&lt;p>&lt;strong>示例 3：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>输入：root = []
输出：[]
&lt;/code>&lt;/pre>&lt;p>来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/p>
&lt;h2 id="思路">思路&lt;/h2>
&lt;p>用层序遍历的思路即可，不过偶数行需要将该行的值翻转。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// BFS处理，记录遍历层数，当层数是奇数，翻转下本层元素
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">zigzagLevelOrder&lt;/span>(&lt;span style="color:#a6e22e">root&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">TreeNode&lt;/span>) [][]&lt;span style="color:#66d9ef">int&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">root&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> [][]&lt;span style="color:#66d9ef">int&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">answers&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> [][]&lt;span style="color:#66d9ef">int&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">queue&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> []&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">TreeNode&lt;/span>{&lt;span style="color:#a6e22e">root&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">level&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; len(&lt;span style="color:#a6e22e">queue&lt;/span>) &amp;gt; &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#a6e22e">level&lt;/span>&lt;span style="color:#f92672">++&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">size&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> len(&lt;span style="color:#a6e22e">queue&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">tmp&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">queue&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">queue&lt;/span> = []&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">TreeNode&lt;/span>{} &lt;span style="color:#75715e">// 清空，存储下一层的节点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">vals&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> []&lt;span style="color:#66d9ef">int&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span> &amp;lt; &lt;span style="color:#a6e22e">size&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">node&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">tmp&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">tmp&lt;/span> = &lt;span style="color:#a6e22e">tmp&lt;/span>[&lt;span style="color:#ae81ff">1&lt;/span>:]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">vals&lt;/span> = append(&lt;span style="color:#a6e22e">vals&lt;/span>, &lt;span style="color:#a6e22e">node&lt;/span>.&lt;span style="color:#a6e22e">Val&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">node&lt;/span>.&lt;span style="color:#a6e22e">Left&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">queue&lt;/span> = append(&lt;span style="color:#a6e22e">queue&lt;/span>, &lt;span style="color:#a6e22e">node&lt;/span>.&lt;span style="color:#a6e22e">Left&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">node&lt;/span>.&lt;span style="color:#a6e22e">Right&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">queue&lt;/span> = append(&lt;span style="color:#a6e22e">queue&lt;/span>, &lt;span style="color:#a6e22e">node&lt;/span>.&lt;span style="color:#a6e22e">Right&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">level&lt;/span>&lt;span style="color:#f92672">%&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> { &lt;span style="color:#75715e">// 偶数行，翻转vals
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">length&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> len(&lt;span style="color:#a6e22e">vals&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span> &amp;lt; &lt;span style="color:#a6e22e">length&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">vals&lt;/span>[&lt;span style="color:#a6e22e">i&lt;/span>], &lt;span style="color:#a6e22e">vals&lt;/span>[&lt;span style="color:#a6e22e">length&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#a6e22e">i&lt;/span>] = &lt;span style="color:#a6e22e">vals&lt;/span>[&lt;span style="color:#a6e22e">length&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#a6e22e">i&lt;/span>], &lt;span style="color:#a6e22e">vals&lt;/span>[&lt;span style="color:#a6e22e">i&lt;/span>] &lt;span style="color:#75715e">// length-1是结束下标，-i就是同步往左逼近
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">answers&lt;/span> = append(&lt;span style="color:#a6e22e">answers&lt;/span>, &lt;span style="color:#a6e22e">vals&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">answers&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>LeetCode105——从前序与中序遍历序列构造二叉树</title><link>https://www.ddhigh.com/2022/02/06/construct-binary-tree-from-preorder-and-inorder-traversal/</link><pubDate>Sun, 06 Feb 2022 20:24:19 +0000</pubDate><guid>https://www.ddhigh.com/2022/02/06/construct-binary-tree-from-preorder-and-inorder-traversal/</guid><description>&lt;h2 id="题目">题目&lt;/h2>
&lt;p>给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。&lt;/p>
&lt;p>&lt;strong>示例 1:&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt="img">&lt;/p>
&lt;pre tabindex="0">&lt;code>输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
输出: [3,9,20,null,null,15,7]
&lt;/code>&lt;/pre>&lt;p>&lt;strong>示例 2:&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>输入: preorder = [-1], inorder = [-1]
输出: [-1]
&lt;/code>&lt;/pre>&lt;p>来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/p>
&lt;h2 id="思路">思路&lt;/h2>
&lt;p>利用前序遍历和中序遍历性质&lt;/p>
&lt;ol>
&lt;li>前序遍历节点顺序如下[根，左，右]&lt;/li>
&lt;li>中序遍历节点顺序如下[左，根，右]&lt;/li>
&lt;li>前序遍历的左/右子树长度和中序遍历的左/右子树长度是相同的&lt;/li>
&lt;li>由于这是同一颗树遍历来的，因此前序遍历的第0个元素和中序遍历的根节点是相同的。因此只要能定位中序遍历的根节点，将中序遍历数组拆分为左右两半后就可以了
&lt;ol>
&lt;li>查找中序遍历的数组中值为前序遍历第0个元素节点的下标，记为&lt;code>middle&lt;/code>&lt;/li>
&lt;li>此时中序遍历左子树节点列表为&lt;code>[:middle]&lt;/code>，右子树节点列表为&lt;code>[middle+1:]&lt;/code>，左子树长度为&lt;code>len([:middle])&lt;/code>，记为&lt;code>leftTreeSize&lt;/code>&lt;/li>
&lt;li>根据第3点可知，前序遍历的左子树节点列表为&lt;code>[1:leftTreeSize+1]&lt;/code>,右子树节点为&lt;code>[leftTreeSize+1:]&lt;/code>&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 递归法
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 中序，左根右；前序根左右
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 1. 根据中序遍历找到根节点(值为preorder[0]的节点)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 2. 中序遍历根节点左边的节点数和前序遍历的节点数是相同的，根据该性质可以将前序遍历拆分为两半
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">buildTree&lt;/span>(&lt;span style="color:#a6e22e">preorder&lt;/span> []&lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#a6e22e">inorder&lt;/span> []&lt;span style="color:#66d9ef">int&lt;/span>) &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">TreeNode&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> len(&lt;span style="color:#a6e22e">preorder&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">root&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">TreeNode&lt;/span>{&lt;span style="color:#a6e22e">Val&lt;/span>: &lt;span style="color:#a6e22e">preorder&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>]}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 查找根节点在中序遍历的位置
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">middle&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> ; &lt;span style="color:#a6e22e">middle&lt;/span> &amp;lt; &lt;span style="color:#a6e22e">n&lt;/span>; &lt;span style="color:#a6e22e">middle&lt;/span>&lt;span style="color:#f92672">++&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">inorder&lt;/span>[&lt;span style="color:#a6e22e">middle&lt;/span>] &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#a6e22e">preorder&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>] {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">leftTreeSize&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> len(&lt;span style="color:#a6e22e">inorder&lt;/span>[:&lt;span style="color:#a6e22e">middle&lt;/span>]) &lt;span style="color:#75715e">// 中序遍历的左半边就是左子树
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">root&lt;/span>.&lt;span style="color:#a6e22e">Left&lt;/span> = &lt;span style="color:#a6e22e">buildTree&lt;/span>(&lt;span style="color:#a6e22e">preorder&lt;/span>[&lt;span style="color:#ae81ff">1&lt;/span>:&lt;span style="color:#a6e22e">leftTreeSize&lt;/span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>], &lt;span style="color:#a6e22e">inorder&lt;/span>[:&lt;span style="color:#a6e22e">middle&lt;/span>]) &lt;span style="color:#75715e">// 将前序遍历的左半边和中序的左半边递归构造左子树
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">root&lt;/span>.&lt;span style="color:#a6e22e">Right&lt;/span> = &lt;span style="color:#a6e22e">buildTree&lt;/span>(&lt;span style="color:#a6e22e">preorder&lt;/span>[&lt;span style="color:#a6e22e">leftTreeSize&lt;/span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>:], &lt;span style="color:#a6e22e">inorder&lt;/span>[&lt;span style="color:#a6e22e">middle&lt;/span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>:]) &lt;span style="color:#75715e">// 将前序遍历的右半边和中序遍历的右半边构建右子树
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">root&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>LeetCode107——二叉树的层序遍历 II</title><link>https://www.ddhigh.com/2022/02/06/binary-tree-level-order-traversal-ii/</link><pubDate>Sun, 06 Feb 2022 20:24:19 +0000</pubDate><guid>https://www.ddhigh.com/2022/02/06/binary-tree-level-order-traversal-ii/</guid><description>&lt;h2 id="题目">题目&lt;/h2>
&lt;p>给你二叉树的根节点 &lt;code>root&lt;/code> ，返回其节点值 &lt;strong>自底向上的层序遍历&lt;/strong> 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）&lt;/p>
&lt;p>&lt;strong>示例 1：&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt="img">&lt;/p>
&lt;pre tabindex="0">&lt;code>输入：root = [3,9,20,null,null,15,7]
输出：[[15,7],[9,20],[3]]
&lt;/code>&lt;/pre>&lt;p>&lt;strong>示例 2：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>输入：root = [1]
输出：[[1]]
&lt;/code>&lt;/pre>&lt;p>&lt;strong>示例 3：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>输入：root = []
输出：[]
&lt;/code>&lt;/pre>&lt;p>来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/p>
&lt;h2 id="思路">思路&lt;/h2>
&lt;p>直接用层序遍历即可，结果数组翻转之后就是答案&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// BFS正向遍历，最后翻转一下最终结果
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">levelOrderBottom&lt;/span>(&lt;span style="color:#a6e22e">root&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">TreeNode&lt;/span>) [][]&lt;span style="color:#66d9ef">int&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">root&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> [][]&lt;span style="color:#66d9ef">int&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">answers&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> [][]&lt;span style="color:#66d9ef">int&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">queue&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> []&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">TreeNode&lt;/span>{&lt;span style="color:#a6e22e">root&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> len(&lt;span style="color:#a6e22e">queue&lt;/span>) &amp;gt; &lt;span style="color:#ae81ff">0&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">size&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> len(&lt;span style="color:#a6e22e">queue&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">tmp&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">queue&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">queue&lt;/span> = []&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">TreeNode&lt;/span>{} &lt;span style="color:#75715e">// 清空，存储下一层的节点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">level&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> []&lt;span style="color:#66d9ef">int&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span> &amp;lt; &lt;span style="color:#a6e22e">size&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">node&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">tmp&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">tmp&lt;/span> = &lt;span style="color:#a6e22e">tmp&lt;/span>[&lt;span style="color:#ae81ff">1&lt;/span>:]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">level&lt;/span> = append(&lt;span style="color:#a6e22e">level&lt;/span>, &lt;span style="color:#a6e22e">node&lt;/span>.&lt;span style="color:#a6e22e">Val&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">node&lt;/span>.&lt;span style="color:#a6e22e">Left&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">queue&lt;/span> = append(&lt;span style="color:#a6e22e">queue&lt;/span>, &lt;span style="color:#a6e22e">node&lt;/span>.&lt;span style="color:#a6e22e">Left&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">node&lt;/span>.&lt;span style="color:#a6e22e">Right&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">queue&lt;/span> = append(&lt;span style="color:#a6e22e">queue&lt;/span>, &lt;span style="color:#a6e22e">node&lt;/span>.&lt;span style="color:#a6e22e">Right&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">answers&lt;/span> = append(&lt;span style="color:#a6e22e">answers&lt;/span>, &lt;span style="color:#a6e22e">level&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 翻转数组
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">length&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> len(&lt;span style="color:#a6e22e">answers&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span> &amp;lt; &lt;span style="color:#a6e22e">length&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">answers&lt;/span>[&lt;span style="color:#a6e22e">i&lt;/span>], &lt;span style="color:#a6e22e">answers&lt;/span>[&lt;span style="color:#a6e22e">length&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#a6e22e">i&lt;/span>] = &lt;span style="color:#a6e22e">answers&lt;/span>[&lt;span style="color:#a6e22e">length&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#a6e22e">i&lt;/span>], &lt;span style="color:#a6e22e">answers&lt;/span>[&lt;span style="color:#a6e22e">i&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">answers&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>LeetCode95——不同的二叉搜索树 II</title><link>https://www.ddhigh.com/2022/02/06/unique-binary-search-trees-ii/</link><pubDate>Sun, 06 Feb 2022 20:24:19 +0000</pubDate><guid>https://www.ddhigh.com/2022/02/06/unique-binary-search-trees-ii/</guid><description>&lt;h2 id="题目">题目&lt;/h2>
&lt;p>给你一个整数 &lt;code>n&lt;/code> ，请你生成并返回所有由 &lt;code>n&lt;/code> 个节点组成且节点值从 &lt;code>1&lt;/code> 到 &lt;code>n&lt;/code> 互不相同的不同 &lt;strong>二叉搜索树&lt;/strong> 。可以按 &lt;strong>任意顺序&lt;/strong> 返回答案。&lt;/p>
&lt;p>&lt;strong>示例 1：&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg" alt="img">&lt;/p>
&lt;pre tabindex="0">&lt;code>输入：n = 3
输出：[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]
&lt;/code>&lt;/pre>&lt;p>&lt;strong>示例 2：&lt;/strong>&lt;/p>
&lt;p>输入：n = 1
输出：[[1]]&lt;/p>
&lt;p>来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/unique-binary-search-trees-ii
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/p>
&lt;h2 id="思路">思路&lt;/h2>
&lt;ol>
&lt;li>由于每个节点都可以成为根节点，因此遍历1~n，i为遍历参数名称，此时可以构造如下树
&lt;ol>
&lt;li>1~i-1为左子树&lt;/li>
&lt;li>i为根节点&lt;/li>
&lt;li>i+1~n为右子树&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>递归的调用步骤1可以得到所有的组合&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">generateTrees&lt;/span>(&lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) []&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">TreeNode&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">generate&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#a6e22e">n&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 生成start ~ end的数列表
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">generate&lt;/span>(&lt;span style="color:#a6e22e">start&lt;/span>, &lt;span style="color:#a6e22e">end&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) []&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">TreeNode&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 非法条件拦截
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">start&lt;/span> &amp;gt; &lt;span style="color:#a6e22e">end&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> []&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">TreeNode&lt;/span>{&lt;span style="color:#66d9ef">nil&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">allNodes&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> []&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">TreeNode&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 遍历n
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">start&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">&amp;lt;=&lt;/span> &lt;span style="color:#a6e22e">end&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// start ~ i-1可以构造左子树节点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">leftTrees&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">generate&lt;/span>(&lt;span style="color:#a6e22e">start&lt;/span>, &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// i+1 ~ end可以构造右子树节点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">rightTrees&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">generate&lt;/span>(&lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#a6e22e">end&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">_&lt;/span>, &lt;span style="color:#a6e22e">left&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">range&lt;/span> &lt;span style="color:#a6e22e">leftTrees&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">_&lt;/span>, &lt;span style="color:#a6e22e">right&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">range&lt;/span> &lt;span style="color:#a6e22e">rightTrees&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 组装左根右节点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">root&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">TreeNode&lt;/span>{&lt;span style="color:#a6e22e">Val&lt;/span>: &lt;span style="color:#a6e22e">i&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">root&lt;/span>.&lt;span style="color:#a6e22e">Left&lt;/span> = &lt;span style="color:#a6e22e">left&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">root&lt;/span>.&lt;span style="color:#a6e22e">Right&lt;/span> = &lt;span style="color:#a6e22e">right&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">allNodes&lt;/span> = append(&lt;span style="color:#a6e22e">allNodes&lt;/span>, &lt;span style="color:#a6e22e">root&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">allNodes&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>LeetCode98——验证二叉搜索树</title><link>https://www.ddhigh.com/2022/02/06/validate-binary-search-tree/</link><pubDate>Sun, 06 Feb 2022 20:24:19 +0000</pubDate><guid>https://www.ddhigh.com/2022/02/06/validate-binary-search-tree/</guid><description>&lt;h2 id="题目">题目&lt;/h2>
&lt;p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。&lt;/p>
&lt;p>&lt;strong>有效&lt;/strong> 二叉搜索树定义如下：&lt;/p>
&lt;p>节点的左子树只包含 &lt;strong>小于&lt;/strong> 当前节点的数。
节点的右子树只包含 &lt;strong>大于&lt;/strong> 当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。&lt;/p>
&lt;p>&lt;strong>示例 1：&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg" alt="img">&lt;/p>
&lt;pre tabindex="0">&lt;code>输入：root = [2,1,3]
输出：true
&lt;/code>&lt;/pre>&lt;p>&lt;strong>示例 2：&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg" alt="img">&lt;/p>
&lt;pre tabindex="0">&lt;code>输入：root = [5,1,4,null,null,3,6]
输出：false
解释：根节点的值是 5 ，但是右子节点的值是 4 。
&lt;/code>&lt;/pre>&lt;p>来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/validate-binary-search-tree
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/p>
&lt;h2 id="思路">思路&lt;/h2>
&lt;p>直接用中序遍历即可。中序遍历可以保证后一个值一定比前一个值大。&lt;/p>
&lt;p>中序遍历处理顺序：左-&amp;gt;根-&amp;gt;右&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 中序遍历，值如果都是升序就满足要求
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">isValidBST&lt;/span>(&lt;span style="color:#a6e22e">root&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">TreeNode&lt;/span>) &lt;span style="color:#66d9ef">bool&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">lastValue&lt;/span> = &lt;span style="color:#a6e22e">math&lt;/span>.&lt;span style="color:#a6e22e">MinInt64&lt;/span> &lt;span style="color:#75715e">// 上一个值，初始化时保证是最小值即可，这样只要树节点有值就能大于该值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">helper&lt;/span> &lt;span style="color:#66d9ef">func&lt;/span>(&lt;span style="color:#a6e22e">root&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">TreeNode&lt;/span>) &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#75715e">// 判断指定节点是否大于lastValue
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">helper&lt;/span> = &lt;span style="color:#66d9ef">func&lt;/span>(&lt;span style="color:#a6e22e">root&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">TreeNode&lt;/span>) &lt;span style="color:#66d9ef">bool&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">root&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> { &lt;span style="color:#75715e">// 节点为空，直接返回true
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> !&lt;span style="color:#a6e22e">helper&lt;/span>(&lt;span style="color:#a6e22e">root&lt;/span>.&lt;span style="color:#a6e22e">Left&lt;/span>) { &lt;span style="color:#75715e">// 如果左子树不满足要求则返回false
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">root&lt;/span>.&lt;span style="color:#a6e22e">Val&lt;/span> &lt;span style="color:#f92672">&amp;lt;=&lt;/span> &lt;span style="color:#a6e22e">lastValue&lt;/span> { &lt;span style="color:#75715e">// 如果当前节点&amp;lt;=上一个节点，则不满足要求（中序遍历本节点一定大于上一个节点）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">lastValue&lt;/span> = &lt;span style="color:#a6e22e">root&lt;/span>.&lt;span style="color:#a6e22e">Val&lt;/span> &lt;span style="color:#75715e">// 更新上一个节点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> !&lt;span style="color:#a6e22e">helper&lt;/span>(&lt;span style="color:#a6e22e">root&lt;/span>.&lt;span style="color:#a6e22e">Right&lt;/span>) { &lt;span style="color:#75715e">// 检查右子树
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">helper&lt;/span>(&lt;span style="color:#a6e22e">root&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>LeetCode99——恢复二叉搜索树</title><link>https://www.ddhigh.com/2022/02/06/recover-binary-search-tree/</link><pubDate>Sun, 06 Feb 2022 20:24:19 +0000</pubDate><guid>https://www.ddhigh.com/2022/02/06/recover-binary-search-tree/</guid><description>&lt;h2 id="题目">题目&lt;/h2>
&lt;p>给你二叉搜索树的根节点 root ，该树中的 恰好 两个节点的值被错误地交换。请在不改变其结构的情况下，恢复这棵树 。&lt;/p>
&lt;p>&lt;strong>示例 1：&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://assets.leetcode.com/uploads/2020/10/28/recover1.jpg" alt="img">&lt;/p>
&lt;pre tabindex="0">&lt;code>输入：root = [1,3,null,null,2]
输出：[3,1,null,null,2]
解释：3 不能是 1 的左孩子，因为 3 &amp;gt; 1 。交换 1 和 3 使二叉搜索树有效。
&lt;/code>&lt;/pre>&lt;p>&lt;strong>示例 2：&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://assets.leetcode.com/uploads/2020/10/28/recover2.jpg" alt="img">&lt;/p>
&lt;pre tabindex="0">&lt;code>输入：root = [3,1,4,null,null,2]
输出：[2,1,4,null,null,3]
解释：2 不能在 3 的右子树中，因为 2 &amp;lt; 3 。交换 2 和 3 使二叉搜索树有效。
&lt;/code>&lt;/pre>&lt;p>来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/recover-binary-search-tree
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/p>
&lt;h2 id="思路">思路&lt;/h2>
&lt;ol>
&lt;li>中序遍历构造一个数组，根据二叉搜索树的性质，中序遍历是严格递增的&lt;/li>
&lt;li>遍历该数组，找出&lt;code>后一个值&lt;/code>小于&lt;code>前一个值&lt;/code>的下标，根据这两个下标访问数组，可以得到两个错误值&lt;/li>
&lt;li>遍历二叉树，根据第2步的两个值定位两个二叉树节点&lt;/li>
&lt;li>交换两个节点的值&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 1. 中序遍历构造一个数组
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 2. 检查数组顺序，定位有问题的下标
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 3. 中序遍历原来的树，定位指定下标的节点， 交换两个节点值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">recoverTree&lt;/span>(&lt;span style="color:#a6e22e">root&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">TreeNode&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 构造数组
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">values&lt;/span> []&lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">valueGetter&lt;/span> &lt;span style="color:#66d9ef">func&lt;/span>(&lt;span style="color:#a6e22e">root&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">TreeNode&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">valueGetter&lt;/span> = &lt;span style="color:#66d9ef">func&lt;/span>(&lt;span style="color:#a6e22e">root&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">TreeNode&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">root&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">valueGetter&lt;/span>(&lt;span style="color:#a6e22e">root&lt;/span>.&lt;span style="color:#a6e22e">Left&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">values&lt;/span> = append(&lt;span style="color:#a6e22e">values&lt;/span>, &lt;span style="color:#a6e22e">root&lt;/span>.&lt;span style="color:#a6e22e">Val&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">valueGetter&lt;/span>(&lt;span style="color:#a6e22e">root&lt;/span>.&lt;span style="color:#a6e22e">Right&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">valueGetter&lt;/span>(&lt;span style="color:#a6e22e">root&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 检查数组值顺序，如果比前面的小或者比后面的大
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">wrongIndex1&lt;/span> = &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">wrongIndex2&lt;/span> = &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span> &amp;lt; len(&lt;span style="color:#a6e22e">values&lt;/span>)&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 如果比前面的小或者比后面的大
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">values&lt;/span>[&lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>] &amp;lt; &lt;span style="color:#a6e22e">values&lt;/span>[&lt;span style="color:#a6e22e">i&lt;/span>] {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">wrongIndex2&lt;/span> = &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">wrongIndex1&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">wrongIndex1&lt;/span> = &lt;span style="color:#a6e22e">i&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 中序遍历，定位到wrongIndex1和wrongIndex2的节点，交换两者的值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">locator&lt;/span> &lt;span style="color:#66d9ef">func&lt;/span>(&lt;span style="color:#a6e22e">root&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">TreeNode&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">wrongNode1&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">TreeNode&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">wrongNode2&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">TreeNode&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">locator&lt;/span> = &lt;span style="color:#66d9ef">func&lt;/span>(&lt;span style="color:#a6e22e">root&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">TreeNode&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">root&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">locator&lt;/span>(&lt;span style="color:#a6e22e">root&lt;/span>.&lt;span style="color:#a6e22e">Left&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">root&lt;/span>.&lt;span style="color:#a6e22e">Val&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#a6e22e">values&lt;/span>[&lt;span style="color:#a6e22e">wrongIndex1&lt;/span>] { &lt;span style="color:#75715e">// 根据值定位节点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">wrongNode1&lt;/span> = &lt;span style="color:#a6e22e">root&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">root&lt;/span>.&lt;span style="color:#a6e22e">Val&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#a6e22e">values&lt;/span>[&lt;span style="color:#a6e22e">wrongIndex2&lt;/span>] {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">wrongNode2&lt;/span> = &lt;span style="color:#a6e22e">root&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">locator&lt;/span>(&lt;span style="color:#a6e22e">root&lt;/span>.&lt;span style="color:#a6e22e">Right&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">locator&lt;/span>(&lt;span style="color:#a6e22e">root&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">wrongNode1&lt;/span>.&lt;span style="color:#a6e22e">Val&lt;/span>, &lt;span style="color:#a6e22e">wrongNode2&lt;/span>.&lt;span style="color:#a6e22e">Val&lt;/span> = &lt;span style="color:#a6e22e">wrongNode2&lt;/span>.&lt;span style="color:#a6e22e">Val&lt;/span>, &lt;span style="color:#a6e22e">wrongNode1&lt;/span>.&lt;span style="color:#a6e22e">Val&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>LeetCode102--二叉树的层序遍历</title><link>https://www.ddhigh.com/2022/02/06/binary-tree-level-order-traversal/</link><pubDate>Sun, 06 Feb 2022 00:00:00 +0000</pubDate><guid>https://www.ddhigh.com/2022/02/06/binary-tree-level-order-traversal/</guid><description>&lt;h2 id="题目">题目&lt;/h2>
&lt;p>给你二叉树的根节点 &lt;code>root&lt;/code> ，返回其节点值的 &lt;strong>层序遍历&lt;/strong> 。 （即逐层地，从左到右访问所有节点）。&lt;/p>
&lt;p>&lt;strong>示例 1：&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt="img">&lt;/p>
&lt;pre tabindex="0">&lt;code>输入：root = [3,9,20,null,null,15,7]
输出：[[3],[9,20],[15,7]]
&lt;/code>&lt;/pre>&lt;p>&lt;strong>示例 2：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>输入：root = [1]
输出：[[1]]
&lt;/code>&lt;/pre>&lt;p>&lt;strong>示例 3：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>输入：root = []
输出：[]
&lt;/code>&lt;/pre>&lt;p>来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/p>
&lt;h2 id="思路">思路&lt;/h2>
&lt;p>层序遍历直接用广度有限遍历即可。&lt;/p>
&lt;ol>
&lt;li>用两个队列存储本层节点&lt;code>tmp&lt;/code>和下一层节点&lt;code>queue&lt;/code>（可以简化处理清理，避免一个队列操作时即弹出又插入的问题）&lt;/li>
&lt;li>获取队列长度，将&lt;code>queue&lt;/code>复制到&lt;code>tmp&lt;/code>,清空本层节点变量(&lt;code>queue&lt;/code>)&lt;/li>
&lt;li>tmp不断出队即可，出队时把后代节点插入&lt;code>queue&lt;/code>&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// BFS遍历即可
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 用队列处理，需要注意的是，每次处理一层，每层的大小就是队列的大小，可以准备两个队列，一个用来存储本层，一个用来存储下一层
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">levelOrder&lt;/span>(&lt;span style="color:#a6e22e">root&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">TreeNode&lt;/span>) [][]&lt;span style="color:#66d9ef">int&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">root&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> [][]&lt;span style="color:#66d9ef">int&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">answers&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> [][]&lt;span style="color:#66d9ef">int&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">queue&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> []&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">TreeNode&lt;/span>{&lt;span style="color:#a6e22e">root&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> len(&lt;span style="color:#a6e22e">queue&lt;/span>) &amp;gt; &lt;span style="color:#ae81ff">0&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">size&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> len(&lt;span style="color:#a6e22e">queue&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">tmp&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">queue&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">queue&lt;/span> = []&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">TreeNode&lt;/span>{} &lt;span style="color:#75715e">// 清空，存储下一层的节点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">level&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> []&lt;span style="color:#66d9ef">int&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span> &amp;lt; &lt;span style="color:#a6e22e">size&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">node&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">tmp&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">tmp&lt;/span> = &lt;span style="color:#a6e22e">tmp&lt;/span>[&lt;span style="color:#ae81ff">1&lt;/span>:]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">level&lt;/span> = append(&lt;span style="color:#a6e22e">level&lt;/span>, &lt;span style="color:#a6e22e">node&lt;/span>.&lt;span style="color:#a6e22e">Val&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">node&lt;/span>.&lt;span style="color:#a6e22e">Left&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">queue&lt;/span> = append(&lt;span style="color:#a6e22e">queue&lt;/span>, &lt;span style="color:#a6e22e">node&lt;/span>.&lt;span style="color:#a6e22e">Left&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">node&lt;/span>.&lt;span style="color:#a6e22e">Right&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">queue&lt;/span> = append(&lt;span style="color:#a6e22e">queue&lt;/span>, &lt;span style="color:#a6e22e">node&lt;/span>.&lt;span style="color:#a6e22e">Right&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">answers&lt;/span> = append(&lt;span style="color:#a6e22e">answers&lt;/span>, &lt;span style="color:#a6e22e">level&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">answers&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>LeetCode328——奇偶链表</title><link>https://www.ddhigh.com/2022/02/05/odd-even-linked-list/</link><pubDate>Sat, 05 Feb 2022 20:24:19 +0000</pubDate><guid>https://www.ddhigh.com/2022/02/05/odd-even-linked-list/</guid><description>&lt;h2 id="题目">题目&lt;/h2>
&lt;p>给定单链表的头节点 head ，将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后返回重新排序的列表。&lt;/p>
&lt;p>第一个节点的索引被认为是 奇数 ， 第二个节点的索引为 偶数 ，以此类推。&lt;/p>
&lt;p>请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致。&lt;/p>
&lt;p>你必须在 O(1) 的额外空间复杂度和 O(n) 的时间复杂度下解决这个问题。&lt;/p>
&lt;p>&lt;strong>示例 1:&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://assets.leetcode.com/uploads/2021/03/10/oddeven-linked-list.jpg" alt="img">&lt;/p>
&lt;pre tabindex="0">&lt;code>输入: head = [1,2,3,4,5]
输出: [1,3,5,2,4]
&lt;/code>&lt;/pre>&lt;p>&lt;strong>示例2:&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://assets.leetcode.com/uploads/2021/03/10/oddeven2-linked-list.jpg" alt="img">&lt;/p>
&lt;pre tabindex="0">&lt;code>输入: head = [2,1,3,5,6,4,7]
输出: [2,3,6,7,1,5,4]
&lt;/code>&lt;/pre>&lt;p>来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/odd-even-linked-list
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/p>
&lt;p>来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/odd-even-linked-list
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/p>
&lt;h2 id="思路">思路&lt;/h2>
&lt;ol>
&lt;li>定义2个链表，&lt;code>odd为奇数链表&lt;/code>，&lt;code>even为偶数链表&lt;/code>&lt;/li>
&lt;li>遍历原链表，根据奇偶位置插入&lt;code>odd&lt;/code>或者&lt;code>even&lt;/code>&lt;/li>
&lt;li>连接&lt;code>odd&lt;/code>和&lt;code>even&lt;/code>&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 1. 定义以下节点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 1. 偶链表头节点，移动节点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 2. 奇链表头结点，移动节点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 2. 奇链表尾节点.Next = 偶链表头结点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">oddEvenList&lt;/span>(&lt;span style="color:#a6e22e">head&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ListNode&lt;/span>) &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ListNode&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 0,1,2个节点时直接返回
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">head&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#a6e22e">head&lt;/span>.&lt;span style="color:#a6e22e">Next&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#a6e22e">head&lt;/span>.&lt;span style="color:#a6e22e">Next&lt;/span>.&lt;span style="color:#a6e22e">Next&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">head&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">oddHead&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ListNode&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">oddMove&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ListNode&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">evenHead&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ListNode&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">evenMove&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ListNode&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">p&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">head&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">p&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 连接奇数节点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">oddHead&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">oddHead&lt;/span> = &lt;span style="color:#a6e22e">p&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">oddMove&lt;/span> = &lt;span style="color:#a6e22e">p&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">oddMove&lt;/span>.&lt;span style="color:#a6e22e">Next&lt;/span> = &lt;span style="color:#a6e22e">p&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">oddMove&lt;/span> = &lt;span style="color:#a6e22e">oddMove&lt;/span>.&lt;span style="color:#a6e22e">Next&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">p&lt;/span> = &lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">Next&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 连接偶数节点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">p&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">evenHead&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">evenHead&lt;/span> = &lt;span style="color:#a6e22e">p&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">evenMove&lt;/span> = &lt;span style="color:#a6e22e">p&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">evenMove&lt;/span>.&lt;span style="color:#a6e22e">Next&lt;/span> = &lt;span style="color:#a6e22e">p&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">evenMove&lt;/span> = &lt;span style="color:#a6e22e">evenMove&lt;/span>.&lt;span style="color:#a6e22e">Next&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 移动到下一个奇数节点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">p&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">p&lt;/span> = &lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">Next&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 断开原来的连接
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">oddMove&lt;/span>.&lt;span style="color:#a6e22e">Next&lt;/span> = &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">evenMove&lt;/span>.&lt;span style="color:#a6e22e">Next&lt;/span> = &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">oddMove&lt;/span>.&lt;span style="color:#a6e22e">Next&lt;/span> = &lt;span style="color:#a6e22e">evenHead&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">oddHead&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>LeetCode142——环形链表2</title><link>https://www.ddhigh.com/2022/02/05/linked-list-cycle-ii/</link><pubDate>Sat, 05 Feb 2022 20:14:56 +0000</pubDate><guid>https://www.ddhigh.com/2022/02/05/linked-list-cycle-ii/</guid><description>&lt;h2 id="题目">题目&lt;/h2>
&lt;p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。&lt;/p>
&lt;p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。&lt;/p>
&lt;p>不允许修改 链表。&lt;/p>
&lt;p>&lt;strong>示例 1：&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img">&lt;/p>
&lt;pre tabindex="0">&lt;code>输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。
&lt;/code>&lt;/pre>&lt;p>&lt;strong>示例 2：&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img">&lt;/p>
&lt;pre tabindex="0">&lt;code>输入：head = [1,2], pos = 0
输出：返回索引为 0 的链表节点
解释：链表中有一个环，其尾部连接到第一个节点。
&lt;/code>&lt;/pre>&lt;p>来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/linked-list-cycle-ii
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/p>
&lt;h2 id="思路">思路&lt;/h2>
&lt;h3 id="哈希表">哈希表&lt;/h3>
&lt;p>参考上一篇&lt;a href="https://www.ddhigh.com/2022/02/05/linked-list-cycle.md">环形链表&lt;/a>，可以利用哈希表存储节点，当再次遇到该节点时，该节点就是成环点。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 1. 遍历节点存入map
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 2. 如果节点已存在，则该节点是成环节点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">detectCycle&lt;/span>(&lt;span style="color:#a6e22e">head&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ListNode&lt;/span>) &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ListNode&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">m&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> make(&lt;span style="color:#66d9ef">map&lt;/span>[&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ListNode&lt;/span>]&lt;span style="color:#66d9ef">struct&lt;/span>{})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">p&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">head&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">p&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">_&lt;/span>, &lt;span style="color:#a6e22e">ok&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">m&lt;/span>[&lt;span style="color:#a6e22e">p&lt;/span>]; &lt;span style="color:#a6e22e">ok&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">p&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">m&lt;/span>[&lt;span style="color:#a6e22e">p&lt;/span>] = &lt;span style="color:#66d9ef">struct&lt;/span>{}{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">p&lt;/span> = &lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">Next&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="快慢指针">快慢指针&lt;/h3>
&lt;ol>
&lt;li>快指针走2步，慢指针走1步&lt;/li>
&lt;li>快慢指针相遇时，慢指针走了&lt;code>s&lt;/code>个节点，快指针走了&lt;code>2s&lt;/code>，同时快指针比慢指针多走了&lt;code>N&lt;/code>圈，设环形区间长度为&lt;code>b&lt;/code>,因此&lt;code>2s = s+nb&lt;/code>，因此&lt;code>s=nb&lt;/code>，也就是快慢指针相遇时慢指针走过的距离刚好是环的倍数。&lt;/li>
&lt;li>新起指针指向头结点，和慢指针一起向后走，两点相遇时新指针走了a，慢指针走了a+nb，此时新指针和慢指针相遇，新指针指向成环点&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">detectCycle&lt;/span>(&lt;span style="color:#a6e22e">head&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ListNode&lt;/span>) &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ListNode&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">head&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#a6e22e">head&lt;/span>.&lt;span style="color:#a6e22e">Next&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fast&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">head&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">slow&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">head&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">fast&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">slow&lt;/span> = &lt;span style="color:#a6e22e">slow&lt;/span>.&lt;span style="color:#a6e22e">Next&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fast&lt;/span> = &lt;span style="color:#a6e22e">fast&lt;/span>.&lt;span style="color:#a6e22e">Next&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">fast&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fast&lt;/span> = &lt;span style="color:#a6e22e">fast&lt;/span>.&lt;span style="color:#a6e22e">Next&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">fast&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#a6e22e">slow&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 快慢相遇，新起指针指向节点，然后和慢指针一起走，两者相遇点就是成环点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">ptr&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">head&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">ptr&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#a6e22e">slow&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ptr&lt;/span> = &lt;span style="color:#a6e22e">ptr&lt;/span>.&lt;span style="color:#a6e22e">Next&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">slow&lt;/span> = &lt;span style="color:#a6e22e">slow&lt;/span>.&lt;span style="color:#a6e22e">Next&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">ptr&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>LeetCode141——环形链表</title><link>https://www.ddhigh.com/2022/02/05/linked-list-cycle/</link><pubDate>Sat, 05 Feb 2022 20:09:35 +0000</pubDate><guid>https://www.ddhigh.com/2022/02/05/linked-list-cycle/</guid><description>&lt;h2 id="题目">题目&lt;/h2>
&lt;p>给你一个链表的头节点 head ，判断链表中是否有环。&lt;/p>
&lt;p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。&lt;/p>
&lt;p>如果链表中存在环 ，则返回 true 。 否则，返回 false 。&lt;/p>
&lt;p>&lt;strong>示例 1：&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img">&lt;/p>
&lt;pre tabindex="0">&lt;code>输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
&lt;/code>&lt;/pre>&lt;p>&lt;strong>示例 2：&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img">&lt;/p>
&lt;pre tabindex="0">&lt;code>输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。
&lt;/code>&lt;/pre>&lt;p>来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/linked-list-cycle
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/p>
&lt;h2 id="思路">思路&lt;/h2>
&lt;h3 id="哈希表法">哈希表法&lt;/h3>
&lt;p>利用哈希表存储访问过的节点，如果遍历时节点在哈希表，则有环。&lt;/p>
&lt;blockquote>
&lt;p>Go语言中map的value为struct可以不占用存储空间。&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">hasCycle&lt;/span>(&lt;span style="color:#a6e22e">head&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ListNode&lt;/span>) &lt;span style="color:#66d9ef">bool&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">m&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">map&lt;/span>[&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ListNode&lt;/span>]&lt;span style="color:#66d9ef">struct&lt;/span>{}{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">head&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">_&lt;/span>, &lt;span style="color:#a6e22e">ok&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">m&lt;/span>[&lt;span style="color:#a6e22e">head&lt;/span>]; &lt;span style="color:#a6e22e">ok&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">m&lt;/span>[&lt;span style="color:#a6e22e">head&lt;/span>] = &lt;span style="color:#66d9ef">struct&lt;/span>{}{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">head&lt;/span> = &lt;span style="color:#a6e22e">head&lt;/span>.&lt;span style="color:#a6e22e">Next&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="快慢指针法">快慢指针法&lt;/h3>
&lt;ol>
&lt;li>快指针每次走两步，慢指针走一步，如果相遇则存在环&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">hasCycle&lt;/span>(&lt;span style="color:#a6e22e">head&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ListNode&lt;/span>) &lt;span style="color:#66d9ef">bool&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">head&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#a6e22e">head&lt;/span>.&lt;span style="color:#a6e22e">Next&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fast&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">head&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">slow&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">head&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">fast&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">slow&lt;/span> = &lt;span style="color:#a6e22e">slow&lt;/span>.&lt;span style="color:#a6e22e">Next&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fast&lt;/span> = &lt;span style="color:#a6e22e">fast&lt;/span>.&lt;span style="color:#a6e22e">Next&lt;/span> &lt;span style="color:#75715e">// 快指针走1步
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">fast&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fast&lt;/span> = &lt;span style="color:#a6e22e">fast&lt;/span>.&lt;span style="color:#a6e22e">Next&lt;/span> &lt;span style="color:#75715e">// 快指针再走1步
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">fast&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#a6e22e">slow&lt;/span> { &lt;span style="color:#75715e">// 相遇了
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>LeetCode92——反转链表 II</title><link>https://www.ddhigh.com/2022/02/05/reverse-linked-list-ii/</link><pubDate>Sat, 05 Feb 2022 19:00:00 +0000</pubDate><guid>https://www.ddhigh.com/2022/02/05/reverse-linked-list-ii/</guid><description>&lt;h2 id="题目">题目&lt;/h2>
&lt;p>给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &amp;lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。&lt;/p>
&lt;p>&lt;strong>示例 1：&lt;/strong>
&lt;img src="https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg" alt="示例1">&lt;/p>
&lt;p>输入：head = [1,2,3,4,5], left = 2, right = 4
输出：[1,4,3,2,5]&lt;/p>
&lt;p>&lt;strong>示例 2：&lt;/strong>&lt;/p>
&lt;p>输入：head = [5], left = 1, right = 1
输出：[5]&lt;/p>
&lt;p>来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/reverse-linked-list-ii
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/p>
&lt;h2 id="思路">思路&lt;/h2>
&lt;h3 id="转数组">转数组&lt;/h3>
&lt;blockquote>
&lt;p>大部分的链表题只要未要求原节点上操作，都可以转数组处理，缺点是空间复杂度会额外增加达到O(n)。&lt;/p>
&lt;/blockquote>
&lt;ol>
&lt;li>将原链表按顺序转为数组&lt;/li>
&lt;li>遍历数组，翻转left ~ right之间的数组，此处用双指针即可
&lt;ol>
&lt;li>定义left和right指针，交换left和right的值&lt;/li>
&lt;li>两个指针同时向中间移动，left++,right&amp;ndash;&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>将数组构造为链表返回&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 数组法
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 1. 链表转换为数组
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 2. 翻转left ~ right的数据
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 3. 重新构造链表
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">reverseBetween&lt;/span>(&lt;span style="color:#a6e22e">head&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ListNode&lt;/span>, &lt;span style="color:#a6e22e">left&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#a6e22e">right&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ListNode&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">array&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">convertListToArray&lt;/span>(&lt;span style="color:#a6e22e">head&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">reverseArrayPart&lt;/span>(&lt;span style="color:#a6e22e">array&lt;/span>, &lt;span style="color:#a6e22e">left&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#a6e22e">right&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">buildLinkList&lt;/span>(&lt;span style="color:#a6e22e">array&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 翻转数组指定区间
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">reverseArrayPart&lt;/span>(&lt;span style="color:#a6e22e">array&lt;/span> []&lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#a6e22e">left&lt;/span>, &lt;span style="color:#a6e22e">right&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">left&lt;/span> &amp;lt; &lt;span style="color:#a6e22e">right&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">array&lt;/span>[&lt;span style="color:#a6e22e">left&lt;/span>], &lt;span style="color:#a6e22e">array&lt;/span>[&lt;span style="color:#a6e22e">right&lt;/span>] = &lt;span style="color:#a6e22e">array&lt;/span>[&lt;span style="color:#a6e22e">right&lt;/span>], &lt;span style="color:#a6e22e">array&lt;/span>[&lt;span style="color:#a6e22e">left&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">left&lt;/span>&lt;span style="color:#f92672">++&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">right&lt;/span>&lt;span style="color:#f92672">--&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 链表构造为数组
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">convertListToArray&lt;/span>(&lt;span style="color:#a6e22e">head&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ListNode&lt;/span>) []&lt;span style="color:#66d9ef">int&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">array&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> make([]&lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">head&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">array&lt;/span> = append(&lt;span style="color:#a6e22e">array&lt;/span>, &lt;span style="color:#a6e22e">head&lt;/span>.&lt;span style="color:#a6e22e">Val&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">head&lt;/span> = &lt;span style="color:#a6e22e">head&lt;/span>.&lt;span style="color:#a6e22e">Next&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">array&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="链表操作">链表操作&lt;/h3>
&lt;blockquote>
&lt;p>链表相关的操作主要是要掌握定位任意节点的指针。&lt;/p>
&lt;/blockquote>
&lt;ol>
&lt;li>定位以下节点
&lt;ol>
&lt;li>leftPrev: 翻转区间开始节点的上一个节点，最终要连接翻转后的头节点，所以需要保留&lt;/li>
&lt;li>rightNext: 翻转区间结束节点的后一个节点，最终要连接到最终链表，所以需要保留&lt;/li>
&lt;li>left和right节点，翻转开始和翻转结束节点&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>定义子函数翻转left和right，返回right，翻转思路如下
&lt;ol>
&lt;li>定义prev和curr指针，prev初始指向null，curr指向head&lt;/li>
&lt;li>开始迭代，迭代结束条件curr不等于rightNode
&lt;ol>
&lt;li>保存curr的下一个节点&lt;code>next:=curr.Next&lt;/code>&lt;/li>
&lt;li>此时我们有3个节点的指针，prev,curr,next&lt;/li>
&lt;li>当前节点指向上一个,&lt;code>curr.Next=prev&lt;/code>&lt;/li>
&lt;li>prev上一个节点指针后移,&lt;code>prev=curr&lt;/code>&lt;/li>
&lt;li>curr后移,&lt;code>curr=next&lt;/code>&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>迭代结束后将&lt;code>curr&lt;/code>指向上一个节点&lt;code>curr.Next=prev&lt;/code>&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>按以下顺序连接所有节点：leftPrev -&amp;gt; right -&amp;gt; left -&amp;gt; rightNext，边界情况如下：
&lt;ol>
&lt;li>left是头结点，此时leftPrevNode是空，最终结果链表right节点成为新头结点&lt;/li>
&lt;li>right是尾节点，此时rightNextNode是空，无需特殊处理&lt;/li>
&lt;li>left == right，无需翻转&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">reverseBetween&lt;/span>(&lt;span style="color:#a6e22e">head&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ListNode&lt;/span>, &lt;span style="color:#a6e22e">left&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#a6e22e">right&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ListNode&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">left&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#a6e22e">right&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">head&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">leftPrevNode&lt;/span>, &lt;span style="color:#a6e22e">leftNode&lt;/span>, &lt;span style="color:#a6e22e">rightNode&lt;/span>, &lt;span style="color:#a6e22e">rightNextNode&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">locateNodes&lt;/span>(&lt;span style="color:#a6e22e">head&lt;/span>, &lt;span style="color:#a6e22e">left&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#a6e22e">right&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">rightNode&lt;/span> = &lt;span style="color:#a6e22e">reverse&lt;/span>(&lt;span style="color:#a6e22e">leftNode&lt;/span>, &lt;span style="color:#a6e22e">rightNode&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// left是头节点，链表连接顺序，right,left,rightNext
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">leftPrevNode&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">leftNode&lt;/span>.&lt;span style="color:#a6e22e">Next&lt;/span> = &lt;span style="color:#a6e22e">rightNextNode&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">rightNode&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 正常连接，连接顺序 leftPrevNode-&amp;gt;right-&amp;gt;left-&amp;gt;rightNextNode
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">leftPrevNode&lt;/span>.&lt;span style="color:#a6e22e">Next&lt;/span> = &lt;span style="color:#a6e22e">rightNode&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">leftNode&lt;/span>.&lt;span style="color:#a6e22e">Next&lt;/span> = &lt;span style="color:#a6e22e">rightNextNode&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">head&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 翻转left ~ right之间的节点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 迭代翻转即可
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// p 指向当前节点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// prev 指向上一个节点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// next指向p的next节点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 如果p == rightNode则结束翻转并返回right
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">reverse&lt;/span>(&lt;span style="color:#a6e22e">leftNode&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ListNode&lt;/span>, &lt;span style="color:#a6e22e">rightNode&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ListNode&lt;/span>) &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ListNode&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">prev&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ListNode&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">p&lt;/span> = &lt;span style="color:#a6e22e">leftNode&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">p&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#a6e22e">rightNode&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">next&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">Next&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">Next&lt;/span> = &lt;span style="color:#a6e22e">prev&lt;/span> &lt;span style="color:#75715e">// p 指向 上一个节点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">prev&lt;/span> = &lt;span style="color:#a6e22e">p&lt;/span> &lt;span style="color:#75715e">// 上一个节点后移
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">p&lt;/span> = &lt;span style="color:#a6e22e">next&lt;/span> &lt;span style="color:#75715e">// p后移
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// p 此时向rightNode，需要连接p和上一个节点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">Next&lt;/span> = &lt;span style="color:#a6e22e">prev&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">p&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 定位
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">locateNodes&lt;/span>(&lt;span style="color:#a6e22e">head&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ListNode&lt;/span>, &lt;span style="color:#a6e22e">left&lt;/span>, &lt;span style="color:#a6e22e">right&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ListNode&lt;/span>, &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ListNode&lt;/span>, &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ListNode&lt;/span>, &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ListNode&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">index&lt;/span> = &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">prevNode&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ListNode&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">leftPrevNode&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ListNode&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">leftNode&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ListNode&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">rightNode&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ListNode&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">rightNextNode&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ListNode&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">head&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 找到左节点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">index&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#a6e22e">left&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">leftPrevNode&lt;/span> = &lt;span style="color:#a6e22e">prevNode&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">leftNode&lt;/span> = &lt;span style="color:#a6e22e">head&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 找到右节点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">index&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#a6e22e">right&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">rightNode&lt;/span> = &lt;span style="color:#a6e22e">head&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">rightNextNode&lt;/span> = &lt;span style="color:#a6e22e">head&lt;/span>.&lt;span style="color:#a6e22e">Next&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 指针移动
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">index&lt;/span>&lt;span style="color:#f92672">++&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">prevNode&lt;/span> = &lt;span style="color:#a6e22e">head&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">head&lt;/span> = &lt;span style="color:#a6e22e">head&lt;/span>.&lt;span style="color:#a6e22e">Next&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">leftPrevNode&lt;/span>, &lt;span style="color:#a6e22e">leftNode&lt;/span>, &lt;span style="color:#a6e22e">rightNode&lt;/span>, &lt;span style="color:#a6e22e">rightNextNode&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>leetcode(4)——寻找两个有序数组的中位数</title><link>https://www.ddhigh.com/2019/09/20/leetcode-median-of-two-sorted-arrays/</link><pubDate>Fri, 20 Sep 2019 18:34:58 +0000</pubDate><guid>https://www.ddhigh.com/2019/09/20/leetcode-median-of-two-sorted-arrays/</guid><description>&lt;p>本文是力扣算法的第四篇，讲解寻找两个有序数组的中位数。&lt;/p>
&lt;h2 id="question">Question&lt;/h2>
&lt;blockquote>
&lt;p>给定两个大小为 m 和 n 的有序数组 &lt;code>nums1&lt;/code> 和 &lt;code>nums2&lt;/code>。&lt;/p>
&lt;p>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。&lt;/p>
&lt;p>你可以假设 &lt;code>nums1&lt;/code> 和 &lt;code>nums2&lt;/code> 不会同时为空。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>示例 1:&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>nums1 = [1, 3]
nums2 = [2]
则中位数是 2.0
&lt;/code>&lt;/pre>&lt;p>&lt;strong>示例 2:&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>nums1 = [1, 2]
nums2 = [3, 4]
则中位数是 (2 + 3)/2 = 2.5
&lt;/code>&lt;/pre>&lt;h2 id="中位数">中位数&lt;/h2>
&lt;blockquote>
&lt;p>中位数是按顺序排列的一组数据中居于中间位置的数，即在这组数据中，有一半的数据比他大，有一半的数据比他小。&lt;/p>
&lt;/blockquote>
&lt;h2 id="暴力法">暴力法&lt;/h2>
&lt;blockquote>
&lt;ol>
&lt;li>
&lt;p>将两个有序数组合并成一个有序数组&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果长度是奇数则返回中间的值，如果是否则则返回中间两个数的平均值。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">findMedianSortedArrays&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> (&lt;span style="color:#a6e22e">nums1&lt;/span>, &lt;span style="color:#a6e22e">nums2&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">nums&lt;/span> &lt;span style="color:#f92672">=&lt;/span> [];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">p1&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">p2&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (&lt;span style="color:#a6e22e">p1&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#a6e22e">nums1&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#a6e22e">p2&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#a6e22e">nums2&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">nums1&lt;/span>[&lt;span style="color:#a6e22e">p1&lt;/span>] &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#a6e22e">nums2&lt;/span>[&lt;span style="color:#a6e22e">p2&lt;/span>]) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">nums&lt;/span>.&lt;span style="color:#a6e22e">push&lt;/span>(&lt;span style="color:#a6e22e">nums1&lt;/span>[&lt;span style="color:#a6e22e">p1&lt;/span>&lt;span style="color:#f92672">++&lt;/span>]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">nums1&lt;/span>[&lt;span style="color:#a6e22e">p1&lt;/span>] &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">nums2&lt;/span>[&lt;span style="color:#a6e22e">p2&lt;/span>]) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">nums&lt;/span>.&lt;span style="color:#a6e22e">push&lt;/span>(&lt;span style="color:#a6e22e">nums2&lt;/span>[&lt;span style="color:#a6e22e">p2&lt;/span>&lt;span style="color:#f92672">++&lt;/span>]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">nums&lt;/span>.&lt;span style="color:#a6e22e">push&lt;/span>(&lt;span style="color:#a6e22e">nums1&lt;/span>[&lt;span style="color:#a6e22e">p1&lt;/span>&lt;span style="color:#f92672">++&lt;/span>]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">nums&lt;/span>.&lt;span style="color:#a6e22e">push&lt;/span>(&lt;span style="color:#a6e22e">nums2&lt;/span>[&lt;span style="color:#a6e22e">p2&lt;/span>&lt;span style="color:#f92672">++&lt;/span>]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">p1&lt;/span> &lt;span style="color:#f92672">!==&lt;/span> &lt;span style="color:#a6e22e">nums1&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span>) { &lt;span style="color:#75715e">// nums2比nums1长度要短，导致nums1没有走到末尾
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> (; &lt;span style="color:#a6e22e">p1&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#a6e22e">nums1&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span>; &lt;span style="color:#a6e22e">p1&lt;/span>&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">nums&lt;/span>.&lt;span style="color:#a6e22e">push&lt;/span>(&lt;span style="color:#a6e22e">nums1&lt;/span>[&lt;span style="color:#a6e22e">p1&lt;/span>]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">p2&lt;/span> &lt;span style="color:#f92672">!==&lt;/span> &lt;span style="color:#a6e22e">nums2&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span>) { &lt;span style="color:#75715e">// nums1比nums2长度要短，导致nums2没有走到末尾
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> (; &lt;span style="color:#a6e22e">p2&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#a6e22e">nums2&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span>; &lt;span style="color:#a6e22e">p2&lt;/span>&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">nums&lt;/span>.&lt;span style="color:#a6e22e">push&lt;/span>(&lt;span style="color:#a6e22e">nums2&lt;/span>[&lt;span style="color:#a6e22e">p2&lt;/span>]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">nums&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span> &lt;span style="color:#f92672">%&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) { &lt;span style="color:#75715e">// 长度为偶数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> (&lt;span style="color:#a6e22e">nums&lt;/span>[&lt;span style="color:#a6e22e">nums&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span> &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>] &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">nums&lt;/span>[&lt;span style="color:#a6e22e">nums&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span> &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>]) &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">nums&lt;/span>[Math.&lt;span style="color:#a6e22e">floor&lt;/span>(&lt;span style="color:#a6e22e">nums&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span> &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>)];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>时间复杂度 $O(m+n)$&lt;/p>
&lt;blockquote>
&lt;p>同时遍历了数组1和数组2&lt;/p>
&lt;/blockquote>
&lt;p>空间复杂度$O(m+n)$&lt;/p>
&lt;blockquote>
&lt;p>声明了新数组，长度为数组1的长度加数组2的长度&lt;/p>
&lt;/blockquote>
&lt;p>提交完通过了，这道题定义为Hard是不是搞错了，明明是个Easy题。&lt;/p>
&lt;p>如果你这么想那你可能漏了一个时间复杂度的要求：$O(log(m+n))$&lt;/p>
&lt;h2 id="思考--规律">思考 &amp;amp;&amp;amp; 规律&lt;/h2>
&lt;blockquote>
&lt;p>一般来说看到$O(log)$ 级别的时间复杂度一般是跟二分有关的算法才会产生这个时间复杂度，所以我们不妨以二分的思想来重新考虑一下这个问题。&lt;/p>
&lt;p>有序数组求中位数，一般化为就两个有序数组的第$k$个数，本问题中$k = (m+n)/2$时就是我们的答案。&lt;/p>
&lt;/blockquote>
&lt;p>怎么求第$k$个数？&lt;/p>
&lt;blockquote>
&lt;p>我们可以现在数组1和数组2中求出$k/2$个数$a$和$b$，如果$a &amp;lt; b$，那说明$k$个数位于数组1的&lt;code>后半段&lt;/code>或和数组2的&lt;code>前半段&lt;/code>之间。我们把不符合规则的数组1&lt;code>前半段&lt;/code>和数组2&lt;code>后判断&lt;/code>给舍弃即可，这就只处理了一般的数据，达到的二分的目的。之后按照这个原则递归处理即可&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">findMedianSortedArrays&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> (&lt;span style="color:#a6e22e">nums1&lt;/span>, &lt;span style="color:#a6e22e">nums2&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">m&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">nums1&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">nums2&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 如果第1个数组为空，直接返回第2个数组的数据即可
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">m&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 第2个数组长度为偶数，返回中间两个数字的平均值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#f92672">%&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> (&lt;span style="color:#a6e22e">nums2&lt;/span>[&lt;span style="color:#a6e22e">nums2&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span> &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>] &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">nums2&lt;/span>[&lt;span style="color:#a6e22e">nums2&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span> &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>]) &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 第2个数组长度为奇数，返回中间两个数字的平均值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">nums2&lt;/span>[Math.&lt;span style="color:#a6e22e">floor&lt;/span>(&lt;span style="color:#a6e22e">nums2&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span> &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>)];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">m&lt;/span> &lt;span style="color:#f92672">%&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> (&lt;span style="color:#a6e22e">nums1&lt;/span>[&lt;span style="color:#a6e22e">nums1&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span> &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>] &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">nums1&lt;/span>[&lt;span style="color:#a6e22e">nums1&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span> &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>]) &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">nums1&lt;/span>[Math.&lt;span style="color:#a6e22e">floor&lt;/span>(&lt;span style="color:#a6e22e">nums1&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span> &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>)];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 总长度
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">total&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">m&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">n&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 总数为奇数，找到第total/2+1个数（下标从1开始）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">total&lt;/span> &lt;span style="color:#f92672">%&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">findKth&lt;/span>(&lt;span style="color:#a6e22e">nums1&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#a6e22e">nums2&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, Math.&lt;span style="color:#a6e22e">floor&lt;/span>(&lt;span style="color:#a6e22e">total&lt;/span> &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>) &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 下标为偶数，找到中间的两个数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">findKth&lt;/span>(&lt;span style="color:#a6e22e">nums1&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#a6e22e">nums2&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, Math.&lt;span style="color:#a6e22e">floor&lt;/span>(&lt;span style="color:#a6e22e">total&lt;/span> &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>)) &lt;span style="color:#f92672">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">findKth&lt;/span>(&lt;span style="color:#a6e22e">nums1&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#a6e22e">nums2&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, Math.&lt;span style="color:#a6e22e">floor&lt;/span>(&lt;span style="color:#a6e22e">total&lt;/span> &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>) &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ) &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 找到两个有序数组的第k大的值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">findKth&lt;/span>(&lt;span style="color:#a6e22e">nums1&lt;/span>, &lt;span style="color:#a6e22e">aBegin&lt;/span>, &lt;span style="color:#a6e22e">nums2&lt;/span>, &lt;span style="color:#a6e22e">bBegin&lt;/span>, &lt;span style="color:#a6e22e">k&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 如果数组1的下标或者数组2的下标超过各自的数组长度，k就是另一个数组的第k个数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">aBegin&lt;/span> &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#a6e22e">nums1&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">nums2&lt;/span>[&lt;span style="color:#a6e22e">bBegin&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">k&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">bBegin&lt;/span> &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#a6e22e">nums2&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">nums1&lt;/span>[&lt;span style="color:#a6e22e">aBegin&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">k&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">k&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Math.&lt;span style="color:#a6e22e">min&lt;/span>(&lt;span style="color:#a6e22e">nums1&lt;/span>[&lt;span style="color:#a6e22e">aBegin&lt;/span>], &lt;span style="color:#a6e22e">nums2&lt;/span>[&lt;span style="color:#a6e22e">bBegin&lt;/span>]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">midA&lt;/span> &lt;span style="color:#f92672">=&lt;/span> Number.&lt;span style="color:#a6e22e">MAX_VALUE&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">midB&lt;/span> &lt;span style="color:#f92672">=&lt;/span> Number.&lt;span style="color:#a6e22e">MAX_VALUE&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 如果数组1的第k/2个数没有越界
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">aBegin&lt;/span> &lt;span style="color:#f92672">+&lt;/span> Math.&lt;span style="color:#a6e22e">floor&lt;/span>(&lt;span style="color:#a6e22e">k&lt;/span> &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>) &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#a6e22e">nums1&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">midA&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">nums1&lt;/span>[&lt;span style="color:#a6e22e">aBegin&lt;/span> &lt;span style="color:#f92672">+&lt;/span> Math.&lt;span style="color:#a6e22e">floor&lt;/span>(&lt;span style="color:#a6e22e">k&lt;/span> &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>) &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">bBegin&lt;/span> &lt;span style="color:#f92672">+&lt;/span> Math.&lt;span style="color:#a6e22e">floor&lt;/span>(&lt;span style="color:#a6e22e">k&lt;/span> &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>) &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#a6e22e">nums2&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">midB&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">nums2&lt;/span>[&lt;span style="color:#a6e22e">bBegin&lt;/span> &lt;span style="color:#f92672">+&lt;/span> Math.&lt;span style="color:#a6e22e">floor&lt;/span>(&lt;span style="color:#a6e22e">k&lt;/span> &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>) &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 如果数组1的第k/2个数小于数组2的k/2个数，表示总的第k个数在数组1后判断和数组2的前半段
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 所以数组1的下标需要往后走k/2个位置，响应的数组b的下标往前走k/2个位置
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">midA&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#a6e22e">midB&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">findKth&lt;/span>(&lt;span style="color:#a6e22e">nums1&lt;/span>, &lt;span style="color:#a6e22e">aBegin&lt;/span> &lt;span style="color:#f92672">+&lt;/span> Math.&lt;span style="color:#a6e22e">floor&lt;/span>(&lt;span style="color:#a6e22e">k&lt;/span> &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>), &lt;span style="color:#a6e22e">nums2&lt;/span>, &lt;span style="color:#a6e22e">bBegin&lt;/span>, &lt;span style="color:#a6e22e">k&lt;/span> &lt;span style="color:#f92672">-&lt;/span> Math.&lt;span style="color:#a6e22e">floor&lt;/span>(&lt;span style="color:#a6e22e">k&lt;/span> &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">findKth&lt;/span>(&lt;span style="color:#a6e22e">nums1&lt;/span>, &lt;span style="color:#a6e22e">aBegin&lt;/span>, &lt;span style="color:#a6e22e">nums2&lt;/span>, &lt;span style="color:#a6e22e">bBegin&lt;/span> &lt;span style="color:#f92672">+&lt;/span> Math.&lt;span style="color:#a6e22e">floor&lt;/span>(&lt;span style="color:#a6e22e">k&lt;/span> &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>), &lt;span style="color:#a6e22e">k&lt;/span> &lt;span style="color:#f92672">-&lt;/span> Math.&lt;span style="color:#a6e22e">floor&lt;/span>(&lt;span style="color:#a6e22e">k&lt;/span> &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>时间复杂度$O(log(m+n))$&lt;/p>
&lt;blockquote>
&lt;p>每次递归都舍弃了一半数据，二分的复杂度是$log$&lt;/p>
&lt;/blockquote>
&lt;p>空间复杂度$O(1)$&lt;/p>
&lt;blockquote>
&lt;p>只使用了固定的几个临时变量&lt;/p>
&lt;/blockquote>
&lt;h2 id="结尾">结尾&lt;/h2>
&lt;p>本问题考察的是对二分法的基本功，面试中后期遇到的可能性比较大，可以多加熟悉。&lt;/p></description></item><item><title>leetcode(3)——无重复字符的最长子串</title><link>https://www.ddhigh.com/2019/09/16/leetcode-longest-substring-without-repeating-characters-copy/</link><pubDate>Mon, 16 Sep 2019 18:34:58 +0000</pubDate><guid>https://www.ddhigh.com/2019/09/16/leetcode-longest-substring-without-repeating-characters-copy/</guid><description>&lt;p>本文是力扣算法的第三篇，讲解无重复字符的最长子串问题。&lt;/p>
&lt;h2 id="question">Question&lt;/h2>
&lt;blockquote>
&lt;p>给定一个字符串，请你找出其中不含有重复字符的 &lt;strong>最长子串&lt;/strong> 的长度。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>示例1：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>输入: &amp;#34;abcabcbb&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>输出: 3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>解释: 因为无重复字符的最长子串是 &amp;#34;abc&amp;#34;，所以其长度为 3。
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>示例2：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>输入: &amp;#34;bbbbb&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>输出: 1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>解释: 因为无重复字符的最长子串是 &amp;#34;b&amp;#34;，所以其长度为 1。
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>示例3：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>输入: &amp;#34;pwwkew&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>输出: 3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>解释: 因为无重复字符的最长子串是 &amp;#34;wke&amp;#34;，所以其长度为 3。
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 请注意，你的答案必须是 子串 的长度，&amp;#34;pwke&amp;#34; 是一个子序列，不是子串。
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="遍历法">遍历法&lt;/h2>
&lt;blockquote>
&lt;p>最容易想到的一种算法，也是效率最低的一种算法&lt;/p>
&lt;ol>
&lt;li>通过两次遍历得到所有可能的 &lt;strong>子字符串&lt;/strong> 列表&lt;/li>
&lt;li>将每个字符串传入一个函数检测是否包含重复字符，如果不包含则更新最长子串的长度&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 判断给定的子串是否包含重复字符
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">isUnique&lt;/span>(&lt;span style="color:#a6e22e">str&lt;/span>, &lt;span style="color:#a6e22e">start&lt;/span>, &lt;span style="color:#a6e22e">end&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">chars&lt;/span> &lt;span style="color:#f92672">=&lt;/span> [];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">start&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#a6e22e">end&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">str&lt;/span>[&lt;span style="color:#a6e22e">i&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#a6e22e">chars&lt;/span>.&lt;span style="color:#a6e22e">indexOf&lt;/span>(&lt;span style="color:#66d9ef">char&lt;/span>) &lt;span style="color:#f92672">!==&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) { &lt;span style="color:#75715e">// 字符已存在，本字符串不符合条件
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">chars&lt;/span>.&lt;span style="color:#a6e22e">push&lt;/span>(&lt;span style="color:#66d9ef">char&lt;/span>); &lt;span style="color:#75715e">// 添加字符
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 获取字符串最长子串长度
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">lengthOfLongestSubstring&lt;/span>(&lt;span style="color:#a6e22e">s&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">max&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#a6e22e">s&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">j&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#a6e22e">j&lt;/span> &lt;span style="color:#f92672">&amp;lt;=&lt;/span> &lt;span style="color:#a6e22e">s&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span>; &lt;span style="color:#a6e22e">j&lt;/span>&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#a6e22e">isUnique&lt;/span>(&lt;span style="color:#a6e22e">s&lt;/span>, &lt;span style="color:#a6e22e">i&lt;/span>, &lt;span style="color:#a6e22e">j&lt;/span>)) { &lt;span style="color:#75715e">// 判断子串是否唯一
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">max&lt;/span> &lt;span style="color:#f92672">=&lt;/span> Math.&lt;span style="color:#a6e22e">max&lt;/span>(&lt;span style="color:#a6e22e">max&lt;/span>, &lt;span style="color:#a6e22e">j&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span>); &lt;span style="color:#75715e">// j - i 为当前子串长度
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">max&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>时间复杂度$O(n^3)$&lt;/p>
&lt;blockquote>
&lt;p>i循环，j循环，isUnquie中的循环，3次循还嵌套&lt;/p>
&lt;/blockquote>
&lt;p>空间复杂度$O(min(n,m))$&lt;/p>
&lt;blockquote>
&lt;p>isUnique函数中定义了一个数组来存储不重复的子串字符，长度为$k$,$k$的长度取决于字符串$s$的大小$n$以及 字符串$s$包含的不重复字符数大小$m$&lt;/p>
&lt;/blockquote>
&lt;h2 id="滑动窗口法">滑动窗口法&lt;/h2>
&lt;blockquote>
&lt;p>暴力法中我们会重复检查一个子串是否包含重复的字符，如果从$i$ ~ $j-1$ 之间的子串已经被检查过没有重复字符了，那么只需要检查$s[j]$是否在这个子串就行了。&lt;/p>
&lt;p>子串使用js自带的数据结构Set存储&lt;/p>
&lt;p>如果不在该子串，那么子串长度+1，$j+1$，继续往后走&lt;/p>
&lt;p>如果在这个子串，证明出现了重复，我们需要将$s[i]$移出来之后$i+1$，继续往后走&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">lengthOfLongestSubstring&lt;/span>(&lt;span style="color:#a6e22e">s&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">set&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">Set&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">max&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">j&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span>(&lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#a6e22e">s&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#a6e22e">j&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#a6e22e">s&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#a6e22e">set&lt;/span>.&lt;span style="color:#a6e22e">has&lt;/span>(&lt;span style="color:#a6e22e">s&lt;/span>[&lt;span style="color:#a6e22e">j&lt;/span>])) { &lt;span style="color:#75715e">// j 不在set中，set中添加s[j],j后移，同时更新最大子串长度
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">set&lt;/span>.&lt;span style="color:#a6e22e">add&lt;/span>(&lt;span style="color:#a6e22e">s&lt;/span>[&lt;span style="color:#a6e22e">j&lt;/span>]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">j&lt;/span>&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">max&lt;/span> &lt;span style="color:#f92672">=&lt;/span> Math.&lt;span style="color:#a6e22e">max&lt;/span>(&lt;span style="color:#a6e22e">max&lt;/span>, &lt;span style="color:#a6e22e">j&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">set&lt;/span>.&lt;span style="color:#66d9ef">delete&lt;/span>(&lt;span style="color:#a6e22e">s&lt;/span>[&lt;span style="color:#a6e22e">i&lt;/span>]); &lt;span style="color:#75715e">// 移除set左边的数据，i后移一位
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">max&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>时间复杂度 $O(2n) \approx O(n)$&lt;/p>
&lt;blockquote>
&lt;p>最好的情况是j一次走完没有出现重复，最坏的情况是i和j都走到了末尾&lt;/p>
&lt;/blockquote>
&lt;p>空间复杂度 $O(min(n,m))$&lt;/p>
&lt;blockquote>
&lt;p>与暴力法相似，也需要一个Set存储不重复字符，$n$ 是字符串$s$长度，$m$是字符串$s$中不重复的字母个数&lt;/p>
&lt;/blockquote>
&lt;h2 id="优化的滑动窗口">优化的滑动窗口&lt;/h2>
&lt;blockquote>
&lt;p>在滑动窗口解法中，$i$的后移可以优化一下，如果 s$[j]$ 在 s[$i$] ~ s[$j$] 内与字符 $c$ (随便取的名字)重复，$i$ 不需要一步一步$i$++，直接把 $i$ 定位到 $c$ + 1的位置即可。这样可以将算法时间复杂度稳定在 $O(n)$&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">lengthOfLongestSubstring&lt;/span>(&lt;span style="color:#a6e22e">s&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">map&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {}; &lt;span style="color:#75715e">// 保存 字符和下标的映射关系，如果字符重复，从map拿到位置，i直接跳到这个位置
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">max&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#a6e22e">j&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;&lt;span style="color:#a6e22e">j&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#a6e22e">s&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span>;&lt;span style="color:#a6e22e">j&lt;/span>&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">s&lt;/span>[&lt;span style="color:#a6e22e">j&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#a6e22e">map&lt;/span>[&lt;span style="color:#66d9ef">char&lt;/span>] &lt;span style="color:#f92672">!==&lt;/span> &lt;span style="color:#66d9ef">undefined&lt;/span>) { &lt;span style="color:#75715e">// 当前字符存在重复，需要将i更新
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">=&lt;/span> Math.&lt;span style="color:#a6e22e">max&lt;/span>(&lt;span style="color:#a6e22e">i&lt;/span>, &lt;span style="color:#a6e22e">map&lt;/span>[&lt;span style="color:#66d9ef">char&lt;/span>]); &lt;span style="color:#75715e">// 如果i的当前位置大于map[char]，不能更新为map[char]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">max&lt;/span> &lt;span style="color:#f92672">=&lt;/span> Math.&lt;span style="color:#a6e22e">max&lt;/span>(&lt;span style="color:#a6e22e">max&lt;/span>, &lt;span style="color:#a6e22e">j&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>); &lt;span style="color:#75715e">// 由于j最大是s.length-1，所以最大子串长度需要+1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">map&lt;/span>[&lt;span style="color:#66d9ef">char&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">j&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#75715e">// 保存映射关系
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">max&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>时间复杂度 $O(n)$&lt;/p>
&lt;blockquote>
&lt;p>只遍历了j&lt;/p>
&lt;/blockquote>
&lt;p>空间复杂度 $O(min(n,m))$&lt;/p>
&lt;blockquote>
&lt;p>与之前的方法相同&lt;/p>
&lt;/blockquote>
&lt;p>Q: 为什么第8行的 &lt;code>i = Math.max(i, map[char])&lt;/code> 不能直接是 &lt;code>i = map[char]&lt;/code>?&lt;/p>
&lt;p>A: $i$ 的位置比&lt;code>map[char]&lt;/code>大的情况下如果直接赋值会导致 $i$ 往前面走，会导致返回的子串长度大于实际的子串长度&lt;/p>
&lt;p>错误例子 &lt;code>abba&lt;/code>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>i&lt;/th>
&lt;th>j&lt;/th>
&lt;th>s[j]&lt;/th>
&lt;th>s[i] ~ s[j]&lt;/th>
&lt;th>Max&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>0&lt;/td>
&lt;td>a&lt;/td>
&lt;td>a&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>1&lt;/td>
&lt;td>b&lt;/td>
&lt;td>ab&lt;/td>
&lt;td>2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2(map中没有s[j]，所以这里的位置直接是当前j的值)&lt;/td>
&lt;td>2&lt;/td>
&lt;td>b&lt;/td>
&lt;td>b&lt;/td>
&lt;td>2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1(map中有s[j]，第1个字符就是a，直接拿来用)&lt;/td>
&lt;td>3&lt;/td>
&lt;td>a&lt;/td>
&lt;td>bba&lt;/td>
&lt;td>3&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>可以看到第4次循环中 i 的位置已经出现了问题，把位置1的a拿过来进行计算了，窗口的起始左边也从2变成了1，往回走了。&lt;/p>
&lt;h2 id="结尾">结尾&lt;/h2>
&lt;p>本问题主要是考察对滑动窗口算法的实际应用，掌握之后解题问题不大。&lt;/p></description></item><item><title>leetcode(2) —— 两数相加</title><link>https://www.ddhigh.com/2019/09/12/leetcode-add-two-sum/</link><pubDate>Thu, 12 Sep 2019 23:16:28 +0000</pubDate><guid>https://www.ddhigh.com/2019/09/12/leetcode-add-two-sum/</guid><description>&lt;p>本文是力扣算法的第二篇，讲解两数相加问题。&lt;/p>
&lt;h2 id="question">Question&lt;/h2>
&lt;blockquote>
&lt;p>给出两个 &lt;strong>非空&lt;/strong> 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 &lt;strong>逆序&lt;/strong> 的方式存储的，并且它们的每个节点只能存储 &lt;strong>一位&lt;/strong> 数字。&lt;/p>
&lt;p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。&lt;/p>
&lt;p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>示例：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>输入：(2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>输出：7 -&amp;gt; 0 -&amp;gt; 8
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>原因：342 + 465 = 807
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="分析">分析&lt;/h2>
&lt;p>遍历两个链表把值加起来好之后插入链表，如果有进位的话需要把进位的值保存到后面的节点上，如果遍历完毕之后还剩下需要进位的值，那么需要插入末尾新节点。&lt;/p>
&lt;h3 id="边界情况">边界情况&lt;/h3>
&lt;p>遇到链表相关的题目时一定要处理好边界情况，因为有些为空的链表或者只有1个节点的链表没有处理的必要，及时返回可以降低算法复杂度。&lt;/p>
&lt;ol>
&lt;li>链表1和链表2同时为空，直接返回undefined即可&lt;/li>
&lt;li>链表1为空，返回链表2&lt;/li>
&lt;li>链表2为空，返回链表1&lt;/li>
&lt;/ol>
&lt;h2 id="解题方法">解题方法&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 链表节点定义
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">ListNode&lt;/span>(&lt;span style="color:#a6e22e">val&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">val&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">val&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">next&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">addTwoNumbers&lt;/span>(&lt;span style="color:#a6e22e">l1&lt;/span>, &lt;span style="color:#a6e22e">l2&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#a6e22e">l1&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#a6e22e">l2&lt;/span>) { &lt;span style="color:#75715e">// 链表1和链表2同时为空，无需任何处理
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#a6e22e">l1&lt;/span>) { &lt;span style="color:#75715e">// 链表1为空，直接返回链表2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">l2&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#a6e22e">l2&lt;/span>) { &lt;span style="color:#75715e">// 链表2为空，直接返回链表1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">l1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">carry&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#75715e">// 进位值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">head&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">ListNode&lt;/span>(&lt;span style="color:#ae81ff">0&lt;/span>); &lt;span style="color:#75715e">// 链表头节点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">p&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">head&lt;/span>; &lt;span style="color:#75715e">// 链表移动指针
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span>(&lt;span style="color:#a6e22e">l1&lt;/span> &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#a6e22e">l2&lt;/span> &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#a6e22e">carry&lt;/span> &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) { &lt;span style="color:#75715e">// l1和l2虽然不会同时为空，但是存在l1和l2长度不一致的情况， 这种也需要处理
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">sum&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">carry&lt;/span>; &lt;span style="color:#75715e">// sum为本节点的值，需要加上前一个节点的进位值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#a6e22e">l1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">sum&lt;/span> &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#a6e22e">l1&lt;/span>.&lt;span style="color:#a6e22e">val&lt;/span>; &lt;span style="color:#75715e">// 把链表1当前节点的值加上
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">l1&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">l1&lt;/span>.&lt;span style="color:#a6e22e">next&lt;/span>; &lt;span style="color:#75715e">// 移动链表1指针
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#a6e22e">l2&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">sum&lt;/span> &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#a6e22e">l2&lt;/span>.&lt;span style="color:#a6e22e">val&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">l2&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">l2&lt;/span>.&lt;span style="color:#a6e22e">next&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#a6e22e">sum&lt;/span> &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>) { &lt;span style="color:#75715e">// 两个个位数相加最大值为18，所以到下一个节点进位的最大值为1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">carry&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">sum&lt;/span> &lt;span style="color:#f92672">-=&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>; &lt;span style="color:#75715e">// 去掉十位，保留个位为节点最终值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">carry&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#75715e">// 相加之后和小于10，不需要进位，清除进位数据，否则死循环
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">next&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">ListNode&lt;/span>(&lt;span style="color:#a6e22e">sum&lt;/span>); &lt;span style="color:#75715e">// 插入新节点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">p&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">next&lt;/span>; &lt;span style="color:#75715e">// 新链表指针后移
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">head&lt;/span>.&lt;span style="color:#a6e22e">next&lt;/span>; &lt;span style="color:#75715e">// 头结点的值不是相加得到的，所以需要后移一个节点返回由两个链表加起来的结果
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>进位的处理搞清楚之后这道题就清楚了。&lt;/p>
&lt;p>时间复杂度O(max(l1.length, l2.length))&lt;/p>
&lt;blockquote>
&lt;p>　循环次数的根据链表1和链表2中长的那个链表来的，因为要保证两个链表的所有节点都被便利到&lt;/p>
&lt;/blockquote>
&lt;p>空间复杂度O(max(l1,l2))&lt;/p>
&lt;blockquote>
&lt;p>最终链表的节点数也是根据链表1和链表2中长的那个链表来的，因为要保证两个链表的所有节点都被便利到，如果最后有进位的话，结果链表的长度会比链表1和链表2中长的链表大小+1。&lt;/p>
&lt;/blockquote>
&lt;h2 id="结尾">结尾&lt;/h2>
&lt;p>这道题的难度是中等，但是摸清楚链表的基本操作之后，应该没什么问题就能解决。&lt;/p></description></item><item><title>leetcode(1) —— 两数之和</title><link>https://www.ddhigh.com/2019/09/12/leetcode-two-sum/</link><pubDate>Thu, 12 Sep 2019 19:32:13 +0000</pubDate><guid>https://www.ddhigh.com/2019/09/12/leetcode-two-sum/</guid><description>&lt;p>本文是力扣算法的第一篇，讲解两数之和问题。&lt;/p>
&lt;h2 id="问题">问题&lt;/h2>
&lt;blockquote>
&lt;p>给定一个整数数组 &lt;em>&lt;code>nums&lt;/code>&lt;/em> 和一个目标值 &lt;em>&lt;code>target&lt;/code>&lt;/em>，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。&lt;/p>
&lt;p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>示例:&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>给定 nums = [2, 7, 11, 15], target = 9
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>因为 nums[0] + nums[1] = 2 + 7 = 9
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>所以返回 [0, 1]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="嵌套循环解题法">嵌套循环解题法&lt;/h2>
&lt;blockquote>
&lt;p>通过第1遍循环可以拿到当前值和剩余值，然后嵌套循环一次，检查剩余值是不是在数组中。&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">twoSum&lt;/span>(&lt;span style="color:#a6e22e">nums&lt;/span>, &lt;span style="color:#a6e22e">target&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;&lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#a6e22e">nums&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span>;&lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">current&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">nums&lt;/span>[&lt;span style="color:#a6e22e">i&lt;/span>]; &lt;span style="color:#75715e">// 拿到当前值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">remain&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">target&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#a6e22e">current&lt;/span>; &lt;span style="color:#75715e">// 拿到剩余值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">j&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;&lt;span style="color:#a6e22e">j&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#a6e22e">nums&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span>;&lt;span style="color:#a6e22e">j&lt;/span>&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#a6e22e">nums&lt;/span>[&lt;span style="color:#a6e22e">j&lt;/span>] &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#a6e22e">remain&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> [&lt;span style="color:#a6e22e">i&lt;/span>, &lt;span style="color:#a6e22e">j&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>时间复杂度是O(n^2)&lt;/p>
&lt;blockquote>
&lt;p>nums的长度为n,嵌套循环的总执行次数是 n*(n-1)，当n趋向于无穷大时n-1和n没什么区别，忽略&lt;/p>
&lt;/blockquote>
&lt;p>空间复杂度为O(1)&lt;/p>
&lt;blockquote>
&lt;p>增加的临时变量有 current, remain, i, j，不会随着nums的长度而增加，所以是常量O(1)&lt;/p>
&lt;/blockquote>
&lt;p>嵌套循环的效率是最低的, 面试的时候就算回答出来被送走的几率也是很大的。&lt;/p>
&lt;h2 id="两遍hashtable解题法">两遍HashTable解题法&lt;/h2>
&lt;blockquote>
&lt;p>核心思想是使用一个HashTable保存每个值和每个值的位置。&lt;/p>
&lt;p>第1次循环时构造出HashTable，键为nums数组的元素，值为元素对应的下标&lt;/p>
&lt;p>第2次循环时获取当前循环的值以及剩余值，如果剩余值的索引不等于当前值的索引，且剩余值也在HashTable中，直接从HashTable读取出当前值和剩余值的index返回。&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">twoSum&lt;/span>(&lt;span style="color:#a6e22e">nums&lt;/span>, &lt;span style="color:#a6e22e">target&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">hashTable&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 第1次循环
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;&lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#a6e22e">nums&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span>;&lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">hashTable&lt;/span>[&lt;span style="color:#a6e22e">nums&lt;/span>[&lt;span style="color:#a6e22e">i&lt;/span>]] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 第2次循环
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;&lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#a6e22e">nums&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span>;&lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">current&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">nums&lt;/span>[&lt;span style="color:#a6e22e">i&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">remain&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">target&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#a6e22e">current&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#a6e22e">map&lt;/span>[&lt;span style="color:#a6e22e">remain&lt;/span>] &lt;span style="color:#f92672">!==&lt;/span> &lt;span style="color:#66d9ef">undefined&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#a6e22e">map&lt;/span>[&lt;span style="color:#a6e22e">remain&lt;/span>] &lt;span style="color:#f92672">!==&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> [&lt;span style="color:#a6e22e">i&lt;/span>, &lt;span style="color:#a6e22e">map&lt;/span>[&lt;span style="color:#a6e22e">remain&lt;/span>]];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>时间复杂度为O(2n) = O(n)&lt;/p>
&lt;blockquote>
&lt;p>进行了两次循环，理论上是2*n的时间复杂度，但是当n趋向于无穷大时，n和2n的差距可以忽略，所以结果是O(n)&lt;/p>
&lt;/blockquote>
&lt;p>空间复杂度为O(n)&lt;/p>
&lt;blockquote>
&lt;p>增加了HashTable，大小是nums的长度n，所以空间复杂度是O(n)&lt;/p>
&lt;/blockquote>
&lt;p>该算法利用了HashTable的O(1)的时间复杂度巧妙地减少了嵌套循环，算法效率提升很大！&lt;/p>
&lt;p>一般回答到这里基本就没啥问题了，但是还有一种基于HashTable一次循环就能解决问题的方案。&lt;/p>
&lt;h2 id="一遍hashtable解题法">一遍HashTable解题法&lt;/h2>
&lt;blockquote>
&lt;p>循环nums数组，得到当前值和剩余值，判断剩余值在不在HashTable，如果在的话，直接返回剩余值的位置和当前值的位置。如果不在则把剩余值插入HashTable，继续循环。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>Q: 为什么先返回的是剩余值的位置而不是当前值的位置？&lt;/p>
&lt;p>A: 因为当前值的位置是确定的，所以当前值的位置不在HashTable中，但是剩余值可能在前面的循环中插入了HashTable，是老值，所以先返回。&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">twoSum&lt;/span>(&lt;span style="color:#a6e22e">nums&lt;/span>, &lt;span style="color:#a6e22e">target&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">hashTable&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;&lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#a6e22e">nums&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span>;&lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">current&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">nums&lt;/span>[&lt;span style="color:#a6e22e">i&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">remain&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">target&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#a6e22e">remain&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#a6e22e">hashTable&lt;/span>[&lt;span style="color:#a6e22e">remain&lt;/span>] &lt;span style="color:#f92672">!==&lt;/span> &lt;span style="color:#66d9ef">undefined&lt;/span>) { &lt;span style="color:#75715e">// 为什么不需要判断位置?因为当前值的位置根本没插入HashTable中，索引不可能重复
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> [&lt;span style="color:#a6e22e">hashTable&lt;/span>[&lt;span style="color:#a6e22e">remain&lt;/span>], &lt;span style="color:#a6e22e">i&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">hashTable&lt;/span>[&lt;span style="color:#a6e22e">current&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span>; &lt;span style="color:#75715e">// 插入当前值到HashTable，下一次循环时这里就成了&amp;#34;老值&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>时间复杂度O(n)&lt;/p>
&lt;blockquote>
&lt;p>正宗的O(n),一次循环解决问题&lt;/p>
&lt;/blockquote>
&lt;p>空间复杂度O(n)&lt;/p>
&lt;blockquote>
&lt;p>增加了HashTable，大小随着nums的增大而增大&lt;/p>
&lt;/blockquote>
&lt;h2 id="结尾">结尾&lt;/h2>
&lt;p>合理使用HashTable能够将算法的时间复杂度降低很多，一般会有一个指数级的提升！&lt;/p></description></item></channel></rss>