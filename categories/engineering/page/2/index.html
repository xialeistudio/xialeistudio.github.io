<!doctype html><html lang=zh><head><meta name=viewport content="width=device-width,initial-scale=1"><title>Engineering</title>
<meta charset=utf-8><meta name=description content="Ladder@Learning & Writing & Sharing"><meta name=author content="Lei Xia"><link rel=canonical href=https://www.ddhigh.com/categories/engineering/><link rel=alternate type=application/rss+xml href=https://www.ddhigh.com//index.xml title="Lei Xia"><meta property="og:title" content="Engineering"><meta property="og:description" content="Learning & Writing & Sharing"><meta property="og:type" content="website"><meta property="og:url" content="https://www.ddhigh.com/categories/engineering/"><meta name=twitter:card content="summary"><meta name=twitter:title content="Engineering"><meta name=twitter:description content="Learning & Writing & Sharing"><link rel=icon href=/img/favicon.ico sizes=16x16><link rel=apple-touch-icon href=/img/favicon.ico><link rel=manifest href=/img/favicon.ico><link rel=stylesheet href=https://cdn.staticfile.org/lxgw-wenkai-webfont/1.6.0/style.css><link rel=stylesheet href=/css/main.min.eb16e2c37edda7bb7b8f844336c65138877ea26f51562d3d69efff7f073bff83.css integrity="sha256-6xbiw37dp7t7j4RDNsZROId+om9RVi09ae//fwc7/4M=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/highlight/github-dark.min.min.66034289ee9a113219a2c4aae0a8bd2095ab255c832a42efcf5863f10814e7a1.css><script src=/js/highlight.min.min.c607d6febd16934a82eb61d3a896ed9d869f54373cc63ce95864ed5488fe3128.js></script><script>hljs.highlightAll()</script><script>$darkModeInit.Content|safeJS</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-EC3XLVSGKV"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-EC3XLVSGKV")</script></head><body><main class=wrapper><nav class=navigation><section class=container><a class=navigation-brand href=/>HOME
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><span></span><span></span><span></span></label><ul class=navigation-list id=navigation-list><li class="navigation-item navigation-menu"><a class=navigation-link href=/archives>归档</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/books>出版物</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/guestbook>留言板</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class="navigation-item navigation-social"><a class=navigation-link href=https://github.com/xialeistudio><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li class="navigation-item navigation-dark"><button id=mode type=button aria-label="toggle user light or dark theme">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span>
<span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></li><li class="navigation-item navigation-language"><a href=https://www.ddhigh.com/en/categories/engineering/>EN</a></li></ul></section></nav><div id=content><div class=blog-wrapper><div><div class=blog-list><article><div class=blog-card><h3><a href=/2021/02/06/go-wire-tutorial/>golang依赖注入工具wire指南</a></h3><p><small>2021年2月6日&nbsp;· 829 字&nbsp;· 4 分钟</small><p>wire与依赖注入 Wire 是一个的Golang依赖注入工具，通过自动生成代码的方式在编译期完成依赖注入，Java体系中最出名的Spring框架采用运行时注入，个人认为这是wire和其他依赖注入最大的不同之处。
依赖注入(Dependency Injection)也称作控制反转(Inversion of Control)，个人给控制反转下的定义如下：
当前对象需要的依赖对象由外部提供（通常是IoC容器），外部负责依赖对象的构造等操作，当前对象只负责调用，而不关心依赖对象的构造。即依赖对象的控制权交给了IoC容器。
下面给出一个控制反转的示例，比如我们通过配置去创建一个数据库连接：
// 连接配置 type DatabaseConfig struct { Dsn string } func NewDB(config *DatabaseConfig)(*sql.DB, error) { db,err := sql.Open("mysql", config.Dsn) if err != nil { return nil, err } // ... } fun NewConfig()(*DatabaseConfig,error) { // 读取配置文件 fp, err := os.Open("config.json") if err != nil { return nil,err } defer fp.Close() // 解析为Json var config DatabaseConfig if err:=json.NewDecoder(fp).Decode(&amp;config);err!=nil { return nil,err } return &amp;config, nil } func InitDatabase() { cfg, err:=NewConfig() if err!</div></article><article><div class=blog-card><h3><a href=/2021/01/12/golang-halia-get-started/>Golang组件化网络服务器框架Halia指南</a></h3><p><small>2021年1月12日&nbsp;· 614 字&nbsp;· 3 分钟</small><p>写在前面 在netty框架面世之前，几乎没有一个成熟的OOP/组件化规范指导网络服务器开发，一些常用的FrameDecoder,BusinessHandler等等组件紧密耦合在了项目当中，整个项目可以说扩展性比较差。
netty的出现可以说是划时代的，基于OOP/组件化屏蔽了底层 BlockingIO/NonBlockingIO/AsynchrousIO之间的差异，各种组件可以无缝切换，网络服务器开发效率有了非常大的提高。
通过阅读netty源码，以及核心组件的架构，基于Golang进行了实现，至此，Golang的Halia框架面世了！
Halia特性 组件化/可扩展 Halia框架面向接口编程，并提供默认实现，同时内置常用的解码器，真正做到开箱即用。
高性能 基于Golang原生网络库进行开发，无第三方依赖，性能有保障。
易用性 Halia框架采用极简设计，没有冗余代码，并附带3个常用解码器示例，助您基于Halia快速开始开发。
开源免费 Halia框架基于MIT开源协议发布，无论是商用以及非商用都可以免费使用。
社区驱动 Halia框架托管于Github，任何人都可以贡献一臂之力。
快速开始 接下来将演示如何开发一个时间回显服务器。
客户端每隔1秒发送时间字符串给服务器，服务器回显该数据。
公用代码 encoder.go 字符串编码器，将字符串转换为[]byte传输到下一个出站处理器
package main import ( "halia/channel" ) type StringToByteEncoder struct{} // 编码器不处理处理，交由下一个处理器(也就是业务处理器)处理 func (e *StringToByteEncoder) OnError(c channel.HandlerContext, err error) { c.FireOnError(err) } func (e *StringToByteEncoder) Write(c channel.HandlerContext, msg interface{}) error { if str, ok := msg.(string); ok { // string才转换 return c.Write([]byte(str)) } return c.Write(msg) } func (e *StringToByteEncoder) Flush(c channel.</div></article><article><div class=blog-card><h3><a href=/2020/10/20/laravel-crontab-log-permission/>Laravel定时任务写入日志用户变为root导致Web进程无法写入日志问题</a></h3><p><small>2020年10月20日&nbsp;· 59 字&nbsp;· 1 分钟</small><p>今天访问接口时返回 接口写入日志失败，通过排查后发现 storage/logs下面出现了root用户新建的日志，导致www用户无法写入日志。
通过排查发现，crontab写入了laravel的定时任务命令。默认情况下，crontab的任务是使用root用户去执行的，因此laravel定时任务新建的文件属主自然成为了root。
解决方法 解决方法就是使用指定用户来运行 crontab 任务。比如使用www用户来运行laravel的计划任务命令。
使用下面的命令编辑www用户的定时任务。
crontab -u www -e 例如写入下面的示例任务：
* * * * * /usr/local/php/bin/php /data/wwwroot/laravel/artisan schedule:run >> /var/log/laravel-crontab.log 2>&amp;1 保存即可，等待系统运行任务。
运行时错误 通过观察发现定时任务并没有成功运行，通过查询/var/log/cron日志发现如下的日志：
(www) CMD (/usr/local/php/bin/php /data/wwwroot/laravel/artisan schedule:run >> /var/log/laravel-crontab.log 2>&amp;1) (CRON) ERROR chdir failed (/home/www): No such file or directory 可以看到，定时任务确实有执行，但是执行出错。出现这个问题的原因是www 用户没有主目录。
解决方案如下：
新建/home/www目录 将/home/www的用户属主改为www用户 相关命令如下：
mkdir /home/www chown -R www:www /home/www 后续执行没有再出现错误。</div></article><article><div class=blog-card><h3><a href=/2020/08/20/golang-http-captcha-example/>Golang Http 验证码示例</a></h3><p><small>2020年8月20日&nbsp;· 192 字&nbsp;· 1 分钟</small><p>验证码（CAPTCHA）是“Completely Automated Public Turing test to tell Computers and Humans Apart”（全自动区分计算机和人类的图灵测试）的缩写，是一种区分用户是计算机还是人的公共全自动程序。可以防止：恶意破解密码、刷票、论坛灌水，有效防止某个黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试，实际上用验证码是现在很多网站通行的方式，我们利用比较简易的方式实现了这个功能。这个问题可以由计算机生成并评判，但是必须只有人类才能解答。由于计算机无法解答CAPTCHA的问题，所以回答出问题的用户就可以被认为是人类。
传统网站验证码工作机制 客户端请求服务器获取验证码图片 服务器生成随机串(验证码值)写入Session，并将验证码值写入到图片中返回给客户端 客户端输入图片上的字符串提交给服务器验证 服务器比对客户端提交的字符串值和 Session 中是否匹配，如果匹配则通过验证 由于服务器生成的验证码值从始至终均未返回给客户端，因此，客户端只能从图片中识别验证码字符串，从而保证人机校验逻辑。
Go的HTTP验证码 思路 Go 语言的 HTTP 服务器默认不支持 Session，因此验证码值需要换个思路存储，以下是不使用 Session 的逻辑
客户端请求服务器获取验证码ID 服务器生成验证码 ID，并生成验证码值，将 ID 和值的映射关系记录到内存或缓存，并将 ID 返回给客户端 客户端根据返回的 ID 请求服务器获取验证码图片 服务器获取到验证码 ID，从内存或缓存中取出验证码值，将该值写入图片并将图片返回给客户端 客户端提交验证码 ID（第1步获得）和验证码值给服务器验证 服务器获取验证码 ID，从内存或缓存中取出验证码值与客户端提交的验证码值比对 示例 安装验证码依赖
github.com/dchest/captcha 代码实现
package main import ( "fmt" "github.com/dchest/captcha" "log" "net/http" ) func main() { // 获取验证码 ID http.HandleFunc("/captcha/generate", func(w http.ResponseWriter, r *http.Request) { id := captcha.</div></article><article><div class=blog-card><h3><a href=/2020/03/18/webpack-plugin-development/>Webpack4不求人(5)——编写自定义插件</a></h3><p><small>2020年3月18日&nbsp;· 567 字&nbsp;· 3 分钟</small><p>Webpack通过Loader完成模块的转换工作，让“一切皆模块”成为可能。Plugin机制则让其更加灵活，可以在Webpack生命周期中调用钩子完成各种任务，包括修改输出资源、输出目录等等。
今天我们一起来学习如何编写Webpack插件。
构建流程 在编写插件之前，还需要了解一下Webpack的构建流程，以便在合适的时机插入合适的插件逻辑。Webpack的基本构建流程如下：
校验配置文件 生成Compiler对象 初始化默认插件 run/watch：如果运行在watch模式则执行watch方法，否则执行run方法 compilation：创建Compilation对象回调compilation相关钩子 emit：文件内容准备完成，准备生成文件，这是最后一次修改最终文件的机会 afterEmit：文件已经写入磁盘完成 done：完成编译 插件示例 一个典型的Webpack插件代码如下：
// 插件代码 class MyWebpackPlugin { constructor(options) { } apply(compiler) { // 在emit阶段插入钩子函数 compiler.hooks.emit.tap('MyWebpackPlugin', (compilation) => {}); } } module.exports = MyWebpackPlugin; 接下来需要在webpack.config.js中引入这个插件。
module.exports = { plugins:[ // 传入插件实例 new MyWebpackPlugin({ param:'paramValue' }), ] }; Webpack在启动时会实例化插件对象，在初始化compiler对象之后会调用插件实例的apply方法，传入compiler对象，插件实例在apply方法中会注册感兴趣的钩子，Webpack在执行过程中会根据构建阶段回调相应的钩子。
Compiler && Compilation对象 在编写Webpack插件过程中，最常用也是最主要的两个对象就是Webpack提供的Compiler和Compilation，Plugin通过访问Compiler和Compilation对象来完成工作。
Compiler 对象包含了当前运行Webpack的配置，包括entry、output、loaders等配置，这个对象在启动Webpack时被实例化，而且是全局唯一的。Plugin可以通过该对象获取到Webpack的配置信息进行处理。 Compilation对象可以理解编译对象，包含了模块、依赖、文件等信息。在开发模式下运行Webpack时，每修改一次文件都会产生一个新的Compilation对象，Plugin可以访问到本次编译过程中的模块、依赖、文件内容等信息。 常见钩子 Webpack会根据执行流程来回调对应的钩子，下面我们来看看都有哪些常见钩子，这些钩子支持的tap操作是什么。
钩子 说明 参数 类型 afterPlugins 启动一次新的编译 compiler 同步 compile 创建compilation对象之前 compilationParams 同步 compilation compilation对象创建完成 compilation 同步 emit 资源生成完成，输出之前 compilation 异步 afterEmit 资源输出到目录完成 compilation 异步 done 完成编译 stats 同步 Tapable Tapable是Webpack的一个核心工具，Webpack中许多对象扩展自Tapable类。Tapable类暴露了tap、tapAsync和tapPromise方法，可以根据钩子的同步/异步方式来选择一个函数注入逻辑。</div></article><article><div class=blog-card><h3><a href=/2020/03/11/webpack-loader-development/>Webpack4不求人(4)——编写自定义Loader</a></h3><p><small>2020年3月11日&nbsp;· 427 字&nbsp;· 3 分钟</small><p>在前面的内容中，我们学习了Webpack的基本知识、常用脚手架和性能优化，虽然说大部分的开发场景社区已经又成熟的模块给我们使用，但是遇到特殊情况还是需要自己有独立开发的能力，因此今天我们一起来学习如何编写自定义Loader。
基本Loader Webpack中loader是一个CommonJs风格的函数，接收输入的源码，通过同步或异步的方式替换源码后进行输出。
module.exports = function(source, sourceMap, meta) { } source是输入的内容 sourceMap是可选的 meta是模块的元数据，也是可选的 需要注意的是，该导出函数必须使用function，不能使用箭头函数，因为loader编写过程中会经常使用到this访问选项和其他方法。
我们先编写一个基本的Loader，完成的工作很简单，那就是把输出的字符串进行替换。
1.新建loader-example目录，执行npm初始化，并安装webpack
mkdir loader-example cd loadeer-example npm init -y npm install webpack webpack-cli 2.构建项目目录
|----loader # loader目录 |----replace-loader.js # 替换字符串的Loader |----src # 应用源码 |----index.js # 首页 |----package.json |----webpack.config.js 3.编写loader/replace-loader.js
module.exports = function(source) { return source.replace(/World/g, 'Loader'); }; 本例中我们Loader只是简单的将源码中的”World“替换成了”Loader“。
4.编写src/index.js
console.log('Hello World'); 5.编写webpack.config.js
const path = require('path'); module.exports = { entry: './src/index', target: 'node', // 我们编译为Node.js环境下的JS，等下直接使用Node.js执行编译完成的文件 output:{ path: path.</div></article><article><div class=blog-card><h3><a href=/2020/03/06/webpack-optimize/>Webpack4不求人(3) ——性能优化</a></h3><p><small>2020年3月6日&nbsp;· 335 字&nbsp;· 2 分钟</small><p>限定Webpack处理文件范围 项目比较小的情况下Webpack的性能问题几乎可以忽略，但是一旦项目复杂度上升，Webpack会有额外的性能损失需要我们进行优化。
通过前面内容的学习我们可以知道Webpack主要干下面这些事情：
通过entry指定的入口脚本进行依赖解析。 找到文件后通过配置的loader对其进行处理。 因此，我们可以从这方面入手进行优化，减少Webpack搜索文件的范围，减少不必要的处理。
loader配置 在之前的内容中介绍过loader可以使用test、include、exclude配置项来匹配需要Loader处理的文件，因此推荐给每个loader定义test之后还定义include或exclude。
module.exports = { module:{ rules:[ { test:/\.js$/, use:'babel-loader', include: path.resolve(__dirname, 'src'), // 只处理src目录下的js文件 } ] } }; resolve.extensions配置 导入未添加扩展名的模块时，Webpack会通过resolve.extensions后缀去检查文件是否存在。由于resolve.extensions是一个数组，如果数组项比较多，正确的后缀放置得越靠后，Webpack尝试次数就会越多，影响到性能。
因此配置resolve.extensions时需要遵守以下规则：
尽量减少后缀列表，不要将不可能存在的文件后缀配置进来 出现频率越高的后缀尽量写到前面，比如可以将.js写在第一个 业务代码中导入模块时，可以手动加上后缀导入，省去Webpack查找过程 module.noParse配置 module.noParse可以告诉Webpack忽略未采用模块系统文件的处理，可以有效地提高性能。比如常见的jQuery非常大，又没有采用模块系统，让Webpack解析这类型文件完全是浪费性能。
因此我们可以配置如下的module.noParse:
module.exports = { module:{ noParse:[/jQuery/] } }; IgnorePlugin 在导入模块时，IgnorePlugin可以忽略指定模块的生成。比如moment.js在导入时会自动导入本地化文件，一般情况下几乎不使用而且又比较大，此时可以通过IgnorePlugin忽略对本地化文件的生成，减小文件大小。
module.exports = { plugins:[ new webpack.IgnorePlugin(/\.\/local/, /moment/) ] }; DllPlugin 使用过Windows操作系统的读者应该会经常看到以.dll扩展名的文件，这些文件叫做动态链接库，包含了其他程序或动态链接库的函数和数据。
Webpack的DllPlugin的思想是类似的，先将公共模块打包为独立的Dll模块，然后在业务代码中直接引用这些模块。采用DllPlugin之后会大大提升Webpack构建速度，原因在于，包含大量复用模块的动态链接库只需要编译一次，之后的构建中会直接引用这些构建好的模块。
在Webpack中使用动态链接库有以下两个步骤：
通过webpack.DllPlugin插件打包出Dll库 通过webpack.DllReferencePlugin引用打包好的Dll库 下面以React项目为例进行说明。
Dll库需要单独构建，因此我们需要一份单独的配置Webpack文件。
1.新建webpack.dll.config.js
const webpack = require('webpack'); module.exports = { entry:{ react: ['react', 'react-dom'] }, output:{ filename: '_dll_[name].</div></article><article><div class=blog-card><h3><a href=/2020/03/02/react-ssr-example/>Webpack4不求人(2) ——手把手搭建TypeScript+React16+ReactRouter5同构应用脚手架</a></h3><p><small>2020年3月2日&nbsp;· 658 字&nbsp;· 4 分钟</small><p>同构应用 使用同一份应用代码，同时提供浏览器环境和服务器环境下的应用，解决传统浏览器单页应用的两个顽固问题：
不利于SEO，浏览器环境代码是在客户端渲染，大部分爬虫都只能爬到一个空白的入口文件 代码在浏览器渲染，低端机可能会卡顿 接下来我们一起从零开始搭建基于Webpack的React同构应用脚手架。
SSR流程 Web应用构建完成后输出CSS、JS和HTML SSR应用构建完成后输出一个CommonJs模块文件，可以将虚拟DOM在服务端渲染为HTML字符串 Node.js新建HTTP服务器，收到请求后调用SSR模块导出的render函数输出HTML到客户端 初始化项目 mkdir react-ssr-example cd react-ssr-example yarn init -y yarn add webpack webpack-cli webpack-dev-server -D # 安装Webpack yarn add react react-dom react-router-dom # 安装React yarn add @types/react @types/react-dom @types/react-router-dom -D # 安装React声明文件 yarn add express # 安装express yarn add css-loader sass-loader node-sass mini-css-extract-plugin # 安装CSS相关模块 yarn add ts-loader typescript # 安装TypeScript yarn add html-webpack-plugin # 安装HTML处理插件 目录结构 脚手架的完整目录如下：(这些文件一步步都会有)
|----build # 构建结果目录 |----styles # 样式 |----main.</div></article><article><div class=blog-card><h3><a href=/2020/02/11/shell-operator-flow-control/>Shell脚本快速入门(2)</a></h3><p><small>2020年2月11日&nbsp;· 774 字&nbsp;· 4 分钟</small><p>今天我们来学习Shell的运算符和流程控制。
运算符 Shell和其他编程语言一样支持多种运算符，包括：
算术运算符 关系运算符 逻辑运算符 字符串运算符 文件测试运算符 下面我们一起来看看。
算术运算符 原生bash不支持简单的数学运算，需要借助expr命令。
例如，输出两个数的和：
sum=`expr 1 + 1` echo $sum 注意：
操作数和操作符之间必须用空格分开；
表达式必须使用反引号包裹；
操作符 说明 示例 + 加法 expr 1 + 1 - 减法 expr 1 - 1 * 乘法 expr 1 \* 1 需要转义*号 / 除法 expr 1 / 1 % 取余 expr 2 % 2 完整示例如下：
a=1 b=2 # 加法 val=`expr $a + $b` echo "$a+$b=$val" # 减法 val=`expr $a - $b` echo "$a-$b=$val" # 乘法 val=`expr $a \* $b` # 必须转义 echo "$a*$b=$val" # 除法 val=`expr $a / $b` echo "$a/$b=$val" # 取余 val=`expr $a % $b` echo "$a%$b=$val" 关系运算符 关系运算符是比较两个操作数的数学大小关系，支持数字和数字字符串(如"1")</div></article><article><div class=blog-card><h3><a href=/2020/02/10/shell-quickstart/>Shell脚本快速入门(1)</a></h3><p><small>2020年2月10日&nbsp;· 195 字&nbsp;· 1 分钟</small><p>Shell 是一个用 C 语言编写的程序，用户可以通过Shell脚本语言来进行程序开发。与其他脚本语言不同，Shell脚本所需的解释器一般是内置在操作系统的，而像Node.js、PHP等脚本语言需要手动安装解释器程序才可以。
接下来将和大家一起来学习Shell脚本编程。
Shell解释器 Shell解释器种类众多，笔者的电脑上内置以下Shell:
/bin/bash /bin/csh /bin/ksh /bin/sh /bin/tcsh /bin/zsh 其中bash和sh是最常见的Shell解释器，一般情况下，这两种Shell没有区别，本文以bash为例。
Hello World 打开文本编辑器(vim或者vscode)，新建文件 hello.sh，扩展名为sh(常用)。
#!/bin/bash echo "Hello World!" 第1行用来指明本脚本需要使用什么解释器来执行。#!是一个约定的语法。
echo用来输出文本。
执行Shell脚本 有两种方法可以执行Shell脚本：
作为可执行程序。给脚本添加可执行权限之后执行即可。 chmod +x ./hello.sh # 添加可执行权限 ./hello.sh # 执行脚本 作为解释器脚本。直接运行指定的解释器程序，并将脚本路径传入，本方式不要求脚本有可执行权限。 /bin/bash hello.sh # 使用/bin/bash来执行hello.sh Shell语法 和其他编程语言一样，Shell脚本也有自己的一套语法规则，我们现在来系统学习一下。
变量 命名规则 定义变量时，变量名不加美元符号$，如：
name="xialei" 和其他编程语言不同的时，Shell脚本中变量名和等号之间不能有空格。Shell变量名的命名规则如下：
只能包含英文字母、数字和下划线，且不能以数字开头 不能包含空格 不能使用关键字命名(通过下划线连接关键字是允许的) 不能使用标点符号 以下是合法的示例
var1 var_2 _var3 MAX_PAGE 以下是不合法的示例
$var 赋值 Shell有以下两种复制方式。
直接赋值。直接在等号后面指定变量值。 name="xialei admin=1 使用命名执行结果。可以将其他命令的执行结果赋值给变量。（以下两种方式是等效的） file=`ls /etc` # 反引号(键盘Tab上面的键) file1=$(ls /etc) 已经存在的变量，可以被重新赋值。</div></article></div><div class=paginator><a class=prev href=/categories/engineering/>&larr;&nbsp;&nbsp;Pre Page</a>
<a class=next href=/categories/engineering/page/3/>Next Page&nbsp;&nbsp;&rarr;</a></div></div></div></div><footer class=footer><p>&copy; 2014 - 2024 <a href=https://www.ddhigh.com/>Lei Xia</a>
Powered by
<a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>
<a href=https://github.com/guangzhengli/hugo-theme-ladder rel=noopener target=_blank>Ladder</a>
️</p></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.5376 22.7916C11.0152 22.7207 22.5795 21.1781 22.0978 10.4211 22.0536 9.43274 21.9303 8.53367 21.7387 7.71865M10.5376 22.7916C16.876 22.3728 20.0969 19.8899 21.5383 16.9142M10.5376 22.7916C9.7707 22.9055 8.97982 22.8964 8.19743 22.7725M21.7387 7.71865C21.4988 6.69828 21.1518 5.80967 20.7188 5.04257m1.0199 2.67608C22.6022 10.1105 23.0542 13.7848 21.5383 16.9142M20.7188 5.04257c-3.5504-6.28886-12.88753-4.410077-16.44303.0C2.88063 6.77451-.0433281 11.1668 1.38159 16.6571c.89322 3.4417 3.7911 5.6365 6.81584 6.1154M20.7188 5.04257c1.3509 1.89783 3.3111 6.34223 1.6353 10.37273M21.5383 16.9142C21.8737 16.4251 22.1428 15.9235 22.3541 15.4153M8.19743 22.7725C12.1971 23.4683 20.6281 22.971 22.3541 15.4153M14 10.945C13.3836 10.289 12.003 8.63215 11.2034 7.04814 11.1703 6.98257 11.0247 6.98456 10.9937 7.05061 10.5221 8.05496 9.07362 9.92941 8 10.945m3.0333-3.50056C10.9392 9.86549 11 15 12 17" stroke="currentcolor" stroke-linecap="round"/></svg>
</a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function n(){t.innerHTML="Copied",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)}),e.parentNode.appendChild(t)})</script></main></body><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script><script>const images=Array.from(document.querySelectorAll(".blog-content img"));images.forEach(e=>{mediumZoom(e,{margin:10,scrollOffset:40,container:null,template:null,background:"rgba(0, 0, 0, 0.5)"})})</script><script src=/main.min.6bb26b69159420159c74dc9e097b06a578ed2b68c701466a91a44a9632d851bd0af167a1b30012387b4c512b48ad9ad4d3394e04d77ae38d57e1920fe4ed34fe.js integrity="sha512-a7JraRWUIBWcdNyeCXsGpXjtK2jHAUZqkaRKljLYUb0K8WehswASOHtMUStIrZrU0zlOBNd6441X4ZIP5O00/g==" crossorigin=anonymous defer></script></html>