<!doctype html><html lang=zh><head><meta name=viewport content="width=device-width,initial-scale=1"><title>Engineering</title>
<meta charset=utf-8><meta name=description content="Ladder@Learning & Writing & Sharing"><meta name=author content="Lei Xia"><link rel=canonical href=https://www.ddhigh.com/categories/engineering/><link rel=alternate type=application/rss+xml href=https://www.ddhigh.com//index.xml title="Lei Xia"><meta property="og:title" content="Engineering"><meta property="og:description" content="Learning & Writing & Sharing"><meta property="og:type" content="website"><meta property="og:url" content="https://www.ddhigh.com/categories/engineering/"><meta name=twitter:card content="summary"><meta name=twitter:title content="Engineering"><meta name=twitter:description content="Learning & Writing & Sharing"><link rel=icon href=/img/favicon.ico sizes=16x16><link rel=apple-touch-icon href=/img/favicon.ico><link rel=manifest href=/img/favicon.ico><link rel=stylesheet href=https://cdn.staticfile.org/lxgw-wenkai-webfont/1.6.0/style.css><link rel=stylesheet href=/css/main.min.eb16e2c37edda7bb7b8f844336c65138877ea26f51562d3d69efff7f073bff83.css integrity="sha256-6xbiw37dp7t7j4RDNsZROId+om9RVi09ae//fwc7/4M=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/highlight/github-dark.min.min.66034289ee9a113219a2c4aae0a8bd2095ab255c832a42efcf5863f10814e7a1.css><script src=/js/highlight.min.min.c607d6febd16934a82eb61d3a896ed9d869f54373cc63ce95864ed5488fe3128.js></script><script>hljs.highlightAll()</script><script>$darkModeInit.Content|safeJS</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-EC3XLVSGKV"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-EC3XLVSGKV")</script></head><body><main class=wrapper><nav class=navigation><section class=container><a class=navigation-brand href=/>HOME
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><span></span><span></span><span></span></label><ul class=navigation-list id=navigation-list><li class="navigation-item navigation-menu"><a class=navigation-link href=/archives>归档</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/books>出版物</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/guestbook>留言板</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class="navigation-item navigation-social"><a class=navigation-link href=https://github.com/xialeistudio><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li class="navigation-item navigation-dark"><button id=mode type=button aria-label="toggle user light or dark theme">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span>
<span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></li><li class="navigation-item navigation-language"><a href=https://www.ddhigh.com/en/categories/engineering/>EN</a></li></ul></section></nav><div id=content><div class=blog-wrapper><div><div class=blog-list><article><div class=blog-card><h3><a href=/2019/08/28/nestjs-pipe/>NestJs学习之旅(8)——管道</a></h3><p><small>2019年8月28日&nbsp;· 387 字&nbsp;· 2 分钟</small><p>本文是NestJs学习之旅的第八篇，讲解管道。
管道 熟悉Linux命令的伙伴应该对“管道运算符”不陌生。
ls -la | grep demo &ldquo;|&rdquo; 就是管道运算符，它把左边命令的输出作为输入传递给右边的命令，支持级联，如此一来，便可以通过管道运算符进行复杂命令的交替运算。
NestJs中的管道有着类似的功能，也可以级联处理数据。NestJs管道通过**@Injectable()装饰器装饰，需要实现PipeTransform**接口。
NestJs中管道的主要职责如下：
数据转换 将输入数据转换为所需的输出 数据验证 接收客户端提交的参数，如果通过验证则继续传递，如果验证未通过则提示错误 执行顺序 在前面的文章中我们讨论了中间件、控制器、路由守卫，结合本问讨论的管道，可能有些读者会对这些组件的执行顺序提出疑问：这些东西执行的顺序到底是怎样的？
执行顺序也不用找资料，自己在这些组件执行时加上日志即可，我得出的结论如下：
客户端请求 -> 中间件 -> 路由守卫 -> 管道 -> 控制器方法
开发管道 数据转换类的管道就不详细解释了：
给你一个value和元数据，你的return值就是转换后的值。
NestJs内置了ValidationPipe、ParseIntPipe和ParseUUIDPipe。为了更好地理解它们的工作原理，我们以ValidationPipe（验证器管道）为例来演示管道的使用。
PipeTransform 这是管道必须实现的接口，该接口定义如下：
export interface PipeTransform&lt;T = any, R = any> { transform(value: T, metadata: ArgumentMetadata): R; } value 输入参数，T为输入参数类型 metadata  value的元数据，包括参数来源，参数类型等等 输出参数，R为输出参数类型 ArgumentMetadata 用来描述当前处理value的元数据接口，接口定义如下：
export interface ArgumentMetadata { readonly type: 'body' | 'query' | 'param' | 'custom'; readonly metatype?</div></article><article><div class=blog-card><h3><a href=/2019/08/27/nestjs-guard/>NestJs学习之旅(7)——路由守卫</a></h3><p><small>2019年8月27日&nbsp;· 457 字&nbsp;· 3 分钟</small><p>本文是NestJs的第七篇，讲解路由守卫。
传统的Web应用中去检测用户登录、权限判断等等都是在控制器层或者中间件层做的，而在目前比较推荐的模块化与组件化架构中，不同职责的功能建议拆分到不同的类文件中去。
通过前几篇的学习可以发现NestJs在这方面做的很好，传统的express/koa应用中，需要开发者去思考项目结构以及代码组织，而NestJs不需要你这样做，降低了开发成本，另外也统一了开发风格。
路由守卫 熟悉Vue,React的伙伴应该比较熟悉这个概念，通俗的说就是在访问指定的路由之前回调一个处理函数，如果该函数返回true或者**调用了next()**就会放行当前访问，否则阻断当前访问。
NestJs中路由守卫也是如此，通过继承CanActive接口即可定义一个路由守卫。
import { CanActivate, ExecutionContext, Injectable } from '@nestjs/common'; import { Observable } from 'rxjs'; @Injectable() class AppGuard implements CanActivate { canActivate(context: ExecutionContext): boolean | Promise&lt;boolean> | Observable&lt;boolean> { return true; } } 路由守卫与中间件 区别 路由守卫本质上也是中间件的一种，koa或者express开发中接口鉴权就是基于中间件开发的，如果当前请求是不被允许的，当前中间件将不会调用后续中间件，达到阻断请求的目的。
但是中间件的职责是不明确的，中间件可以干任何事（数据校验，格式转化，响应体压缩等等），这导致只能通过名称来识别中间件，项目迭代比较久以后，有比较高的维护成本。
联系 由于单一职责的关系，路由守卫只能返回true和false来决定放行/阻断当前请求，不可以修改request/response对象，因为一旦破坏单一职责的原则，排查问题比较麻烦。
如果需要修改request对象，可以结合中间件一起使用。
路由守卫在所有中间件执行完毕之后开始执行。
以下是一个结合路由守卫和中间件的例子。
// auth.middleware.ts // 中间件职责：读取请求头Authorization，如果存在且有效的话，设置user对象到request中 import { Injectable, NestMiddleware } from '@nestjs/common'; import { Request, Response } from 'express'; @Injectable() export class AuthMiddleware implements NestMiddleware&lt;Request|any, Response> { constructor(private readonly userService: UserService) {} async use(req: Request|any, res: Response, next: Function) { const token = req.</div></article><article><div class=blog-card><h3><a href=/2019/08/26/nestjs-exception-filter/>NestJs学习之旅(6)——异常处理</a></h3><p><small>2019年8月26日&nbsp;· 405 字&nbsp;· 2 分钟</small><p>本文是NestJs的第六篇，讲解异常处理。
传统的异常处理 在前面的内容中我们介绍了NestJs的几大常用组件，但是有一点没有做出说明，当我们的应用需要中断此次请求且输出错误信息时，我们需要怎么做？
这个问题有两种解决办法：
services层直接返回中断请求的响应对象，controller直接输出该对象即可
if(!this.allowLogin()) { return {errcode: 403, errmsg: '不允许登录'}; } services层抛出异常，controller捕获该异常，然后输出响应对象
以上两种方法都有一定的缺点：
controller调用多个services时，需要依据services层的返回值来进行错误判断，要是漏了判断的话会导致原本需要中断的请求处理继续运行，导致不可预料的后果 如果每个controller都需要try/catch掉services层抛出的异常的话，会多了很多“重复”代码 那有没有一个像SpringBoot的ExceptionHandler相似的解决办法呢?
NestJs的异常处理 NestJs提供了统一的异常处理器，来集中处理运行过程中未捕获的异常，可以自定义响应参数，非常灵活。
默认响应 NestJs内置了默认的全局异常过滤器，该过滤器处理HttpException(及其子类)的异常。如果抛出的异常不是上述异常，则会响应以下默认JSON：
{ "statusCode": 500, "message": "Interval server error" } 内置异常过滤器 由于NestJs内置了默认的异常过滤器，如果在应用内抛出HttpException，是可以被NestJs自动捕获的。
比如在services层抛出一个HttpException：
@Injectable() export class UserService { login(username: string, password: string) { if(!this.allowLogin()) { throw new HttpException('您无权登录', HttpStatus.FORBIDDEN); } return {user_id:1, token: 'fake token'} } } controller正常调用该services即可:
@Controller('users') export class UserController { constructor(private readonly userService: UserService) {} @Post('login') login(@Body('username') username: string, @Body('password') password: string) { return this.</div></article><article><div class=blog-card><h3><a href=/2019/08/24/socks5-protocol/>socks5协议详解</a></h3><p><small>2019年8月24日&nbsp;· 355 字&nbsp;· 2 分钟</small><p>Socks5代理协议 或许你没听说过socks5，但你一定听说过SS，SS内部使用的正是socks5协议。
socks5是一种网络传输协议，主要用于客户端与目标服务器之间通讯的透明传递。
该协议设计之初是为了让有权限的用户可以穿过防火墙的限制，访问外部资源。
1. RFC地址 socks5协议规范rfc1928 socks5账号密码鉴权规范rfc1929 2. 协议过程 客户端连接上代理服务器之后需要发送请求告知服务器目前的socks协议版本以及支持的认证方式 代理服务器收到请求后根据其设定的认证方式返回给客户端 如果代理服务器不需要认证，客户端将直接向代理服务器发起真实请求 代理服务器收到该请求之后连接客户端请求的目标服务器 代理服务器开始转发客户端与目标服务器之间的流量 3. 认证过程 3.1 客户端发出请求 客户端连接服务器之后将直接发出该数据包给代理服务器
VERSION METHODS_COUNT METHODS&mldr; 1字节 1字节 1到255字节，长度由METHODS_COUNT值决定 0x05 0x03 0x00 0x01 0x02 VERSION SOCKS协议版本，目前固定0x05 METHODS_COUNT 客户端支持的认证方法数量 METHODS&mldr; 客户端支持的认证方法，每个方法占用1个字节 METHOD定义
0x00 不需要认证（常用） 0x01 GSSAPI认证 0x02 账号密码认证（常用） 0x03 - 0x7F IANA分配 0x80 - 0xFE 私有方法保留 0xFF 无支持的认证方法 3.2 服务端返回选择的认证方法 接收完客户端支持的认证方法列表后，代理服务器从中选择一个受支持的方法返回给客户端
3.2.1 无需认证 VERSION METHOD 1字节 1字节 0x05 0x00 VERSION SOCKS协议版本，目前固定0x05 METHOD 本次连接所用的认证方法，上例中为无需认证 3.2.2 账号密码认证 VERSION METHOD 1字节 1字节 0x05 0x02 3.</div></article><article><div class=blog-card><h3><a href=/2019/08/23/nestjs-middlware/>NestJs学习之旅(5)——中间件</a></h3><p><small>2019年8月23日&nbsp;· 271 字&nbsp;· 2 分钟</small><p>本文是NestJs学习之旅的第五篇，讲解中间件。
中间件 中间件是在路由处理程序之前调用的函数。中间件函数可以访问请求和响应对象。
使用过koa和express的朋友应该知道，中间件是一个很核心的功能，尤其是koa，核心就是中间件，连路由功能都是由中间件提供的。
中间件可以提供以下功能：
运行过程中执行任意代码 对请求和响应进行更改 结束本次请求的响应 继续调用下一个中间件 示例 NestJs使用@Injectable()来装饰中间件，被装饰的对象应该实现NestMiddleware接口。
以下是一个日志中间件的实现：
// log.middleware.ts import {Injectable, NestMiddleware} from '@nestjs/common'; import {Request, Response} from 'express'; @Injectable() export class LogMiddleware implements NestMiddleware { use(req: Request, resp: Response, next: Function) { console.log(`${req.method} ${req.path}`) next(); } } // app.module.ts import { Module, NestModule, MiddlewareConsumer } from '@nestjs/common'; import { LogMiddleware } from './common/middleware/log.middleware'; import { UserModule } from './user/user.module'; @Module({ imports: [UserModule], }) export class AppModule implements NestModule { configure(consumer: MiddlewareConsumer) { consumer .</div></article><article><div class=blog-card><h3><a href=/2019/08/22/nestjs-module/>NestJs学习之旅(4)——模块系统</a></h3><p><small>2019年8月22日&nbsp;· 270 字&nbsp;· 2 分钟</small><p>本文是NestJs学习之旅的第四篇，讲解模块系统。
模块 NestJs中模块是构建和组织业务单元的基本元素。使用@Module()装饰模块来声明该模块的元信息：
本模块导出哪些服务提供者 本模块导入了哪些依赖模块 本模块提供了哪些控制器 每个NestJs至少有一个跟模块，这个就是app.module.ts定义的。根模块一般不放具体的业务逻辑，具体业务逻辑应该下沉到各个子业务模块去做。
比如我们开发一个商城系统，该系统有以下业务模块：
订单中心 用户中心 支付中心 商品中心 物流中心 那我们可以定义以下的模块结构:
|-- app.module.ts |-- order |-- order.module.ts |-- services |-- order.service.ts |-- controllers |-- order.controller.ts |-- user |-- user.module.ts |-- services |-- user.service.ts |-- controllers |-- user.controller.ts |-- pay |-- pay.module.ts |-- services |-- wepay.service.ts |-- alipay.service.ts |-- pay.service.ts |-- controller |-- pay.controller.ts ... 模块化有以下优点：
业务低耦合 边界清晰 便于排查错误 便于维护 模块声明与配置 @Module()装饰的类为模块类，该装饰器的典型用法如下：
@Module({ providers: [UserService], controllers: [UserController], imports: [OrderModule], exports: [UserService] }) export class UserModule { } 参数名称 说明 proviers 服务提供者列表，本模块可用，可以自动注入 controllers 控制器列表，本模块可用，用来绑定路由访问 imports 本模块导入的模块，如果需要使用到其他模块的服务提供者，此处必须导入其他模块 exports 本模块导出的服务提供者，只有在此处定义的服务提供者才能在其他模块使用 模块重导出 ts中有以下用法：</div></article><article><div class=blog-card><h3><a href=/2019/08/21/nestjs-provider/>NestJs学习之旅(3)——服务提供者</a></h3><p><small>2019年8月21日&nbsp;· 363 字&nbsp;· 2 分钟</small><p>本文是NestJs学习之旅的第三篇，讲解服务提供者。
简介 服务提供者是NestJs一个非常重要的概念，一般来说，被装饰器@Injectable()修饰的类都可以视为服务提供者。服务提供者一般包含以下几种：
Services(业务逻辑) Factory(用来创建提供者) Repository(数据库访问使用) Utils(工具函数) 使用 下文中将以Services来说明服务提供者的具体使用。
典型的MVC架构中其实有一个问题，业务逻辑到底放哪里？
放在控制器，代码复用成了问题，不可能去New一个控制器然后调用方法，控制器方法都是根据路由地址绑定的 放在Model，导致Model层臃肿，Model应该是直接和数据库打交道的，业务逻辑跟数据库的关系并不是强制绑定的，只有业务逻辑涉及到数据查询/存储才会使用到Model层 现阶段比较流行的架构是多添加一个Services层来写业务逻辑，分离Model层不应该做的事情。
// 业务类 user.service.ts @Injectable() export class UserServices { private readonly users: User[] = []; create(user: User) { this.users.push(user); } findAll(): User[] { return this.users; } } // 用户控制器 @Controller('users') export class UserController { constructor(private readonly userService: UserService) {} // 注入UserService @Post() async create(@Body() createUserDTO:CreateUserDTO) { this.userService.create(createUserDTO); } @Get() async findAll() { return this.userService.findAll(); } } 服务提供者的Scope SpringBoot中提供了Scope注解来指明Bean的作用域，NestJs也提供了类似的@Scope()装饰器：</div></article><article><div class=blog-card><h3><a href=/2019/08/20/nestjs-controller/>NestJs学习之旅(2)——控制器</a></h3><p><small>2019年8月20日&nbsp;· 378 字&nbsp;· 2 分钟</small><p>本文是NestJs学习之旅的第二篇，主要讲解控制器。
MVC 说到控制器就不得不说经典的MVC架构。
MVC模式（Model–view–controller）是软件工程中的一种软件架构模式，把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）。
控制器（Controller）- 负责转发请求，对请求进行处理，处理完毕后输出响应。 视图 （View） - 界面设计人员进行图形界面设计 模型 （Model）- 数据库查询和业务逻辑 可以看到控制器起着承上启下的作用，是Web开发中必备的一环，视图和模型倒不是必须的，理由如下：
API项目直接输出JSON数据，无需渲染页面 无数据库或者复杂业务逻辑的项目时可以把请求处理直接在控制器完成 路由 控制器的目的是接收应用程序的特定请求。基于路由机制来实现请求的分发。通常，每个控制器具有多个路由，并且不同的路由可以执行不同的动作。
为了创建一个基本的控制器，我们使用类和装饰器。装饰器将类与所需的元数据相关联，并使Nest能够创建路由映射（将请求绑定到相应的控制器）。
控制器定义 使用@Controller装饰器来定义控制器，传入一个可选的路由前缀可以将该控制器绑定到该前缀。
import { Controller, Get } from '@nestjs/common'; @Controller('cats') export class CatsController { @Get('list') findAll(): string { return 'This action returns all cats'; } @Get('show') fineOne(): string { return 'one cat'; } @Get() index():string { return 'index'; } } 以上例程会生成以下路由：
GET /cats/list CatsController::findAll方法处理 GET /cats/show CatsController::show方法处理 GET /cats CatsController::index方法处理 上述例程使用的是@Get装饰器，所以只能处理GET请求，以下是支持的请求方法与对应的装饰器</div></article><article><div class=blog-card><h3><a href=/2019/08/19/nestjs-get-started/>NestJs学习之旅(1)——快速开始</a></h3><p><small>2019年8月19日&nbsp;· 179 字&nbsp;· 1 分钟</small><p>本文是NestJs学习之旅的第一篇，简要介绍一下NestJs框架，搭建一个Hello World应用。
介绍 Nest（或NestJS）是一个用于构建高效，可扩展的Node.js服务器端应用程序的框架。它使用渐进式JavaScript，内置并完全支持TypeScript（但仍然允许开发人员使用纯JavaScript编写代码）并结合了OOP（面向对象编程），FP（功能编程）和FRP（功能反应编程）的元素。
import { Controller, Get } from '@nestjs/common'; @Controller('cats') export class CatsController { @Get() findAll(): string { return 'This action returns all cats'; } } 熟悉Java的同学应该有似曾相识的感觉，SpringBoot中大量使用注解来简化开发。现在，使用基于ES6装饰器构建的NestJs框架，你也可以做到!
优缺点 先说说优点吧：
完美支持Typescript，因此可以使用日益繁荣的TS生态资源 兼容express中间件，降低造轮子成本 完美支持响应式编程框架rxjs 完美支持依赖注入 模块化思想，方便开发以及后期维护 使用装饰器简化开发，减少样板代码 组件化设计，解决Node.js无全栈框架约束的现存问题 当然，&ldquo;缺点"也是有点的，不过熟练之后这些都不是缺点：
基于TS导致的语言门槛 代码设计上对模块化/组件化思想有一定要求 第一个NestJs应用 使用NestJs的命令行工具，可以简化项目的创建以及项目文件的创建。
npm install -g @nestjs/cli安装命令行工具 nest new 项目名称初始化项目 初始化完毕后可以看到一个完整的项目结果，目录如下(忽略node_modules)：
├── README.md 自述文件 ├── nest-cli.json NestJs项目配置 ├── package.json npm文件 ├── src 项目源码 │ ├── app.controller.spec.ts 控制器测试文件 │ ├── app.controller.ts 控制器类 │ ├── app.</div></article><article><div class=blog-card><h3><a href=/2019/08/06/typescript-quick-guide4/>TS简明教程(4)</a></h3><p><small>2019年8月6日&nbsp;· 295 字&nbsp;· 2 分钟</small><p>本文是TS简明教程的第四篇，讲解装饰器。
装饰器 装饰器是一种特殊类型的声明，它能够被附加到类声明，方法，访问符，属性或参数上。 装饰器使用@expression这种形式，expression必须是一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入。
Typescript中的装饰器是一项实验性功能，需要在tsconfig.json中开启该特性
{ "compilerOptions": { "experimentalDecorators": true } } 例如，有一个@sealed装饰器，我们这样定义sealed:
function sealed(target: any) { // 操作被装饰对象 } 装饰器工厂 如果需要给装饰器添加一些动态行为，比如开发一个监控统计的装饰器，需要传入当前统计的事件名称，有多个事件名称时只需要变更传入的事件名而不用重复定义装饰器。
这时候需要使用到装饰器工厂。装饰器工厂也是一个函数，只不过它的返回值是一个装饰器。例如如下的事件监控装饰器：
function event(eventName: string) { return function(target: any) { // 获取到当前eventName和被装饰对象进行操作 } } 装饰器组合 多个装饰器可以同时应用到被装饰对象上，例如下面的例子：
@sealed @test('test') class Demo { } 装饰器执行顺序：
装饰器工厂需要先求值，再装饰，求值顺序是由上到下 装饰器可以直接求值，装饰顺序是由下到上 上面的说明可以难以理解，下面举一个实际的例子：
function f() { console.log('f求值'); return function(target: any) { console.log('f装饰'); } } function g() { console.log('g求值'); return function(target: any) { console.log('g装饰'); } } @f() @g() class Demo { } 上例的执行顺序为</div></article></div><div class=paginator><a class=prev href=/categories/engineering/page/4/>&larr;&nbsp;&nbsp;Pre Page</a>
<a class=next href=/categories/engineering/page/6/>Next Page&nbsp;&nbsp;&rarr;</a></div></div></div></div><footer class=footer><p>&copy; 2014 - 2024 <a href=https://www.ddhigh.com/>Lei Xia</a>
Powered by
<a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>
<a href=https://github.com/guangzhengli/hugo-theme-ladder rel=noopener target=_blank>Ladder</a>
️</p></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.5376 22.7916C11.0152 22.7207 22.5795 21.1781 22.0978 10.4211 22.0536 9.43274 21.9303 8.53367 21.7387 7.71865M10.5376 22.7916C16.876 22.3728 20.0969 19.8899 21.5383 16.9142M10.5376 22.7916C9.7707 22.9055 8.97982 22.8964 8.19743 22.7725M21.7387 7.71865C21.4988 6.69828 21.1518 5.80967 20.7188 5.04257m1.0199 2.67608C22.6022 10.1105 23.0542 13.7848 21.5383 16.9142M20.7188 5.04257c-3.5504-6.28886-12.88753-4.410077-16.44303.0C2.88063 6.77451-.0433281 11.1668 1.38159 16.6571c.89322 3.4417 3.7911 5.6365 6.81584 6.1154M20.7188 5.04257c1.3509 1.89783 3.3111 6.34223 1.6353 10.37273M21.5383 16.9142C21.8737 16.4251 22.1428 15.9235 22.3541 15.4153M8.19743 22.7725C12.1971 23.4683 20.6281 22.971 22.3541 15.4153M14 10.945C13.3836 10.289 12.003 8.63215 11.2034 7.04814 11.1703 6.98257 11.0247 6.98456 10.9937 7.05061 10.5221 8.05496 9.07362 9.92941 8 10.945m3.0333-3.50056C10.9392 9.86549 11 15 12 17" stroke="currentcolor" stroke-linecap="round"/></svg>
</a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function n(){t.innerHTML="Copied",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)}),e.parentNode.appendChild(t)})</script></main></body><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script><script>const images=Array.from(document.querySelectorAll(".blog-content img"));images.forEach(e=>{mediumZoom(e,{margin:10,scrollOffset:40,container:null,template:null,background:"rgba(0, 0, 0, 0.5)"})})</script><script src=/main.min.6bb26b69159420159c74dc9e097b06a578ed2b68c701466a91a44a9632d851bd0af167a1b30012387b4c512b48ad9ad4d3394e04d77ae38d57e1920fe4ed34fe.js integrity="sha512-a7JraRWUIBWcdNyeCXsGpXjtK2jHAUZqkaRKljLYUb0K8WehswASOHtMUStIrZrU0zlOBNd6441X4ZIP5O00/g==" crossorigin=anonymous defer></script></html>