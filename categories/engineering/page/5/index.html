<!doctype html><html lang=en><head><meta name=viewport content="width=device-width,initial-scale=1"><title>Engineering</title>
<meta charset=utf-8><meta name=description content="Ladder@Learning & Writing & Sharing"><meta name=author content="Lei Xia"><link rel=canonical href=https://www.ddhigh.com/categories/engineering/><link rel=alternate type=application/rss+xml href=https://www.ddhigh.com/index.xml title="Lei Xia"><script async defer data-website-id=865c8529-0729-4cf5-88a9-448616abbcbb src=https://umami-beta-peach.vercel.app/xialeistudio></script><meta property="og:title" content="Engineering"><meta property="og:description" content="Learning & Writing & Sharing"><meta property="og:type" content="website"><meta property="og:url" content="https://www.ddhigh.com/categories/engineering/"><meta name=twitter:card content="summary"><meta name=twitter:title content="Engineering"><meta name=twitter:description content="Learning & Writing & Sharing"><link rel=icon href=/img/favicon.ico sizes=16x16><link rel=apple-touch-icon href=/img/favicon.ico><link rel=manifest href=/img/favicon.ico><link rel=stylesheet href=https://cdn.staticfile.org/lxgw-wenkai-webfont/1.6.0/style.css><link rel=stylesheet href=/css/main.min.ff1bc260fafbfb440e10194d7d06d57eb5e85eed11d12d06255581262664204e.css integrity="sha256-/xvCYPr7+0QOEBlNfQbVfrXoXu0R0S0GJVWBJiZkIE4=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/highlight/github-dark.min.min.66034289ee9a113219a2c4aae0a8bd2095ab255c832a42efcf5863f10814e7a1.css><script src=/js/highlight.min.min.894ca9c68afab956438c4926a0dc7f5293e04e08595bd27abdb123e94801f684.js></script><script>hljs.highlightAll()</script><script>(()=>{var t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,e=localStorage.getItem("theme");t&&e===null&&(localStorage.setItem("theme","dark"),document.documentElement.setAttribute("data-dark-mode","")),t&&e==="dark"&&document.documentElement.setAttribute("data-dark-mode",""),e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script></head><body><main class=wrapper><nav class=navigation><section class=container><a class=navigation-brand href=/>HOME
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><span></span><span></span><span></span></label><ul class=navigation-list id=navigation-list><li class="navigation-item navigation-menu"><a class=navigation-link href=/archives>Archive</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/tags>Tags</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/books>Books</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/guestbook>Guestbook</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class="navigation-item navigation-social"><a class=navigation-link href=https://github.com/xialeistudio><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li class="navigation-item navigation-dark"><button id=mode type=button aria-label="toggle user light or dark theme">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span><span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></li></ul></section></nav><div id=content><div class=blog-wrapper><div><div class=blog-list><article><div class=blog-card><h3><a href=/2019/10/28/symbol/>深入浅出ES6的Symbol类型</a></h3><p><small>October 28, 2019&nbsp;· 252 words&nbsp;· 2 min</small><p>本文内容 JS基本数据类型种类 Symbol的主要用法, 全局Symbol的使用与检测 Symbol与其他基本类型转换时的规则 ES6引入了一种新的原始数据类型，表示独一无二的值，最大的用处是作为对象属性的唯一标识符。
至此，Javascript拥有6种基本数据类型和一种复杂数据类型。
数据类型 基本类型
string number boolean undefined null symbol 复杂类型
object 用法 基本语法 Symbol([description]) description 可选的描述，一般用在调试的时候作为区分，但是 不能用来访问Symbol。 该方法返回一个symbol值 let s = Symbol('test'); let s2 = Symbol('test'); let s3 = new Symbol('test'); // TypeError console.log(s === s2); // false console.log(typeof s); // symbol console.log(s.description); // test 每次调用Symbol()返回的值都是独一无二的，不管描述是否一致。 Symbol不支持new调用 通过description属性可以获取到传入Symbol的描述性字符串 全局单例的Symbol 使用Symbol.for()可以创建全局单例的symbol值，语法如下：
Symbol.for([name]) name 可选的描述，建议传入，否则name会作为undefined传入 类似于单例模式，执行环境(一般是浏览器)内部维护了一个全局Symbol注册表，记录name和Symbol(name)关系 尝试通过name在该注册表查找对应symbol值，如果找到，则返回这个symbol值 如果没找到，则使用Symbol(name)创建一个symbol值，并记录该symbol值与name的关联关系，之后返回该symbol const name = Symbol('name'); const name2 = Symbol.for('name'); const name3 = Symbol.</div></article><article><div class=blog-card><h3><a href=/2019/10/22/let-and-const/>不只是块级作用域，你不知道的let和const</a></h3><p><small>October 22, 2019&nbsp;· 171 words&nbsp;· One minute</small><p>ES6新增了两个重要的关键字let和const，相信大家都不陌生，但是包括我在内，在系统学习ES6之前也只使用到了【不存在变量提升】这个特性。
let声明一个块级作用域的本地变量 const语句声明一个块级作用域的本地常量，不可以重新赋值 支持块级作用域 var定义的变量会提升到整个函数作用域内，let/const则支持块级作用域。
块级作用域: 由{}包裹的作用域（函数那种{}不算）
来看一个var的例子:
{ var a = 1; } console.log(a); 此时输出1，因为var没有块级作用域。
来看一个let的例子(const效果一样):
{ let a = 1; } console.log(a); 此时会报错ReferenceError，因为let/const支持块级作用域，所以let定义的a只在{}可以访问
不存在变量提升 与var不同的是，let/const声明的变量不存在变量提升，也就是说{}对于let/const是有效的。
来看一个var的例子:
console.log(a); var a = 1; 此时会输出undefined，因为var声明的变量会提升到作用域顶部（只提升声明，不提升赋值）
来看一个let的例子(const效果也一样):
console.log(a); let a = 1; 此时会报错ReferenceError，因为let不存在变量提升
同一作用域内不可以重复声明 同一作用域内let/const不可以重复声明,var可以。
来看一个var的例子:
var a = 1; var a = 2; console.log(a); 此时会输出2，var是支持重复声明的，后面声明的值会覆盖前面声明的值。
来看一个let的例子(const效果也一样):
let a = 1; let a = 2; console.log(a); 此时会报错SyntaxError，因为同一作用域内let/const不可以重复声明。
再来看一个不同作用域的例子：
let a = 1; { let a = 2; } console.</div></article><article><div class=blog-card><h3><a href=/2019/10/15/valueof-and-tostring/>聊一聊valueOf和toString</a></h3><p><small>October 15, 2019&nbsp;· 407 words&nbsp;· 2 min</small><p>valueOf和toString是Object.prototype的方法。一般很少直接调用，但是在使用对象参与运算的时候就会调用这两个方法了。我想大部分人都存在以下疑问：
valueOf和toString哪个优先级较高? 是不是所有场景都会调用valueOf和toString 概念解释 valueOf: 返回对象的原始值表示 toString: 返回对象的字符串表示 在介绍下面的内容之前先了解一下转换规则，下面的内容解释都是基于这个规则表来的：
valueOf转换规则 valueOf是Object.prototype的方法，由Object来的对象都会有该方法，但是很多内置对象会重写这个方法，以适合实际需要。
说到原始值就必须说到原始类型，JS规范中 原始类型 如下：
Boolean Null Undefined Number String 非原始值(也就是对象)重写规则如下：
对象 valueOf返回值 Array 数组本身 Boolean 布尔值 Date 返回毫秒形式的时间戳 Function 函数本身 Number 数字值 Object 对象本身 String 字符串值 以下规则是经过验证的，如果对验证过程不关心，可以只看转换规则。
建议看一下验证过程，这样可以加深理解
对象转换为布尔值 直接转换为true（包装类型也一样），不调用valueOf和toString 对象转换为数字 在预期会将对象用作数字使用时，比如参与算术运算等等操作，对象转换为数字会依次调用valueOf和toString方法，具体规则如下：
如果对象具有valueOf方法且返回原始值(string、number、boolean、undefined、null)，则将该原始值转换为数字(转换失败会返回NaN)，并返回这个数字 如果对象具有toString方法且返回原始值(string、number、boolean、undefined、null)，则将该原始值转换为数字(转换失败会返回NaN)，并返回这个数字 转换失败，抛出TypeError 对象转换为字符串 如果对象具有toString方法且返回原始值(string、number、boolean、undefined、null)，则将该原始值转换为字符串，并返回该字符串 如果对象具有valueOf方法且返回原始值(string、number、boolean、undefined、null)，则将该原始值转换为字符串，并返回该字符串 转换失败，抛出TypeError toString转换规则 对象 toString返回值 Array 以逗号分割的字符串，如[1,2]的toString返回值为"1,2" Boolean &ldquo;True&rdquo; Date 可读的时间字符串，如"Tue Oct 15 2019 12:20:56 GMT+0800 (中国标准时间)" Function 声明函数的JS源代码字符串 Number &ldquo;数字值&rdquo; Object &ldquo;[object Object]&rdquo; String &ldquo;字符串&rdquo; 验证对象到原始值的转换 光看valueOf和toString没啥东西可说，日常开发中也很少直接调用，但是当我们将对象当做原始值来使用时会发生转换，而且转换过程还略微有点迷糊。</div></article><article><div class=blog-card><h3><a href=/2019/10/14/js-closure/>搞懂JS闭包</a></h3><p><small>October 14, 2019&nbsp;· 198 words&nbsp;· One minute</small><p>闭包(Closure)是JS比较难懂的一个东西，或者说别人说的难以理解， 本文将以简洁的语言+面试题来深入浅出地介绍一下。
作用域和作用域链 在将闭包之前，需要先讲一下作用域。
JS中有全局作用域和局部作用域两种。
全局作用域任何地方都能访问，而局部作用于只有内部能访问。
function a() { var num = 1; } console.log(num); 在上面的例子中会报错，num不存在。
总结：函数外部无法访问函数内部的值
当代码在一个作用域中执行时，JS引擎会默认创建一个作用域链(从当前作用域一直链接到全局作用域)。
在访问变量或者函数时，如果当前作用域查找不到，则向上级作用域查找，找到就返回，如果查找到全局作用域还没找到的话就报错。
function a() { var num = 1; function b() { console.log(num); } } 在上面的例子中，num是在a函数作用域下的局部变量，我们在b函数访问num时会有以下过程：
在b的作用域查找num，发现找不到 往上一级作用域查找，发现num在a作用域，查找成功 总结：函数可以访问同级或上级作用域的值
闭包 当我们需要在函数外部访问函数内部的值时，闭包就产生了。
function a() { var num = 1; function b () { console.log(num); } return b; } var bb = a(); bb(); // 1 在函数a的内部声明一个函数b，然后把return b，这个时候的b()函数就可以在外部访问，最终能够访问到num。
简单来说：
闭包就是函数内部的函数，上面的那个b就是闭包，可以在外面访问到内部的num
面试题 // 每隔1秒输出0-10的数字 for(var i = 0;i&lt;10;i++) { setTimeout(function() { console.</div></article><article><div class=blog-card><h3><a href=/2019/10/11/https-protocol/>HTTPS协议是如何保证安全的?</a></h3><p><small>October 11, 2019&nbsp;· 89 words&nbsp;· One minute</small><p>相信大家对于HTTPS协议都不陌生，但是应该存在以下疑问：
HTTPS协议到底是如何运作的?
HTTPS是如何解决HTTP协议的不安全特性的?
HTTPS网站抓包为什么要信任证书?
HTTP协议 HTTP协议是一个应用层协议，通常运行在TCP协议之上。它是一个明文协议，客户端发起请求，服务端给出响应的响应。
由于网络并不是可信任的，HTTP协议的明文特性会存在以下风险：
通信数据有被窃听和被篡改的风险 目标网站有被冒充的风险 一般的网站可能没什么影响，但是如果是银行这种网站呢?
好在国内的银行在HTTP协议时代针对IE开发了ActiveX插件来保证安全性，这一点算是值得点赞了。
解决方案 既然HTTP协议是明文协议，如果对数据进行加密之后是否就能保证安全性了呢?
在回答这个问题之前，我们先看看比较常见的两种加密算法。
加密算法 常见的有对称加密算法和非对称加密算法。
对称加密
加密和解密使用同一个密钥。加解密效率比非对称加密高。但是密钥一旦泄露，通信就不安全了
非对称加密
存在密钥对，公钥加密私钥解密或者私钥加密公钥解密，无法通过公钥反推私钥，也无法通过私钥反推公钥。
一般情况下，使用非对称加密来传输通信所用的密钥，通信过程中采用对称加密，可以解决对称加密的安全问题以及非对称加密的性能问题。
HTTP加密通信过程 浏览器生成随机串A作为通信密钥 浏览器使用公钥将随机串A加密后得到密文B发送给服务器，这一步是安全的，因为黑客没有服务端私钥无法解密 服务端利用私钥解密出随机串A得到通信密钥 服务端和客户端用随机串A以及对称加密算法进行通信 这么一看似乎没有问题，毕竟黑客无法破解非对称加密的的内容，但是浏览器是如何得到公钥的?
有以下两种办法：
浏览器内置(不太可能，网站域名这么多，浏览器内置这么多公钥不现实) 服务器给浏览器下发(由于是明文下发，存在被窃听和篡改风险，也就是著名的中间人攻击) 中间人攻击 浏览器请求服务器获取公钥 中间人劫持了服务器的公钥，保存在自己手里 中间人生成一对密钥对，把伪造的公钥下发给浏览器 浏览器使用伪造的公钥和中间人通信 中间人和服务器进行通信 由于浏览器使用了伪造的公钥进行通信，所以通信过程是不可靠的
需要解决的问题 只要保证浏览器得到的公钥是目标网站的公钥即可保证通信安全，那么问题来了，如何在不可靠的网络上安全的传输公钥呢?
这就是HTTPS协议需要解决的问题
HTTPS协议 HTTPS协议涉及到的知识很多，本文只关注密钥安全交换部分，这也是HTTPS协议的精华。
HTTPS协议引入了CA和数字证书的概念。
数字证书 包含签发机构、有效期、申请人公钥、证书所有者、证书签名算法、证书指纹以及指纹算法等信息。
CA 数字证书签发机构，权威CA是受操作系统信任的，安装操作系统就会内置。
数字签名 用Hash算法对数据进行计算得到Hash值，利用私钥对该Hash加密得到签名。
只有匹配的公钥才能解密出签名，来保证签名是本人私钥签发的
证书签发过程 网站生成密钥对，将私钥自己保存，公钥和网站域名等信息提交给CA CA把证书签发机构(也就是自己)、证书有效期、网站的公钥、网站域名等信息以明文形式写入到一个文本文件 CA选择一个指纹算法(一般为hash算法)计算文本文件的内容得到指纹，用CA的私钥对指纹和指纹算法进行加密得到数字签名，签名算法包含在证书的明文部分 CA把明文证书、指纹、指纹算法、数字签名等信息打包在一起得到证书下发给服务器 此时服务器拥有了权威CA颁发的数字证书以及自己的私钥 证书验证过程 浏览器是如何验证网站的有效性的呢?
浏览器以HTTPS协议请求服务器的443端口 服务器下发自己的数字证书给浏览器(明文) 浏览器先校验CA、有效期、域名是否有效，如果无效，则终止连接(服务器此时不可信任) 如果有效，则从操作系统取出证书颁发机构的公钥，根据签名算法对数字签名解密得到证书指纹和指纹算法 浏览器用解密得到的指纹算法计算证书的指纹，与解密得到的指纹进行比对，如果一致，证书有效，公钥也安全拿到了 浏览器此时已经和真实的服务器进行通信了，中间人无法得知通信内容，因为中间人没有网站私钥 问题是如何解决的 黑客冒充CA给了一个假证书给浏览器
浏览器通过CA名称从操作系统取出CA公钥时对数字签名进行解密，发现解密失败，证明这个CA签名用的私钥和操作系统内置的不是一对，就发现了伪造
黑客篡改了证书中的网站公钥
证书中的网站公钥可以被篡改，但是数字签名是CA私钥计算出来的，黑客无法计算数字签名，浏览器用内置的CA公钥对数字签名解密时就会发现指纹不匹配了，这也发现了伪造
黑客也能正常获取网站公钥</div></article><article><div class=blog-card><h3><a href=/2019/09/27/javascript-this/>Javavscript基础——this指向</a></h3><p><small>September 27, 2019&nbsp;· 374 words&nbsp;· 2 min</small><p>本文研究一下Javascript的this指向。
Javascript的this指向问题，有些人可能觉得很简单，有些人却觉得扑朔迷离，看完本文之后相应会对this的掌握有一个直观的判断，而不是"开局全靠猜"。
敲黑板 function函数this指向由调用方式确定，跟定义环境无关。
箭头函数this指向由定义环境决定，与调用方式无关，也不可以bind(this)。
严格模式 非严格模式下，全局作用域下的this指向window
严格模式下，全局作用域下的this指向undefined
以下讨论均为非严格模式，这个不影响今天的讨论。
实践 说结论往往是让人难以理解的，下面通过不同的调用场景对this做一个说明。
1. 直接调用 function test() { console.log(this); } test(); // 输出undefined 直接调用是最简单的， 大部分人在这里都能回答的很好。
总结 直接调用时this指向全局作用域。
非严格模式this指向window 严格模式this指向undefined 2. 对象调用 'use strict' var n = 1; var a = { n: 2, b: function() { console.log(this.n); } }; a.b(); // 输出2 var b = a.b; b(); // 输出1 面试题：请问上述例子输出什么? 非严格模式下，输出2和1，严格模式下输出2和一个报错(this指向undefined，访问undefined的n属性肯定报错)
那如果你这么回答，满分!
分析 知其然还要知其所以然，我们分析一下：
为什么输出2?
因为a.b()是对象调用方式，所以b()中的this指向a
为什么输出1?
这个非常有意思，而且也很有迷惑性，面试的时候经常问到，也经常有人被问倒。
var b = a.b 把a.</div></article><article><div class=blog-card><h3><a href=/2019/09/23/javascript-prototype/>Javavscript基础——原型和原型链</a></h3><p><small>September 23, 2019&nbsp;· 289 words&nbsp;· 2 min</small><p>本文研究一下Javascript的核心基础——原型链和继承。
对于使用过基于类的语言(如Java或C#)的人来说，Javascript的继承有点难以搞懂，因为它本身没有class这种东西。(ES6中引入了class关键字，看上去也像传统的OOP语言，但是那只是语法糖，底层还是基于原型)。
原型链 MDN上对于原型链的解释：
当谈到继承时，JavaScript 只有一种结构：对象。每个实例对象（ object ）都有一个私有属性（称之为 __proto__ ）指向它的构造函数的原型对象（prototype ）。该原型对象也有一个自己的原型对象( __proto__ ) ，层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节。
几乎所有 JavaScript 中的对象都是位于原型链顶端的 Object 的实例。
这段话可能难以理解，我们来举个例子：
const list = []; // 定义数组 list.__proto__ === Array.prototype; // true list.__proto__.__proto__ === Object.prototype; // true list.__proto__.__proto__.__proto__===null; // true // 继承关系为 // list -> Array.prototype -> Object.prototype -> null 结合MDN的解释，我们来解释一下上述例子：
list是Array的实例对象，使用了字面量的方式创建了对象实例。
每个实例对象（ object ）都有一个私有属性（称之为 __proto__ ）指向它的构造函数的原型对象（prototype ）。
// list的构造函数是Array，所以list.__proto__指向构造函数Array的原型对象。 list.__proto__ === Array.prototype; // true 该原型对象也有一个自己的原型对象( __proto__ )
// Array.</div></article><article><div class=blog-card><h3><a href=/2019/09/17/javascript-var-scope/>搞懂JS变量提升</a></h3><p><small>September 17, 2019&nbsp;· 107 words&nbsp;· One minute</small><p>本文讲解Javascript变量提升引起的问题以及如何规避。
问题 今天看到一道有意思的面试题，考察的还真是JS的基本功，题目如下：
var name = "world"; (function(){ if(typeof name === "undefined") { var name = "Jack"; console.log("Hello " + name); } else { console.log("Hello " + name); } }()); 根据if条件可以得出可能的答案：
Hello world Hello Jack 正确答案 答案是Hello Jack，但是答案怎么来的，回答不好可能还是只能打50分，有以下两种理解：
理解1：
立即执行函数有独立的作用域，访问不到外部name，所以if判断成立，输出 Hello Jack
这个理解是不正确的。虽然函数隔离了作用域，但是由于作用域链的关系，JS会从当前作用域一直往上级查找，直到顶级作用域（浏览器环境为window）。
如下代码输出Hello world
var name = "world"; (function(){ console.log("Hello " + name); }()); 理解2：
var存在变量提升，所以if在判断的时候name确实为undefined，走了if分支，输出 Hello Jack
变量提升 MDN对变量提升的解释：
“变量提升”意味着变量和函数的声明会在物理层面移动到代码的最前面，但这么说并不准确。实际上变量和函数声明在代码里的位置是不会动的，而是在编译阶段被放入内存中。
JavaScript 仅提升声明，而不提升初始化 函数和变量相比，会被优先提升 根据变量提升理论我们可以“模拟”JS实际执行代码的过程：
var name = "world"; (function(){ var name; // 变量提升，仅提升声明，不提升初始化 if(typeof name === "undefined") { name = "Jack"; console.</div></article><article><div class=blog-card><h3><a href=/2019/09/10/nestjs-interceptor/>NestJs学习之旅(9)——拦截器</a></h3><p><small>September 10, 2019&nbsp;· 405 words&nbsp;· 2 min</small><p>本文是NestJs的第九篇，讲解拦截器。
拦截器是一个实现了NestInterceptor接口且被**@Injectable**装饰器修饰的类。
拦截器是基于AOP编程思想的一种应用，以下是常用的功能：
在方法执行之前或之后执行额外的逻辑，这些逻辑一般不属于业务的一部分 转换函数执行结果 转换函数执行时抛出的异常 扩展函数基本行为 特定场景下完全重写函数的行为（比如缓存拦截器，一旦有可用的缓存则直接返回，不执行真正的业务逻辑，即业务逻辑处理函数行为已经被重写） 拦截器接口 每个拦截器都需要实现NestInterceptor接口的**intercept()**方法，该方法接收两个参数。方法原型如下：
function intercept(context: ExecutionContext, next: CallHandler): Observable&lt;any> ExecutionContext 执行上下文，与NestJs学习之旅(7)——路由守卫中的执行上下文相同 CallHandler 路由处理函数 CallHandler 该接口是对路由处理函数的抽象，接口定义如下：
export interface CallHandler&lt;T = any> { handle(): Observable&lt;T>; } handle()函数的返回值也就是对应路由函数的返回值。
以获取用户列表为例：
// user.controller.ts @Controller('user') export class UserController { @Get() list() { return []; } } 当访问 /user/list 时，路由处理函数返回**[]**，如果在应用拦截器的情况下，调用CallHandler接口的handle()方法得到的也是Observable&lt;[]>(RxJs包装对象)。
所以，如果在拦截器中调用了next.handle()方法就会执行对应的路由处理函数，如果不调用的话就不会执行。
一个请求链路日志记录拦截器 随着微服务的兴起，原来的单一项目被拆分成多个比较小的子模块，这些子模块可以独立开发、独立部署、独立运行，大大提高了开发、执行效率，但是带来的问题也比较多，一个经常遇到的问题是接口调用出错不好查找日志。
如果在业务逻辑中硬编码这种链路调用日志是非常不可取的，严重违反了单一职责的原则，这在微服务开发中是相当不好的一种行为，会让微服务变得臃肿，这些逻辑完全可以通过拦截器来实现。
// app.interceptor.ts import { CallHandler, ExecutionContext, Injectable, Logger, NestInterceptor } from '@nestjs/common'; import { Observable } from 'rxjs'; import { tap } from 'rxjs/operators'; import { Request } from 'express'; import { format } from 'util'; @Injectable() export class AppInterceptor implements NestInterceptor { private readonly logger = new Logger(); // 实例化日志记录器 intercept(context: ExecutionContext, next: CallHandler): Observable&lt;any> { const start = Date.</div></article><article><div class=blog-card><h3><a href=/2019/08/28/nestjs-pipe/>NestJs学习之旅(8)——管道</a></h3><p><small>August 28, 2019&nbsp;· 387 words&nbsp;· 2 min</small><p>本文是NestJs学习之旅的第八篇，讲解管道。
管道 熟悉Linux命令的伙伴应该对“管道运算符”不陌生。
ls -la | grep demo &ldquo;|&rdquo; 就是管道运算符，它把左边命令的输出作为输入传递给右边的命令，支持级联，如此一来，便可以通过管道运算符进行复杂命令的交替运算。
NestJs中的管道有着类似的功能，也可以级联处理数据。NestJs管道通过**@Injectable()装饰器装饰，需要实现PipeTransform**接口。
NestJs中管道的主要职责如下：
数据转换 将输入数据转换为所需的输出 数据验证 接收客户端提交的参数，如果通过验证则继续传递，如果验证未通过则提示错误 执行顺序 在前面的文章中我们讨论了中间件、控制器、路由守卫，结合本问讨论的管道，可能有些读者会对这些组件的执行顺序提出疑问：这些东西执行的顺序到底是怎样的？
执行顺序也不用找资料，自己在这些组件执行时加上日志即可，我得出的结论如下：
客户端请求 -> 中间件 -> 路由守卫 -> 管道 -> 控制器方法
开发管道 数据转换类的管道就不详细解释了：
给你一个value和元数据，你的return值就是转换后的值。
NestJs内置了ValidationPipe、ParseIntPipe和ParseUUIDPipe。为了更好地理解它们的工作原理，我们以ValidationPipe（验证器管道）为例来演示管道的使用。
PipeTransform 这是管道必须实现的接口，该接口定义如下：
export interface PipeTransform&lt;T = any, R = any> { transform(value: T, metadata: ArgumentMetadata): R; } value 输入参数，T为输入参数类型 metadata  value的元数据，包括参数来源，参数类型等等 输出参数，R为输出参数类型 ArgumentMetadata 用来描述当前处理value的元数据接口，接口定义如下：
export interface ArgumentMetadata { readonly type: 'body' | 'query' | 'param' | 'custom'; readonly metatype?</div></article></div><div class=paginator><a class=prev href=/categories/engineering/page/4/>&larr;&nbsp;&nbsp;Pre Page</a>
<a class=next href=/categories/engineering/page/6/>Next Page&nbsp;&nbsp;&rarr;</a></div></div></div></div><footer class=footer><p>&copy; 2014 - 2023 <a href=https://www.ddhigh.com>Lei Xia</a>
Powered by
<a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>
<a href=https://github.com/guangzhengli/hugo-theme-ladder rel=noopener target=_blank>Ladder</a>
<a href=https://umami-beta-peach.vercel.app/ target=_blank>Statistics</a>
️</p></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.5376 22.7916C11.0152 22.7207 22.5795 21.1781 22.0978 10.4211 22.0536 9.43274 21.9303 8.53367 21.7387 7.71865M10.5376 22.7916C16.876 22.3728 20.0969 19.8899 21.5383 16.9142M10.5376 22.7916C9.7707 22.9055 8.97982 22.8964 8.19743 22.7725M21.7387 7.71865C21.4988 6.69828 21.1518 5.80967 20.7188 5.04257m1.0199 2.67608C22.6022 10.1105 23.0542 13.7848 21.5383 16.9142M20.7188 5.04257c-3.5504-6.28886-12.88753-4.410077-16.44303.0C2.88063 6.77451-.0433281 11.1668 1.38159 16.6571c.89322 3.4417 3.7911 5.6365 6.81584 6.1154M20.7188 5.04257c1.3509 1.89783 3.3111 6.34223 1.6353 10.37273M21.5383 16.9142C21.8737 16.4251 22.1428 15.9235 22.3541 15.4153M8.19743 22.7725C12.1971 23.4683 20.6281 22.971 22.3541 15.4153M14 10.945C13.3836 10.289 12.003 8.63215 11.2034 7.04814 11.1703 6.98257 11.0247 6.98456 10.9937 7.05061 10.5221 8.05496 9.07362 9.92941 8 10.945m3.0333-3.50056C10.9392 9.86549 11 15 12 17" stroke="currentcolor" stroke-linecap="round"/></svg></a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function n(){t.innerHTML="Copied",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)}),e.parentNode.appendChild(t)})</script></main></body><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script><script>const images=Array.from(document.querySelectorAll(".blog-content img"));images.forEach(e=>{mediumZoom(e,{margin:10,scrollOffset:40,container:null,template:null,background:"rgba(0, 0, 0, 0.5)"})})</script><script src=/main.min.6bb26b69159420159c74dc9e097b06a578ed2b68c701466a91a44a9632d851bd0af167a1b30012387b4c512b48ad9ad4d3394e04d77ae38d57e1920fe4ed34fe.js integrity="sha512-a7JraRWUIBWcdNyeCXsGpXjtK2jHAUZqkaRKljLYUb0K8WehswASOHtMUStIrZrU0zlOBNd6441X4ZIP5O00/g==" crossorigin=anonymous defer></script></html>