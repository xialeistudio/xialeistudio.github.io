<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>Kategorie: backend - Learning &amp; Sharing</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Learning &amp; Sharing"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Learning &amp; Sharing"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Learning &amp;amp; Sharing"><meta property="og:type" content="website"><meta property="og:title" content="Learning &amp; Sharing"><meta property="og:url" content="https://www.ddhigh.com/"><meta property="og:site_name" content="Learning &amp; Sharing"><meta property="og:description" content="Learning &amp;amp; Sharing"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://www.ddhigh.com/img/og_image.png"><meta property="article:author" content="Xia Lei"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://www.ddhigh.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.ddhigh.com"},"headline":"Learning & Sharing","image":["https://www.ddhigh.com/img/og_image.png"],"author":{"@type":"Person","name":"Xia Lei"},"publisher":{"@type":"Organization","name":"Learning & Sharing","logo":{"@type":"ImageObject","url":{"text":"Learning & Sharing"}}},"description":"Learning &amp; Sharing"}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.4.1/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?78141f99bbb49f1564a7af89344f5add";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">Learning &amp; Sharing</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Suche" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">Kategorien</a></li><li class="is-active"><a href="#" aria-current="page">backend</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Gepostet vor&nbsp;<time dateTime="2019-07-25T03:00:00.000Z" title="7/25/2019, 3:00:00 AM">2019-07-25</time></span><span class="level-item"><a class="link-muted" href="/categories/backend/">backend</a><span> / </span><a class="link-muted" href="/categories/backend/nodejs/">nodejs</a></span><span class="level-item">4 minutes lesen (Über 581 Wörter)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/07/25/2019-07-25-nodejs-guide-dgram.html">NodeJs简明教程(10)</a></p><div class="content"><p>本文是NodeJs简明教程的第十篇，将介绍NodeJs <strong>dgram</strong> 模块(<code>UDP服务端/客户端</code>)相关的基本操作。</p>
<h2 id="啥是UDP"><a href="#啥是UDP" class="headerlink" title="啥是UDP"></a>啥是UDP</h2><blockquote>
<p>Internet 协议集支持一个无连接的传输协议，该协议称为用户数据报协议（UDP，User Datagram Protocol）。UDP 为应用程序提供了一种无需建立连接就可以发送封装的 IP 数据报的方法。RFC 768描述了 UDP。</p>
</blockquote>
<p>NodeJs使用<code>dgram模块</code>实现<code>UDP服务端/客户端</code>相关功能。</p>
<p><code>dgram.createSocket</code>用来创建一个Socket对象，可以基于该套接口<code>接收</code>或<code>发送</code>数据。该方法原型如下：</p>
<p><code>dgram.createSocket(type[, callback])</code></p>
<ul>
<li>type <code>&lt;string&gt;</code> socket类型。<code>udp4</code>或<code>udp6</code>，对应<code>ipv4</code>和<code>ipv6</code></li>
<li>callback <code>&lt;Function&gt;</code> 接收到消息时的回调函数</li>
</ul>
<h2 id="Echo服务端开发"><a href="#Echo服务端开发" class="headerlink" title="Echo服务端开发"></a>Echo服务端开发</h2><p>server.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dgram = <span class="built_in">require</span>(<span class="string">&#x27;dgram&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> socket = dgram.<span class="title function_">createSocket</span>(<span class="string">&#x27;udp4&#x27;</span>);</span><br><span class="line"></span><br><span class="line">socket.<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, <span class="keyword">function</span>(<span class="params">err</span>) &#123; <span class="comment">// 监听socket错误</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;服务器错误&#x27;</span>, err);</span><br><span class="line">    socket.<span class="title function_">close</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">socket.<span class="title function_">on</span>(<span class="string">&#x27;message&#x27;</span>,<span class="keyword">function</span>(<span class="params">msg,sender</span>) &#123; <span class="comment">// 监听收到数据</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;%s:%d =&gt; %s&#x27;</span>, sender.<span class="property">address</span>,sender.<span class="property">port</span>,msg.<span class="title function_">toString</span>()); <span class="comment">// 打印该数据包详情</span></span><br><span class="line">    socket.<span class="title function_">send</span>(<span class="string">&#x27;socket: &#x27;</span>+msg.<span class="title function_">toString</span>(),sender.<span class="property">port</span>,sender.<span class="property">address</span>,<span class="keyword">function</span>(<span class="params">err</span>) &#123; <span class="comment">// 发送数据给来源地址</span></span><br><span class="line">        <span class="keyword">if</span>(err) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;回复%s:%d失败: %s&#x27;</span>,sender.<span class="property">address</span>,sender.<span class="property">port</span>,err.<span class="property">message</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">socket.<span class="title function_">bind</span>(<span class="number">10000</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">// 监听UDP端口</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;服务器正在监听 %s:%d&#x27;</span>, socket.<span class="title function_">address</span>().<span class="property">address</span>, socket.<span class="title function_">address</span>().<span class="property">port</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="Echo客户端开发"><a href="#Echo客户端开发" class="headerlink" title="Echo客户端开发"></a>Echo客户端开发</h2><p>由于<code>telnet</code>连接服务器使用的是<code>TCP协议</code>，所以本文对应的客户端需要使用NodeJs开发。</p>
<p>client.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dgram = <span class="built_in">require</span>(<span class="string">&#x27;dgram&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> socket = dgram.<span class="title function_">createSocket</span>(<span class="string">&#x27;udp4&#x27;</span>); <span class="comment">// 创建socket实例</span></span><br><span class="line"></span><br><span class="line">socket.<span class="title function_">on</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span>(<span class="params">msg,sender</span>) &#123; <span class="comment">// 监听收到数据</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;接收到%s:%d的消息:%s&#x27;</span>,sender.<span class="property">address</span>,sender.<span class="property">port</span>,msg.<span class="title function_">toString</span>());</span><br><span class="line">    socket.<span class="title function_">close</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">socket.<span class="title function_">send</span>(<span class="string">&#x27;hello&#x27;</span>,<span class="number">10000</span>,<span class="keyword">function</span>(<span class="params">err</span>) &#123; <span class="comment">// 向目标端口发送数据</span></span><br><span class="line">    <span class="keyword">if</span>(err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;发送错误&#x27;</span>, err);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;发送成功&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h2><ol>
<li><p>终端执行<code>node server.js</code>，输出</p>
 <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">服务器正在监听 0.0.0.0:10000</span><br></pre></td></tr></table></figure></li>
<li><p>终端执行<code>node client.js</code>，输出</p>
 <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">发送成功</span><br><span class="line">接收到127.0.0.1:10000的消息:server: hello</span><br></pre></td></tr></table></figure>
</li>
<li><p>服务端输出:</p>
 <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:50577 =&gt; hello</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>NodeJs UDP服务端与客户端开发到此结束，但是使用UDP的情况下，数据包确认、流量控制等等操作都需要程序员手动完成，这一方面确实挺复杂的，没有什么特殊的要求的话使用TCP即可。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Gepostet vor&nbsp;<time dateTime="2019-07-24T02:23:56.000Z" title="7/24/2019, 2:23:56 AM">2019-07-24</time></span><span class="level-item"><a class="link-muted" href="/categories/backend/">backend</a><span> / </span><a class="link-muted" href="/categories/backend/nodejs/">nodejs</a></span><span class="level-item">6 minutes lesen (Über 878 Wörter)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/07/24/2019-07-24-nodejs-guide-net.html">NodeJs简明教程(9)</a></p><div class="content"><p>本文是NodeJs简明教程的第九篇，将介绍NodeJs <strong>net</strong> 模块(<code>TCP服务端/客户端</code>)相关的基本操作。</p>
<h2 id="啥是TCP"><a href="#啥是TCP" class="headerlink" title="啥是TCP"></a>啥是TCP</h2><blockquote>
<p>传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793 定义。</p>
</blockquote>
<p>NodeJs使用<code>net模块</code>实现<code>TCP服务端/客户端</code>相关功能。</p>
<h2 id="Echo服务器开发"><a href="#Echo服务器开发" class="headerlink" title="Echo服务器开发"></a>Echo服务器开发</h2><blockquote>
<p>Echo服务器就是客户端发送什么，服务端就显示什么的一种服务端程序。主要为了调试网络和协议是否正常工作。</p>
</blockquote>
<p><code>net.createServer</code>用来创建一个服务端，该方法原型如下：</p>
<p><code>net.createServer([options][, connectionlistener]): net.Server</code></p>
<ul>
<li>options <code>&lt;Object&gt;</code><ul>
<li>allowHalfOpen <code>&lt;boolean&gt;</code> 表明是否允许半开的 TCP 连接。默认值: <code>false</code>。</li>
<li>pauseOnConnect <code>&lt;boolean&gt;</code> 表明是否应在传入连接上暂停套接字。默认值: false。</li>
</ul>
</li>
<li>connectionListener <code>&lt;Function&gt;</code> 客户端连接事件监听器。回调参数为<code>Socket(可以视为一个客户端连接)</code></li>
</ul>
<p>返回值为<code>net.Server</code>，<code>net.Server</code>主要方法如下：</p>
<p><code>server.listen([port[, host[, backlog]]][, callback])</code></p>
<ul>
<li>port <code>&lt;number&gt;</code> 监听端口</li>
<li>host <code>&lt;string&gt;</code> 监听主机</li>
<li>backlog <code>&lt;number&gt;</code> 待连接队列的最大长度</li>
<li>callback <code>&lt;Function&gt;</code> 监听成功回调函数</li>
</ul>
<p>server.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">&#x27;net&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = net.<span class="title function_">createServer</span>(<span class="keyword">function</span> (<span class="params">client</span>) &#123; <span class="comment">// 创建服务端</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(client.<span class="title function_">address</span>().<span class="property">address</span>, <span class="string">&#x27;连接成功&#x27;</span>); <span class="comment">// 客户端连接成功时打印客户端地址</span></span><br><span class="line"></span><br><span class="line">    client.<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(client.<span class="title function_">address</span>().<span class="property">address</span>, <span class="string">&#x27; error &gt;&gt; &#x27;</span>, e.<span class="property">message</span>); <span class="comment">// 连接错误时（如客户端异常断开）</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    client.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="keyword">function</span> (<span class="params">data</span>) &#123; <span class="comment">// 收到客户端数据</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(client.<span class="title function_">address</span>().<span class="property">address</span>, <span class="string">&#x27; &gt;&gt; &#x27;</span>, data.<span class="title function_">toString</span>());</span><br><span class="line">        client.<span class="title function_">write</span>(data); <span class="comment">// 往客户端写数据</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    client.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">// 客户端正常断开</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(client.<span class="title function_">address</span>().<span class="property">address</span>, <span class="string">&#x27;断开连接&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123; <span class="comment">// 服务器错误（如启动失败，端口占用）</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;服务器启动失败&#x27;</span>, e);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">10000</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;启动成功，地址&#x27;</span>, server.<span class="title function_">address</span>().<span class="property">address</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol>
<li><p>执行<code>node server.js</code>可以看到输出<code>启动成功，地址xxx</code></p>
</li>
<li><p>打开终端，执行<code>telnet localhost 10000</code>，可以看到输出如下（如果不一样，请加群讨论）：</p>
 <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Trying ::1...</span><br><span class="line">Connected to localhost.</span><br><span class="line">Escape character is &#x27;^]&#x27;.</span><br></pre></td></tr></table></figure>
</li>
<li><p>终端继续输入以下字符：</p>
 <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helloworld</span><br></pre></td></tr></table></figure>
</li>
<li><p>服务端会回复</p>
 <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br></pre></td></tr></table></figure></li>
</ol>
<p>该Echo服务器就开发已经测试通过了。虽然代码量不多，但是演示了从零开始开发一个TCP服务器的流程，相比于C语言开发TCP服务器还是方便很多的。</p>
<h2 id="TCP客户端"><a href="#TCP客户端" class="headerlink" title="TCP客户端"></a>TCP客户端</h2><p><code>net.connect</code>可以连接目标TCP服务器，该方法原型如下：</p>
<p><code>net.connect(port[,host][,connectionListener])</code></p>
<ul>
<li>port <code>&lt;number&gt;</code> 连接端口</li>
<li>host <code>&lt;string&gt;</code> 连接主机</li>
<li>connectionListener <code>&lt;Function&gt;</code> 连接成功的回调</li>
</ul>
<p>还是以刚才监听<code>10000</code>端口的服务端为例来开发客户端</p>
<p>client.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">&#x27;net&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> client = net.<span class="title function_">connect</span>(<span class="number">10000</span>, <span class="string">&#x27;localhost&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">// 连接服务器</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;连接服务器成功&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    client.<span class="title function_">write</span>(<span class="string">&#x27;我是客户端&#x27;</span>); <span class="comment">// 往服务端发送数据</span></span><br><span class="line"></span><br><span class="line">    client.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="keyword">function</span> (<span class="params">data</span>) &#123; <span class="comment">// 接收到服务端数据</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;服务端消息&#x27;</span>, data.<span class="title function_">toString</span>());</span><br><span class="line">        client.<span class="title function_">end</span>(); <span class="comment">// 断开连接</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    client.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">// 连接断开事件</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;服务端连接断开&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>保证服务端开启的情况下，执行该js，输出如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">连接服务器成功</span><br><span class="line">服务端消息 我是客户端</span><br><span class="line">服务端连接断开</span><br></pre></td></tr></table></figure>

<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>NodeJs TCP服务端与客户端开发到此结束，但是TCP协议的学习远远不止于此，包括<code>自定义协议开发</code>、<code>TCP粘包问题</code>等等。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Gepostet vor&nbsp;<time dateTime="2019-07-23T02:52:47.000Z" title="7/23/2019, 2:52:47 AM">2019-07-23</time></span><span class="level-item"><a class="link-muted" href="/categories/backend/">backend</a><span> / </span><a class="link-muted" href="/categories/backend/nodejs/">nodejs</a></span><span class="level-item">7 minutes lesen (Über 1102 Wörter)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/07/23/2019-07-23-nodejs-guide-child-process.html">NodeJs简明教程(8)</a></p><div class="content"><p>本文是NodeJs简明教程的第八篇，将介绍NodeJs <strong>子进程</strong> 模块相关的基本操作。</p>
<blockquote>
<p>child_process 模块提供了衍生子进程的能力（以一种与 popen(3) 类似但不相同的方式）。</p>
</blockquote>
<p>NodeJs的JS线程虽然是单线程，不能利用多核CPU，也不能执行CPU密集型的任务，但是通过派生子进程的形式加上**IPC(进程间通信)**，可以充分利用多核CPU。</p>
<h2 id="spawn"><a href="#spawn" class="headerlink" title="spawn"></a>spawn</h2><p> <code>spawn</code>可以执行<code>指定的命令</code>，<code>spawn</code>的函数原型如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">child_process.<span class="title function_">spawn</span>(command[,args][,options])</span><br></pre></td></tr></table></figure>

<ul>
<li>command <code>&lt;string&gt;</code> 要执行的命令</li>
<li>args <code>&lt;string[]&gt;</code> 传给命令的参数列表</li>
<li>options <code>&lt;Object&gt;</code> 额外选项<ul>
<li>cwd <code>&lt;string&gt;</code> 子进程<code>workdir</code></li>
<li>env <code>&lt;Object&gt;</code> 子进程环境变量</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; spawn &#125; = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> ls = <span class="title function_">spawn</span>(<span class="string">&#x27;ls&#x27;</span>, [<span class="string">&#x27;-lh&#x27;</span>, <span class="string">&#x27;/usr&#x27;</span>]); <span class="comment">// 命令配置</span></span><br><span class="line"></span><br><span class="line">ls.<span class="property">stdout</span>.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123; <span class="comment">// 监听命令执行的标准输出</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`stdout: <span class="subst">$&#123;data&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ls.<span class="property">stderr</span>.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123; <span class="comment">// 监听命令执行的标准错误输出</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`stderr: <span class="subst">$&#123;data&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ls.<span class="title function_">on</span>(<span class="string">&#x27;close&#x27;</span>, <span class="function">(<span class="params">code</span>) =&gt;</span> &#123; <span class="comment">// 监听子进程退出</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`子进程退出，使用退出码 <span class="subst">$&#123;code&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>以上例程输出(不同机器输出可能不一样)</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">stdout: total 0</span><br><span class="line">drwxr-xr-x  970 root  wheel    30K  7 19 23:00 bin</span><br><span class="line">drwxr-xr-x  306 root  wheel   9.6K  7 12 22:35 lib</span><br><span class="line">drwxr-xr-x  249 root  wheel   7.8K  7 19 23:00 libexec</span><br><span class="line">drwxr-xr-x   15 root  wheel   480B  4  1 14:15 local</span><br><span class="line">drwxr-xr-x  239 root  wheel   7.5K  7 12 22:35 sbin</span><br><span class="line">drwxr-xr-x   46 root  wheel   1.4K  9 21  2018 share</span><br><span class="line">drwxr-xr-x    5 root  wheel   160B  9 21  2018 standalone</span><br><span class="line"></span><br><span class="line">子进程退出，使用退出码 0</span><br></pre></td></tr></table></figure>

<h2 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h2><p><code>exec</code>也可以执行<code>指定的命令</code>，与<code>spawn</code>区别是执行结果通过回调通知，<code>spawn</code>是通过事件，<code>exec</code>函数原型如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">exec</span>(command[,options][,callback])</span><br></pre></td></tr></table></figure>

<ul>
<li>command <code>&lt;string&gt;</code> 要执行的命令，命令参数使用空格分隔</li>
<li>options <code>&lt;Object&gt;</code> 额外选项<ul>
<li>cwd <code>&lt;string&gt;</code> 子进程<code>workdir</code></li>
<li>env <code>&lt;Object&gt;</code> 子进程环境变量</li>
<li>timeout <code>&lt;number&gt;</code> 子进程执行超时</li>
</ul>
</li>
<li>callback <code>&lt;Function&gt;</code> 执行结果回调<ul>
<li>error <code>&lt;Error&gt;</code> 执行错误(不是子进程的错误输出)</li>
<li>stdout <code>&lt;string|Buffer&gt;</code> 子进程标准输出</li>
<li>stderr <code>&lt;string|Buffer&gt;</code> 子进程标准错误输出</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> exec = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>).<span class="property">exec</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">exec</span>(<span class="string">&#x27;ls -lh /usr&#x27;</span>,<span class="keyword">function</span>(<span class="params">err,stdout,stderr</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;执行错误&#x27;</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;stdout&#x27;</span>, stdout);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;stderr&#x27;</span>, stderr);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>以上例程输出</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">stdout: total 0</span><br><span class="line">drwxr-xr-x  970 root  wheel    30K  7 19 23:00 bin</span><br><span class="line">drwxr-xr-x  306 root  wheel   9.6K  7 12 22:35 lib</span><br><span class="line">drwxr-xr-x  249 root  wheel   7.8K  7 19 23:00 libexec</span><br><span class="line">drwxr-xr-x   15 root  wheel   480B  4  1 14:15 local</span><br><span class="line">drwxr-xr-x  239 root  wheel   7.5K  7 12 22:35 sbin</span><br><span class="line">drwxr-xr-x   46 root  wheel   1.4K  9 21  2018 share</span><br><span class="line">drwxr-xr-x    5 root  wheel   160B  9 21  2018 standalone</span><br><span class="line"></span><br><span class="line">子进程退出，使用退出码 0</span><br></pre></td></tr></table></figure>

<h2 id="execFile"><a href="#execFile" class="headerlink" title="execFile"></a>execFile</h2><p><code>execFile</code>类似于<code>exec</code>，但默认情况下不会派生shell， 相反，指定的可执行文件 file 会作为新进程直接地衍生，使其比 <code>exec</code>稍微更高效。</p>
<p>支持与<code>exec</code>相同的选项。 由于没有衍生 shell，因此<code>不支持 I/O 重定向和文件通配等行为</code>。<code>execFile</code>原型：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">execFile</span>(file[,args][,options][,callback])</span><br></pre></td></tr></table></figure>

<ul>
<li>file <code>&lt;string&gt;</code> 要执行的命令或可执行文件路径</li>
<li>args <code>&lt;string[]&gt;</code> 字符串数组形式的参数列表</li>
<li>options <code>&lt;Object&gt;</code> 额外选项<ul>
<li>cwd <code>&lt;string&gt;</code> 子进程<code>workdir</code></li>
<li>env <code>&lt;Object&gt;</code> 子进程环境变量</li>
<li>timeout <code>&lt;number&gt;</code> 子进程执行超时</li>
</ul>
</li>
<li>callback <code>&lt;Function&gt;</code> 执行结果回调<ul>
<li>error <code>&lt;Error&gt;</code> 执行错误(不是子进程的错误输出)</li>
<li>stdout <code>&lt;string|Buffer&gt;</code> 子进程标准输出</li>
<li>stderr <code>&lt;string|Buffer&gt;</code> 子进程标准错误输出</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> execFile = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>).<span class="property">execFile</span>;</span><br><span class="line"><span class="title function_">execFile</span>(<span class="string">&#x27;ls&#x27;</span>, [<span class="string">&#x27;--version&#x27;</span>], <span class="keyword">function</span>(<span class="params">error, stdout, stderr</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;执行错误&#x27;</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;stdout&#x27;</span>, stdout);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;stderr&#x27;</span>, stderr);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>以上例程输出同<code>exec</code></p>
<h2 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h2><p><code>fork</code>是<code>spawn</code>的一个特例，专门用于派生新的<code>NodeJs进程</code>。<code>spawn</code>可以派生<code>任何进程</code>。<code>fork</code>方法原型如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fork</span>(modulePath[,args][,options])</span><br></pre></td></tr></table></figure>

<ul>
<li>modulePath <code>&lt;string&gt;</code> 要执行的JS路径</li>
<li>args <code>&lt;string[]&gt;</code> 字符串数组形式的参数列表</li>
<li>options <code>&lt;Object&gt;</code> 额外选项<ul>
<li>cwd <code>&lt;string&gt;</code> 子进程的<code>workdir</code></li>
<li>env <code>&lt;Object&gt;</code> 环境变量</li>
<li>silent <code>&lt;boolean&gt;</code> 如果为 true，则子进程的 stdin、stdout 和 stderr 将会被输送到父进程，否则它们将会继承自父进程。默认<code>false</code></li>
</ul>
</li>
</ul>
<p>b.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fork = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>).<span class="property">fork</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> child = <span class="title function_">fork</span>(<span class="string">&#x27;./a.js&#x27;</span>,&#123;<span class="attr">silent</span>:<span class="literal">true</span>&#125;); <span class="comment">// silent为true时可以监听子进程标准输出和标准错误输出</span></span><br><span class="line">child.<span class="property">stdout</span>.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>,<span class="keyword">function</span>(<span class="params">data</span>)&#123; <span class="comment">// 监听子进程标准输出</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;child stdout&#x27;</span>, data.<span class="title function_">toString</span>(<span class="string">&#x27;utf8&#x27;</span>));</span><br><span class="line">&#125;);</span><br><span class="line">child.<span class="property">stderr</span>.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="keyword">function</span>(<span class="params">data</span>)&#123; <span class="comment">// 监听子进程标准错误输出</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;child stderr&#x27;</span>, data.<span class="title function_">toString</span>(<span class="string">&#x27;utf8&#x27;</span>));</span><br><span class="line">&#125;);</span><br><span class="line">child.<span class="title function_">on</span>(<span class="string">&#x27;close&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;child exit&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>a.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我是子进程`);</span></span><br></pre></td></tr></table></figure>

<p>终端执行<code>node b.js</code>，以上例程输出：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">child stdout 我是子进程</span><br><span class="line"></span><br><span class="line">child exit</span><br></pre></td></tr></table></figure>

<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>子进程模块的介绍到此就告一段落了，一般情况下使用<code>spawn</code>和<code>execFile</code>即可。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Gepostet vor&nbsp;<time dateTime="2019-07-22T02:53:10.000Z" title="7/22/2019, 2:53:10 AM">2019-07-22</time></span><span class="level-item"><a class="link-muted" href="/categories/backend/">backend</a><span> / </span><a class="link-muted" href="/categories/backend/nodejs/">nodejs</a></span><span class="level-item">6 minutes lesen (Über 828 Wörter)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/07/22/2019-07-22-nodejs-guide-events.html">NodeJs简明教程(7)</a></p><div class="content"><p>本文是NodeJs简明教程的第七篇，将介绍NodeJs events模块相关的基本操作。</p>
<blockquote>
<p>大多数 Node.js 核心 API 构建于惯用的异步事件驱动架构，其中某些类型的对象（又称触发器，Emitter）会触发命名事件来调用函数（又称监听器，Listener）。</p>
</blockquote>
<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p>使用事件监听器一般包含以下操作：</p>
<ol>
<li>新建事件监听器实例</li>
<li>设置监听函数</li>
<li>触发事件</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">EventEmitter</span> = <span class="built_in">require</span>(<span class="string">&#x27;events&#x27;</span>); <span class="comment">// 引用模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyEmitter</span> <span class="keyword">extends</span> <span class="title class_ inherited__">EventEmitter</span> &#123;&#125; <span class="comment">// 初始化监听器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myEmitter = <span class="keyword">new</span> <span class="title class_">MyEmitter</span>();</span><br><span class="line"></span><br><span class="line">myEmitter.<span class="title function_">on</span>(<span class="string">&#x27;event&#x27;</span>, <span class="function">() =&gt;</span> &#123; <span class="comment">// 设置监听函数</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;an event occurred!&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">myEmitter.<span class="title function_">emit</span>(<span class="string">&#x27;event&#x27;</span>); <span class="comment">// 触发事件</span></span><br></pre></td></tr></table></figure>

<p>以上例程会输出<code>an event occurred!</code></p>
<h2 id="一次性事件监听"><a href="#一次性事件监听" class="headerlink" title="一次性事件监听"></a>一次性事件监听</h2><p>上文中的监听方式<code>事件触发几次</code>就会<code>输出几次an event occurred!</code>，有些事件可能是一次性的。这时候可以使用<code>once</code>监听。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">EventEmitter</span> = <span class="built_in">require</span>(<span class="string">&#x27;events&#x27;</span>); <span class="comment">// 引用模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyEmitter</span> <span class="keyword">extends</span> <span class="title class_ inherited__">EventEmitter</span> &#123;&#125; <span class="comment">// 初始化监听器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myEmitter = <span class="keyword">new</span> <span class="title class_">MyEmitter</span>();</span><br><span class="line"></span><br><span class="line">myEmitter.<span class="title function_">once</span>(<span class="string">&#x27;event&#x27;</span>, <span class="function">() =&gt;</span> &#123; <span class="comment">// 设置监听函数</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;an event occurred!&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">myEmitter.<span class="title function_">emit</span>(<span class="string">&#x27;event&#x27;</span>); <span class="comment">// 触发事件</span></span><br><span class="line">myEmitter.<span class="title function_">emit</span>(<span class="string">&#x27;event&#x27;</span>); <span class="comment">// 触发事件</span></span><br></pre></td></tr></table></figure>

<p>以上例程会输出<code>1次</code> <code>an event occurred!</code>;</p>
<h2 id="同一事件多次监听"><a href="#同一事件多次监听" class="headerlink" title="同一事件多次监听"></a>同一事件多次监听</h2><p>上文中的监听方式都是只有<code>1个</code>监听函数，通过<code>多次调用on</code>可以设置多个监听函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">EventEmitter</span> = <span class="built_in">require</span>(<span class="string">&#x27;events&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyEmitter</span> <span class="keyword">extends</span> <span class="title class_ inherited__">EventEmitter</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myEmitter = <span class="keyword">new</span> <span class="title class_">MyEmitter</span>();</span><br><span class="line"></span><br><span class="line">myEmitter.<span class="title function_">once</span>(<span class="string">&#x27;event&#x27;</span>, <span class="function">() =&gt;</span> &#123; <span class="comment">// 监听器1</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;监听器1收到事件&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">myEmitter.<span class="title function_">on</span>(<span class="string">&#x27;event&#x27;</span>, <span class="function">() =&gt;</span> &#123; <span class="comment">// 监听器2</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;监听器2收到事件&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">myEmitter.<span class="title function_">emit</span>(<span class="string">&#x27;event&#x27;</span>); <span class="comment">// 触发事件</span></span><br></pre></td></tr></table></figure>

<p>以上例程会输出</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">监听器1收到事件</span><br><span class="line">监听器2收到事件</span><br></pre></td></tr></table></figure>

<h2 id="接收事件参数"><a href="#接收事件参数" class="headerlink" title="接收事件参数"></a>接收事件参数</h2><ol>
<li><code>emit</code>函数的第一个值为<code>事件名</code>,<code>后续参数为事件值</code></li>
<li><code>on</code>和<code>once</code>等监听器设置函数的回调函数收到的值<code>为emit传入的事件参数</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">EventEmitter</span> = <span class="built_in">require</span>(<span class="string">&#x27;events&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyEmitter</span> <span class="keyword">extends</span> <span class="title class_ inherited__">EventEmitter</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myEmitter = <span class="keyword">new</span> <span class="title class_">MyEmitter</span>();</span><br><span class="line"></span><br><span class="line">myEmitter.<span class="title function_">once</span>(<span class="string">&#x27;event&#x27;</span>, <span class="function">(<span class="params">param1,param2,param3</span>) =&gt;</span> &#123; <span class="comment">// 接收事件参数</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;收到事件&#x27;</span>,param1,param2,param3);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">myEmitter.<span class="title function_">emit</span>(<span class="string">&#x27;event&#x27;</span>,<span class="string">&#x27;参数1&#x27;</span>,<span class="string">&#x27;参数2&#x27;</span>,&#123;<span class="attr">name</span>:<span class="string">&#x27;参数3&#x27;</span>&#125;); <span class="comment">// 发送事件参数</span></span><br></pre></td></tr></table></figure>

<p>以上例程会输出</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">收到事件 参数1 参数2 &#123; name: &#x27;参数3&#x27; &#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取事件监听器上所有事件"><a href="#获取事件监听器上所有事件" class="headerlink" title="获取事件监听器上所有事件"></a>获取事件监听器上所有事件</h2><p>使用<code>eventNames()实例方法</code>获取监听器上所有事件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">EventEmitter</span> = <span class="built_in">require</span>(<span class="string">&#x27;events&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyEmitter</span> <span class="keyword">extends</span> <span class="title class_ inherited__">EventEmitter</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myEmitter = <span class="keyword">new</span> <span class="title class_">MyEmitter</span>();</span><br><span class="line"></span><br><span class="line">myEmitter.<span class="title function_">once</span>(<span class="string">&#x27;event&#x27;</span>, <span class="function">(<span class="params">param1,param2,param3</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;收到事件&#x27;</span>,param1,param2,param3);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">myEmitter.<span class="title function_">once</span>(<span class="string">&#x27;event2&#x27;</span>,<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;收到事件2&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myEmitter.<span class="title function_">eventNames</span>());</span><br></pre></td></tr></table></figure>

<p>以上例程输出<code>[ &#39;event&#39;, &#39;event2&#39; ]</code></p>
<h2 id="移除事件监听器"><a href="#移除事件监听器" class="headerlink" title="移除事件监听器"></a>移除事件监听器</h2><p>使用<code>off实例方法</code>移除单个监听器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">EventEmitter</span> = <span class="built_in">require</span>(<span class="string">&#x27;events&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyEmitter</span> <span class="keyword">extends</span> <span class="title class_ inherited__">EventEmitter</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myEmitter = <span class="keyword">new</span> <span class="title class_">MyEmitter</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">callback</span> = (<span class="params">param1</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(param1);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myEmitter.<span class="title function_">on</span>(<span class="string">&#x27;event&#x27;</span>, callback); <span class="comment">// 添加监听器</span></span><br><span class="line"></span><br><span class="line">myEmitter.<span class="title function_">off</span>(<span class="string">&#x27;event&#x27;</span>, callback); <span class="comment">// 移除监听器</span></span><br><span class="line"></span><br><span class="line">myEmitter.<span class="title function_">emit</span>(<span class="string">&#x27;event&#x27;</span>); <span class="comment">// 触发事件</span></span><br></pre></td></tr></table></figure>

<p>以上例程<code>没有输出</code>，因为<code>先添加监听器，随后移除，触发事件时已经没有可用的监听器了</code></p>
<h2 id="移除所有监听器"><a href="#移除所有监听器" class="headerlink" title="移除所有监听器"></a>移除所有监听器</h2><p>使用<code>removeAllListeners([eventName])实例方法移除所有监听器</code>。</p>
<ol>
<li>removeAllListener<code>不传参数</code>时移除该<code>emitter实例</code>上<code>所有</code>事件监听器</li>
<li>removeAllListener传入<code>字符串</code>参数时移除该<code>emitter实例</code>上<code>所有该事件</code>的监听器</li>
</ol>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>事件系统是NodeJs的灵魂，在几乎所有的I&#x2F;O模块都有使用，希望各位读者好好掌握。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Gepostet vor&nbsp;<time dateTime="2019-07-21T02:25:22.000Z" title="7/21/2019, 2:25:22 AM">2019-07-21</time></span><span class="level-item"><a class="link-muted" href="/categories/backend/">backend</a><span> / </span><a class="link-muted" href="/categories/backend/nodejs/">nodejs</a></span><span class="level-item">8 minutes lesen (Über 1271 Wörter)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/07/21/2019-07-21-nodejs-guide-crypto.html">NodeJs简明教程(6)</a></p><div class="content"><p>本文是NodeJs简明教程的第六篇，将介绍NodeJs crypto模块相关的基本操作。</p>
<blockquote>
<p>crypto 模块提供了加密功能，包括对 OpenSSL 的哈希、HMAC、加密、解密、签名、以及验证功能的一整套封装。</p>
</blockquote>
<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><blockquote>
<p>Hash类是用于创建数据哈希值的工具类。</p>
</blockquote>
<p>哈希算法严格来说并不属于加密算法，传统意义上的 <strong>加密</strong> 是与 <strong>解密</strong> 相配对的。哈希算法能够保证被哈希的内容不被篡改。针对任意长度的输入数据都可以产生固定位数的哈希值。</p>
<p>crypto模块对hash的操作是一致的，除了算法名不一致之外，本文以 <strong>md5</strong> 和 <strong>sha1</strong> 作为示例。</p>
<h3 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&#x27;crypto&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hash = crypto.<span class="title function_">createHash</span>(<span class="string">&#x27;md5&#x27;</span>); <span class="comment">// 创建MD5 hash示例</span></span><br><span class="line"></span><br><span class="line">hash.<span class="title function_">update</span>(<span class="string">&#x27;111111&#x27;</span>); <span class="comment">// 待计算hash的数据</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hash.<span class="title function_">digest</span>(<span class="string">&#x27;hex&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>以上例程输出 <code>96e79218965eb72c92a549dd5a330112</code></p>
<h3 id="SHA1"><a href="#SHA1" class="headerlink" title="SHA1"></a>SHA1</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&#x27;crypto&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hash = crypto.<span class="title function_">createHash</span>(<span class="string">&#x27;sha1&#x27;</span>); <span class="comment">// 创建MD5 hash示例</span></span><br><span class="line"></span><br><span class="line">hash.<span class="title function_">update</span>(<span class="string">&#x27;111111&#x27;</span>); <span class="comment">// 待计算hash的数据</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hash.<span class="title function_">digest</span>(<span class="string">&#x27;hex&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>以上例程输出 <code>3d4f2bf07dc1be38b20cd6e46949a1071f9d0e3d</code></p>
<h2 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h2><p><code>Base64</code>并不是<code>crypto</code>模块的成员，但是跟本节内容比较相近，所以放过来了。Base64是一套编码算法，常用在二进制数据编码上。</p>
<h3 id="Base64编码"><a href="#Base64编码" class="headerlink" title="Base64编码"></a>Base64编码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = <span class="string">&#x27;111111&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> encodedData = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(data, <span class="string">&#x27;utf8&#x27;</span>).<span class="title function_">toString</span>(<span class="string">&#x27;base64&#x27;</span>); <span class="comment">// 输入编码为utf8,输出为base64</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(encodedData);</span><br></pre></td></tr></table></figure>

<p>以上例程输出 <code>MTExMTEx</code></p>
<h3 id="Base64解码"><a href="#Base64解码" class="headerlink" title="Base64解码"></a>Base64解码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = <span class="string">&#x27;MTExMTEx&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> decodedData = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(data, <span class="string">&#x27;base64&#x27;</span>).<span class="title function_">toString</span>(<span class="string">&#x27;utf8&#x27;</span>); <span class="comment">// 输入编码为base64,输出编码为utf8</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(decodedData);</span><br></pre></td></tr></table></figure>

<p>以上例程输出<code>111111</code></p>
<h2 id="Hmac"><a href="#Hmac" class="headerlink" title="Hmac"></a>Hmac</h2><blockquote>
<p>Hmac类是用于创建加密Hmac摘要的工具。</p>
</blockquote>
<p>Hmac算法也是一种hash算法，但是它需要一个密钥，针对同样的输入，传统的hash算法输出是固定的。<br>但是Hmac的输出会随着密钥的不同而不同。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&#x27;crypto&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hmac = crypto.<span class="title function_">createHmac</span>(<span class="string">&#x27;sha256&#x27;</span>, <span class="string">&#x27;secret-key&#x27;</span>);</span><br><span class="line"></span><br><span class="line">hmac.<span class="title function_">update</span>(<span class="string">&#x27;Hello, world!&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hmac.<span class="title function_">digest</span>(<span class="string">&#x27;hex&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>以上例程输出 <code>f4d850b1017eb4e20e0c58443919033c90cc9f4fe889b4d6b4572a4a0ec2d08a</code></p>
<h2 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h2><blockquote>
<p>AES是一种常用的对称加密算法，加解密都用同一个密钥。</p>
</blockquote>
<h3 id="AES加密"><a href="#AES加密" class="headerlink" title="AES加密"></a>AES加密</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&#x27;crypto&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cipher = crypto.<span class="title function_">createCipheriv</span>(<span class="string">&#x27;aes192&#x27;</span>, <span class="string">&#x27;111111111111111111111111&#x27;</span>, <span class="string">&#x27;1111111111111111&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> crypted = cipher.<span class="title function_">update</span>(<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>, <span class="string">&#x27;hex&#x27;</span>); </span><br><span class="line">crypted += cipher.<span class="title function_">final</span>(<span class="string">&#x27;hex&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(crypted);</span><br></pre></td></tr></table></figure>

<p>以上例程输出 <code>5bb3e6eb39e502b5fa74d93796087efa</code></p>
<p><strong>说明：</strong></p>
<p><code>createCipheriv</code>原型如下：</p>
<p><code>crypto.createCipheriv（algorithm，key，iv [，options]）</code></p>
<ol>
<li><code>iv</code>是初始化向量，可以 <strong>为空</strong> 或者 <strong>16</strong> 字节的字符串</li>
<li><code>key</code>是加密密钥，根据选用的算法不同，密钥长度也不同，对应关系如下：<ol>
<li><code>aes128</code>对应<code>16位</code>长度密钥</li>
<li><code>aes192</code>对应<code>24位</code>长度秘钥</li>
<li><code>aes256</code>对应<code>32位</code>长度密钥</li>
</ol>
</li>
</ol>
<h3 id="AES解密"><a href="#AES解密" class="headerlink" title="AES解密"></a>AES解密</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&#x27;crypto&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cipher = crypto.<span class="title function_">createDecipheriv</span>(<span class="string">&#x27;aes192&#x27;</span>, <span class="string">&#x27;111111111111111111111111&#x27;</span>, <span class="string">&#x27;1111111111111111&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> data = cipher.<span class="title function_">update</span>(<span class="string">&#x27;5bb3e6eb39e502b5fa74d93796087efa&#x27;</span>, <span class="string">&#x27;hex&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>); <span class="comment">// 输入数据编码为hex(16进制)，输出为utf8</span></span><br><span class="line">data += cipher.<span class="title function_">final</span>(<span class="string">&#x27;utf8&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br></pre></td></tr></table></figure>

<p>以上例程输出<code>1</code></p>
<p><code>crypto.createDecipheriv</code>方法原型与<code>crypto.createCipher</code>一致，这里不在赘述。</p>
<h2 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h2><blockquote>
<p>RSA算法是一种非对称加密算法，即由一个私钥和一个公钥构成的密钥对，通过私钥加密，公钥解密，或者通过公钥加密，私钥解密。其中，公钥可以公开，私钥必须保密。</p>
</blockquote>
<h3 id="生成密钥对"><a href="#生成密钥对" class="headerlink" title="生成密钥对"></a>生成密钥对</h3><p>使用RSA算法前必须提供密钥对，本文使用<code>openssl</code>命令进行生成。</p>
<ol>
<li><code>openssl genrsa -out private.pem 2048 </code> 生成<code>2048位</code>长度的<code>私钥</code></li>
<li><code>openssl rsa -in private.pem -pubout -out public.pem</code> 导出公钥</li>
</ol>
<p>这样在当前目录我们就得到了<code>private.pem</code>和<code>public.pem</code></p>
<h3 id="RSA加密"><a href="#RSA加密" class="headerlink" title="RSA加密"></a>RSA加密</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&#x27;crypto&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> privateKey = fs.<span class="title function_">readFileSync</span>(<span class="string">&#x27;./private.pem&#x27;</span>, &#123; <span class="attr">encoding</span>: <span class="string">&#x27;utf8&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> encodedData = crypto.<span class="title function_">privateEncrypt</span>(privateKey, <span class="title class_">Buffer</span>.<span class="title function_">from</span>(<span class="string">&#x27;111111&#x27;</span>,<span class="string">&#x27;utf8&#x27;</span>)); <span class="comment">// 传入utf8编码的数据</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(encodedData.<span class="title function_">toString</span>(<span class="string">&#x27;hex&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>以上例程输出</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">44a1b50b9639e4cbe17d55ca57dcb041387acadae3d3721fd9803a3a33091a36d59977feaa6caad990e58b9542c26297de6014e20819f0a71eadd0793bfe0fac834f30d2a05f8b329a3b2409e9f8b7fbd7de3734ada00228b84027568be58a2a34ccf0c4a8b2d02c58eef510931423ed5f40c696361b606df11609248b271aebcd17f9a113f98a8fa86c9c45bd609256f4779ce01ea3027171fffb35e695f1c38553aecafb72a2f46a9012246fde0f2934eacba8932bca38e228f4f4294873ed75d9acf79ab854897ebaab2375384b2da682c1b2e2b49b0592929067b3d5a11971d912629a178691345f7f88137343588b5c51d60643e5c00998484727b8c4a8</span><br></pre></td></tr></table></figure>

<h3 id="RSA解密"><a href="#RSA解密" class="headerlink" title="RSA解密"></a>RSA解密</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&#x27;crypto&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> publicKey = fs.<span class="title function_">readFileSync</span>(<span class="string">&#x27;./public.pem&#x27;</span>, &#123; <span class="attr">encoding</span>: <span class="string">&#x27;utf8&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> encodedData = <span class="string">&#x27;44a1b50b9639e4cbe17d55ca57dcb041387acadae3d3721fd9803a3a33091a36d59977feaa6caad990e58b9542c26297de6014e20819f0a71eadd0793bfe0fac834f30d2a05f8b329a3b2409e9f8b7fbd7de3734ada00228b84027568be58a2a34ccf0c4a8b2d02c58eef510931423ed5f40c696361b606df11609248b271aebcd17f9a113f98a8fa86c9c45bd609256f4779ce01ea3027171fffb35e695f1c38553aecafb72a2f46a9012246fde0f2934eacba8932bca38e228f4f4294873ed75d9acf79ab854897ebaab2375384b2da682c1b2e2b49b0592929067b3d5a11971d912629a178691345f7f88137343588b5c51d60643e5c00998484727b8c4a8&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rawData = crypto.<span class="title function_">publicDecrypt</span>(publicKey, <span class="title class_">Buffer</span>.<span class="title function_">from</span>(encodedData, <span class="string">&#x27;hex&#x27;</span>)); <span class="comment">// 传入hex(16进制)数据</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rawData.<span class="title function_">toString</span>(<span class="string">&#x27;utf8&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>以上例程输出</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">111111</span><br></pre></td></tr></table></figure>

<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>常用的加解密、哈希、编解码用法已经介绍完毕。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Gepostet vor&nbsp;<time dateTime="2019-07-20T05:00:27.000Z" title="7/20/2019, 5:00:27 AM">2019-07-20</time></span><span class="level-item"><a class="link-muted" href="/categories/backend/">backend</a><span> / </span><a class="link-muted" href="/categories/backend/nodejs/">nodejs</a></span><span class="level-item">6 minutes lesen (Über 930 Wörter)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/07/20/2019-07-20-nodejs-guide-path.html">NodeJs简明教程(5)</a></p><div class="content"><p>本文是NodeJs简明教程的第五篇，将介绍NodeJs path模块相关的基本操作。</p>
<blockquote>
<p>path 模块提供用于处理文件路径和目录路径的实用工具。 </p>
</blockquote>
<p><strong>注意：path模块只是处理文件路径，说白了就是字符串处理，跟文件系统无关</strong></p>
<h2 id="读取路径的文件名"><a href="#读取路径的文件名" class="headerlink" title="读取路径的文件名"></a>读取路径的文件名</h2><blockquote>
<p>path.basename() 方法返回 path 的最后一部分，类似于 Unix 的 basename 命令。 尾部的目录分隔符将被忽略。</p>
</blockquote>
<ol>
<li><p>返回带扩展名</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">basename</span>(<span class="string">&#x27;/usr/local/a.txt&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 a.txt</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>返回不带扩展名</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">basename</span>(<span class="string">&#x27;/usr/local/a.txt&#x27;</span>,<span class="string">&#x27;.txt&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 a</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="读取文件路径的目录名"><a href="#读取文件路径的目录名" class="headerlink" title="读取文件路径的目录名"></a>读取文件路径的目录名</h2><blockquote>
<p>path.dirname() 方法返回 path 的目录名，类似于 Unix 的 dirname 命令。 尾部的目录分隔符将被忽略。<br>path.extname() 方法返回 path 的扩展名，从最后一次出现 .（句点）字符到 path 最后一部分的字符串结束。 如果在 path 的最后一部分中没有 . ，或者如果 path 的基本名称（参阅 path.basename()）除了第一个字符以外没有 .，则返回空字符串。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">dirname</span>(<span class="string">&#x27;/usr/local/a.txt&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 /usr/local</span></span><br></pre></td></tr></table></figure>

<h2 id="获取文件扩展名"><a href="#获取文件扩展名" class="headerlink" title="获取文件扩展名"></a>获取文件扩展名</h2><blockquote>
<p>path.extname() 方法返回 path 的扩展名，从最后一次出现 .（句点）字符到 path 最后一部分的字符串结束。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">extname</span>(<span class="string">&#x27;/usr/local/a.txt&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 .txt</span></span><br></pre></td></tr></table></figure>

<h2 id="检测路径是否为绝对路径"><a href="#检测路径是否为绝对路径" class="headerlink" title="检测路径是否为绝对路径"></a>检测路径是否为绝对路径</h2><blockquote>
<p>path.isAbsolute() 方法检测 path 是否为绝对路径。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="comment">// linux || macosx</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">isAbsolute</span>(<span class="string">&#x27;/usr/local&#x27;</span>)); <span class="comment">// 输出 true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">isAbsolute</span>(<span class="string">&#x27;usr/local&#x27;</span>)); <span class="comment">// 输出 false</span></span><br><span class="line"><span class="comment">// windows</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">isAbsolute</span>(<span class="string">&#x27;//server&#x27;</span>)); <span class="comment">// 输出 true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">isAbsolute</span>(<span class="string">&#x27;\\\\server&#x27;</span>)); <span class="comment">// 输出 true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">isAbsolute</span>(<span class="string">&#x27;c:\windows&#x27;</span>)); <span class="comment">// 输出 true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">isAbsolute</span>(<span class="string">&#x27;foo/bar&#x27;</span>)); <span class="comment">// 输出 false</span></span><br></pre></td></tr></table></figure>

<h2 id="生成规范化的路径"><a href="#生成规范化的路径" class="headerlink" title="生成规范化的路径"></a>生成规范化的路径</h2><blockquote>
<p>path.join() 方法使用平台特定的分隔符作为定界符将所有给定的 path 片段连接在一起，然后规范化生成的路径。<br>零长度的 path 片段会被忽略。 如果连接的路径字符串是零长度的字符串，则返回 ‘.’，表示当前工作目录。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">join</span>(<span class="string">&#x27;/a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;..&#x27;</span>)); <span class="comment">// 输出 /a/b</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">join</span>(<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;..&#x27;</span>,<span class="string">&#x27;c&#x27;</span>)); <span class="comment">// 输出 a/c</span></span><br></pre></td></tr></table></figure>

<h2 id="解析路径"><a href="#解析路径" class="headerlink" title="解析路径"></a>解析路径</h2><blockquote>
<p>path.parse() 方法返回一个对象，其属性表示 path 的重要元素。 尾部的目录分隔符将被忽略。<br>返回对象属性如下：<br>dir 目录<br>root 根目录<br>base 带扩展名的文件名或者目录名(最后一级是目录的情况下)<br>name 文件名(不带扩展名)或目录名<br>ext 文件扩展名(如果是目录则为空字符串)</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line">path.<span class="title function_">parse</span>(<span class="string">&#x27;/home/user/dir/file.txt&#x27;</span>);</span><br><span class="line"><span class="comment">// 返回:</span></span><br><span class="line"><span class="comment">// &#123; root: &#x27;/&#x27;,</span></span><br><span class="line"><span class="comment">//   dir: &#x27;/home/user/dir&#x27;,</span></span><br><span class="line"><span class="comment">//   base: &#x27;file.txt&#x27;,</span></span><br><span class="line"><span class="comment">//   ext: &#x27;.txt&#x27;,</span></span><br><span class="line"><span class="comment">//   name: &#x27;file&#x27; &#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="获取两个路径的相对路径"><a href="#获取两个路径的相对路径" class="headerlink" title="获取两个路径的相对路径"></a>获取两个路径的相对路径</h2><blockquote>
<p>path.relative() 方法根据当前工作目录返回 from 到 to 的相对路径。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">relative</span>(<span class="string">&#x27;/data/orandea/test/aaa&#x27;</span>, <span class="string">&#x27;/data/orandea/impl/bbb&#x27;</span>)); </span><br><span class="line"><span class="comment">// 输出 ../../impl/bbb</span></span><br></pre></td></tr></table></figure>

<h2 id="获取规范化的绝对路径"><a href="#获取规范化的绝对路径" class="headerlink" title="获取规范化的绝对路径"></a>获取规范化的绝对路径</h2><blockquote>
<p>path.resolve() 方法将路径或路径片段的序列解析为绝对路径。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">resolve</span>(<span class="string">&#x27;/foo/bar&#x27;</span>, <span class="string">&#x27;./baz&#x27;</span>)); <span class="comment">// 输出 /for/bar/baz</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">resolve</span>(<span class="string">&#x27;/foo/bar&#x27;</span>, <span class="string">&#x27;/tmp/file/&#x27;</span>);); <span class="comment">// 输出 /tmp/file</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">resolve</span>(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;../c/img.gif&#x27;</span>));</span><br><span class="line"><span class="comment">// 假设当前工作目录 /home/wwwroot，上述语句输出 /home/wwwroot/a/c/img.gif</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">resolve</span>()); <span class="comment">// 假设当前工作目录 /home/wwwroot 输出 /home/wwwroot</span></span><br></pre></td></tr></table></figure>

<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p><code>path</code>模块的主要就是处理路径相关，经常和<code>fs</code>模块共同使用。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Gepostet vor&nbsp;<time dateTime="2019-07-20T03:38:51.000Z" title="7/20/2019, 3:38:51 AM">2019-07-20</time></span><span class="level-item"><a class="link-muted" href="/categories/backend/">backend</a><span> / </span><a class="link-muted" href="/categories/backend/nodejs/">nodejs</a></span><span class="level-item">5 minutes lesen (Über 699 Wörter)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/07/20/2019-07-20-nodejs-guide-filesystem.html">NodeJs简明教程(4)</a></p><div class="content"><p>本文是NodeJs简明教程的第四篇，将介绍NodeJs文件系统模块相关的基本操作。</p>
<blockquote>
<p>fs 模块提供了一个 API，用于以模仿标准 POSIX 函数的方式与文件系统进行交互。</p>
</blockquote>
<h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><p>文件系统的大部分函数都存在 <strong>异步调用</strong> 和 <strong>同步调用</strong> 两种形式。</p>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>异步模式下，回调函数的第一个参数总为 <strong>Error</strong> 对象，且函数一般无返回值。</p>
<ol>
<li>如果为null，则本次调用未出错</li>
<li>如果不为null，证明本次调用出错</li>
</ol>
<p>新建 <code>index.js</code> 文件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./index.js&#x27;</span>, &#123; <span class="attr">encoding</span>: <span class="string">&#x27;utf8&#x27;</span> &#125;, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;读取文件失败&#x27;</span>, err);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>readFile</code>的第二个参数如果不指定编码，回调函数取到的<code>data</code>对象是<code>Buffer</code>，需要手动转字符串。读取文本文件可以指定编码，但是读取二进制文件(<code>比如读取图片文件</code>)就不能指定编码了，有一些字符时不可见字符，编码之后会出问题。</p>
<ol>
<li><p>在当前目录执行 <code>node index.js</code></p>
</li>
<li><p>输出如下：</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./index.js&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;读取文件失败&#x27;</span>, err);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="同步模式"><a href="#同步模式" class="headerlink" title="同步模式"></a>同步模式</h3><p>同步模式下，返回值为调用函数的结果，如果调用失败，将抛出<strong>Error</strong>对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> data = fs.<span class="title function_">readFileSync</span>(<span class="string">&#x27;./index.js&#x27;</span>, &#123; <span class="attr">encoding</span>: <span class="string">&#x27;utf8&#x27;</span> &#125;);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取失败&#x27;</span>, e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出数据和同步模式一致。</p>
<p>可以看到同步模式和异步模式下处理错误的方式是不同的。</p>
<blockquote>
<p>各位读者在生产中尽量不要使用同步函数，否则会阻塞事件循环。<br>当然，有一种情况例外，需要同步读取配置文件然后才启动服务器的这种情况是可以的。</p>
</blockquote>
<h2 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h2><p>新建<code>index.js</code>，代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = <span class="string">&#x27;Hello World&#x27;</span>;</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">writeFile</span>(<span class="string">&#x27;./a.txt&#x27;</span>, data, <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;保存失败&#x27;</span>, error);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;保存成功&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol>
<li>执行<code>node index.js</code></li>
<li>输出<code>保存成功</code>，同时当前目录会多出内容为<code>Hello World</code>的文本文件。</li>
</ol>
<h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><ol>
<li><code>fs.copyFile(src,dest[,flags],callback)</code> 复制文件</li>
<li><code>fs.stat(path[,options],callback)</code> 读取文件状态</li>
<li><code>fs.unlink(path,callback)</code> 删除文件</li>
<li><code>fs.rename(oldPath,newPath,callback)</code> 重命名文件</li>
<li><code>fs.mkdir(path[,options],callback)</code> 新建目录</li>
<li><code>fs.rmdir(path,callback)</code> 删除目录</li>
</ol>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>文件系统的学习暂时到此为止，用到的时候大家可以详细查看文件，文件系统的函数调用方式和本文的示例都是类似的，各位读者可以举一反三。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Gepostet vor&nbsp;<time dateTime="2019-07-19T03:04:46.000Z" title="7/19/2019, 3:04:46 AM">2019-07-19</time></span><span class="level-item"><a class="link-muted" href="/categories/backend/">backend</a><span> / </span><a class="link-muted" href="/categories/backend/nodejs/">nodejs</a></span><span class="level-item">7 minutes lesen (Über 1046 Wörter)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/07/19/2019-07-19-nodejs-guide-http-server.html">NodeJs简明教程(3)</a></p><div class="content"><p>本文是NodeJs简明教程的第三篇，将介绍NodeJs自带HTTP模块服务器相关的基本操作。</p>
<h2 id="HTTP模块介绍"><a href="#HTTP模块介绍" class="headerlink" title="HTTP模块介绍"></a>HTTP模块介绍</h2><p>以下是官方原文[1]：</p>
<blockquote>
<p>The HTTP interfaces in Node.js are designed to support many features of the protocol which have been traditionally difficult to use. In particular, large, possibly chunk-encoded, messages. The interface is careful to never buffer entire requests or responses — the user is able to stream data.</p>
</blockquote>
<p>大致意思就是：</p>
<blockquote>
<p>NodeJs的HTTP模块旨在支持传统上HTTP协议难以使用的许多功能，让这些功能或者特性能够使用简单的API进行调用。</p>
</blockquote>
<h2 id="HTTP模块服务器开发"><a href="#HTTP模块服务器开发" class="headerlink" title="HTTP模块服务器开发"></a>HTTP模块服务器开发</h2><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>以下是NodeJs最简单的HTTP服务器示例:</p>
<ol>
<li><p>新建<code>index.js</code></p>
</li>
<li><p>编码</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;%s %s&#x27;</span>, req.<span class="property">method</span>, req.<span class="property">url</span>)</span><br><span class="line">    res.<span class="title function_">end</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(req.<span class="property">headers</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">8080</span>, <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;listen on 8080&#x27;</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开终端或者控制台，执行 <code>node index.js</code>，终端或控制台会输出<code>listen on 8080</code>，此时HTTP服务器已经启动，如果启动失败，可以在下方留言</p>
</li>
<li><p>打开浏览器访问 <code>http://localhost:8080</code>，笔者输出如下：</p>
 <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;host&quot;</span><span class="punctuation">:</span> <span class="string">&quot;localhost:8080&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;connection&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keep-alive&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;cache-control&quot;</span><span class="punctuation">:</span> <span class="string">&quot;max-age=0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;upgrade-insecure-requests&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;user-agent&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;dnt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;accept&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;accept-encoding&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gzip, deflate, br&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;accept-language&quot;</span><span class="punctuation">:</span> <span class="string">&quot;zh-CN,zh;q=0.9,en;q=0.8,zh-TW;q=0.7&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h3><ol>
<li>NodeJs采用 <strong>CommonJs模块系统</strong>，<strong>require</strong> 用来加载模块，本例中加载了<strong>NodeJs自带的http模块</strong>以使用其中的功能</li>
<li><code>http.createServer</code>函数创建了一个 <strong>HTTP服务器</strong>，并配置了请求回调函数，在本系列的第一篇文章中说到事件驱动是需要回调函数进行监听的。</li>
<li><code>server.listen</code>是监听系统端口，第二个参数是<strong>监听成功的回调函数</strong></li>
</ol>
<h3 id="req对象"><a href="#req对象" class="headerlink" title="req对象"></a>req对象</h3><p>服务器收到的HTTP请求对象，以下是常用的属性或方法：</p>
<ol>
<li><code>req.url</code> 本次请求的路径(不包含域名)</li>
<li><code>req.headers</code> 本次请求的请求头</li>
<li><code>req.httpVersion</code> 本次请求的<code>HTTP协议版本号</code></li>
<li><code>req.method</code> 本次请求的请求方法,有<code>GET/POST/PUT等等</code></li>
<li><code>on()</code> 监听请求体数据 <code>POST/PUT/PATCH</code>方法会有请求体</li>
</ol>
<h3 id="res对象"><a href="#res对象" class="headerlink" title="res对象"></a>res对象</h3><p>res对象是req请求对象相应的响应对象，HTTP协议设计是<code>请求-应答</code>模型，一次请求对应一次应答。</p>
<p>以下是常用的属性或方法：</p>
<ol>
<li><code>res.writeHead</code> 输出<code>响应状态码</code>，<code>状态码说明</code>以及<code>多个HTTP响应头</code></li>
<li><code>res.end</code> 输出数据并结束本次响应</li>
<li><code>res.write</code> 输出<code>部分内容(chunk)</code></li>
<li><code>res.setHeader</code> 输出<code>单个响应头</code></li>
</ol>
<h3 id="请求路由"><a href="#请求路由" class="headerlink" title="请求路由"></a>请求路由</h3><p>NodeJs自带的HTTP服务器是没有路由功能的，也是就说，根据请求的URI来执行不同的逻辑需要开发者手动去做</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (req.<span class="property">url</span> === <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        res.<span class="title function_">end</span>(<span class="string">&#x27;index&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (req.<span class="property">url</span> === <span class="string">&#x27;/user&#x27;</span>) &#123;</span><br><span class="line">        res.<span class="title function_">end</span>(<span class="string">&#x27;user&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">8080</span>, <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;listen on 8080&#x27;</span>));</span><br></pre></td></tr></table></figure>

<ol>
<li>执行<code>node index.js</code></li>
<li>浏览器访问 <a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080/</a> 会输出<code>index</code></li>
<li>浏览器访问 <a target="_blank" rel="noopener" href="http://localhost:8080/user">http://localhost:8080/user</a> 会输出<code>user</code></li>
</ol>
<h3 id="读取请求参数"><a href="#读取请求参数" class="headerlink" title="读取请求参数"></a>读取请求参数</h3><h4 id="读取GET请求参数"><a href="#读取GET请求参数" class="headerlink" title="读取GET请求参数"></a>读取GET请求参数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> qs = <span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> parsed = url.<span class="title function_">parse</span>(req.<span class="property">url</span>);</span><br><span class="line">    <span class="keyword">const</span> query = qs.<span class="title function_">parse</span>(parsed.<span class="property">query</span>);</span><br><span class="line">    res.<span class="title function_">end</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(query));</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">8080</span>, <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;listen on 8080&#x27;</span>));</span><br></pre></td></tr></table></figure>

<ol>
<li><p>执行<code>node index.js</code></p>
</li>
<li><p>浏览器访问 <a target="_blank" rel="noopener" href="http://localhost:8080/?a=x&b=2&c%5B%5D=1&c%5B%5D=2">http://localhost:8080/?a=x&b=2&c[]&#x3D;1&amp;c[]&#x3D;2</a></p>
</li>
<li><p>显示</p>
 <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">     <span class="attr">&quot;a&quot;</span><span class="punctuation">:</span> <span class="string">&quot;x&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;b&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;c[]&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;1&quot;</span><span class="punctuation">,</span> <span class="string">&quot;2&quot;</span><span class="punctuation">]</span></span><br><span class="line"> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="读取请求体参数"><a href="#读取请求体参数" class="headerlink" title="读取请求体参数"></a>读取请求体参数</h4><p>HTTP协议规范中POST&#x2F;PUT&#x2F;PATCH都可以携带请求体，NodeJs HTTP服务器接收请求体代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> qs = <span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> data = <span class="title class_">Buffer</span>.<span class="title function_">alloc</span>(<span class="number">0</span>);</span><br><span class="line">    req.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="function">(<span class="params">buffer</span>) =&gt;</span> &#123;</span><br><span class="line">        data = <span class="title class_">Buffer</span>.<span class="title function_">concat</span>([data, buffer]);</span><br><span class="line">    &#125;)</span><br><span class="line">    req.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        res.<span class="title function_">end</span>(data.<span class="title function_">toString</span>())</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">8080</span>, <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;listen on 8080&#x27;</span>));</span><br></pre></td></tr></table></figure>

<ol>
<li>执行<code>node index.js</code></li>
<li>使用 <strong>postman</strong> 发出POST请求<code>http://localhost:8080</code>，本例POST请求体为 <code>a=1&amp;b=2</code></li>
<li><strong>postman</strong>会返回 <code>a=1&amp;b=2</code></li>
</ol>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>一个简单的HTTP服务器就到此结束了，当然，实际生产中该方法用的比较少，几乎都是使用框架进行开发，提高开发效率。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Gepostet vor&nbsp;<time dateTime="2019-07-19T02:15:29.000Z" title="7/19/2019, 2:15:29 AM">2019-07-19</time></span><span class="level-item"><a class="link-muted" href="/categories/backend/">backend</a><span> / </span><a class="link-muted" href="/categories/backend/nodejs/">nodejs</a></span><span class="level-item">3 minutes lesen (Über 514 Wörter)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/07/19/2019-07-19-nodejs-guide-installation.html">NodeJs简明教程(2)</a></p><div class="content"><p>本文是NodeJs简明教程的第二篇，将介绍NodeJs在不同操作系统下的安装操作。</p>
<h2 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h2><p><a target="_blank" rel="noopener" href="https://nodejs.org/en/">https://nodejs.org</a></p>
<p>由于国内的网络原因，官网可能访问速度有点慢，推荐直接使用淘宝镜像源下载</p>
<h2 id="淘宝镜像源"><a href="#淘宝镜像源" class="headerlink" title="淘宝镜像源"></a>淘宝镜像源</h2><p><a target="_blank" rel="noopener" href="https://npm.taobao.org/mirrors/node">https://npm.taobao.org/mirrors/node</a>，这里是所有版本&#x2F;所有操作系统的NodeJs安装包。</p>
<p>本系列文章使用 <strong>latest-v10.x</strong>，也就是 <strong>10.x</strong> 的NodeJs版本</p>
<ol>
<li>进入<a target="_blank" rel="noopener" href="https://npm.taobao.org/mirrors/node/latest-v10.x/">https://npm.taobao.org/mirrors/node/latest-v10.x/</a></li>
<li>可以看到最新的版本号为 <strong>node-v10.16.0</strong></li>
</ol>
<h2 id="Windows安装"><a href="#Windows安装" class="headerlink" title="Windows安装"></a>Windows安装</h2><ol>
<li><strong>64位</strong> 系统选择<a target="_blank" rel="noopener" href="https://npm.taobao.org/mirrors/node/latest-v10.x/node-v10.16.0-x64.msi">node-v10.16.0-x64.msi</a></li>
<li><strong>32位</strong> 系统选择<a target="_blank" rel="noopener" href="https://npm.taobao.org/mirrors/node/latest-v10.x/node-v10.16.0-x86.msi">node-v10.16.0-x86.msi</a></li>
<li>双击即可完成安装</li>
<li>安装完毕之后打开<code>cmd</code>执行<code>node -v</code>，显示版本号即为安装成功，安装失败的读者可以在下方留言</li>
</ol>
<h2 id="Mac安装"><a href="#Mac安装" class="headerlink" title="Mac安装"></a>Mac安装</h2><h3 id="PKG安装包安装"><a href="#PKG安装包安装" class="headerlink" title="PKG安装包安装"></a>PKG安装包安装</h3><ol>
<li>选择<a target="_blank" rel="noopener" href="https://npm.taobao.org/mirrors/node/latest-v10.x/node-v10.16.0.pkg">node-v10.16.0.pkg</a></li>
<li>双击即可完成安装</li>
<li>安装完毕之后打开<code>终端</code>执行<code>node -v</code>，显示版本号即为安装成功，安装失败的读者可以在下方留言</li>
</ol>
<h3 id="Homebrew安装"><a href="#Homebrew安装" class="headerlink" title="Homebrew安装"></a>Homebrew安装</h3><ol>
<li><code>brew install node</code></li>
<li>安装完毕之后打开<code>终端</code>执行<code>node -v</code>，显示版本号即为安装成功，安装失败的读者可以在下方留言</li>
</ol>
<h2 id="Linux安装"><a href="#Linux安装" class="headerlink" title="Linux安装"></a>Linux安装</h2><ol>
<li>选择<a target="_blank" rel="noopener" href="https://npm.taobao.org/mirrors/node/latest-v10.x/node-v10.16.0-linux-x64.tar.gz">node-v10.16.0-linux-x64.tar.gz</a>下载文件</li>
<li>执行<code>wget https://npm.taobao.org/mirrors/node/latest-v10.x/node-v10.16.0-linux-x64.tar.gz</code></li>
<li>执行<code>tar xf node-v10.16.0-linux-x64.tar.gz</code>解压</li>
<li>执行<code>mv node-v10.16.0-linux-x64 /opt/node</code>移动到<code>/opt</code>目录</li>
<li>执行<code>echo &quot;export PATH=/opt/node/bin:$PATH&quot; &gt;&gt; ~/.bashrc</code>编辑<code>PATH</code>环境变量</li>
<li>执行<code>source ~/.bashrc</code>更新环境变量</li>
<li>执行<code>node -v</code>，显示版本号即为安装成功，安装失败的读者可以在下方留言</li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Gepostet vor&nbsp;<time dateTime="2019-07-18T02:02:46.000Z" title="7/18/2019, 2:02:46 AM">2019-07-18</time></span><span class="level-item"><a class="link-muted" href="/categories/backend/">backend</a><span> / </span><a class="link-muted" href="/categories/backend/nodejs/">nodejs</a></span><span class="level-item">11 minutes lesen (Über 1715 Wörter)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/07/18/2019-07-18-nodejs-guide-about.html">NodeJs简明教程(1)</a></p><div class="content"><p>本文是NodeJs简明教程的第一篇，将介绍NodeJs整体架构以及重点概念。</p>
<h2 id="NodeJs究竟是什么"><a href="#NodeJs究竟是什么" class="headerlink" title="NodeJs究竟是什么"></a>NodeJs究竟是什么</h2><p>来看一段官方的说法[1]：</p>
<blockquote>
<p>As an asynchronous event driven JavaScript runtime, Node is designed to build scalable network applications. In the following “hello world” example, many connections can be handled concurrently. Upon each connection the callback is fired, but if there is no work to be done, Node will sleep.</p>
</blockquote>
<p>Google翻译版本：</p>
<blockquote>
<p>作为异步事件驱动的JavaScript运行时，Node旨在构建可伸缩的网络应用程序。 在下面的“hello world”示例中，可以同时处理许多连接。 在每次连接时都会触发回调，但是如果没有工作要做，Node将会休眠。</p>
</blockquote>
<p>结合上面的介绍，我们可以得出一个结论：</p>
<blockquote>
<p>NodeJs的本质是一个Javascript运行时。该运行时基于异步事件驱动进行运作。</p>
</blockquote>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>本文中的异步指异步IO。维基百科对异步IO的定义[2]：</p>
<blockquote>
<p>异步IO是计算机操作系统对输入输出的一种处理方式：发起IO请求的线程不等IO操作完成，就继续执行随后的代码，IO结果用其他方式通知发起IO请求的程序。与异步IO相对的是更为常见的“同步（阻塞）IO”：发起IO请求的线程不从正在调用的IO操作函数返回（即被阻塞），直至IO操作完成。</p>
</blockquote>
<p>一言以蔽之就是：</p>
<blockquote>
<p>执行IO请求后，调用方不等执行结果就继续执行下面的代码，IO操作完成后执行者会告诉调用者“我执行完了”。在NodeJs中通知方式是“回调”。</p>
</blockquote>
<h3 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h3><p>事件驱动是相对 <strong>线程驱动</strong> 而言的。<strong>线程驱动</strong> 下服务器为每个请求新建一个线程去处理。<br>维基百科对事件驱动的定义[3]：</p>
<blockquote>
<p>事件驱动程序模型下的系统，基本上的架构是预先设计一个事件循环所形成的程序，这个事件循环程序不断地检查当前要处理的信息，根据要处理的信息运行一个触发函数进行必要的处理。其中这个外部信息可能来自一个目录夹中的文件，可能来自键盘或鼠标的动作，或者是一个时间事件。</p>
</blockquote>
<p>以NodeJs的HTTP服务器为例，当调用<code>server.listen</code>函数时，NodeJs就会创建一个事件循环，当有客户端请求过来时，NodeJs将该请求入队列进行后续处理，主线程以及轮询客户端请求并入队列，队列中的请求执行完毕后会通过回调函数的形式通知主线程，如此循环。</p>
<h3 id="Javascript运行时"><a href="#Javascript运行时" class="headerlink" title="Javascript运行时"></a>Javascript运行时</h3><p>Javascript运行时是个比较复杂的概念，本文在介绍 <strong>Javascript运行时</strong> 之前介绍一下 <strong>Javascript引擎</strong>。</p>
<h4 id="Javascript引擎"><a href="#Javascript引擎" class="headerlink" title="Javascript引擎"></a>Javascript引擎</h4><p>维基百科的定义[4]：</p>
<blockquote>
<p>JavaScript引擎是一个专门处理JavaScript脚本的虚拟机，一般会附带在网页浏览器之中。</p>
</blockquote>
<p>个人理解：</p>
<blockquote>
<p>Javascript引擎主要是对Javascript代码进行词法、语法等分析，通过解释器转化为字节码，虚拟机执行该字节码，带有JIT(Just-In-Time，即时编译技术)的虚拟机会将热点代码编译为机器码，从而加速执行过程。感谢<a target="_blank" rel="noopener" href="https://github.com/luckymore">luckymore</a>的热心指正！</p>
</blockquote>
<p>目前业内出名的Javascript引擎非V8莫属了。</p>
<h4 id="运行时的组成"><a href="#运行时的组成" class="headerlink" title="运行时的组成"></a>运行时的组成</h4><p>Javascript可以运行在浏览器，也可以运行在服务器(NodeJs)中，有些API或者对象只有浏览器有(比如DOM,BOM等)，而有些API或者对象只有服务器中有(如文件操作，HTTP服务器等)。</p>
<blockquote>
<p>Javascript运行时包括了Javascript引擎、特定环境API、事件循环和事件队列。</p>
</blockquote>
<h3 id="NodeJs架构图"><a href="#NodeJs架构图" class="headerlink" title="NodeJs架构图"></a>NodeJs架构图</h3><p>NodeJs由C++语言基于libuv开发，分层设计，Javascript只是其基于V8提供的上层接口，换句话说，如果把上层接口换成其他语言实现，比如换成PHP实现，那么PHP就可以实现异步事件驱动的服务器，运行时名称就成为 <strong>NODE-PHP</strong>。</p>
<p><img src="https://more-happy.ddhigh.com/FqnmcUJhX0mGNDjMAIa1lOSJhNHJ" alt="NodeJs架构图"></p>
<ul>
<li>Node standard library NodeJs标准库，也是直接提供给开发者调用的顶层代码</li>
<li>Node bindings Javascript和libuv在该层进行通信，基于V8打通语言壁垒</li>
<li>V8 执行JS代码</li>
<li>libuv 高性能异步I&#x2F;O、事件驱动、线程池的库，也是NodeJs高性能的保证</li>
<li>C-ares 提供异步DNS</li>
<li>http_parser、OpenSSL、Zlib 提供HTTP解析、openssl加解密、数据压缩等接口</li>
</ul>
<h3 id="NodeJs到底是不是单线程"><a href="#NodeJs到底是不是单线程" class="headerlink" title="NodeJs到底是不是单线程"></a>NodeJs到底是不是单线程</h3><blockquote>
<p>不是，主线程Javascript线程是单线程，libuv提供线程池，NodeJs不仅仅是一个Javascript引擎，而是一套运行时，不能将Javascript线程孤立出来。</p>
</blockquote>
<h2 id="NodeJs为什么这么快"><a href="#NodeJs为什么这么快" class="headerlink" title="NodeJs为什么这么快"></a>NodeJs为什么这么快</h2><ol>
<li>单线程解决了多线程环境下线程切换开销以及可能的线程同步开销</li>
<li>异步+事件驱动保证了NodeJs主线程不会阻塞，会一直接受请求(这也是受人诟病的地方，其他语言实现的服务器，请求过大会排队处理，NodeJs会将请求全部入队，导致内存暴涨)</li>
</ol>
<h2 id="NodeJs优缺点以及适合的场景"><a href="#NodeJs优缺点以及适合的场景" class="headerlink" title="NodeJs优缺点以及适合的场景"></a>NodeJs优缺点以及适合的场景</h2><ol>
<li>由于主线程Javascript线程是单线程，所以主线程不能做CPU密集操作（比如什么加解密之类的，这种操作只能有Javascript线程运行，会阻塞事件循环），所以NodeJs适合I&#x2F;O密集场景，比如常见的（TCP&#x2F;HTTP服务器）</li>
<li>对于前端开发者来说，几乎没有语言门槛</li>
<li>跨平台，NodeJs在主流操作系统都有对应的二进制程序</li>
<li>标准库强大，第三方库也很多，降低了造轮子成本</li>
<li>易于部署，服务器安装一个NodeJs程序配合NPM包管理器即可运行，不用像PHP那样还要安装扩展，配置前端HTTP服务器</li>
</ol>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>欢迎继续关注本系列文章。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a target="_blank" rel="noopener" href="https://nodejs.org/en/about/">About NodeJs</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-hans/%E5%BC%82%E6%AD%A5IO">异步IO</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BA%8B%E4%BB%B6%E9%A9%85%E5%8B%95%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88">事件驱动</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/JavaScript%E5%BC%95%E6%93%8E">Javascript引擎</a></li>
</ol>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/categories/backend/page/5/">Zurück</a></div><div class="pagination-next"><a href="/categories/backend/page/7/">Weiter</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/categories/backend/">1</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/categories/backend/page/5/">5</a></li><li><a class="pagination-link is-current" href="/categories/backend/page/6/">6</a></li><li><a class="pagination-link" href="/categories/backend/page/7/">7</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/categories/backend/page/17/">17</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://static.ddhigh.com/blog/2019-09-18-094336.jpg" alt="XiaLei"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">XiaLei</p><p class="is-size-6 is-block">Senior Software Engineer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Tencent</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Seiten</p><a href="/archives"><p class="title">306</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Kategorien</p><a href="/categories"><p class="title">25</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">38</p></a></div></div></nav><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/xialeistudio"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="LinkedIn" href="https://www.linkedin.com/in/xialeidoc/"><i class="fa-brands fa-linkedin"></i></a></div></div></div><!--!--></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">Learning &amp; Sharing</a><p class="is-size-7"><span>&copy; 2023 Xia Lei</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en-us");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><a id="back-to-top" title="Zurück nach oben" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "Diese Website verwendet Cookies, um Ihre Erfahrung zu verbessern.",
          dismiss: "Verstanden!",
          allow: "Cookies zulassen",
          deny: "Ablehnen",
          link: "Mehr erfahren",
          policy: "Cookie-Richtlinie",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Tippen Sie etwas..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Tippen Sie etwas...","untitled":"(Ohne Titel)","posts":"Seiten","pages":"Pages","categories":"Kategorien","tags":"Tags"});
        });</script></body></html>