<!doctype html><html lang=en><head><meta name=viewport content="width=device-width,initial-scale=1"><title>Principles Of Microservice Architecture</title>
<meta charset=utf-8><meta name=google-adsense-account content="ca-pub-2871082647721658"><meta content="Web ,Java ,Go ,Node.js ,PHP ,Koa ,MySQL ,Redis ,front-end ,back-end ,database" name=keywords><meta name=description content="The microservices architecture is a method of building complex applications as a collection of small services, where each service runs in its own independent process and is typically built around specific business capabilities. These services communicate through well-defined APIs, often HTTP RESTful APIs or lightweight messaging systems. When designing a microservices architecture, it is crucial to follow a series of core principles to ensure the maintainability, scalability, and flexibility of the system."><meta name=author content="Lei Xia"><link rel=canonical href=https://www.ddhigh.com/en/2025/02/13/principles-of-microservice-architecture/><link rel=alternate type=application/rss+xml href=https://www.ddhigh.com/index.xml title=每天进步一点点><script async src="https://www.googletagmanager.com/gtag/js?id=G-EC3XLVSGKV"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-EC3XLVSGKV")</script><meta property="og:title" content="Principles Of Microservice Architecture"><meta property="og:description" content="The microservices architecture is a method of building complex applications as a collection of small services, where each service runs in its own independent process and is typically built around specific business capabilities. These services communicate through well-defined APIs, often HTTP RESTful APIs or lightweight messaging systems. When designing a microservices architecture, it is crucial to follow a series of core principles to ensure the maintainability, scalability, and flexibility of the system."><meta property="og:type" content="article"><meta property="og:url" content="https://www.ddhigh.com/en/2025/02/13/principles-of-microservice-architecture/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-02-13T11:53:08+08:00"><meta property="article:modified_time" content="2025-02-13T11:53:08+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Principles Of Microservice Architecture"><meta name=twitter:description content="The microservices architecture is a method of building complex applications as a collection of small services, where each service runs in its own independent process and is typically built around specific business capabilities. These services communicate through well-defined APIs, often HTTP RESTful APIs or lightweight messaging systems. When designing a microservices architecture, it is crucial to follow a series of core principles to ensure the maintainability, scalability, and flexibility of the system."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":4,"name":"Principles Of Microservice Architecture","item":"https://www.ddhigh.com/en/2025/02/13/principles-of-microservice-architecture/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Principles Of Microservice Architecture","name":"Principles Of Microservice Architecture","description":"The microservices architecture is a method of building complex applications as a collection of small services, where each service runs in its own independent process and is typically built around specific business capabilities. These services communicate through well-defined APIs, often HTTP RESTful APIs or lightweight messaging systems. When designing a microservices architecture, it is crucial to follow a series of core principles to ensure the maintainability, scalability, and flexibility of the system.\n","keywords":["Microservices"],"articleBody":"The microservices architecture is a method of building complex applications as a collection of small services, where each service runs in its own independent process and is typically built around specific business capabilities. These services communicate through well-defined APIs, often HTTP RESTful APIs or lightweight messaging systems. When designing a microservices architecture, it is crucial to follow a series of core principles to ensure the maintainability, scalability, and flexibility of the system.\nThe Single Responsibility Principle The Single Responsibility Principle (SRP) is one of the object-oriented design principles, proposed by Robert C. Martin in the SOLID principles. The core idea of SRP is that a class should have only one reason to change. In other words, a class should be responsible for only one function, and all related operations of that function should be encapsulated within this class.\nDefinition and Explanation\nIn the microservices architecture, the concept of SRP can be extended and applied to the design of services. Each microservice should have only one business function, and all related operations of that function should be handled by this service. This means that services should be built around specific business domains or business capabilities, rather than mixing multiple unrelated functions together.\nAdvantages\nImprove Cohesion: Microservices that follow SRP have high cohesion because all components of the service are closely organized around the same business function. Reduce Coupling: The coupling between services is reduced because each service is independent of other services and focuses only on its own business logic. Simplify Development and Maintenance: When a service is responsible for only one function, it becomes easier to understand and maintain the service, as developers can focus on the specific business domain of the service. Enhance Testability: Services with a single responsibility are easier to unit test and integrate test, as the scope of testing is more clear and limited. Facilitate Team Collaboration: Different teams can develop and deploy their respective services independently without worrying about affecting other services. Practice\nIn practice, implementing SRP means that in-depth analysis of business requirements is needed to determine the boundaries of services. This usually involves the following steps:\nBusiness Domain Analysis: Identify and define the business domain, as well as the key business entities and operations within the domain. Service Boundary Definition: Based on the business domain and business entities, determine the boundaries of services to ensure that each service contains only relevant business logic. Continuous Refactoring: As business requirements change, continuously refactor the services to ensure that they always adhere to SRP. Challenges\nAlthough SRP brings many advantages, it also faces some challenges in practice:\nOver-refinement: Over-refining services may lead to an excessive number of services, increasing the complexity of the system. Ambiguous Service Definition: In some cases, it may be difficult to determine the boundaries of services, requiring in-depth business understanding and design experience. The Loose Coupling Principle In software engineering, the loose coupling principle means that the dependencies between system components should be weakened as much as possible, so that each component can be developed, tested, deployed, and maintained independently. In the microservices architecture, the loose coupling principle is particularly important because it helps to improve the flexibility and scalability of the system while reducing the mutual influence of changes between components.\nDefinition and Explanation\nThe loose coupling principle requires that the interaction between services should be as simple and clear as possible. Services should communicate through well-defined interfaces rather than relying on the implementation details inside other services. In this way, when the internal implementation of a service needs to be changed, as long as the interface remains unchanged, other services do not need to be modified accordingly.\nAdvantages\nImprove Flexibility: Loosely coupled services can be changed and upgraded independently without affecting other services, which improves the flexibility of the system. Reduce Risk: When developing and deploying new services, loose coupling reduces the potential impact on other services, thereby reducing risks. Simplify Maintenance: Loosely coupled services are easier to understand and maintain because the dependencies between them are clear and simple. Facilitate Team Collaboration: Different teams can work independently on different services without the need for frequent coordination and communication. Practice\nIn the microservices architecture, achieving loose coupling usually involves the following aspects:\nDefine Clear APIs: Communication between services should be carried out through clearly defined APIs, and these APIs should be stable and easy to understand. Use Message Queues: For complex interactions, message queues can be used to achieve asynchronous communication between services and reduce direct dependencies. Avoid Sharing Databases: Each service should have its own database to avoid coupling between services through the database. Service Discovery Mechanism: Use a service discovery mechanism to dynamically discover and connect services instead of hard-coding service addresses. Challenges\nAlthough the loose coupling principle has many advantages, it also faces some challenges in practice:\nDesign Complexity: Achieving loose coupling may require more design work to ensure that the interfaces between services are properly defined. Performance Considerations: In some cases, the introduction of message queues or other mechanisms to achieve loose coupling may affect the performance of the system. Testing Complexity: Loosely coupled services may require more complex testing strategies to ensure that the interactions between services are correct. The API Design First Principle The API design first principle means that before developing microservices, the communication interfaces (APIs) between services should be defined and designed first to ensure that these interfaces are clear, consistent, and easy to understand. This principle emphasizes the core position of APIs in the microservices architecture because APIs are the bridge for communication between services, and the quality of their design directly affects the usability and maintainability of the entire system.\nDefinition and Explanation\nIn the microservices architecture, each service is independent, and they exchange data and events through APIs. The API design first principle requires developers to reach an agreement on the design of the API before writing any service code. This usually involves aspects such as API specification, data format, endpoints, methods, and version control.\nAdvantages\nImprove Collaboration Efficiency: A clear API design helps with collaboration between different teams because all team members can understand how services interact. Promote Reusability: A well-designed API can promote the reusability of services because they are easier to be understood and integrated by other services. Simplify Maintenance: When the API is well-designed, the maintenance and upgrade of services become easier because changes to the API can be minimized. Enhance Flexibility: A well-designed API can adapt to future changes and provide support for the expansion and evolution of the system. Practice\nIn practice, following the API design first principle usually includes the following steps:\nDefine API Specification: Use tools such as OpenAPI (formerly known as Swagger) to define the specification of the API, including the format of requests and responses, parameters, and error handling. Version Control: Implement version control for the API to enable updates and improvements without affecting existing clients. Use RESTful Principles: Design RESTful APIs and use HTTP methods (such as GET, POST, PUT, DELETE) to represent operations on resources. Consider Security: Consider security in API design, including authentication, authorization, and data encryption. The Containerization Principle The containerization principle means that in the microservices architecture, each service and its dependencies are packaged into a lightweight container to achieve the rapid deployment, scaling, and portability of services. Containerization technologies, such as Docker, provide a way to encapsulate applications and their environments together, enabling applications to run in the same way in different environments.\nDefinition and Explanation\nContainerization is an operating system-level virtualization method that allows developers to package applications and their dependencies into a container image. This image contains everything needed to run the application, including code, runtime, libraries, environment variables, and configuration files. Containerization enables applications to run on any system that supports containers without worrying about environmental differences.\nAdvantages\nEnvironmental Consistency: Containerization ensures consistency between development, testing, and production environments, reducing the problem of “it works on my machine”. Rapid Deployment: Containers can be started and stopped quickly, making the deployment and scaling of services more rapid. Resource Efficiency: Containers share the kernel of the host operating system and do not need to run a complete operating system for each application, thus improving the utilization efficiency of resources. Portability: Containerized applications can run on different cloud platforms and operating systems, improving the portability of applications. Practice\nIn practice, the containerization principle usually includes the following steps:\nCreate Container Images: Create a container image for each microservice, including the service and all its dependencies. Use Container Orchestration Tools: Use container orchestration tools such as Kubernetes or Docker Swarm to manage the deployment, scaling, and operation and maintenance of containers. Continuous Integration/Continuous Deployment (CI/CD): Integrate containerization with the CI/CD process to achieve automated building, testing, and deployment. Monitoring and Logging: Implement monitoring and logging of containers to track and diagnose the running status and performance issues of services. The Domain-Driven Design (DDD) Principle Domain-Driven Design (DDD) is a software design approach that emphasizes software development centered around the business domain, closely integrating the knowledge of business experts with system design. The core of DDD lies in dividing the business domain into a series of bounded contexts, and each context defines a set of specific business rules and terms.\nDefinition and Explanation\nIn DDD, the business domain is regarded as a rich, complex, and constantly changing concept. Software developers need to have an in-depth understanding of this domain knowledge to ensure that the software design can accurately reflect business requirements. DDD encourages developers to work closely with business experts to communicate and design the system through a ubiquitous language.\nAdvantages\nEnhance the Consistency between Business and Technology: Through the ubiquitous language and bounded contexts, DDD ensures the consistency between software design and business requirements. Improve the Maintainability of Software: DDD makes software easier to understand and maintain through model-driven design. Facilitate Cross-team Communication: The ubiquitous language helps with communication and collaboration among team members with different backgrounds. Support Complex Business Logic: DDD provides a set of tools and patterns for handling complex business logic and rules. Practice\nIn practice, DDD usually includes the following steps:\nDomain Modeling: Collaborate with business experts to identify and define the core concepts and entities in the business domain. Define Bounded Contexts: Determine the boundaries of different business rules and terms and design models for each context. Create a Ubiquitous Language: Develop a set of language shared with business experts for communication and documentation. Implement the Domain Model: Implement the domain model in the code to ensure that the model can accurately reflect business rules. The Continuous Integration and Continuous Deployment (CI/CD) Principle Continuous Integration (CI) and Continuous Deployment (CD) are two core principles of modern software development practices, aiming to improve the speed and quality of software delivery through automated processes.\nDefinition and Explanation\nContinuous Integration (CI) is a development practice that requires developers to frequently merge code changes into the main branch. Each code merge is verified through automated building and testing to detect and fix integration errors as early as possible.\nContinuous Deployment (CD) is the process of automatically deploying the code that has passed the test to the production environment or other environments on the basis of continuous integration. This enables new features to be released quickly, frequently, and with low risk.\nAdvantages\nRapid Feedback: The CI/CD process provides a rapid feedback mechanism, enabling problems to be identified and solved before they expand. Improve Quality: Automated testing and deployment reduce human errors and improve the quality and stability of software. Accelerate Delivery: CI/CD makes the release of new features faster and speeds up the time to market of products. Reduce Risk: Through automated testing and deployment, the risks and errors of manual operations are reduced. Practice\nIn practice, the CI/CD principle usually includes the following steps:\nAutomated Building: Code changes trigger the automated building process, compiling the code and running unit tests. Automated Testing: Execute automated tests, including unit tests, integration tests, and end-to-end tests. Continuous Deployment: After the tests pass, the automated process deploys the new version to the production environment or other environments. Monitoring and Feedback: After deployment, monitor the application performance and collect user feedback to provide data support for the next iteration. The Fault Tolerance and Recovery Capability Principle In the microservices architecture, the fault tolerance and recovery capability principle means that when designing the system, it must be considered that services may fail and be able to automatically recover from failures to maintain the stability and availability of the overall system. This principle is the key to building a resilient system, requiring services to be able to handle error situations gracefully instead of causing the entire system to crash.\nDefinition and Explanation\nFault tolerance refers to the ability of a system to continue running in the face of component failures. Recovery capability refers to the ability of a system to automatically return to normal operation after a failure occurs. In the microservices architecture, due to the communication between services through the network and each service may be developed by different teams using different technology stacks, the failure of services is common and inevitable.\nAdvantages\nImprove System Stability: By designing fault tolerance mechanisms, the system can continue to provide services when some components fail. Enhance User Experience: Even when there are problems with backend services, users can still receive timely feedback and alternative solutions. Reduce Manual Intervention: Automated recovery mechanisms reduce the dependence on manual intervention and improve the efficiency of operation and maintenance. Practice\nIn practice, achieving fault tolerance and recovery capability usually includes the following aspects:\nService Circuit Breaker: When a service cannot handle more requests or the dependent service is unavailable, automatically stop sending requests to it to prevent the system from being overloaded. Retry Mechanism: For temporary failures, implement an automatic retry logic to increase the chance of request success. Circuit Breaker Pattern: When the service fails continuously up to a certain threshold, the circuit breaker opens to block further requests until the service recovers to normal. Health Check and Self-healing: Regularly perform health checks on services and automatically restart services or reschedule tasks when problems are detected. Backup and Data Recovery: Regularly back up data and ensure that data can be quickly recovered in case of data loss or damage. The Event-Driven Architecture (EDA) Principle The Event-Driven Architecture (EDA) is a design paradigm that achieves loose coupling and high responsiveness of the system through the generation, detection, consumption, and reaction of events. In the microservices architecture, the EDA principle helps to build a flexible, scalable, and asynchronous system.\nDefinition and Explanation\nIn EDA, system components communicate through events instead of directly calling each other’s methods or services. When an event occurs, such as a user operation, data change, or external signal, the system generates an event message, which is published to a message queue or event stream. Other services or components can subscribe to these events and react when the events occur.\nAdvantages\nDecoupling: Communication between services is carried out through events, reducing the direct dependence between services and improving the flexibility of the system. Asynchronous Processing: The event-driven architecture supports asynchronous processing, which can improve the throughput and responsiveness of the system. Scalability: The system can be easily scaled by adding event handlers to cope with increased loads. Fault Tolerance: The event-driven architecture can improve the fault tolerance of the system through event persistence and retry mechanisms. Practice\nIn practice, the EDA principle usually includes the following aspects:\nEvent Definition: Clearly define the types, data formats, and semantics of events. Event Publishing: Services publish events when specific operations are completed. Event Subscription: Other services or components subscribe to events they are interested in and define event handling logic. Event Processing: When an event occurs, subscribers receive the event and execute the corresponding processing logic. Event Storage: Persist events to support fault recovery and historical data analysis. The Security Design Principle In the microservices architecture, the security design principle is the key to ensuring that the system protects data and resources from unauthorized access and various threats throughout the design, development, and deployment processes. Security is a multi-faceted concept that involves multiple aspects such as authentication, authorization, data encryption, secure communication, and security auditing.\nDefinition and Explanation\nThe security design principle requires considering security measures at every level of the microservices architecture, from communication between services to data storage and then to the user interface. This includes but is not limited to using secure coding practices to prevent injection attacks, implementing strong authentication and authorization mechanisms to restrict resource access, and encrypting sensitive data to protect the integrity and privacy of information.\nAdvantages\nProtect Data: Ensure the security of sensitive data during transmission and storage to prevent data leakage. Prevent Unauthorized Access: Through authentication and authorization mechanisms, ensure that only authorized users can access specific resources. Compliance: Help organizations comply with data protection regulations and industry standards, such as GDPR or HIPAA. Enhance Trust: Improve the trust of users and partners in the security of the system. Practice\nIn practice, the security design principle usually includes the following aspects:\nUse HTTPS: Ensure the security of communication between services and prevent data from being intercepted during transmission. Implement OAuth and JWT: Use modern authentication and authorization frameworks to manage user access tokens. Data Encryption: Encrypt sensitive data, whether in the database or during transmission. Security Auditing: Record and monitor system activities for investigation in case of security incidents. Regular Security Assessments: Conduct penetration testing and security audits to identify and fix potential security vulnerabilities. The Monitoring and Logging Principle In the microservices architecture, the monitoring and logging principle is a crucial strategy for ensuring system health, performance optimization, and quick problem identification. Effective monitoring and logging can help the team understand the system’s status in real time, predict potential issues, and respond promptly when failures occur.\nDefinition and Explanation\nThe monitoring and logging principle involves the continuous observation and recording of the runtime behavior of microservices, including service performance indicators, error logs, user activities, and system events. This data is essential for maintaining the stability and reliability of the system.\nAdvantages\nReal-time Insight: Real-time monitoring provides an immediate view of the system’s operating status, enabling the team to detect and resolve problems in a timely manner. Performance Optimization: By analyzing performance indicators, bottlenecks can be identified, and services can be optimized to enhance efficiency. Fault Diagnosis: Detailed log records help quickly pinpoint the causes of faults, shortening the system recovery time. Security Analysis: Monitoring and logging can be used to detect and respond to security incidents, enhancing the system’s security. Practice\nIn practice, the monitoring and logging principle typically includes the following aspects:\nPerformance Indicator Monitoring: Monitor key performance indicators such as CPU usage, memory usage, response time, and throughput. Log Management: Centralize the management and analysis of service logs to ensure their integrity and queryability. Error and Exception Tracking: Record and track errors and exceptions for quick response and resolution. User Activity Monitoring: Monitor user behavior and system events for security audits and business analysis. Alert System: Set up an alert mechanism to automatically notify the team when key indicators exceed the normal range. Conclusion In this article, we have in-depthly discussed ten key design principles of the microservices architecture. These principles are vital for ensuring the stability, scalability, and security of microservices systems. From the Single Responsibility Principle to the Monitoring and Logging Principle, each principle emphasizes the importance of implementing best practices at different levels. The implementation of these principles helps the team make more informed decisions during the development process and also lays a solid foundation for the future expansion and maintenance of the system. By integrating these principles into the microservices architecture, we can build more efficient, reliable, and user-friendly applications.\n","wordCount":"3289","inLanguage":"en","datePublished":"2025-02-13T11:53:08+08:00","dateModified":"2025-02-13T11:53:08+08:00","author":{"@type":"Person","name":"Lei Xia"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.ddhigh.com/en/2025/02/13/principles-of-microservice-architecture/"},"publisher":{"@type":"Organization","name":"每天进步一点点","logo":{"@type":"ImageObject","url":"https://www.ddhigh.com/favicon.ico"}}}</script><link rel=icon href=/img/favicon.ico sizes=16x16><link rel=apple-touch-icon href=/img/favicon.ico><link rel=manifest href=/img/favicon.ico><link href=/titilliumweb/titilliumweb.css rel=stylesheet><link rel=stylesheet href=/css/main.min.0eb4160ba4a2d63122fe8ae83f1560951a87ab510d5dab0615973b5206555759.css integrity="sha256-DrQWC6Si1jEi/oroPxVglRqHq1ENXasGFZc7UgZVV1k=" crossorigin=anonymous media=screen><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css integrity="sha512-ygEyjMC6rqnzJqWGjRTJUPYMEs9JUOm3i7OWUS9CgQ4XkBUvMsgCS1I8JqavidQ2ClHcREB7IbA2mN08+r9Elg==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=/scss/highlight/github-dark.min.min.66034289ee9a113219a2c4aae0a8bd2095ab255c832a42efcf5863f10814e7a1.css><script src=/js/highlight.min.min.894ca9c68afab956438c4926a0dc7f5293e04e08595bd27abdb123e94801f684.js></script><script>hljs.highlightAll()</script><script>$darkModeInit.Content|safeJS</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2871082647721658" crossorigin=anonymous></script></head><body><main class=wrapper><nav class=navigation><section class=container><a class=navigation-brand href=/en>DayDayUP
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><span></span><span></span><span></span></label><ul class=navigation-list id=navigation-list><li class="navigation-item navigation-menu"><a class=navigation-link href=/en/>Home</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/en/archives>Archives</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/en/books>Books</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/en/guestbook>Guestbook</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class="navigation-item navigation-social"><a class=navigation-link href=https://github.com/xialeistudio><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li class="navigation-item navigation-dark"><button id=mode type=button aria-label="toggle user light or dark theme">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span><span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></li><li class="navigation-item navigation-language"><a href=https://www.ddhigh.com/2025/02/13/principles-of-microservice-architecture/>中</a></li></ul></section></nav><div id=content><article class=blog-single><header class=blog-title><h1>Principles Of Microservice Architecture</h1></header><p><small>February 13, 2025&nbsp;· 3289 words&nbsp;· 16 min</small><p><div class=blog-toc><nav id=TableOfContents><ul><li><a href=#the-single-responsibility-principle>The Single Responsibility Principle</a></li><li><a href=#the-loose-coupling-principle>The Loose Coupling Principle</a></li><li><a href=#the-api-design-first-principle>The API Design First Principle</a></li><li><a href=#the-containerization-principle>The Containerization Principle</a></li><li><a href=#the-domain-driven-design-ddd-principle>The Domain-Driven Design (DDD) Principle</a></li><li><a href=#the-continuous-integration-and-continuous-deployment-cicd-principle>The Continuous Integration and Continuous Deployment (CI/CD) Principle</a></li><li><a href=#the-fault-tolerance-and-recovery-capability-principle>The Fault Tolerance and Recovery Capability Principle</a></li><li><a href=#the-event-driven-architecture-eda-principle>The Event-Driven Architecture (EDA) Principle</a></li><li><a href=#the-security-design-principle>The Security Design Principle</a></li><li><a href=#the-monitoring-and-logging-principle>The Monitoring and Logging Principle</a></li><li><a href=#conclusion>Conclusion</a></li></ul></nav></div><section class=blog-content><p>The microservices architecture is a method of building complex applications as a collection of small services, where each service runs in its own independent process and is typically built around specific business capabilities. These services communicate through well-defined APIs, often HTTP RESTful APIs or lightweight messaging systems. When designing a microservices architecture, it is crucial to follow a series of core principles to ensure the maintainability, scalability, and flexibility of the system.</p><h2 id=the-single-responsibility-principle>The Single Responsibility Principle</h2><p>The Single Responsibility Principle (SRP) is one of the object-oriented design principles, proposed by Robert C. Martin in the SOLID principles. The core idea of SRP is that a class should have only one reason to change. In other words, a class should be responsible for only one function, and all related operations of that function should be encapsulated within this class.</p><p><strong>Definition and Explanation</strong></p><p>In the microservices architecture, the concept of SRP can be extended and applied to the design of services. Each microservice should have only one business function, and all related operations of that function should be handled by this service. This means that services should be built around specific business domains or business capabilities, rather than mixing multiple unrelated functions together.</p><p><strong>Advantages</strong></p><ol><li>Improve Cohesion: Microservices that follow SRP have high cohesion because all components of the service are closely organized around the same business function.</li><li>Reduce Coupling: The coupling between services is reduced because each service is independent of other services and focuses only on its own business logic.</li><li>Simplify Development and Maintenance: When a service is responsible for only one function, it becomes easier to understand and maintain the service, as developers can focus on the specific business domain of the service.</li><li>Enhance Testability: Services with a single responsibility are easier to unit test and integrate test, as the scope of testing is more clear and limited.</li><li>Facilitate Team Collaboration: Different teams can develop and deploy their respective services independently without worrying about affecting other services.</li></ol><p><strong>Practice</strong></p><p>In practice, implementing SRP means that in-depth analysis of business requirements is needed to determine the boundaries of services. This usually involves the following steps:</p><ol><li>Business Domain Analysis: Identify and define the business domain, as well as the key business entities and operations within the domain.</li><li>Service Boundary Definition: Based on the business domain and business entities, determine the boundaries of services to ensure that each service contains only relevant business logic.</li><li>Continuous Refactoring: As business requirements change, continuously refactor the services to ensure that they always adhere to SRP.</li></ol><p><strong>Challenges</strong></p><p>Although SRP brings many advantages, it also faces some challenges in practice:</p><ol><li>Over-refinement: Over-refining services may lead to an excessive number of services, increasing the complexity of the system.</li><li>Ambiguous Service Definition: In some cases, it may be difficult to determine the boundaries of services, requiring in-depth business understanding and design experience.</li></ol><h2 id=the-loose-coupling-principle>The Loose Coupling Principle</h2><p>In software engineering, the loose coupling principle means that the dependencies between system components should be weakened as much as possible, so that each component can be developed, tested, deployed, and maintained independently. In the microservices architecture, the loose coupling principle is particularly important because it helps to improve the flexibility and scalability of the system while reducing the mutual influence of changes between components.</p><p><strong>Definition and Explanation</strong></p><p>The loose coupling principle requires that the interaction between services should be as simple and clear as possible. Services should communicate through well-defined interfaces rather than relying on the implementation details inside other services. In this way, when the internal implementation of a service needs to be changed, as long as the interface remains unchanged, other services do not need to be modified accordingly.</p><p><strong>Advantages</strong></p><ol><li>Improve Flexibility: Loosely coupled services can be changed and upgraded independently without affecting other services, which improves the flexibility of the system.</li><li>Reduce Risk: When developing and deploying new services, loose coupling reduces the potential impact on other services, thereby reducing risks.</li><li>Simplify Maintenance: Loosely coupled services are easier to understand and maintain because the dependencies between them are clear and simple.</li><li>Facilitate Team Collaboration: Different teams can work independently on different services without the need for frequent coordination and communication.</li></ol><p><strong>Practice</strong></p><p>In the microservices architecture, achieving loose coupling usually involves the following aspects:</p><ol><li>Define Clear APIs: Communication between services should be carried out through clearly defined APIs, and these APIs should be stable and easy to understand.</li><li>Use Message Queues: For complex interactions, message queues can be used to achieve asynchronous communication between services and reduce direct dependencies.</li><li>Avoid Sharing Databases: Each service should have its own database to avoid coupling between services through the database.</li><li>Service Discovery Mechanism: Use a service discovery mechanism to dynamically discover and connect services instead of hard-coding service addresses.</li></ol><p><strong>Challenges</strong></p><p>Although the loose coupling principle has many advantages, it also faces some challenges in practice:</p><ol><li>Design Complexity: Achieving loose coupling may require more design work to ensure that the interfaces between services are properly defined.</li><li>Performance Considerations: In some cases, the introduction of message queues or other mechanisms to achieve loose coupling may affect the performance of the system.</li><li>Testing Complexity: Loosely coupled services may require more complex testing strategies to ensure that the interactions between services are correct.</li></ol><h2 id=the-api-design-first-principle>The API Design First Principle</h2><p>The API design first principle means that before developing microservices, the communication interfaces (APIs) between services should be defined and designed first to ensure that these interfaces are clear, consistent, and easy to understand. This principle emphasizes the core position of APIs in the microservices architecture because APIs are the bridge for communication between services, and the quality of their design directly affects the usability and maintainability of the entire system.</p><p><strong>Definition and Explanation</strong></p><p>In the microservices architecture, each service is independent, and they exchange data and events through APIs. The API design first principle requires developers to reach an agreement on the design of the API before writing any service code. This usually involves aspects such as API specification, data format, endpoints, methods, and version control.</p><p><strong>Advantages</strong></p><ol><li>Improve Collaboration Efficiency: A clear API design helps with collaboration between different teams because all team members can understand how services interact.</li><li>Promote Reusability: A well-designed API can promote the reusability of services because they are easier to be understood and integrated by other services.</li><li>Simplify Maintenance: When the API is well-designed, the maintenance and upgrade of services become easier because changes to the API can be minimized.</li><li>Enhance Flexibility: A well-designed API can adapt to future changes and provide support for the expansion and evolution of the system.</li></ol><p><strong>Practice</strong></p><p>In practice, following the API design first principle usually includes the following steps:</p><ol><li>Define API Specification: Use tools such as OpenAPI (formerly known as Swagger) to define the specification of the API, including the format of requests and responses, parameters, and error handling.</li><li>Version Control: Implement version control for the API to enable updates and improvements without affecting existing clients.</li><li>Use RESTful Principles: Design RESTful APIs and use HTTP methods (such as GET, POST, PUT, DELETE) to represent operations on resources.</li><li>Consider Security: Consider security in API design, including authentication, authorization, and data encryption.</li></ol><h2 id=the-containerization-principle>The Containerization Principle</h2><p>The containerization principle means that in the microservices architecture, each service and its dependencies are packaged into a lightweight container to achieve the rapid deployment, scaling, and portability of services. Containerization technologies, such as Docker, provide a way to encapsulate applications and their environments together, enabling applications to run in the same way in different environments.</p><p><strong>Definition and Explanation</strong></p><p>Containerization is an operating system-level virtualization method that allows developers to package applications and their dependencies into a container image. This image contains everything needed to run the application, including code, runtime, libraries, environment variables, and configuration files. Containerization enables applications to run on any system that supports containers without worrying about environmental differences.</p><p><strong>Advantages</strong></p><ol><li>Environmental Consistency: Containerization ensures consistency between development, testing, and production environments, reducing the problem of &ldquo;it works on my machine&rdquo;.</li><li>Rapid Deployment: Containers can be started and stopped quickly, making the deployment and scaling of services more rapid.</li><li>Resource Efficiency: Containers share the kernel of the host operating system and do not need to run a complete operating system for each application, thus improving the utilization efficiency of resources.</li><li>Portability: Containerized applications can run on different cloud platforms and operating systems, improving the portability of applications.</li></ol><p><strong>Practice</strong></p><p>In practice, the containerization principle usually includes the following steps:</p><ol><li>Create Container Images: Create a container image for each microservice, including the service and all its dependencies.</li><li>Use Container Orchestration Tools: Use container orchestration tools such as Kubernetes or Docker Swarm to manage the deployment, scaling, and operation and maintenance of containers.</li><li>Continuous Integration/Continuous Deployment (CI/CD): Integrate containerization with the CI/CD process to achieve automated building, testing, and deployment.</li><li>Monitoring and Logging: Implement monitoring and logging of containers to track and diagnose the running status and performance issues of services.</li></ol><h2 id=the-domain-driven-design-ddd-principle>The Domain-Driven Design (DDD) Principle</h2><p>Domain-Driven Design (DDD) is a software design approach that emphasizes software development centered around the business domain, closely integrating the knowledge of business experts with system design. The core of DDD lies in dividing the business domain into a series of bounded contexts, and each context defines a set of specific business rules and terms.</p><p><strong>Definition and Explanation</strong></p><p>In DDD, the business domain is regarded as a rich, complex, and constantly changing concept. Software developers need to have an in-depth understanding of this domain knowledge to ensure that the software design can accurately reflect business requirements. DDD encourages developers to work closely with business experts to communicate and design the system through a ubiquitous language.</p><p><strong>Advantages</strong></p><ol><li>Enhance the Consistency between Business and Technology: Through the ubiquitous language and bounded contexts, DDD ensures the consistency between software design and business requirements.</li><li>Improve the Maintainability of Software: DDD makes software easier to understand and maintain through model-driven design.</li><li>Facilitate Cross-team Communication: The ubiquitous language helps with communication and collaboration among team members with different backgrounds.</li><li>Support Complex Business Logic: DDD provides a set of tools and patterns for handling complex business logic and rules.</li></ol><p><strong>Practice</strong></p><p>In practice, DDD usually includes the following steps:</p><ol><li>Domain Modeling: Collaborate with business experts to identify and define the core concepts and entities in the business domain.</li><li>Define Bounded Contexts: Determine the boundaries of different business rules and terms and design models for each context.</li><li>Create a Ubiquitous Language: Develop a set of language shared with business experts for communication and documentation.</li><li>Implement the Domain Model: Implement the domain model in the code to ensure that the model can accurately reflect business rules.</li></ol><h2 id=the-continuous-integration-and-continuous-deployment-cicd-principle>The Continuous Integration and Continuous Deployment (CI/CD) Principle</h2><p>Continuous Integration (CI) and Continuous Deployment (CD) are two core principles of modern software development practices, aiming to improve the speed and quality of software delivery through automated processes.</p><p><strong>Definition and Explanation</strong></p><p><strong>Continuous Integration (CI)</strong> is a development practice that requires developers to frequently merge code changes into the main branch. Each code merge is verified through automated building and testing to detect and fix integration errors as early as possible.</p><p><strong>Continuous Deployment (CD)</strong> is the process of automatically deploying the code that has passed the test to the production environment or other environments on the basis of continuous integration. This enables new features to be released quickly, frequently, and with low risk.</p><p><strong>Advantages</strong></p><ol><li>Rapid Feedback: The CI/CD process provides a rapid feedback mechanism, enabling problems to be identified and solved before they expand.</li><li>Improve Quality: Automated testing and deployment reduce human errors and improve the quality and stability of software.</li><li>Accelerate Delivery: CI/CD makes the release of new features faster and speeds up the time to market of products.</li><li>Reduce Risk: Through automated testing and deployment, the risks and errors of manual operations are reduced.</li></ol><p><strong>Practice</strong></p><p>In practice, the CI/CD principle usually includes the following steps:</p><ol><li>Automated Building: Code changes trigger the automated building process, compiling the code and running unit tests.</li><li>Automated Testing: Execute automated tests, including unit tests, integration tests, and end-to-end tests.</li><li>Continuous Deployment: After the tests pass, the automated process deploys the new version to the production environment or other environments.</li><li>Monitoring and Feedback: After deployment, monitor the application performance and collect user feedback to provide data support for the next iteration.</li></ol><h2 id=the-fault-tolerance-and-recovery-capability-principle>The Fault Tolerance and Recovery Capability Principle</h2><p>In the microservices architecture, the fault tolerance and recovery capability principle means that when designing the system, it must be considered that services may fail and be able to automatically recover from failures to maintain the stability and availability of the overall system. This principle is the key to building a resilient system, requiring services to be able to handle error situations gracefully instead of causing the entire system to crash.</p><p><strong>Definition and Explanation</strong></p><p>Fault tolerance refers to the ability of a system to continue running in the face of component failures. Recovery capability refers to the ability of a system to automatically return to normal operation after a failure occurs. In the microservices architecture, due to the communication between services through the network and each service may be developed by different teams using different technology stacks, the failure of services is common and inevitable.</p><p><strong>Advantages</strong></p><ol><li>Improve System Stability: By designing fault tolerance mechanisms, the system can continue to provide services when some components fail.</li><li>Enhance User Experience: Even when there are problems with backend services, users can still receive timely feedback and alternative solutions.</li><li>Reduce Manual Intervention: Automated recovery mechanisms reduce the dependence on manual intervention and improve the efficiency of operation and maintenance.</li></ol><p><strong>Practice</strong></p><p>In practice, achieving fault tolerance and recovery capability usually includes the following aspects:</p><ol><li>Service Circuit Breaker: When a service cannot handle more requests or the dependent service is unavailable, automatically stop sending requests to it to prevent the system from being overloaded.</li><li>Retry Mechanism: For temporary failures, implement an automatic retry logic to increase the chance of request success.</li><li>Circuit Breaker Pattern: When the service fails continuously up to a certain threshold, the circuit breaker opens to block further requests until the service recovers to normal.</li><li>Health Check and Self-healing: Regularly perform health checks on services and automatically restart services or reschedule tasks when problems are detected.</li><li>Backup and Data Recovery: Regularly back up data and ensure that data can be quickly recovered in case of data loss or damage.</li></ol><h2 id=the-event-driven-architecture-eda-principle>The Event-Driven Architecture (EDA) Principle</h2><p>The Event-Driven Architecture (EDA) is a design paradigm that achieves loose coupling and high responsiveness of the system through the generation, detection, consumption, and reaction of events. In the microservices architecture, the EDA principle helps to build a flexible, scalable, and asynchronous system.</p><p><strong>Definition and Explanation</strong></p><p>In EDA, system components communicate through events instead of directly calling each other&rsquo;s methods or services. When an event occurs, such as a user operation, data change, or external signal, the system generates an event message, which is published to a message queue or event stream. Other services or components can subscribe to these events and react when the events occur.</p><p><strong>Advantages</strong></p><ol><li>Decoupling: Communication between services is carried out through events, reducing the direct dependence between services and improving the flexibility of the system.</li><li>Asynchronous Processing: The event-driven architecture supports asynchronous processing, which can improve the throughput and responsiveness of the system.</li><li>Scalability: The system can be easily scaled by adding event handlers to cope with increased loads.</li><li>Fault Tolerance: The event-driven architecture can improve the fault tolerance of the system through event persistence and retry mechanisms.</li></ol><p><strong>Practice</strong></p><p>In practice, the EDA principle usually includes the following aspects:</p><ol><li>Event Definition: Clearly define the types, data formats, and semantics of events.</li><li>Event Publishing: Services publish events when specific operations are completed.</li><li>Event Subscription: Other services or components subscribe to events they are interested in and define event handling logic.</li><li>Event Processing: When an event occurs, subscribers receive the event and execute the corresponding processing logic.</li><li>Event Storage: Persist events to support fault recovery and historical data analysis.</li></ol><h2 id=the-security-design-principle>The Security Design Principle</h2><p>In the microservices architecture, the security design principle is the key to ensuring that the system protects data and resources from unauthorized access and various threats throughout the design, development, and deployment processes. Security is a multi-faceted concept that involves multiple aspects such as authentication, authorization, data encryption, secure communication, and security auditing.</p><p><strong>Definition and Explanation</strong></p><p>The security design principle requires considering security measures at every level of the microservices architecture, from communication between services to data storage and then to the user interface. This includes but is not limited to using secure coding practices to prevent injection attacks, implementing strong authentication and authorization mechanisms to restrict resource access, and encrypting sensitive data to protect the integrity and privacy of information.</p><p><strong>Advantages</strong></p><ol><li>Protect Data: Ensure the security of sensitive data during transmission and storage to prevent data leakage.</li><li>Prevent Unauthorized Access: Through authentication and authorization mechanisms, ensure that only authorized users can access specific resources.</li><li>Compliance: Help organizations comply with data protection regulations and industry standards, such as GDPR or HIPAA.</li><li>Enhance Trust: Improve the trust of users and partners in the security of the system.</li></ol><p><strong>Practice</strong></p><p>In practice, the security design principle usually includes the following aspects:</p><ol><li>Use HTTPS: Ensure the security of communication between services and prevent data from being intercepted during transmission.</li><li>Implement OAuth and JWT: Use modern authentication and authorization frameworks to manage user access tokens.</li><li>Data Encryption: Encrypt sensitive data, whether in the database or during transmission.</li><li>Security Auditing: Record and monitor system activities for investigation in case of security incidents.</li><li>Regular Security Assessments: Conduct penetration testing and security audits to identify and fix potential security vulnerabilities.</li></ol><h2 id=the-monitoring-and-logging-principle>The Monitoring and Logging Principle</h2><p>In the microservices architecture, the monitoring and logging principle is a crucial strategy for ensuring system health, performance optimization, and quick problem identification. Effective monitoring and logging can help the team understand the system&rsquo;s status in real time, predict potential issues, and respond promptly when failures occur.</p><p><strong>Definition and Explanation</strong></p><p>The monitoring and logging principle involves the continuous observation and recording of the runtime behavior of microservices, including service performance indicators, error logs, user activities, and system events. This data is essential for maintaining the stability and reliability of the system.</p><p><strong>Advantages</strong></p><ol><li>Real-time Insight: Real-time monitoring provides an immediate view of the system&rsquo;s operating status, enabling the team to detect and resolve problems in a timely manner.</li><li>Performance Optimization: By analyzing performance indicators, bottlenecks can be identified, and services can be optimized to enhance efficiency.</li><li>Fault Diagnosis: Detailed log records help quickly pinpoint the causes of faults, shortening the system recovery time.</li><li>Security Analysis: Monitoring and logging can be used to detect and respond to security incidents, enhancing the system&rsquo;s security.</li></ol><p><strong>Practice</strong></p><p>In practice, the monitoring and logging principle typically includes the following aspects:</p><ol><li>Performance Indicator Monitoring: Monitor key performance indicators such as CPU usage, memory usage, response time, and throughput.</li><li>Log Management: Centralize the management and analysis of service logs to ensure their integrity and queryability.</li><li>Error and Exception Tracking: Record and track errors and exceptions for quick response and resolution.</li><li>User Activity Monitoring: Monitor user behavior and system events for security audits and business analysis.</li><li>Alert System: Set up an alert mechanism to automatically notify the team when key indicators exceed the normal range.</li></ol><h2 id=conclusion>Conclusion</h2><p>In this article, we have in-depthly discussed ten key design principles of the microservices architecture. These principles are vital for ensuring the stability, scalability, and security of microservices systems. From the Single Responsibility Principle to the Monitoring and Logging Principle, each principle emphasizes the importance of implementing best practices at different levels. The implementation of these principles helps the team make more informed decisions during the development process and also lays a solid foundation for the future expansion and maintenance of the system. By integrating these principles into the microservices architecture, we can build more efficient, reliable, and user-friendly applications.</p><div class=blog-footer><div class=social-share></div><div class=copyright><ul><li style=margin-bottom:.5em>Author: <a href=https://ddhigh.com/ target=_blank style=color:#000;text-decoration:none>xialeistudio</a></li><li style=margin-bottom:.5em>Link: <a href=https://www.ddhigh.com/en/2025/02/13/principles-of-microservice-architecture/ target=_blank style=color:#000;text-decoration:none>Principles Of Microservice Architecture</a></li><li>Copyright: <a href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank style=color:#000;text-decoration:none>「CC BY-NC 4.0 DEED」</a></li></ul></div></div></section><div class=paginator><a class=prev href=https://www.ddhigh.com/en/2025/03/25/aws-irsa-vs-ec2iam/><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M9.94496 9C9.28897 9.61644 7.63215 10.997 6.04814 11.7966 5.98257 11.8297 5.98456 11.9753 6.05061 12.0063c1.00435.4716 2.8788 1.9201 3.89435 2.9937M6.44444 11.9667C8.86549 12.0608 14 12 16 11" stroke="currentcolor" stroke-linecap="round"/></svg><span>IRSA vs. EC2 IAM:Usage Scenarios and Permission Management Practices</span></a>
<a class=next href=https://www.ddhigh.com/en/2025/02/12/the-evolution-of-service-architecture/><span>The Evolution Of Service Architecture</span><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M12.055 9C12.711 9.61644 14.3679 10.997 15.9519 11.7966 16.0174 11.8297 16.0154 11.9753 15.9494 12.0063 14.945 12.4779 13.0706 13.9264 12.055 15m3.5006-3.0333C13.1345 12.0608 8 12 6 11" stroke="currentcolor" stroke-linecap="round"/></svg></a></div><div class=comments><script>const getTheme=window.localStorage&&window.localStorage.getItem("theme");let theme=getTheme==="dark"?"dark":"light",s=document.createElement("script");s.src="https://giscus.app/client.js",s.setAttribute("data-repo","xialeistudio/discussion"),s.setAttribute("data-repo-id","R_kgDOKurTRA"),s.setAttribute("data-category","General"),s.setAttribute("data-category-id","DIC_kwDOKurTRM4CbCJt"),s.setAttribute("data-mapping","pathname"),s.setAttribute("data-strict","0"),s.setAttribute("data-reactions-enabled","1"),s.setAttribute("data-emit-metadata","0"),s.setAttribute("data-input-position","bottom"),s.setAttribute("data-theme",theme),s.setAttribute("data-lang","en"),s.setAttribute("data-loading","lazy"),s.setAttribute("crossorigin","anonymous"),s.setAttribute("async",""),document.querySelector("div.comments").innerHTML="",document.querySelector("div.comments").appendChild(s)</script></div></article></div><footer class=footer><p>&copy; 2014 - 2025 <a href=https://www.ddhigh.com>每天进步一点点</a>
Powered by
<a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>
<a href=https://github.com/guangzhengli/hugo-theme-ladder rel=noopener target=_blank>Ladder</a>
️</p></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.5376 22.7916C11.0152 22.7207 22.5795 21.1781 22.0978 10.4211 22.0536 9.43274 21.9303 8.53367 21.7387 7.71865M10.5376 22.7916C16.876 22.3728 20.0969 19.8899 21.5383 16.9142M10.5376 22.7916C9.7707 22.9055 8.97982 22.8964 8.19743 22.7725M21.7387 7.71865C21.4988 6.69828 21.1518 5.80967 20.7188 5.04257m1.0199 2.67608C22.6022 10.1105 23.0542 13.7848 21.5383 16.9142M20.7188 5.04257c-3.5504-6.28886-12.88753-4.410077-16.44303.0C2.88063 6.77451-.0433281 11.1668 1.38159 16.6571c.89322 3.4417 3.7911 5.6365 6.81584 6.1154M20.7188 5.04257c1.3509 1.89783 3.3111 6.34223 1.6353 10.37273M21.5383 16.9142C21.8737 16.4251 22.1428 15.9235 22.3541 15.4153M8.19743 22.7725C12.1971 23.4683 20.6281 22.971 22.3541 15.4153M14 10.945C13.3836 10.289 12.003 8.63215 11.2034 7.04814 11.1703 6.98257 11.0247 6.98456 10.9937 7.05061 10.5221 8.05496 9.07362 9.92941 8 10.945m3.0333-3.50056C10.9392 9.86549 11 15 12 17" stroke="currentcolor" stroke-linecap="round"/></svg></a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function n(){t.innerHTML="Copied",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)}),e.parentNode.appendChild(t)})</script><script src=https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js integrity="sha512-9DNXrSjk17bU9MUbRp3IjwcWe46V8FaGA062PFbryPUAEQVRbz4jiZP6FW0AdbqEGtMYBDWnul3eiGBMJOQajA==" crossorigin=anonymous referrerpolicy=no-referrer></script></main></body><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script><script>const images=Array.from(document.querySelectorAll(".blog-content img"));images.forEach(e=>{mediumZoom(e,{margin:10,scrollOffset:40,container:null,template:null,background:"rgba(0, 0, 0, 0.5)"})})</script><script src=/main.min.6bb26b69159420159c74dc9e097b06a578ed2b68c701466a91a44a9632d851bd0af167a1b30012387b4c512b48ad9ad4d3394e04d77ae38d57e1920fe4ed34fe.js integrity="sha512-a7JraRWUIBWcdNyeCXsGpXjtK2jHAUZqkaRKljLYUb0K8WehswASOHtMUStIrZrU0zlOBNd6441X4ZIP5O00/g==" crossorigin=anonymous defer></script></html>